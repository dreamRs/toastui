(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("HTMLWidgets"));
	else if(typeof define === 'function' && define.amd)
		define(["HTMLWidgets"], factory);
	else if(typeof exports === 'object')
		exports["chart"] = factory(require("HTMLWidgets"));
	else
		root["chart"] = factory(root["HTMLWidgets"]);
})(self, function(__WEBPACK_EXTERNAL_MODULE_widgets__) {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@toast-ui/chart/dist/esm/animator.js":
/*!***********************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/animator.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Animator)
/* harmony export */ });
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");

class Animator {
    constructor() {
        this.anims = [];
        this.state = 'IDLE';
        this.requestId = null;
        this.firstRendering = true;
    }
    add({ chart, duration, requester, onCompleted = () => { }, onFrame = (delta) => {
        if (!this.firstRendering) {
            chart.update(delta);
        }
        if (this.firstRendering) {
            chart.initUpdate(delta);
            if (delta === 1) {
                this.firstRendering = false;
            }
        }
    }, }) {
        if (this.anims.length) {
            this.reset();
        }
        if (this.state === 'IDLE') {
            this.anims.push({
                chart,
                requester,
                duration,
                onFrame,
                onCompleted,
                start: null,
                current: null,
                completed: false,
            });
            this.start();
        }
    }
    reset() {
        this.anims.forEach((anim) => {
            anim.current = 1;
            anim.onFrame(anim.current);
            anim.completed = true;
        });
        this.anims = [];
        this.cancelAnimFrame();
        this.state = 'IDLE';
        this.requestId = null;
    }
    start() {
        if (this.anims.length) {
            this.state = 'RUNNING';
            this.runFrame();
        }
    }
    runFrame() {
        this.requestId = window.requestAnimationFrame((timestamp) => {
            this.runAnims(timestamp);
        });
    }
    runAnims(timestamp) {
        this.next(timestamp);
        if (this.anims.length) {
            this.runFrame();
        }
        else {
            this.state = 'IDLE';
            this.requestId = null;
        }
    }
    next(timestamp) {
        this.anims.forEach((anim) => {
            if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNull)(anim.start)) {
                anim.start = timestamp;
            }
            Object.defineProperty(anim.chart, '___animId___', {
                value: timestamp,
                enumerable: false,
                writable: false,
                configurable: true,
            });
            anim.current = anim.duration ? Math.min((timestamp - anim.start) / anim.duration, 1) : 1;
            anim.onFrame(anim.current);
            anim.completed = anim.current === 1;
        });
        this.anims.forEach((anim) => {
            if (anim.chart.___animId___ === timestamp) {
                anim.chart.draw();
                delete anim.chart.___animId___;
            }
            if (anim.completed) {
                this.cancelAnimFrame();
                anim.onCompleted();
                anim.chart.eventBus.emit('animationCompleted', anim.requester);
            }
        });
        this.anims = this.anims.filter((anim) => !anim.completed);
    }
    cancelAnimFrame() {
        if (this.requestId) {
            window.cancelAnimationFrame(this.requestId);
        }
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js":
/*!***************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TICK_SIZE": () => (/* binding */ TICK_SIZE),
/* harmony export */   "tick": () => (/* binding */ tick)
/* harmony export */ });
/* harmony import */ var _basic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");

const TICK_SIZE = 5;
function tick(ctx, tickModel) {
    const { x, y, isYAxis, tickSize = TICK_SIZE, strokeStyle, lineWidth } = tickModel;
    const lineModel = {
        type: 'line',
        x,
        y,
        x2: x,
        y2: y,
        strokeStyle,
        lineWidth,
    };
    if (isYAxis) {
        lineModel.x2 += tickSize;
    }
    else {
        lineModel.y2 += tickSize;
    }
    (0,_basic__WEBPACK_IMPORTED_MODULE_0__.line)(ctx, lineModel);
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js":
/*!****************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clipRectArea": () => (/* binding */ clipRectArea),
/* harmony export */   "pathRect": () => (/* binding */ pathRect),
/* harmony export */   "circle": () => (/* binding */ circle),
/* harmony export */   "line": () => (/* binding */ line),
/* harmony export */   "rect": () => (/* binding */ rect),
/* harmony export */   "arc": () => (/* binding */ arc)
/* harmony export */ });
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _helpers_sector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/sector */ "./node_modules/@toast-ui/chart/dist/esm/helpers/sector.js");


const circleStyle = {
    default: {
        strokeStyle: '#ffffff',
        lineWidth: 2,
    },
    plot: {
        lineWidth: 1,
        strokeStyle: 'rgba(0, 0, 0, 0.05)',
    },
};
const rectStyle = {
    shadow: {
        shadowColor: 'rgba(0, 0, 0, 0.3)',
        shadowOffsetX: 2,
        shadowOffsetY: 2,
        shadowBlur: 6,
    },
};
function clipRectArea(ctx, clipRectAreaModel) {
    const { x, y, width, height } = clipRectAreaModel;
    ctx.beginPath();
    ctx.rect(x, y, width, height);
    ctx.clip();
}
function pathRect(ctx, pathRectModel) {
    const { x, y, width, height, radius = 0, stroke: strokeStyle = 'black', fill = '', lineWidth = 1, } = pathRectModel;
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    if (fill) {
        (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.fillStyle)(ctx, fill);
    }
    (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.strokeWithOptions)(ctx, { lineWidth, strokeStyle });
}
function circle(ctx, circleModel) {
    const { x, y, style, radius, color, angle = { start: 0, end: Math.PI * 2 }, borderWidth: lineWidth, borderColor: strokeStyle, } = circleModel;
    ctx.beginPath();
    if (style) {
        const styleObj = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.makeStyleObj)(style, circleStyle);
        Object.keys(styleObj).forEach((key) => {
            ctx[key] = styleObj[key];
        });
    }
    ctx.arc(x, y, radius, angle.start, angle.end, true);
    (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.strokeWithOptions)(ctx, { lineWidth, strokeStyle });
    (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.fillStyle)(ctx, color);
    ctx.closePath();
}
function line(ctx, lineModel) {
    const { x, y, x2, y2, strokeStyle, lineWidth, dashSegments } = lineModel;
    ctx.beginPath();
    if (dashSegments) {
        (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.setLineDash)(ctx, dashSegments);
    }
    ctx.moveTo(x, y);
    ctx.lineTo(x2, y2);
    (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.strokeWithOptions)(ctx, { strokeStyle, lineWidth });
    ctx.closePath();
}
function rect(ctx, model) {
    const { x, y, width, height, style, thickness = 0, color, borderColor = '#ffffff' } = model;
    ctx.beginPath();
    if (style) {
        const styleObj = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.makeStyleObj)(style, rectStyle);
        Object.keys(styleObj).forEach((key) => {
            ctx[key] = styleObj[key];
        });
    }
    if (thickness) {
        ctx.fillStyle = borderColor;
        ctx.fillRect(x - thickness, y - thickness, width + thickness * 2, height + thickness * 2);
        ctx.shadowColor = 'rgba(0, 0, 0, 0)'; // reset shadow color
    }
    ctx.rect(x, y, width, height);
    (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.fillStyle)(ctx, color);
}
function arc(ctx, arcModel) {
    const { x, y, angle: { start, end }, borderWidth: lineWidth, borderColor: strokeStyle, drawingStartAngle, radius, clockwise = true, } = arcModel;
    ctx.beginPath();
    const startRadian = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_1__.calculateDegreeToRadian)(start, drawingStartAngle);
    const endRadian = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_1__.calculateDegreeToRadian)(end, drawingStartAngle);
    ctx.arc(x, y, radius, startRadian, endRadian, !clockwise);
    (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.strokeWithOptions)(ctx, { lineWidth, strokeStyle });
    ctx.closePath();
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/brushes/boxPlot.js":
/*!******************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/brushes/boxPlot.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "boxPlot": () => (/* binding */ boxPlot)
/* harmony export */ });
/* harmony import */ var _basic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");

function boxPlot(ctx, model) {
    const { rect: rectModel, upperWhisker, lowerWhisker, median, minimum, maximum } = model;
    if (minimum) {
        (0,_basic__WEBPACK_IMPORTED_MODULE_0__.line)(ctx, Object.assign({ type: 'line' }, minimum));
    }
    if (lowerWhisker) {
        (0,_basic__WEBPACK_IMPORTED_MODULE_0__.line)(ctx, Object.assign({ type: 'line' }, lowerWhisker));
    }
    if (rectModel) {
        (0,_basic__WEBPACK_IMPORTED_MODULE_0__.rect)(ctx, Object.assign({ type: 'rect' }, rectModel));
    }
    if (upperWhisker) {
        (0,_basic__WEBPACK_IMPORTED_MODULE_0__.line)(ctx, Object.assign({ type: 'line' }, upperWhisker));
    }
    if (maximum) {
        (0,_basic__WEBPACK_IMPORTED_MODULE_0__.line)(ctx, Object.assign({ type: 'line' }, maximum));
    }
    if (median) {
        (0,_basic__WEBPACK_IMPORTED_MODULE_0__.line)(ctx, Object.assign({ type: 'line' }, median));
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/brushes/circleLegend.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/brushes/circleLegend.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "circleLegend": () => (/* binding */ circleLegend)
/* harmony export */ });
/* harmony import */ var _basic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _label__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");


function circleLegend(ctx, circleLegendModel) {
    const { x, y, radius, value } = circleLegendModel;
    const ratioArray = [1, 0.5, 0.25];
    ratioArray.forEach((ratio, idx) => {
        const circleRadius = ratio * radius;
        const circleY = y + (idx ? (1 - ratio) * radius : 0);
        (0,_basic__WEBPACK_IMPORTED_MODULE_0__.circle)(ctx, {
            type: 'circle',
            x,
            y: circleY,
            radius: circleRadius,
            color: '#fff',
            seriesIndex: 0,
            style: ['default', { strokeStyle: '#888', lineWidth: 1 }],
        });
        (0,_label__WEBPACK_IMPORTED_MODULE_1__.label)(ctx, {
            type: 'label',
            x,
            y: circleY - circleRadius,
            text: String(value * ratio),
            style: ['default', { textAlign: 'center', textBaseline: 'bottom' }],
        });
    });
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/brushes/dataLabel.js":
/*!********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/brushes/dataLabel.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dataLabel": () => (/* binding */ dataLabel),
/* harmony export */   "drawBubbleLabel": () => (/* binding */ drawBubbleLabel),
/* harmony export */   "getBubbleArrowPoints": () => (/* binding */ getBubbleArrowPoints)
/* harmony export */ });
/* harmony import */ var _label__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _basic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");





function dataLabel(ctx, model) {
    var _a;
    const { x, y, text, textAlign, textBaseline, opacity, callout, theme, radian } = model;
    const { color, textBubble } = theme;
    const font = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.getFont)(theme);
    const textStyle = { textAlign, textBaseline, font, fillStyle: color };
    const textStrokeStyle = getTextStrokeStyle(theme);
    if (callout) {
        const { theme: { lineWidth, lineColor }, } = callout;
        (0,_basic__WEBPACK_IMPORTED_MODULE_1__.line)(ctx, Object.assign(Object.assign({ type: 'line' }, (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.pick)(callout, 'x', 'y', 'x2', 'y2')), { strokeStyle: lineColor, lineWidth }));
    }
    if ((_a = textBubble) === null || _a === void 0 ? void 0 : _a.visible) {
        drawBubbleLabel(ctx, model);
        return;
    }
    (0,_label__WEBPACK_IMPORTED_MODULE_3__.label)(ctx, {
        type: 'label',
        x,
        y,
        text,
        style: [textStyle],
        stroke: [textStrokeStyle],
        opacity,
        radian,
    });
}
function drawBubbleLabel(ctx, model) {
    const { text, theme, radian = 0 } = model;
    const { color, textStrokeColor } = theme;
    const font = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.getFont)(theme);
    const bubbleRect = getBubbleRect(model);
    const { x, y, width, height } = bubbleRect;
    (0,_label__WEBPACK_IMPORTED_MODULE_3__.bubbleLabel)(ctx, {
        type: 'bubbleLabel',
        radian,
        rotationPosition: { x: model.x, y: model.y },
        bubble: bubbleRect,
        label: {
            x: x + width / 2,
            y: y + height / 2,
            text,
            style: [{ font, fillStyle: color, textAlign: 'center', textBaseline: 'middle' }],
            strokeStyle: textStrokeColor,
        },
    });
}
function getBubbleArrowPoints(direction, { x, y }, arrowPointTheme) {
    const width = arrowPointTheme.width;
    const height = arrowPointTheme.height;
    let points = [];
    if (direction === 'top') {
        points = [
            { x: x - width / 2, y: y + height },
            { x, y },
            { x: x + width / 2, y: y + height },
        ];
    }
    else if (direction === 'bottom') {
        points = [
            { x: x + width / 2, y: y - height },
            { x, y },
            { x: x - width / 2, y: y - height },
        ];
    }
    else if (direction === 'right') {
        points = [
            { x: x - height, y: y - width / 2 },
            { x, y },
            { x: x - height, y: y + width / 2 },
        ];
    }
    else if (direction === 'left') {
        points = [
            { x: x + height, y: y + width / 2 },
            { x, y },
            { x: x + height, y: y - width / 2 },
        ];
    }
    return points;
}
function getBubbleRect(model) {
    const { text, theme, textAlign, textBaseline } = model;
    const font = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.getFont)(theme);
    const { arrow, paddingX, paddingY, borderRadius, borderColor, borderWidth, backgroundColor, shadowBlur, shadowOffsetX, shadowOffsetY, shadowColor, } = theme.textBubble;
    const labelWidth = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_4__.getTextWidth)(text, font);
    const width = labelWidth + paddingX * 2;
    const height = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_4__.getTextHeight)(text, font) + paddingY * 2;
    let { x, y } = model;
    if (textAlign === 'center') {
        x -= width / 2;
    }
    else if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.includes)(['right', 'end'], textAlign)) {
        x -= width;
    }
    if (textBaseline === 'middle') {
        y -= height / 2;
    }
    else if (textBaseline === 'bottom') {
        y -= height;
    }
    const rect = { x, y, width, height };
    return Object.assign(Object.assign(Object.assign({}, rect), { radius: borderRadius, lineWidth: borderWidth, fill: backgroundColor, strokeStyle: borderColor, style: [
            {
                shadowBlur,
                shadowOffsetX,
                shadowOffsetY,
                shadowColor,
            },
        ] }), getArrowInfo(rect, textAlign, textBaseline, arrow));
}
function getArrowInfo(rect, textAlign, textBaseline, theme) {
    var _a, _b;
    if (!((_a = theme) === null || _a === void 0 ? void 0 : _a.visible)) {
        return null;
    }
    const arrowHeight = theme.height;
    const { width, height } = rect;
    const direction = (_b = theme.direction, (_b !== null && _b !== void 0 ? _b : getArrowDirection(textAlign, textBaseline)));
    let { x: boxX, y: boxY } = rect;
    let { x: pointX, y: pointY } = rect;
    if (direction === 'top') {
        boxY += arrowHeight;
    }
    else if (direction === 'bottom') {
        boxY -= arrowHeight;
        pointY += height;
    }
    else if (direction === 'right') {
        boxX -= arrowHeight;
        pointX += width;
    }
    else if (direction === 'left') {
        boxX += arrowHeight;
    }
    if (textAlign === 'center') {
        pointX = rect.x + width / 2;
    }
    else if (textBaseline === 'middle') {
        pointY = rect.y + height / 2;
    }
    return {
        direction,
        points: getBubbleArrowPoints(direction, { x: pointX, y: pointY }, theme),
        x: boxX,
        y: boxY,
    };
}
function getArrowDirection(textAlign, textBaseline) {
    let direction = 'top';
    if (textAlign === 'center' && textBaseline === 'top') {
        direction = 'top';
    }
    else if (textAlign === 'center' && textBaseline === 'bottom') {
        direction = 'bottom';
    }
    else if (textBaseline === 'middle' && textAlign === 'right') {
        direction = 'right';
    }
    else if (textBaseline === 'middle' && textAlign === 'left') {
        direction = 'left';
    }
    return direction;
}
function getTextStrokeStyle(theme) {
    const { textStrokeColor } = theme;
    const textStrokeStyle = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.pick)(theme, 'lineWidth', 'shadowColor', 'shadowBlur');
    if (textStrokeColor) {
        textStrokeStyle.strokeStyle = textStrokeColor;
    }
    return textStrokeStyle;
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "exportMenuButton": () => (/* binding */ exportMenuButton)
/* harmony export */ });
/* harmony import */ var _basic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");


function drawXIcon(ctx, icon, rectSize) {
    const { x: startX, y: startY, theme: { color: strokeStyle, lineWidth }, } = icon;
    const offset = rectSize / 3;
    const x = startX + offset;
    const y = startY + offset;
    const x2 = startX + offset * 2;
    const y2 = startY + offset * 2;
    const points = [
        { x, y, x2, y2 },
        { x, y: y2, x2, y2: y },
    ];
    points.forEach((p) => {
        (0,_basic__WEBPACK_IMPORTED_MODULE_0__.line)(ctx, Object.assign(Object.assign({ type: 'line' }, p), { strokeStyle, lineWidth }));
    });
}
function drawMoreIcon(ctx, icon, rectSize) {
    const { x, y, theme: { color, width, height, gap }, } = icon;
    const paddingX = (rectSize - width) / 2;
    const paddingY = (rectSize - (height * 3 + gap * 2)) / 2;
    const centerX = x + paddingX;
    const points = [
        { x: centerX, y: y + paddingY },
        { x: centerX, y: y + paddingY + height + gap },
        { x: centerX, y: y + paddingY + (height + gap) * 2 },
    ];
    points.forEach((p) => {
        (0,_basic__WEBPACK_IMPORTED_MODULE_0__.rect)(ctx, Object.assign(Object.assign({ type: 'rect' }, p), { color, width: width, height: height }));
    });
}
function exportMenuButton(ctx, exportMenuButtonModel) {
    const { opened, x: xPos, y: yPos, theme } = exportMenuButtonModel;
    const { borderColor, backgroundColor, borderWidth, borderRadius, xIcon, dotIcon, } = theme;
    const x = xPos + borderWidth;
    const y = yPos + borderWidth;
    const rectSize = _component_exportMenu__WEBPACK_IMPORTED_MODULE_1__.BUTTON_RECT_SIZE - 2 * borderWidth;
    (0,_basic__WEBPACK_IMPORTED_MODULE_0__.pathRect)(ctx, {
        type: 'pathRect',
        x,
        y,
        fill: backgroundColor,
        stroke: borderColor,
        width: rectSize,
        height: rectSize,
        radius: borderRadius,
        lineWidth: borderWidth,
    });
    if (opened) {
        drawXIcon(ctx, { x, y, theme: xIcon }, rectSize);
    }
    else {
        drawMoreIcon(ctx, { x, y, theme: dotIcon }, rectSize);
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/brushes/gauge.js":
/*!****************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/brushes/gauge.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clockHand": () => (/* binding */ clockHand)
/* harmony export */ });
/* harmony import */ var _helpers_sector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/sector */ "./node_modules/@toast-ui/chart/dist/esm/helpers/sector.js");
/* harmony import */ var _basic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polygon */ "./node_modules/@toast-ui/chart/dist/esm/brushes/polygon.js");



function getClockHandPoints(model) {
    const { x, y, x2, y2, degree, baseLine } = model;
    const halfBaseLine = baseLine / 2;
    let startPoint, endPoint;
    if (x === x2) {
        startPoint = { x: x - halfBaseLine, y };
        endPoint = { x: x + halfBaseLine, y };
    }
    else if (y === y2) {
        startPoint = { x, y: y - halfBaseLine };
        endPoint = { x, y: y + halfBaseLine };
    }
    else {
        startPoint = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_0__.getRadialPosition)(x, y, halfBaseLine, (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_0__.calculateDegreeToRadian)((0,_helpers_sector__WEBPACK_IMPORTED_MODULE_0__.calculateValidAngle)(degree + _helpers_sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_90)));
        endPoint = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_0__.getRadialPosition)(x, y, halfBaseLine, (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_0__.calculateDegreeToRadian)((0,_helpers_sector__WEBPACK_IMPORTED_MODULE_0__.calculateValidAngle)(degree - _helpers_sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_90)));
    }
    return [startPoint, { x: x2, y: y2 }, endPoint];
}
function clockHand(ctx, model) {
    const { color, x, y, pin: { color: pinColor, radius, style }, } = model;
    (0,_basic__WEBPACK_IMPORTED_MODULE_1__.circle)(ctx, {
        type: 'circle',
        x,
        y,
        radius,
        color: pinColor,
        style,
    });
    (0,_polygon__WEBPACK_IMPORTED_MODULE_2__.polygon)(ctx, {
        type: 'polygon',
        color,
        lineWidth: 1,
        fillColor: color,
        points: getClockHandPoints(model),
    });
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js":
/*!****************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/brushes/label.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_LABEL_TEXT": () => (/* binding */ DEFAULT_LABEL_TEXT),
/* harmony export */   "labelStyle": () => (/* binding */ labelStyle),
/* harmony export */   "strokeLabelStyle": () => (/* binding */ strokeLabelStyle),
/* harmony export */   "label": () => (/* binding */ label),
/* harmony export */   "bubbleLabel": () => (/* binding */ bubbleLabel)
/* harmony export */ });
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");



const DEFAULT_LABEL_TEXT = 'normal 11px Arial';
const labelStyle = {
    default: {
        font: DEFAULT_LABEL_TEXT,
        fillStyle: '#333333',
        textAlign: 'left',
        textBaseline: 'middle',
    },
    title: {
        textBaseline: 'top',
    },
    axisTitle: {
        textBaseline: 'top',
    },
    rectLabel: {
        font: DEFAULT_LABEL_TEXT,
        fillStyle: 'rgba(0, 0, 0, 0.3)',
        textAlign: 'center',
        textBaseline: 'middle',
    },
};
const strokeLabelStyle = {
    none: {
        lineWidth: 1,
        strokeStyle: 'rgba(255, 255, 255, 0)',
    },
    stroke: {
        lineWidth: 4,
        strokeStyle: 'rgba(255, 255, 255, 0.5)',
    },
};
function label(ctx, labelModel) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { x, y, text, style, stroke, opacity, radian, rotationPosition } = labelModel;
    if (style) {
        const styleObj = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.makeStyleObj)(style, labelStyle);
        Object.keys(styleObj).forEach((key) => {
            ctx[key] =
                key === 'fillStyle' && (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(opacity) ? (0,_helpers_color__WEBPACK_IMPORTED_MODULE_2__.rgba)(styleObj[key], opacity) : styleObj[key];
        });
    }
    ctx.save();
    if (radian) {
        ctx.translate((_b = (_a = rotationPosition) === null || _a === void 0 ? void 0 : _a.x, (_b !== null && _b !== void 0 ? _b : x)), (_d = (_c = rotationPosition) === null || _c === void 0 ? void 0 : _c.y, (_d !== null && _d !== void 0 ? _d : y)));
        ctx.rotate(radian);
        ctx.translate(-(_f = (_e = rotationPosition) === null || _e === void 0 ? void 0 : _e.x, (_f !== null && _f !== void 0 ? _f : x)), -(_h = (_g = rotationPosition) === null || _g === void 0 ? void 0 : _g.y, (_h !== null && _h !== void 0 ? _h : y)));
    }
    if (stroke) {
        const strokeStyleObj = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.makeStyleObj)(stroke, strokeLabelStyle);
        const strokeStyleKeys = Object.keys(strokeStyleObj);
        strokeStyleKeys.forEach((key) => {
            ctx[key] =
                key === 'strokeStyle' && (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(opacity)
                    ? (0,_helpers_color__WEBPACK_IMPORTED_MODULE_2__.rgba)(strokeStyleObj[key], opacity)
                    : strokeStyleObj[key];
        });
        if (strokeStyleKeys.length) {
            ctx.strokeText(text, x, y);
        }
    }
    ctx.fillText(text, x, y);
    ctx.restore();
}
const textBubbleStyle = {
    shadow: {
        shadowColor: 'rgba(0, 0, 0, 0.3)',
        shadowOffsetY: 2,
        shadowBlur: 4,
    },
};
function bubbleLabel(ctx, model) {
    var _a, _b, _c, _d;
    const { radian = 0, rotationPosition, bubble: { x, y, width, height, radius = 0, lineWidth = 1, direction, points = [], fill = '#fff', strokeStyle = 'rgba(0, 0, 0, 0)', style: bubbleStyle = null, }, } = model;
    if (width > 0 && height > 0) {
        drawBubble(ctx, {
            x,
            y,
            radius,
            width,
            height,
            style: bubbleStyle,
            fill,
            strokeStyle,
            lineWidth,
            direction,
            points,
            radian,
            rotationPosition: {
                x: (_b = (_a = rotationPosition) === null || _a === void 0 ? void 0 : _a.x, (_b !== null && _b !== void 0 ? _b : x)),
                y: (_d = (_c = rotationPosition) === null || _c === void 0 ? void 0 : _c.y, (_d !== null && _d !== void 0 ? _d : y)),
            },
        });
    }
    if (model.label.text) {
        const { x: labelX, y: labelY, text, strokeStyle: labelStrokeColor = 'rgba(0, 0, 0, 0)', style, } = model.label;
        ctx.shadowColor = 'rgba(0, 0, 0, 0)';
        label(ctx, {
            type: 'label',
            x: labelX,
            y: labelY,
            text,
            style,
            stroke: [{ strokeStyle: labelStrokeColor }],
            radian,
            rotationPosition,
        });
    }
}
function drawBubbleArrow(ctx, points) {
    if (!points.length) {
        return;
    }
    ctx.lineTo(points[0].x, points[0].y);
    ctx.lineTo(points[1].x, points[1].y);
    ctx.lineTo(points[2].x, points[2].y);
}
function drawBubble(ctx, model) {
    const { x, y, width, height, style, radius = 0, strokeStyle, fill, lineWidth = 1, points = [], direction = '', radian, rotationPosition, } = model;
    const right = x + width;
    const bottom = y + height;
    ctx.beginPath();
    ctx.save();
    if (radian && rotationPosition) {
        ctx.translate(rotationPosition.x, rotationPosition.y);
        ctx.rotate(radian);
        ctx.translate(-rotationPosition.x, -rotationPosition.y);
    }
    ctx.moveTo(x + radius, y);
    if (direction === 'top') {
        drawBubbleArrow(ctx, points);
    }
    ctx.lineTo(right - radius, y);
    ctx.quadraticCurveTo(right, y, right, y + radius);
    if (direction === 'right') {
        drawBubbleArrow(ctx, points);
    }
    ctx.lineTo(right, y + height - radius);
    ctx.quadraticCurveTo(right, bottom, right - radius, bottom);
    if (direction === 'bottom') {
        drawBubbleArrow(ctx, points);
    }
    ctx.lineTo(x + radius, bottom);
    ctx.quadraticCurveTo(x, bottom, x, bottom - radius);
    if (direction === 'left') {
        drawBubbleArrow(ctx, points);
    }
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    if (style) {
        const styleObj = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.makeStyleObj)(style, textBubbleStyle);
        Object.keys(styleObj).forEach((key) => {
            ctx[key] = styleObj[key];
        });
    }
    if (fill) {
        (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.fillStyle)(ctx, fill);
    }
    if (strokeStyle) {
        (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.strokeWithOptions)(ctx, { strokeStyle, lineWidth });
    }
    ctx.restore();
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LEGEND_ITEM_MARGIN_X": () => (/* binding */ LEGEND_ITEM_MARGIN_X),
/* harmony export */   "LEGEND_MARGIN_X": () => (/* binding */ LEGEND_MARGIN_X),
/* harmony export */   "LEGEND_CHECKBOX_SIZE": () => (/* binding */ LEGEND_CHECKBOX_SIZE),
/* harmony export */   "LEGEND_ICON_SIZE": () => (/* binding */ LEGEND_ICON_SIZE),
/* harmony export */   "getLegendItemHeight": () => (/* binding */ getLegendItemHeight),
/* harmony export */   "legend": () => (/* binding */ legend)
/* harmony export */ });
/* harmony import */ var _basic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _label__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _helpers_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");
/* harmony import */ var _scatterSeries__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scatterSeries */ "./node_modules/@toast-ui/chart/dist/esm/brushes/scatterSeries.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _store_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../store/layout */ "./node_modules/@toast-ui/chart/dist/esm/store/layout.js");







const LEGEND_ITEM_MARGIN_X = 40;
const LEGEND_MARGIN_X = 5;
const LEGEND_CHECKBOX_SIZE = 12;
const LEGEND_ICON_SIZE = 12;
const ICON_BORDER_WIDTH = 1.5;
const INACTIVE_OPACITY = 0.3;
const RECT_SIZE = 10;
const LINE_ICON_PADDING = 2;
const CIRCLE_ICON_RADIUS = 6;
function getLegendItemHeight(fontSize) {
    return fontSize + _store_layout__WEBPACK_IMPORTED_MODULE_0__.padding.Y;
}
function drawLineIcon(ctx, x, y, color) {
    const xCurveOffset = [2, 2, 6, 6, 10, 10];
    const yCurveOffset = [8, 0, 0, 8, 8, 0];
    xCurveOffset.forEach((xOffset, idx) => {
        if (idx === 5) {
            return;
        }
        (0,_basic__WEBPACK_IMPORTED_MODULE_1__.line)(ctx, {
            type: 'line',
            x: x + xOffset,
            y: y + yCurveOffset[idx],
            x2: x + xCurveOffset[idx + 1],
            y2: y + yCurveOffset[idx + 1],
            lineWidth: 2,
            strokeStyle: color,
        });
    });
}
function drawCheckIcon(ctx, x, y, active) {
    const color = '#555555';
    const strokeStyle = active ? color : (0,_helpers_color__WEBPACK_IMPORTED_MODULE_2__.getRGBA)(color, INACTIVE_OPACITY);
    (0,_basic__WEBPACK_IMPORTED_MODULE_1__.line)(ctx, {
        type: 'line',
        x: x + 2,
        y: y + 5,
        x2: x + 5,
        y2: y + 8,
        strokeStyle,
        lineWidth: 2,
    });
    (0,_basic__WEBPACK_IMPORTED_MODULE_1__.line)(ctx, {
        type: 'line',
        x: x + 5,
        y: y + 9,
        x2: x + 10,
        y2: y + 3,
        strokeStyle,
        lineWidth: 2,
    });
}
function drawCheckbox(ctx, x, y, renderOptions) {
    const { active, checked } = renderOptions;
    const borderColor = active ? '#bbb' : (0,_helpers_color__WEBPACK_IMPORTED_MODULE_2__.getRGBA)('#bbbbbb', INACTIVE_OPACITY);
    (0,_basic__WEBPACK_IMPORTED_MODULE_1__.rect)(ctx, {
        type: 'rect',
        x,
        y,
        width: LEGEND_CHECKBOX_SIZE,
        height: LEGEND_CHECKBOX_SIZE,
        color: '#fff',
        borderColor,
        thickness: 1,
    });
    if (checked) {
        drawCheckIcon(ctx, x, y, active);
    }
}
function drawIcon(ctx, x, y, renderOptions) {
    const { iconType, active, color, showCheckbox } = renderOptions;
    const iconX = x + (showCheckbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0);
    const iconColor = active ? color : (0,_helpers_color__WEBPACK_IMPORTED_MODULE_2__.getRGBA)(color, INACTIVE_OPACITY);
    if (iconType === 'rect') {
        (0,_basic__WEBPACK_IMPORTED_MODULE_1__.rect)(ctx, {
            type: 'rect',
            x: iconX,
            y: y + (LEGEND_CHECKBOX_SIZE - RECT_SIZE) / 2,
            width: RECT_SIZE,
            height: RECT_SIZE,
            color: iconColor,
        });
    }
    else if (iconType === 'line') {
        drawLineIcon(ctx, iconX, y + LINE_ICON_PADDING, iconColor);
    }
    else if (iconType === 'circle') {
        (0,_basic__WEBPACK_IMPORTED_MODULE_1__.circle)(ctx, {
            type: 'circle',
            x: iconX + CIRCLE_ICON_RADIUS,
            y: y + CIRCLE_ICON_RADIUS,
            radius: CIRCLE_ICON_RADIUS,
            color: iconColor,
            style: ['default'],
        });
    }
}
function drawScatterIcon(ctx, x, y, renderOptions) {
    const { iconType, active, color, showCheckbox } = renderOptions;
    const iconX = x + (showCheckbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0);
    const iconColor = active ? color : (0,_helpers_color__WEBPACK_IMPORTED_MODULE_2__.getRGBA)(color, INACTIVE_OPACITY);
    (0,_scatterSeries__WEBPACK_IMPORTED_MODULE_3__.scatterSeries)(ctx, {
        type: 'scatterSeries',
        iconType: iconType,
        x: iconX + CIRCLE_ICON_RADIUS,
        y: y + CIRCLE_ICON_RADIUS,
        borderColor: iconColor,
        size: CIRCLE_ICON_RADIUS * 2,
        fillColor: 'rgba(255, 255, 255, 0)',
        borderWidth: ICON_BORDER_WIDTH,
    });
}
function drawLabel(ctx, x, y, text, renderOptions) {
    const { active, showCheckbox, font, fontColor } = renderOptions;
    const fillStyle = active ? fontColor : (0,_helpers_color__WEBPACK_IMPORTED_MODULE_2__.getRGBA)(fontColor, INACTIVE_OPACITY);
    (0,_label__WEBPACK_IMPORTED_MODULE_4__.label)(ctx, {
        type: 'label',
        x: x +
            LEGEND_ICON_SIZE +
            LEGEND_MARGIN_X +
            (showCheckbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0),
        y,
        text,
        style: ['default', { font, textBaseline: 'top', fillStyle }],
    });
}
function legend(ctx, model) {
    const { data, showCheckbox, align, fontSize, fontFamily, fontWeight } = model;
    const font = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_5__.getTitleFontString)({ fontSize, fontFamily, fontWeight });
    const fontColor = model.color;
    data.forEach((datum) => {
        const { x, y, checked, active, color, iconType, useScatterChartIcon, viewLabel: legendLabel, } = datum;
        const iconY = y - 1 + ((0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_6__.getTextHeight)(legendLabel, font) - 11) / 4;
        const renderOptions = {
            iconType,
            checked,
            active,
            color,
            showCheckbox,
            align,
            font,
            fontColor,
        };
        if (showCheckbox) {
            drawCheckbox(ctx, x, iconY, renderOptions);
        }
        if (useScatterChartIcon && iconType !== 'line') {
            drawScatterIcon(ctx, x, iconY, renderOptions);
        }
        else {
            drawIcon(ctx, x, iconY, renderOptions);
        }
        drawLabel(ctx, x, y, legendLabel, renderOptions);
    });
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/brushes/lineSeries.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/brushes/lineSeries.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linePoints": () => (/* binding */ linePoints),
/* harmony export */   "areaPoints": () => (/* binding */ areaPoints)
/* harmony export */ });
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");


function linePoints(ctx, pointsModel) {
    const { color: strokeStyle, lineWidth, points, dashSegments = [] } = pointsModel;
    ctx.lineCap = 'round';
    ctx.beginPath();
    if (dashSegments) {
        (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.setLineDash)(ctx, dashSegments);
    }
    let start = false;
    points.forEach((point, idx) => {
        var _a, _b;
        if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(point)) {
            start = false;
            return;
        }
        if (!start) {
            ctx.moveTo(point.x, point.y);
            start = true;
            return;
        }
        if (point.controlPoint && ((_b = (_a = points[idx - 1]) === null || _a === void 0 ? void 0 : _a.controlPoint) === null || _b === void 0 ? void 0 : _b.next)) {
            const { x: prevX, y: prevY } = points[idx - 1].controlPoint.next;
            const { controlPoint, x, y } = point;
            ctx.bezierCurveTo(prevX, prevY, controlPoint.prev.x, controlPoint.prev.y, x, y);
        }
        else {
            ctx.lineTo(point.x, point.y);
        }
    });
    (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.strokeWithOptions)(ctx, { lineWidth, strokeStyle });
    ctx.closePath();
    (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.setLineDash)(ctx, []);
}
function areaPoints(ctx, areaPointsModel) {
    const { fillColor } = areaPointsModel;
    ctx.beginPath();
    linePoints(ctx, areaPointsModel);
    (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.fillStyle)(ctx, fillColor);
    ctx.closePath();
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/brushes/polygon.js":
/*!******************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/brushes/polygon.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "polygon": () => (/* binding */ polygon)
/* harmony export */ });
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");

function polygon(ctx, polygonModel) {
    const { color: strokeStyle, points, lineWidth, fillColor, dashSegments = [] } = polygonModel;
    if (!points.length) {
        return;
    }
    ctx.beginPath();
    if (dashSegments) {
        (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.setLineDash)(ctx, dashSegments);
    }
    points.forEach(({ x, y }, idx) => {
        if (idx === 0) {
            ctx.moveTo(x, y);
            return;
        }
        ctx.lineTo(x, y);
    });
    ctx.lineTo(points[0].x, points[0].y);
    if (fillColor) {
        (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.fillStyle)(ctx, fillColor);
    }
    (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.strokeWithOptions)(ctx, { lineWidth, strokeStyle });
    ctx.closePath();
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/brushes/resetButton.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/brushes/resetButton.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "backButton": () => (/* binding */ backButton),
/* harmony export */   "resetButton": () => (/* binding */ resetButton)
/* harmony export */ });
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _basic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _lineSeries__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lineSeries */ "./node_modules/@toast-ui/chart/dist/esm/brushes/lineSeries.js");



const ARROW_HEIGHT = 3;
const ARROW_WIDTH = 6;
function drawResetIcon(ctx, point) {
    const { x, y } = point;
    const centerX = x + _component_exportMenu__WEBPACK_IMPORTED_MODULE_0__.BUTTON_RECT_SIZE / 2;
    const centerY = y + _component_exportMenu__WEBPACK_IMPORTED_MODULE_0__.BUTTON_RECT_SIZE / 2;
    const tickSize = _component_exportMenu__WEBPACK_IMPORTED_MODULE_0__.BUTTON_RECT_SIZE / 10;
    const color = '#545454';
    (0,_basic__WEBPACK_IMPORTED_MODULE_1__.circle)(ctx, {
        type: 'circle',
        x: centerX,
        y: centerY,
        radius: tickSize * 2,
        angle: { start: 0, end: Math.PI / 2 },
        color: 'transparent',
        style: [{ lineWidth: 2, strokeStyle: color }],
    });
    const pointStartX = centerX + tickSize * 2;
    const pointStartY = centerY;
    const points = [
        { x: pointStartX - ARROW_WIDTH / 2, y: pointStartY },
        { x: pointStartX + ARROW_WIDTH / 2, y: pointStartY },
        { x: pointStartX, y: pointStartY + ARROW_HEIGHT },
    ];
    (0,_lineSeries__WEBPACK_IMPORTED_MODULE_2__.areaPoints)(ctx, {
        type: 'areaPoints',
        points,
        lineWidth: 1,
        color,
        fillColor: color,
    });
}
function drawBackIcon(ctx, point) {
    const barWidth = 4;
    const radius = _component_exportMenu__WEBPACK_IMPORTED_MODULE_0__.BUTTON_RECT_SIZE / 7;
    const { x, y } = point;
    const centerX = x + _component_exportMenu__WEBPACK_IMPORTED_MODULE_0__.BUTTON_RECT_SIZE / 2;
    const centerY = y + _component_exportMenu__WEBPACK_IMPORTED_MODULE_0__.BUTTON_RECT_SIZE / 2;
    const color = '#545454';
    (0,_basic__WEBPACK_IMPORTED_MODULE_1__.line)(ctx, {
        type: 'line',
        lineWidth: 2,
        x: centerX - barWidth / 2,
        y: centerY + radius,
        x2: centerX + barWidth / 2,
        y2: centerY + radius,
        strokeStyle: color,
    });
    (0,_basic__WEBPACK_IMPORTED_MODULE_1__.line)(ctx, {
        type: 'line',
        lineWidth: 2,
        x: centerX - barWidth / 2,
        y: centerY - radius,
        x2: centerX + barWidth / 2,
        y2: centerY - radius,
        strokeStyle: color,
    });
    (0,_basic__WEBPACK_IMPORTED_MODULE_1__.circle)(ctx, {
        type: 'circle',
        x: centerX + barWidth / 2,
        y: centerY,
        radius,
        angle: { start: Math.PI / 2, end: (Math.PI * 3) / 2 },
        color: 'transparent',
        style: [{ lineWidth: 2, strokeStyle: color }],
    });
    const pointStartX = centerX - barWidth / 2;
    const pointStartY = centerY - radius;
    const points = [
        { x: pointStartX - ARROW_HEIGHT, y: pointStartY },
        { x: pointStartX, y: pointStartY - ARROW_WIDTH / 2 },
        { x: pointStartX, y: pointStartY + ARROW_WIDTH / 2 },
    ];
    (0,_lineSeries__WEBPACK_IMPORTED_MODULE_2__.areaPoints)(ctx, {
        type: 'areaPoints',
        points,
        lineWidth: 1,
        color,
        fillColor: color,
    });
}
function backButton(ctx, backButtonModel) {
    const { x, y } = backButtonModel;
    (0,_basic__WEBPACK_IMPORTED_MODULE_1__.pathRect)(ctx, {
        type: 'pathRect',
        x,
        y,
        fill: '#f4f4f4',
        stroke: '#f4f4f4',
        width: _component_exportMenu__WEBPACK_IMPORTED_MODULE_0__.BUTTON_RECT_SIZE,
        height: _component_exportMenu__WEBPACK_IMPORTED_MODULE_0__.BUTTON_RECT_SIZE,
        radius: 5,
    });
    drawBackIcon(ctx, { x, y });
}
function resetButton(ctx, resetButtonModel) {
    const { x, y } = resetButtonModel;
    (0,_basic__WEBPACK_IMPORTED_MODULE_1__.pathRect)(ctx, {
        type: 'pathRect',
        x,
        y,
        fill: '#f4f4f4',
        stroke: '#f4f4f4',
        width: _component_exportMenu__WEBPACK_IMPORTED_MODULE_0__.BUTTON_RECT_SIZE,
        height: _component_exportMenu__WEBPACK_IMPORTED_MODULE_0__.BUTTON_RECT_SIZE,
        radius: 5,
    });
    drawResetIcon(ctx, { x, y });
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/brushes/scatterSeries.js":
/*!************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/brushes/scatterSeries.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "scatterSeries": () => (/* binding */ scatterSeries)
/* harmony export */ });
/* harmony import */ var _basic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./polygon */ "./node_modules/@toast-ui/chart/dist/esm/brushes/polygon.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");



function regularPolygon(ctx, model) {
    const { numberOfSides, size, x, y, borderColor, borderWidth, fillColor } = model;
    const s = size / 2;
    const shift = numberOfSides % 2 ? (Math.PI / 180.0) * (10 + (numberOfSides - 3) / 2) * numberOfSides : 0;
    const step = (2 * Math.PI) / numberOfSides;
    ctx.beginPath();
    for (let i = 0; i <= numberOfSides; i += 1) {
        const curStep = i * step + shift;
        ctx.lineTo(x + s * Math.cos(curStep), y + s * Math.sin(curStep));
    }
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = borderWidth;
    (0,_helpers_style__WEBPACK_IMPORTED_MODULE_0__.fillStyle)(ctx, fillColor);
    ctx.stroke();
    ctx.closePath();
}
// https://programmingthomas.wordpress.com/2012/05/16/drawing-stars-with-html5-canvas/
function star(ctx, model) {
    const { x, y, borderColor, borderWidth, size, fillColor } = model;
    ctx.lineWidth = borderWidth;
    ctx.strokeStyle = borderColor;
    ctx.fillStyle = fillColor;
    ctx.save();
    ctx.beginPath();
    ctx.translate(x, y);
    ctx.moveTo(0, -size);
    for (let i = 0; i < 5; i += 1) {
        ctx.rotate(Math.PI / 5);
        ctx.lineTo(0, -size / 2);
        ctx.rotate(Math.PI / 5);
        ctx.lineTo(0, -size);
    }
    ctx.fill();
    ctx.stroke();
    ctx.restore();
    ctx.closePath();
}
function cross(ctx, model) {
    const { x, y, borderColor, borderWidth, size, fillColor } = model;
    const quarter = size / 4;
    const half = size / 2;
    const xPointsOffset = [
        -half,
        -half,
        -quarter,
        -quarter,
        quarter,
        quarter,
        half,
        half,
        quarter,
        quarter,
        -quarter,
        -quarter,
    ];
    const yPointsOffset = [];
    for (let idx = 0, len = xPointsOffset.length; idx < len; idx += 1) {
        const startIdx = 9;
        yPointsOffset.push(xPointsOffset[(startIdx + idx) % len]);
    }
    (0,_polygon__WEBPACK_IMPORTED_MODULE_1__.polygon)(ctx, {
        type: 'polygon',
        lineWidth: borderWidth,
        color: borderColor,
        points: xPointsOffset.map((val, idx) => ({ x: x + val, y: y + yPointsOffset[idx] })),
        fillColor,
    });
}
function getNumberOfSidesByIconType(iconType) {
    switch (iconType) {
        case 'triangle':
            return 3;
        case 'diamond':
            return 4;
        case 'pentagon':
            return 5;
        case 'hexagon':
            return 6;
    }
}
function scatterSeries(ctx, model) {
    const { x, y, borderColor, borderWidth, fillColor, iconType, size } = model;
    const commonModel = { x, y, fillColor, borderColor, borderWidth, size };
    ctx.beginPath();
    switch (iconType) {
        case 'rect':
            (0,_basic__WEBPACK_IMPORTED_MODULE_2__.pathRect)(ctx, {
                type: 'pathRect',
                x: x - size / 2,
                y: y - size / 2,
                width: size,
                height: size,
                stroke: borderColor,
                lineWidth: borderWidth,
                fill: fillColor,
            });
            break;
        case 'triangle':
        case 'pentagon':
        case 'diamond':
        case 'hexagon':
            regularPolygon(ctx, Object.assign({ type: 'regularPolygon', numberOfSides: getNumberOfSidesByIconType(iconType) }, commonModel));
            break;
        case 'star':
            star(ctx, Object.assign(Object.assign({ type: 'star' }, commonModel), { size: size / 2 }));
            break;
        case 'cross':
            cross(ctx, Object.assign({ type: 'cross' }, commonModel));
            break;
        default:
            (0,_basic__WEBPACK_IMPORTED_MODULE_2__.circle)(ctx, {
                type: 'circle',
                x,
                y,
                radius: size / 2,
                style: [{ strokeStyle: borderColor, lineWidth: borderWidth }],
                color: fillColor,
            });
    }
    ctx.stroke();
    ctx.closePath();
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/brushes/sector.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/brushes/sector.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sector": () => (/* binding */ sector)
/* harmony export */ });
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _helpers_sector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/sector */ "./node_modules/@toast-ui/chart/dist/esm/helpers/sector.js");


function sector(ctx, sectorModel) {
    const { degree: { start, end }, color, style, lineWidth, } = sectorModel;
    if (start === end) {
        return;
    }
    const isCircle = Math.abs(start - end) === _helpers_sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_360;
    ctx.beginPath();
    if (style) {
        const styleObj = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_1__.makeStyleObj)(style, {});
        Object.keys(styleObj).forEach((key) => {
            ctx[key] = styleObj[key];
        });
    }
    if (isCircle) {
        drawCircle(ctx, sectorModel);
    }
    else {
        drawSector(ctx, sectorModel);
    }
    ctx.closePath();
    (0,_helpers_style__WEBPACK_IMPORTED_MODULE_1__.fillStyle)(ctx, color);
    if (lineWidth) {
        ctx.lineWidth = lineWidth;
        ctx.stroke();
    }
}
function drawSector(ctx, sectorModel) {
    const { x, y, radius: { inner, outer }, degree: { start, end }, clockwise, drawingStartAngle, } = sectorModel;
    if (inner < 0 || outer < 0) {
        return;
    }
    const startRadian = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_0__.calculateDegreeToRadian)(start, drawingStartAngle);
    const endRadian = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_0__.calculateDegreeToRadian)(end, drawingStartAngle);
    if (!inner) {
        ctx.moveTo(x, y);
    }
    ctx.arc(x, y, outer, startRadian, endRadian, !clockwise);
    if (inner) {
        ctx.arc(x, y, inner, endRadian, startRadian, clockwise);
    }
}
function drawCircle(ctx, sectorModel) {
    const { x, y, radius: { inner, outer }, clockwise, } = sectorModel;
    ctx.arc(x, y, outer, 0, 2 * Math.PI, !clockwise);
    if (inner) {
        const { x: innerStartPosX, y: innerStartPosY } = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_0__.getRadialPosition)(x, y, inner, 0);
        const startX = inner ? innerStartPosX : x;
        const startY = inner ? innerStartPosY : y;
        ctx.moveTo(startX, startY);
        ctx.arc(x, y, inner, 0, 2 * Math.PI, clockwise);
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/brushes/spectrumLegend.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/brushes/spectrumLegend.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SPECTRUM_LEGEND_LABEL_HEIGHT": () => (/* binding */ SPECTRUM_LEGEND_LABEL_HEIGHT),
/* harmony export */   "spectrumLegendBar": () => (/* binding */ spectrumLegendBar),
/* harmony export */   "spectrumLegendTooltip": () => (/* binding */ spectrumLegendTooltip),
/* harmony export */   "spectrumLegend": () => (/* binding */ spectrumLegend),
/* harmony export */   "spectrumTooltip": () => (/* binding */ spectrumTooltip)
/* harmony export */ });
/* harmony import */ var _store_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/layout */ "./node_modules/@toast-ui/chart/dist/esm/store/layout.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _label__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _dataLabel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dataLabel */ "./node_modules/@toast-ui/chart/dist/esm/brushes/dataLabel.js");




const SPECTRUM_LEGEND_LABEL_HEIGHT = 12;
const spectrumLegendBar = {
    HEIGHT: 6,
    PADDING: 5,
};
const spectrumLegendTooltip = {
    HEIGHT: 28,
    POINT_WIDTH: 8,
    POINT_HEIGHT: 6,
    PADDING: 6,
};
function getBarStartPoint(model) {
    const { align, x: modelX, y: modelY, labels, width } = model;
    const { PADDING } = spectrumLegendBar;
    let x, y;
    if (align === 'top') {
        x = modelX;
        y = modelY + SPECTRUM_LEGEND_LABEL_HEIGHT + PADDING;
    }
    else if (align === 'bottom') {
        x = modelX;
        y = modelY + spectrumLegendTooltip.HEIGHT;
    }
    else if (align === 'left') {
        x = modelX + (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.getMaxLengthLabelWidth)(labels) + PADDING;
        y = modelY + SPECTRUM_LEGEND_LABEL_HEIGHT / 2;
    }
    else {
        x =
            modelX +
                width -
                ((0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.getMaxLengthLabelWidth)(labels) + _store_layout__WEBPACK_IMPORTED_MODULE_1__.padding.X + PADDING * 2 + spectrumLegendBar.HEIGHT);
        y = modelY + SPECTRUM_LEGEND_LABEL_HEIGHT / 2;
    }
    return { x, y };
}
function getLabelsStartPoint(model) {
    const { align, x: modelX, y: modelY, labels, width } = model;
    let x, y;
    if (align === 'top') {
        x = modelX;
        y = modelY;
    }
    else if (align === 'bottom') {
        x = modelX;
        y =
            modelY + spectrumLegendTooltip.HEIGHT + spectrumLegendBar.HEIGHT + spectrumLegendBar.PADDING;
    }
    else if (align === 'left') {
        x = modelX + (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.getMaxLengthLabelWidth)(labels);
        y = modelY;
    }
    else {
        x = modelX + width - (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.getMaxLengthLabelWidth)(labels) - _store_layout__WEBPACK_IMPORTED_MODULE_1__.padding.X;
        y = modelY;
    }
    return { x, y };
}
function getBarSize(width, height, verticalAlign) {
    const { HEIGHT } = spectrumLegendBar;
    const barWidth = verticalAlign ? width : HEIGHT;
    const barHeight = verticalAlign ? HEIGHT : height - SPECTRUM_LEGEND_LABEL_HEIGHT;
    return { barWidth, barHeight };
}
function drawLabels(ctx, model) {
    const { labels, align, x, y, width, height, verticalAlign } = model;
    const { barWidth, barHeight } = getBarSize(width, height, verticalAlign);
    const labelSize = labels.length - 1;
    const textBaseStyleMap = {
        left: {
            textAlign: 'right',
            textBaseline: 'top',
        },
        right: {
            textAlign: 'left',
            textBaseline: 'top',
        },
        top: {
            textAlign: 'center',
            textBaseline: 'top',
        },
        bottom: {
            textAlign: 'center',
            textBaseline: 'top',
        },
    };
    labels.forEach((text, idx) => {
        const startX = verticalAlign ? x + (barWidth / labelSize) * idx : x;
        const startY = verticalAlign ? y : y + (barHeight / labelSize) * idx;
        (0,_label__WEBPACK_IMPORTED_MODULE_2__.label)(ctx, {
            type: 'label',
            x: startX,
            y: startY,
            text,
            style: ['default', textBaseStyleMap[align]],
        });
    });
}
function drawBar(ctx, model) {
    const { width, height, startColor, endColor, x, y, verticalAlign } = model;
    const { barWidth, barHeight } = getBarSize(width, height, verticalAlign);
    const gradient = verticalAlign
        ? ctx.createLinearGradient(x, y, x + barWidth, y)
        : ctx.createLinearGradient(x, y, x, y + barHeight);
    gradient.addColorStop(0, startColor);
    gradient.addColorStop(1, endColor);
    ctx.fillStyle = gradient;
    ctx.fillRect(x, y, barWidth, barHeight);
}
function getTooltipArrowPoint(model) {
    const { align, colorRatio, width, height, x, y, labels, verticalAlign } = model;
    const { barWidth, barHeight } = getBarSize(width, height, verticalAlign);
    const { PADDING, HEIGHT } = spectrumLegendBar;
    if (align === 'top') {
        return {
            x: x + barWidth * colorRatio,
            y: y + SPECTRUM_LEGEND_LABEL_HEIGHT + HEIGHT + PADDING * 2,
        };
    }
    if (align === 'bottom') {
        return {
            x: x + barWidth * colorRatio,
            y: y + SPECTRUM_LEGEND_LABEL_HEIGHT + PADDING * 2,
        };
    }
    if (align === 'left') {
        return {
            x: x + (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.getMaxLengthLabelWidth)(labels) + HEIGHT + PADDING * 2,
            y: y + barHeight * colorRatio + PADDING,
        };
    }
    if (align === 'right') {
        return {
            x: x + width - ((0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.getMaxLengthLabelWidth)(labels) + _store_layout__WEBPACK_IMPORTED_MODULE_1__.padding.X + PADDING * 3 + HEIGHT),
            y: y + barHeight * colorRatio + PADDING,
        };
    }
}
function spectrumLegend(ctx, model) {
    const labelsStartPoint = getLabelsStartPoint(model);
    const barStartPoint = getBarStartPoint(model);
    drawLabels(ctx, Object.assign(Object.assign({}, model), labelsStartPoint));
    drawBar(ctx, Object.assign(Object.assign({}, model), barStartPoint));
}
function spectrumTooltip(ctx, model) {
    const { x, y } = getTooltipArrowPoint(model);
    const { PADDING, POINT_HEIGHT, POINT_WIDTH } = spectrumLegendTooltip;
    const { align, text, color } = model;
    const labelWidth = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.getTextWidth)(text);
    const width = labelWidth + PADDING * 2;
    const height = SPECTRUM_LEGEND_LABEL_HEIGHT + PADDING * 2;
    const direction = align;
    let boxStartX = x;
    let boxStartY = y;
    if (align === 'top') {
        boxStartY += POINT_HEIGHT;
    }
    else if (align === 'right') {
        boxStartX -= width / 2 + POINT_HEIGHT;
        boxStartY -= height / 2;
    }
    else if (align === 'left') {
        boxStartX += width / 2 + POINT_HEIGHT;
        boxStartY -= height / 2;
    }
    else if (align === 'bottom') {
        boxStartY -= height + POINT_HEIGHT;
    }
    const points = (0,_dataLabel__WEBPACK_IMPORTED_MODULE_3__.getBubbleArrowPoints)(align, { x, y }, { visible: true, width: POINT_WIDTH, height: POINT_HEIGHT });
    (0,_label__WEBPACK_IMPORTED_MODULE_2__.bubbleLabel)(ctx, {
        type: 'bubbleLabel',
        bubble: {
            x: boxStartX - width / 2,
            y: boxStartY,
            width,
            height,
            points,
            direction,
            fill: color,
        },
        label: {
            text,
            x: boxStartX,
            y: boxStartY + height / 2,
            style: [
                {
                    font: 'normal 11px Arial',
                    fillStyle: '#333333',
                    textAlign: 'center',
                    textBaseline: 'middle',
                },
            ],
        },
    });
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/areaChart.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/areaChart.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AreaChart)
/* harmony export */ });
/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart */ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js");
/* harmony import */ var _store_dataRange__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/dataRange */ "./node_modules/@toast-ui/chart/dist/esm/store/dataRange.js");
/* harmony import */ var _store_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/scale */ "./node_modules/@toast-ui/chart/dist/esm/store/scale.js");
/* harmony import */ var _store_axes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store/axes */ "./node_modules/@toast-ui/chart/dist/esm/store/axes.js");
/* harmony import */ var _store_plot__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../store/plot */ "./node_modules/@toast-ui/chart/dist/esm/store/plot.js");
/* harmony import */ var _store_stackSeriesData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/stackSeriesData */ "./node_modules/@toast-ui/chart/dist/esm/store/stackSeriesData.js");
/* harmony import */ var _component_hoveredSeries__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../component/hoveredSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js");
/* harmony import */ var _component_tooltip__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../component/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js");
/* harmony import */ var _component_plot__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/plot */ "./node_modules/@toast-ui/chart/dist/esm/component/plot.js");
/* harmony import */ var _component_areaSeries__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/areaSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/areaSeries.js");
/* harmony import */ var _component_axis__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component/axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");
/* harmony import */ var _component_dataLabels__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../component/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/component/dataLabels.js");
/* harmony import */ var _component_title__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/title */ "./node_modules/@toast-ui/chart/dist/esm/component/title.js");
/* harmony import */ var _component_axisTitle__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../component/axisTitle */ "./node_modules/@toast-ui/chart/dist/esm/component/axisTitle.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _component_resetButton__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../component/resetButton */ "./node_modules/@toast-ui/chart/dist/esm/component/resetButton.js");
/* harmony import */ var _component_legend__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/legend */ "./node_modules/@toast-ui/chart/dist/esm/component/legend.js");
/* harmony import */ var _component_rangeSelection__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../component/rangeSelection */ "./node_modules/@toast-ui/chart/dist/esm/component/rangeSelection.js");
/* harmony import */ var _component_selectedSeries__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../component/selectedSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js");
/* harmony import */ var _component_background__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component/background */ "./node_modules/@toast-ui/chart/dist/esm/component/background.js");
/* harmony import */ var _component_noDataText__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../component/noDataText */ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js");
/* harmony import */ var _brushes_lineSeries__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../brushes/lineSeries */ "./node_modules/@toast-ui/chart/dist/esm/brushes/lineSeries.js");
/* harmony import */ var _brushes_basic__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../brushes/basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _brushes_axis__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../brushes/axis */ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../brushes/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js");
/* harmony import */ var _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../brushes/dataLabel */ "./node_modules/@toast-ui/chart/dist/esm/brushes/dataLabel.js");
/* harmony import */ var _brushes_resetButton__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../brushes/resetButton */ "./node_modules/@toast-ui/chart/dist/esm/brushes/resetButton.js");





























/**
 * @class
 * @classdesc Area Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Area Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<number|Array<number>>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Area Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.showDot=false] - Whether to show dot or not.
 *       @param {boolean} [props.options.series.spline=false] - Whether to make spline chart or not.
 *       @param {boolean} [props.options.series.zoomable=false] - Whether to use zoom feature or not.
 *       @param {boolean} [props.options.series.rangeSelectable=false] - Whether to use range selection feature or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'near', 'nearest', 'grouped', 'point' is available.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {boolean|Object} [props.options.series.stack] - Option to decide whether to use stack chart and type of stack chart. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Area Chart guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *       @param {Array<Object>} [props.options.plot.lines] - Plot lines information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Area Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
class AreaChart extends _chart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(props) {
        super({
            el: props.el,
            options: props.options,
            series: {
                area: props.data.series,
            },
            categories: props.data.categories,
            modules: [_store_stackSeriesData__WEBPACK_IMPORTED_MODULE_1__["default"], _store_dataRange__WEBPACK_IMPORTED_MODULE_2__["default"], _store_scale__WEBPACK_IMPORTED_MODULE_3__["default"], _store_axes__WEBPACK_IMPORTED_MODULE_4__["default"], _store_plot__WEBPACK_IMPORTED_MODULE_5__["default"]],
        });
    }
    initialize() {
        super.initialize();
        this.componentManager.add(_component_background__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.componentManager.add(_component_title__WEBPACK_IMPORTED_MODULE_7__["default"]);
        this.componentManager.add(_component_plot__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.componentManager.add(_component_legend__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.componentManager.add(_component_areaSeries__WEBPACK_IMPORTED_MODULE_10__["default"]);
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_11__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_11__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_11__["default"], { name: 'secondaryYAxis' });
        this.componentManager.add(_component_dataLabels__WEBPACK_IMPORTED_MODULE_12__["default"]);
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_13__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_13__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_13__["default"], { name: 'secondaryYAxis' });
        this.componentManager.add(_component_exportMenu__WEBPACK_IMPORTED_MODULE_14__["default"], { chartEl: this.el });
        this.componentManager.add(_component_hoveredSeries__WEBPACK_IMPORTED_MODULE_15__["default"]);
        this.componentManager.add(_component_selectedSeries__WEBPACK_IMPORTED_MODULE_16__["default"]);
        this.componentManager.add(_component_tooltip__WEBPACK_IMPORTED_MODULE_17__["default"], { chartEl: this.el });
        this.componentManager.add(_component_resetButton__WEBPACK_IMPORTED_MODULE_18__["default"]);
        this.componentManager.add(_component_rangeSelection__WEBPACK_IMPORTED_MODULE_19__["default"]);
        this.componentManager.add(_component_noDataText__WEBPACK_IMPORTED_MODULE_20__["default"]);
        this.painter.addGroups([
            _brushes_basic__WEBPACK_IMPORTED_MODULE_21__,
            _brushes_axis__WEBPACK_IMPORTED_MODULE_22__,
            _brushes_lineSeries__WEBPACK_IMPORTED_MODULE_23__,
            _brushes_legend__WEBPACK_IMPORTED_MODULE_24__,
            _brushes_label__WEBPACK_IMPORTED_MODULE_25__,
            _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_26__,
            _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_27__,
            _brushes_resetButton__WEBPACK_IMPORTED_MODULE_28__,
        ]);
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */
    addData(data, category) {
        this.resetSeries();
        this.animationControlFlag.updating = true;
        this.store.dispatch('addData', { data, category });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number|Array<number>>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */
    addSeries(data) {
        this.resetSeries();
        this.store.dispatch('addSeries', { data });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */
    setData(data) {
        const { categories, series } = data;
        this.resetSeries();
        this.store.dispatch('setData', { series: { area: series }, categories });
    }
    /**
     * Add plot line.
     * @param {Object} data - Plot info.
     *   @param {string|number} data.value - The value where the plot line will be drawn.
     *   @param {string} data.color - Plot line color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
     * @api
     * @example
     * chart.addPlotLine({
     *   value: 2,
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */
    addPlotLine(data) {
        this.store.dispatch('addPlotLine', { data });
    }
    /**
     * Remove plot line with id.
     * @param {string} id - Id of the plot line to be removed.
     * @api
     * @example
     * chart.removePlotLine('plot-1');
     */
    removePlotLine(id) {
        this.store.dispatch('removePlotLine', { id });
    }
    /**
     * Add plot band.
     * @param {Object} data - Plot info.
     * @param {Array<string|number>} data.range - The range to be drawn.
     * @param {string} data.color - Plot band color.
     * @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
     * @api
     * @example
     * chart.addPlotBand({
     *   value: [2, 4],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */
    addPlotBand(data) {
        this.store.dispatch('addPlotBand', { data });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - id of the plot band to be removed.
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */
    removePlotBand(id) {
        this.store.dispatch('removePlotBand', { id });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */
    hideSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: false } } },
        });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */
    showSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: true } } },
        });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    setOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    updateOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
     *      @param {number} [seriesInfo.seriesIndex] - Index of series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */
    showTooltip(seriesInfo) {
        this.eventBus.emit('showTooltip', Object.assign({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */
    hideTooltip() {
        this.eventBus.emit('hideTooltip');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/barChart.js":
/*!******************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/barChart.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BarChart)
/* harmony export */ });
/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart */ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js");
/* harmony import */ var _store_dataRange__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/dataRange */ "./node_modules/@toast-ui/chart/dist/esm/store/dataRange.js");
/* harmony import */ var _store_stackSeriesData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/stackSeriesData */ "./node_modules/@toast-ui/chart/dist/esm/store/stackSeriesData.js");
/* harmony import */ var _store_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/scale */ "./node_modules/@toast-ui/chart/dist/esm/store/scale.js");
/* harmony import */ var _store_axes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store/axes */ "./node_modules/@toast-ui/chart/dist/esm/store/axes.js");
/* harmony import */ var _store_plot__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../store/plot */ "./node_modules/@toast-ui/chart/dist/esm/store/plot.js");
/* harmony import */ var _component_axis__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../component/axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");
/* harmony import */ var _component_boxSeries__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/boxSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/boxSeries.js");
/* harmony import */ var _component_boxStackSeries__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component/boxStackSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/boxStackSeries.js");
/* harmony import */ var _component_plot__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/plot */ "./node_modules/@toast-ui/chart/dist/esm/component/plot.js");
/* harmony import */ var _component_tooltip__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../component/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js");
/* harmony import */ var _component_legend__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/legend */ "./node_modules/@toast-ui/chart/dist/esm/component/legend.js");
/* harmony import */ var _component_dataLabels__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../component/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/component/dataLabels.js");
/* harmony import */ var _component_axisTitle__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../component/axisTitle */ "./node_modules/@toast-ui/chart/dist/esm/component/axisTitle.js");
/* harmony import */ var _component_title__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/title */ "./node_modules/@toast-ui/chart/dist/esm/component/title.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _component_zeroAxis__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../component/zeroAxis */ "./node_modules/@toast-ui/chart/dist/esm/component/zeroAxis.js");
/* harmony import */ var _component_axisUsingCenterY__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../component/axisUsingCenterY */ "./node_modules/@toast-ui/chart/dist/esm/component/axisUsingCenterY.js");
/* harmony import */ var _component_hoveredSeries__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../component/hoveredSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js");
/* harmony import */ var _component_selectedSeries__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../component/selectedSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js");
/* harmony import */ var _component_background__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component/background */ "./node_modules/@toast-ui/chart/dist/esm/component/background.js");
/* harmony import */ var _component_noDataText__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../component/noDataText */ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js");
/* harmony import */ var _brushes_basic__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../brushes/basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _brushes_axis__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../brushes/axis */ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../brushes/dataLabel */ "./node_modules/@toast-ui/chart/dist/esm/brushes/dataLabel.js");
/* harmony import */ var _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../brushes/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js");




























/**
 * @class
 * @classdesc Bar Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Bar Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {string} props.data.series.colorByCategories - Paint Rect with color based on categories.
 *       @param {Array<number|Array<number>>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Bar Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {number} [props.options.series.barWidth] - Bar width.
 *       @param {boolean} [props.options.series.diverging] - Whether to use diverging chart or not.
 *       @param {Object} [props.options.series.stack] - Option to use the stack chart or, if so, what type of stack to use.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'grouped', 'point' is available.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Bar Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
class BarChart extends _chart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ el, options, data }) {
        super({
            el,
            options,
            series: {
                bar: data.series,
            },
            categories: data.categories,
            modules: [_store_stackSeriesData__WEBPACK_IMPORTED_MODULE_1__["default"], _store_dataRange__WEBPACK_IMPORTED_MODULE_2__["default"], _store_scale__WEBPACK_IMPORTED_MODULE_3__["default"], _store_axes__WEBPACK_IMPORTED_MODULE_4__["default"], _store_plot__WEBPACK_IMPORTED_MODULE_5__["default"]],
        });
    }
    initialize() {
        var _a;
        super.initialize();
        const stackChart = !!((_a = this.store.initStoreState.options.series) === null || _a === void 0 ? void 0 : _a.stack);
        this.componentManager.add(_component_background__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.componentManager.add(_component_title__WEBPACK_IMPORTED_MODULE_7__["default"]);
        this.componentManager.add(_component_plot__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.componentManager.add(_component_legend__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.componentManager.add(_component_boxSeries__WEBPACK_IMPORTED_MODULE_10__["default"], { name: 'bar', stackChart });
        this.componentManager.add(_component_boxStackSeries__WEBPACK_IMPORTED_MODULE_11__["default"], { name: 'bar', stackChart });
        this.componentManager.add(_component_zeroAxis__WEBPACK_IMPORTED_MODULE_12__["default"]);
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_13__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_13__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_13__["default"], { name: 'secondaryYAxis' });
        this.componentManager.add(_component_axisUsingCenterY__WEBPACK_IMPORTED_MODULE_14__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_axisUsingCenterY__WEBPACK_IMPORTED_MODULE_14__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_15__["default"], { name: 'secondaryYAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_15__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_15__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_exportMenu__WEBPACK_IMPORTED_MODULE_16__["default"], { chartEl: this.el });
        this.componentManager.add(_component_hoveredSeries__WEBPACK_IMPORTED_MODULE_17__["default"]);
        this.componentManager.add(_component_selectedSeries__WEBPACK_IMPORTED_MODULE_18__["default"]);
        this.componentManager.add(_component_dataLabels__WEBPACK_IMPORTED_MODULE_19__["default"]);
        this.componentManager.add(_component_tooltip__WEBPACK_IMPORTED_MODULE_20__["default"], { chartEl: this.el });
        this.componentManager.add(_component_noDataText__WEBPACK_IMPORTED_MODULE_21__["default"]);
        this.painter.addGroups([
            _brushes_basic__WEBPACK_IMPORTED_MODULE_22__,
            _brushes_axis__WEBPACK_IMPORTED_MODULE_23__,
            _brushes_legend__WEBPACK_IMPORTED_MODULE_24__,
            _brushes_label__WEBPACK_IMPORTED_MODULE_25__,
            _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_26__,
            _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_27__,
        ]);
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */
    addData(data, category) {
        this.animationControlFlag.updating = true;
        this.resetSeries();
        this.store.dispatch('addData', { data, category });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number|Array<number>>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */
    addSeries(data) {
        this.resetSeries();
        this.store.dispatch('addSeries', { data });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */
    setData(data) {
        const { categories, series } = data;
        this.resetSeries();
        this.store.dispatch('setData', { series: { bar: series }, categories });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */
    hideSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: false } } },
        });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */
    showSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: true } } },
        });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    setOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    updateOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *   @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
     *   @param {number} [seriesInfo.seriesIndex] - Index of series
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */
    showTooltip(seriesInfo) {
        this.eventBus.emit('showTooltip', Object.assign({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */
    hideTooltip() {
        this.eventBus.emit('hideTooltip');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/boxPlotChart.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/boxPlotChart.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BoxPlotChart)
/* harmony export */ });
/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart */ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js");
/* harmony import */ var _store_dataRange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/dataRange */ "./node_modules/@toast-ui/chart/dist/esm/store/dataRange.js");
/* harmony import */ var _store_scale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/scale */ "./node_modules/@toast-ui/chart/dist/esm/store/scale.js");
/* harmony import */ var _store_axes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/axes */ "./node_modules/@toast-ui/chart/dist/esm/store/axes.js");
/* harmony import */ var _store_plot__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store/plot */ "./node_modules/@toast-ui/chart/dist/esm/store/plot.js");
/* harmony import */ var _component_axis__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");
/* harmony import */ var _component_boxPlotSeries__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/boxPlotSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/boxPlotSeries.js");
/* harmony import */ var _component_plot__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/plot */ "./node_modules/@toast-ui/chart/dist/esm/component/plot.js");
/* harmony import */ var _component_tooltip__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../component/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js");
/* harmony import */ var _component_legend__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/legend */ "./node_modules/@toast-ui/chart/dist/esm/component/legend.js");
/* harmony import */ var _component_axisTitle__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component/axisTitle */ "./node_modules/@toast-ui/chart/dist/esm/component/axisTitle.js");
/* harmony import */ var _component_title__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component/title */ "./node_modules/@toast-ui/chart/dist/esm/component/title.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _component_hoveredSeries__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../component/hoveredSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js");
/* harmony import */ var _component_selectedSeries__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../component/selectedSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js");
/* harmony import */ var _component_background__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../component/background */ "./node_modules/@toast-ui/chart/dist/esm/component/background.js");
/* harmony import */ var _component_noDataText__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../component/noDataText */ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js");
/* harmony import */ var _brushes_basic__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../brushes/basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _brushes_axis__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../brushes/axis */ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../brushes/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js");
/* harmony import */ var _brushes_boxPlot__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../brushes/boxPlot */ "./node_modules/@toast-ui/chart/dist/esm/brushes/boxPlot.js");























/**
 * @class
 * @classdesc BoxPlot Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making BoxPlot Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<Array<number>>} props.data.series.data - Series data.
 *       @param {Array<Array<number>>} props.data.series.outliers - Series outliers data.
 *   @param {Object} [props.options] - Options for making BoxPlot Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'grouped', 'point' is available.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object} [props.options.yAxis]
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|BoxPlot Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
class BoxPlotChart extends _chart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ el, options, data: { series, categories } }) {
        super({
            el,
            options,
            series: {
                boxPlot: series,
            },
            categories,
            modules: [_store_dataRange__WEBPACK_IMPORTED_MODULE_1__["default"], _store_scale__WEBPACK_IMPORTED_MODULE_2__["default"], _store_axes__WEBPACK_IMPORTED_MODULE_3__["default"], _store_plot__WEBPACK_IMPORTED_MODULE_4__["default"]],
        });
    }
    initialize() {
        super.initialize();
        this.componentManager.add(_component_background__WEBPACK_IMPORTED_MODULE_5__["default"]);
        this.componentManager.add(_component_title__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.componentManager.add(_component_plot__WEBPACK_IMPORTED_MODULE_7__["default"]);
        this.componentManager.add(_component_legend__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.componentManager.add(_component_boxPlotSeries__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_10__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_10__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_11__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_11__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_exportMenu__WEBPACK_IMPORTED_MODULE_12__["default"], { chartEl: this.el });
        this.componentManager.add(_component_hoveredSeries__WEBPACK_IMPORTED_MODULE_13__["default"]);
        this.componentManager.add(_component_selectedSeries__WEBPACK_IMPORTED_MODULE_14__["default"]);
        this.componentManager.add(_component_tooltip__WEBPACK_IMPORTED_MODULE_15__["default"], { chartEl: this.el });
        this.componentManager.add(_component_noDataText__WEBPACK_IMPORTED_MODULE_16__["default"]);
        this.painter.addGroups([
            _brushes_basic__WEBPACK_IMPORTED_MODULE_17__,
            _brushes_axis__WEBPACK_IMPORTED_MODULE_18__,
            _brushes_boxPlot__WEBPACK_IMPORTED_MODULE_19__,
            _brushes_legend__WEBPACK_IMPORTED_MODULE_20__,
            _brushes_label__WEBPACK_IMPORTED_MODULE_21__,
            _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_22__,
        ]);
    }
    /**
     * Add data.
     * @param {Array<<Array<number>>} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData(
        [
           [3000, 4000, 4714, 6000, 7000],
           [3000, 5750, 7571, 8250, 9000],
        ],
        'newCategory'
      );
     */
    addData(data, category) {
        this.animationControlFlag.updating = true;
        this.resetSeries();
        this.store.dispatch('addData', { data, category });
    }
    /**
     * add outlier.
     * @param {number} seriesIndex - Index of series.
     * @param {number} outliers - Array of outlier.
     * @api
     * @example
     * chart.addOutlier(1, [[1, 10000], [3, 12000]]);
     */
    addOutlier(seriesIndex, outliers) {
        this.animationControlFlag.updating = true;
        this.resetSeries();
        this.store.dispatch('addOutlier', { seriesIndex, outliers });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Array<number>>} data.data - Array of data to be added.
     *   @param {Array<Array<number>>} data.outliers - Series outliers data.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [
     *     [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     *   ],
     *   outliers: [
     *     [0, 14000],
     *     [2, 10000],
     *   ]
     * });
     */
    addSeries(data) {
        this.resetSeries();
        this.store.dispatch('addSeries', { data });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'newSeries',
     *       data: [
     *         [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     *       ],
     *       outliers: [
     *         [0, 14000],
     *         [2, 10000],
     *       ]
     *     }
     *   ]
     * });
     */
    setData(data) {
        const { categories, series } = data;
        this.resetSeries();
        this.store.dispatch('setData', { series: { boxPlot: series }, categories });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    setOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    updateOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */
    showTooltip(seriesInfo) {
        this.eventBus.emit('showTooltip', Object.assign(Object.assign({}, seriesInfo), { state: this.store.state }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */
    hideTooltip() {
        this.eventBus.emit('hideTooltip');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/bubbleChart.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/bubbleChart.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BubbleChart)
/* harmony export */ });
/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart */ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js");
/* harmony import */ var _store_scale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/scale */ "./node_modules/@toast-ui/chart/dist/esm/store/scale.js");
/* harmony import */ var _store_axes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/axes */ "./node_modules/@toast-ui/chart/dist/esm/store/axes.js");
/* harmony import */ var _store_dataRange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/dataRange */ "./node_modules/@toast-ui/chart/dist/esm/store/dataRange.js");
/* harmony import */ var _store_plot__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store/plot */ "./node_modules/@toast-ui/chart/dist/esm/store/plot.js");
/* harmony import */ var _component_tooltip__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../component/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js");
/* harmony import */ var _component_plot__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/plot */ "./node_modules/@toast-ui/chart/dist/esm/component/plot.js");
/* harmony import */ var _component_bubbleSeries__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/bubbleSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/bubbleSeries.js");
/* harmony import */ var _component_axis__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");
/* harmony import */ var _component_circleLegend__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../component/circleLegend */ "./node_modules/@toast-ui/chart/dist/esm/component/circleLegend.js");
/* harmony import */ var _component_legend__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/legend */ "./node_modules/@toast-ui/chart/dist/esm/component/legend.js");
/* harmony import */ var _component_title__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component/title */ "./node_modules/@toast-ui/chart/dist/esm/component/title.js");
/* harmony import */ var _component_axisTitle__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component/axisTitle */ "./node_modules/@toast-ui/chart/dist/esm/component/axisTitle.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _component_hoveredSeries__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../component/hoveredSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js");
/* harmony import */ var _component_selectedSeries__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../component/selectedSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js");
/* harmony import */ var _component_background__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../component/background */ "./node_modules/@toast-ui/chart/dist/esm/component/background.js");
/* harmony import */ var _component_noDataText__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../component/noDataText */ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js");
/* harmony import */ var _brushes_basic__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../brushes/basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _brushes_axis__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../brushes/axis */ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js");
/* harmony import */ var _brushes_circleLegend__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../brushes/circleLegend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/circleLegend.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../brushes/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js");
























/**
 * @class
 * @classdesc Bubble Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Bubble Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<Object>} props.data.series.data - Series data. Coordinates x, y values, radius r, and label values are required.
 *   @param {Object} [props.options] - Options for making Bubble Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object} [props.options.yAxis]
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.circleLegend]
 *       @param {boolean} [props.options.circleLegend.visible] - Whether to show circle legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Bubble Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
class BubbleChart extends _chart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(props) {
        super({
            el: props.el,
            options: props.options,
            series: {
                bubble: props.data.series,
            },
            modules: [_store_dataRange__WEBPACK_IMPORTED_MODULE_1__["default"], _store_scale__WEBPACK_IMPORTED_MODULE_2__["default"], _store_axes__WEBPACK_IMPORTED_MODULE_3__["default"], _store_plot__WEBPACK_IMPORTED_MODULE_4__["default"]],
        });
    }
    initialize() {
        super.initialize();
        this.componentManager.add(_component_background__WEBPACK_IMPORTED_MODULE_5__["default"]);
        this.componentManager.add(_component_title__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.componentManager.add(_component_plot__WEBPACK_IMPORTED_MODULE_7__["default"]);
        this.componentManager.add(_component_legend__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.componentManager.add(_component_bubbleSeries__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_10__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_10__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_11__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_11__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_exportMenu__WEBPACK_IMPORTED_MODULE_12__["default"], { chartEl: this.el });
        this.componentManager.add(_component_hoveredSeries__WEBPACK_IMPORTED_MODULE_13__["default"]);
        this.componentManager.add(_component_selectedSeries__WEBPACK_IMPORTED_MODULE_14__["default"]);
        this.componentManager.add(_component_tooltip__WEBPACK_IMPORTED_MODULE_15__["default"], { chartEl: this.el });
        this.componentManager.add(_component_circleLegend__WEBPACK_IMPORTED_MODULE_16__["default"]);
        this.componentManager.add(_component_noDataText__WEBPACK_IMPORTED_MODULE_17__["default"]);
        this.painter.addGroups([
            _brushes_basic__WEBPACK_IMPORTED_MODULE_18__,
            _brushes_axis__WEBPACK_IMPORTED_MODULE_19__,
            _brushes_circleLegend__WEBPACK_IMPORTED_MODULE_20__,
            _brushes_legend__WEBPACK_IMPORTED_MODULE_21__,
            _brushes_label__WEBPACK_IMPORTED_MODULE_22__,
            _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_23__,
        ]);
    }
    /**
     * Add data.
     * @param {Array<Object>} data - Array of data to be added.
     * @api
     * @example
     * chart.addData([
     *   {x: 10, y: 20, r: 10, label: 'label1'},
     *   {x: 30, y: 40, r: 10, label: 'label2'},
     * ]);
     */
    addData(data) {
        this.animationControlFlag.updating = true;
        this.resetSeries();
        this.store.dispatch('addData', { data });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [
     *     {x: 10, y: 20, r: 10, label: 'label1'},
     *     {x: 30, y: 40, r: 10, label: 'label2'},
     *   ],
     * });
     */
    addSeries(data) {
        this.resetSeries();
        this.store.dispatch('addSeries', { data });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   series: [
     *     {
     *       name: 'name'
     *       data: [
     *         {x: 10, y: 20, r: 10, label: 'label1'},
     *         {x: 30, y: 40, r: 10, label: 'label2'},
     *       ]
     *     }
     *   ]
     * });
     */
    setData(data) {
        this.resetSeries();
        this.store.dispatch('setData', { series: { bubble: data.series } });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    setOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    updateOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */
    showTooltip(seriesInfo) {
        this.eventBus.emit('showTooltip', Object.assign(Object.assign({}, seriesInfo), { state: this.store.state }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */
    hideTooltip() {
        this.eventBus.emit('hideTooltip');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/bulletChart.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/bulletChart.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BulletChart)
/* harmony export */ });
/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart */ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js");
/* harmony import */ var _store_dataRange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/dataRange */ "./node_modules/@toast-ui/chart/dist/esm/store/dataRange.js");
/* harmony import */ var _store_scale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/scale */ "./node_modules/@toast-ui/chart/dist/esm/store/scale.js");
/* harmony import */ var _store_axes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/axes */ "./node_modules/@toast-ui/chart/dist/esm/store/axes.js");
/* harmony import */ var _store_plot__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store/plot */ "./node_modules/@toast-ui/chart/dist/esm/store/plot.js");
/* harmony import */ var _component_axis__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");
/* harmony import */ var _component_bulletSeries__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/bulletSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/bulletSeries.js");
/* harmony import */ var _component_plot__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/plot */ "./node_modules/@toast-ui/chart/dist/esm/component/plot.js");
/* harmony import */ var _component_tooltip__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../component/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js");
/* harmony import */ var _component_legend__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/legend */ "./node_modules/@toast-ui/chart/dist/esm/component/legend.js");
/* harmony import */ var _component_axisTitle__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component/axisTitle */ "./node_modules/@toast-ui/chart/dist/esm/component/axisTitle.js");
/* harmony import */ var _component_title__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component/title */ "./node_modules/@toast-ui/chart/dist/esm/component/title.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _component_selectedSeries__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../component/selectedSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js");
/* harmony import */ var _component_hoveredSeries__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../component/hoveredSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js");
/* harmony import */ var _component_dataLabels__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../component/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/component/dataLabels.js");
/* harmony import */ var _component_background__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../component/background */ "./node_modules/@toast-ui/chart/dist/esm/component/background.js");
/* harmony import */ var _component_noDataText__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../component/noDataText */ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js");
/* harmony import */ var _brushes_basic__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../brushes/basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _brushes_axis__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../brushes/axis */ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../brushes/dataLabel */ "./node_modules/@toast-ui/chart/dist/esm/brushes/dataLabel.js");
/* harmony import */ var _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../brushes/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js");
























/**
 * @class
 * @classdesc Bullet Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Bullet Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {number} props.data.series.data - Series data.
 *       @param {Array<number>} props.data.series.markers - Series markers. It specifies the marker for comparing.
 *       @param {Array<Array<number>>} props.data.series.ranges - Series ranges. It specifies the range of values that can be compared.
 *   @param {Object} [props.options] - Options for making Bullet Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {number} [props.options.series.vertical] - Whether to use vertical bullet series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object} [props.options.yAxis]
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Bullets Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
class BulletChart extends _chart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ el, options, data: { series } }) {
        super({
            el,
            options,
            series: {
                bullet: series,
            },
            modules: [_store_dataRange__WEBPACK_IMPORTED_MODULE_1__["default"], _store_scale__WEBPACK_IMPORTED_MODULE_2__["default"], _store_axes__WEBPACK_IMPORTED_MODULE_3__["default"], _store_plot__WEBPACK_IMPORTED_MODULE_4__["default"]],
        });
        /**
         * Hide tooltip.
         * @api
         * @example
         * chart.hideTooltip();
         */
        this.hideTooltip = () => {
            this.eventBus.emit('hideTooltip');
        };
    }
    initialize() {
        super.initialize();
        this.componentManager.add(_component_background__WEBPACK_IMPORTED_MODULE_5__["default"]);
        this.componentManager.add(_component_title__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.componentManager.add(_component_plot__WEBPACK_IMPORTED_MODULE_7__["default"]);
        this.componentManager.add(_component_legend__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.componentManager.add(_component_bulletSeries__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_10__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_10__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_11__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_11__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_exportMenu__WEBPACK_IMPORTED_MODULE_12__["default"], { chartEl: this.el });
        this.componentManager.add(_component_hoveredSeries__WEBPACK_IMPORTED_MODULE_13__["default"]);
        this.componentManager.add(_component_selectedSeries__WEBPACK_IMPORTED_MODULE_14__["default"]);
        this.componentManager.add(_component_dataLabels__WEBPACK_IMPORTED_MODULE_15__["default"]);
        this.componentManager.add(_component_tooltip__WEBPACK_IMPORTED_MODULE_16__["default"], { chartEl: this.el });
        this.componentManager.add(_component_noDataText__WEBPACK_IMPORTED_MODULE_17__["default"]);
        this.painter.addGroups([
            _brushes_basic__WEBPACK_IMPORTED_MODULE_18__,
            _brushes_axis__WEBPACK_IMPORTED_MODULE_19__,
            _brushes_legend__WEBPACK_IMPORTED_MODULE_20__,
            _brushes_label__WEBPACK_IMPORTED_MODULE_21__,
            _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_22__,
            _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_23__,
        ]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added
     *   @param {string} data.name - Series name
     *   @param {Array<<Array<number>>} data.data - Array of data to be added
     *   @param {Array<number>} data.markers - Series markers. It specifies the marker for comparing.
     *   @param {Array<Array<number>>} data.ranges - Series ranges. It specifies the range of values that can be compared.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: 20,
     *   markers: [28, 2, 15],
     *   ranges: [
     *     [-1, 10],
     *     [10, 20],
     *     [20, 30],
     *   ],
     * });
     */
    addSeries(data) {
        this.resetSeries();
        this.store.dispatch('addSeries', { data });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   series: [
     *     {
     *       name: 'newSeries',
     *       data: 20,
     *       markers: [28, 2, 15],
     *       ranges: [
     *         [-1, 10],
     *         [10, 20],
     *         [20, 30],
     *       ],
     *     }
     *   ]
     * });
     */
    setData(data) {
        this.resetSeries();
        this.store.dispatch('setData', { series: { bullet: data.series } });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */
    hideSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: false } } },
        });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */
    showSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: true } } },
        });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    setOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    updateOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     * @api
     * @example
     * chart.showTooltip({seriesIndex: 1});
     */
    showTooltip(seriesInfo) {
        this.eventBus.emit('showTooltip', Object.assign(Object.assign({}, seriesInfo), { state: this.store.state }));
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js":
/*!***************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/chart.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_ANIM_DURATION": () => (/* binding */ DEFAULT_ANIM_DURATION),
/* harmony export */   "default": () => (/* binding */ Chart)
/* harmony export */ });
/* harmony import */ var _store_store__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../store/store */ "./node_modules/@toast-ui/chart/dist/esm/store/store.js");
/* harmony import */ var _store_root__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../store/root */ "./node_modules/@toast-ui/chart/dist/esm/store/root.js");
/* harmony import */ var _store_layout__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../store/layout */ "./node_modules/@toast-ui/chart/dist/esm/store/layout.js");
/* harmony import */ var _store_seriesData__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../store/seriesData */ "./node_modules/@toast-ui/chart/dist/esm/store/seriesData.js");
/* harmony import */ var _store_category__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../store/category */ "./node_modules/@toast-ui/chart/dist/esm/store/category.js");
/* harmony import */ var _store_legend__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../store/legend */ "./node_modules/@toast-ui/chart/dist/esm/store/legend.js");
/* harmony import */ var _store_options__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../store/options */ "./node_modules/@toast-ui/chart/dist/esm/store/options.js");
/* harmony import */ var _store_theme__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../store/theme */ "./node_modules/@toast-ui/chart/dist/esm/store/theme.js");
/* harmony import */ var _eventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../eventEmitter */ "./node_modules/@toast-ui/chart/dist/esm/eventEmitter.js");
/* harmony import */ var _component_componentManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/componentManager */ "./node_modules/@toast-ui/chart/dist/esm/component/componentManager.js");
/* harmony import */ var _painter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../painter */ "./node_modules/@toast-ui/chart/dist/esm/painter.js");
/* harmony import */ var _animator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../animator */ "./node_modules/@toast-ui/chart/dist/esm/animator.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _responderDetectors__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../responderDetectors */ "./node_modules/@toast-ui/chart/dist/esm/responderDetectors.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");
/* harmony import */ var _helpers_googleAnalytics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/googleAnalytics */ "./node_modules/@toast-ui/chart/dist/esm/helpers/googleAnalytics.js");
/* harmony import */ var _store_reactive__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/reactive */ "./node_modules/@toast-ui/chart/dist/esm/store/reactive.js");
/* harmony import */ var _helpers_coordinate__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../helpers/coordinate */ "./node_modules/@toast-ui/chart/dist/esm/helpers/coordinate.js");


















const DEFAULT_ANIM_DURATION = 500;
function getUsingContainerSize(eventName, usingContainerSize, width, height) {
    const { width: usingContainerWidth, height: usingContainerHeight } = usingContainerSize;
    const isAutoWidth = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isAutoValue)(width);
    const isAutoHeight = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isAutoValue)(height);
    return eventName === 'updateOptions'
        ? {
            width: !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(width) && usingContainerWidth !== isAutoWidth
                ? isAutoWidth
                : usingContainerWidth,
            height: !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(height) && usingContainerHeight !== isAutoHeight
                ? isAutoHeight
                : usingContainerHeight,
        }
        : {
            width: isAutoWidth,
            height: isAutoHeight,
        };
}
/**
 * @class
 * @abstract
 * Abstract class used to implement each chart.
 */
class Chart {
    constructor(props) {
        var _a, _b, _c, _d;
        this.___animId___ = null;
        this.painter = new _painter__WEBPACK_IMPORTED_MODULE_1__["default"](this);
        this.eventBus = new _eventEmitter__WEBPACK_IMPORTED_MODULE_2__["default"]();
        this.enteredComponents = [];
        this.animationControlFlag = {
            resizing: false,
            updating: false,
        };
        this.resizeObserver = null;
        this.debounceResizeEvent = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.debounce)(() => {
            const { offsetWidth, offsetHeight } = this.containerEl;
            this.resizeChartSize(offsetWidth, offsetHeight);
        }, 100);
        /**
         * Get checked legend chart type and label, checked state.
         * @returns {Array<{checked: boolean, chartType: string, label: string}>} Array data that whether series has checked
         * @api
         * @example
         * const checkedLegend = chart.getCheckedLegend()
         */
        this.getCheckedLegend = () => {
            const { data } = this.store.state.legend;
            return data
                .filter((datum) => datum.checked)
                .map((datum) => (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(datum, 'chartType', 'label', 'checked'));
        };
        /**
         * Returns the currently applied chart options.
         * @returns {Object} options
         * @api
         * @example
         * const options = chart.getOptions();
         */
        this.getOptions = () => {
            return (0,_store_reactive__WEBPACK_IMPORTED_MODULE_3__.makeObservableObjectToNormal)(this.store.initStoreState.options);
        };
        /**
         * Register of user custom event.
         * @param {string} eventName - Event name. 'clickLegendLabel', 'clickLegendCheckbox', 'selectSeries', 'unselectSeries', 'hoverSeries', 'unhoverSeries', 'zoom', 'resetZoom' is available.
         * @param {Function} handler - Event handler
         * @api
         */
        this.on = (eventName, handler) => {
            /**
             * Register Events that occur when click legend label
             * @event ChartBase#clickLegendLabel
             * @param {object} info selected legend information
             * @api
             * @example
             * chart.on('clickLegendLabel', (info) => {
             *   console.log(info);
             * });
             */
            /**
             * Register Events that occur when click legend checkbox
             * @event ChartBase#clickLegendCheckbox
             * @param {object} info selected legend info
             * @api
             * @example
             * chart.on('clickLegendCheckbox', (info) => {
             *   console.log(info);
             * });
             */
            /**
             * Register Events that occur when select series
             * @event ChartBase#selectSeries
             * @param {object} info selected series info
             * @api
             * @example
             * chart.on('selectSeries', (info) => {
             *   console.log(info);
             * });
             */
            /**
             * Register Events that occur when unselect series
             * @event ChartBase#unselectSeries
             * @param {object} info unselected series info
             * @api
             * @example
             * chart.on('unselectSeries', (info) => {
             *   console.log(info);
             * });
             */
            /**
             * Register Events that occur when hover to series
             * @event ChartBase#hoverSeries
             * @param {object} info hovered series info
             * @api
             * @example
             * chart.on('hoverSeries', (info) => {
             *   console.log(info);
             * });
             */
            /**
             * Register Events that occur when unhover from series
             * @event ChartBase#unhoverSeries
             * @param {object} info unhovered series info
             * @api
             * @example
             * chart.on('unhoverSeries', (info) => {
             *  console.log(info);
             * });
             */
            /**
             * Register Events that occur when zooming
             * @event ChartBase#zoom
             * @param {string[]} dataRange - []
             * @api
             * @example
             * chart.on('zoom', (dataRange) => {
             *    console.log(dataRange);
             * });
             */
            /**
             * Register Events that occur when zoom is reset
             * @event ChartBase#resetZoom
             * @api
             * @example
             * chart.on('resetZoom', () => {});
             */
            this.eventBus.on(eventName, handler);
        };
        /**
         * Destroys the instance.
         * @api
         * @example
         * chart.destroy();
         */
        this.destroy = () => {
            this.componentManager.clear();
            this.clearResizeEvent();
            this.containerEl.innerHTML = '';
        };
        /**
         * Select series. It works only when the selectable option is true.
         * @param {Object} seriesInfo - Information of the series to be selected
         *      @param {number} [seriesInfo.seriesIndex] - Index of series
         *      @param {number} [seriesInfo.index] - Index of data within series
         *      @param {string} [seriesInfo.name] - Specify name for NestedPie Chart
         *      @param {string} [seriesInfo.chartType] - Specify which chart to select when using LineArea, LineScatter, and ColumnLine charts.specifies which chart to select when using LineArea, LineScatter, and ColumnLine charts.
         * @api
         * @example
         * chart.selectSeries({index: 1, seriesIndex: 2});
         */
        this.selectSeries = (seriesInfo) => {
            if (!this.isSelectableSeries()) {
                throw new Error(_message__WEBPACK_IMPORTED_MODULE_4__.message.SELECT_SERIES_API_SELECTABLE_ERROR);
            }
            this.eventBus.emit('selectSeries', Object.assign(Object.assign({}, seriesInfo), { state: this.store.state }));
        };
        /**
         * Unselect selected series. It works only when the selectable option is true.
         * @api
         * @example
         * chart.unselectSeries();
         */
        this.unselectSeries = () => {
            if (!this.isSelectableSeries()) {
                throw new Error(_message__WEBPACK_IMPORTED_MODULE_4__.message.SELECT_SERIES_API_SELECTABLE_ERROR);
            }
            this.store.dispatch('setAllLegendActiveState', true);
            this.eventBus.emit('resetSelectedSeries');
        };
        /**
         * Resize chart size.
         * @param {Object} size Chart size
         *   @param {number} [size.width] Width
         *   @param {number} [size.height] Height
         * @api
         * @example
         * chart.resize({height: 100, width: 200});
         */
        this.resize = (size) => {
            this.resetSeries();
            this.dispatchOptionsEvent('updateOptions', { chart: Object.assign({}, size) });
        };
        this.resetSeries = () => {
            this.eventBus.emit('resetHoveredSeries');
            this.eventBus.emit('resetSelectedSeries');
        };
        this.setResizeEventListeners = (eventName, options) => {
            var _a, _b, _c, _d;
            const { usingContainerSize } = this.store.state;
            const { width: usingContainerWidth, height: usingContainerHeight } = usingContainerSize;
            const width = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.chart) === null || _b === void 0 ? void 0 : _b.width;
            const height = (_d = (_c = options) === null || _c === void 0 ? void 0 : _c.chart) === null || _d === void 0 ? void 0 : _d.height;
            const isAutoWidth = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isAutoValue)(width);
            const isAutoHeight = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isAutoValue)(height);
            this.store.dispatch('setUsingContainerSize', getUsingContainerSize(eventName, usingContainerSize, width, height));
            if ((usingContainerWidth || usingContainerHeight) && (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(width) && (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(height)) {
                this.clearResizeEvent();
            }
            else if (!(usingContainerWidth || usingContainerHeight) && (isAutoWidth || isAutoHeight)) {
                this.setResizeEvent();
            }
        };
        const { el, options, series, categories, modules } = props;
        this.modules = (modules !== null && modules !== void 0 ? modules : []);
        if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(options.usageStatistics) || options.usageStatistics) {
            (0,_helpers_googleAnalytics__WEBPACK_IMPORTED_MODULE_5__.sendHostname)();
        }
        this.containerEl = el;
        this.el = this.createChartWrapper();
        this.containerEl.appendChild(this.el);
        this.animator = new _animator__WEBPACK_IMPORTED_MODULE_6__["default"]();
        this.store = new _store_store__WEBPACK_IMPORTED_MODULE_7__["default"]({
            series,
            categories,
            options,
        });
        this.componentManager = new _component_componentManager__WEBPACK_IMPORTED_MODULE_8__["default"]({
            store: this.store,
            eventBus: this.eventBus,
        });
        this.eventBus.on('needLoop', (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.debounce)(() => {
            var _a, _b;
            let duration = this.getAnimationDuration((_a = options.chart) === null || _a === void 0 ? void 0 : _a.animation);
            if (this.animationControlFlag.resizing) {
                duration = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(options.responsive)
                    ? this.getAnimationDuration()
                    : this.getAnimationDuration((_b = options.responsive) === null || _b === void 0 ? void 0 : _b.animation);
                this.animationControlFlag.resizing = false;
            }
            this.eventBus.emit('loopStart');
            this.animator.add({
                onCompleted: () => {
                    this.eventBus.emit('loopComplete');
                },
                chart: this,
                duration,
                requester: this,
            });
        }, 10));
        this.eventBus.on('needSubLoop', (opts) => {
            this.animator.add(Object.assign(Object.assign({}, opts), { chart: this }));
        });
        this.eventBus.on('needDraw', (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.debounce)(() => {
            this.draw();
        }, 10));
        this.initialize();
        this.store.observe(() => {
            this.painter.setup();
        });
        if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isAutoValue)((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.chart) === null || _b === void 0 ? void 0 : _b.width) || (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isAutoValue)((_d = (_c = options) === null || _c === void 0 ? void 0 : _c.chart) === null || _d === void 0 ? void 0 : _d.height)) {
            this.setResizeEvent();
        }
    }
    getAnimationDuration(animationOption) {
        const { firstRendering } = this.animator;
        const { resizing, updating } = this.animationControlFlag;
        let duration;
        if ((!firstRendering && !resizing) || (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(animationOption)) {
            duration = DEFAULT_ANIM_DURATION;
        }
        else if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(animationOption)) {
            duration = animationOption ? DEFAULT_ANIM_DURATION : 0;
        }
        else if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(animationOption.duration)) {
            duration = animationOption.duration;
        }
        if (updating) {
            duration = 0;
        }
        this.animationControlFlag.updating = false;
        return duration;
    }
    createChartWrapper() {
        const el = document.createElement('div');
        el.classList.add('toastui-chart-wrapper');
        return el;
    }
    resizeChartSize(containerWidth, containerHeight) {
        this.animationControlFlag.resizing = true;
        const { usingContainerSize: { width: usingContainerWidth, height: usingContainerHeight }, chart: { width, height }, } = this.store.state;
        if (!(usingContainerWidth || usingContainerHeight) ||
            !(containerWidth || containerHeight) ||
            (containerWidth === width && containerHeight === height)) {
            this.animationControlFlag.resizing = false;
            return;
        }
        // @TODO: For updates where the data doesn't change, it looks good to recalculate the selected series position.
        this.resetSeries();
        this.store.dispatch('setChartSize', {
            width: usingContainerWidth ? containerWidth : width,
            height: usingContainerHeight ? containerHeight : height,
        });
        this.draw();
    }
    setResizeEvent() {
        const { usingContainerSize } = this.store.state;
        if ((usingContainerSize.height && !this.containerEl.style.height.length) ||
            (usingContainerSize.width && !this.containerEl.style.width.length)) {
            throw new Error(_message__WEBPACK_IMPORTED_MODULE_4__.message.AUTO_LAYOUT_CONTAINER_SIZE_ERROR);
        }
        const isResizeObserverAPIExist = typeof ResizeObserver === 'undefined';
        if (isResizeObserverAPIExist) {
            window.addEventListener('resize', this.debounceResizeEvent);
        }
        else {
            this.resizeObserver = new ResizeObserver((entries) => {
                entries.forEach(() => {
                    this.debounceResizeEvent();
                });
            });
            this.resizeObserver.observe(this.containerEl);
        }
    }
    clearResizeEvent() {
        if (this.resizeObserver) {
            this.resizeObserver.unobserve(this.containerEl);
            this.resizeObserver.disconnect();
            this.resizeObserver = null;
        }
        else {
            window.removeEventListener('resize', this.debounceResizeEvent);
        }
    }
    handleCanvasMouseEvent(eventType, mousePosition) {
        const newEnteredComponents = [];
        this.componentManager.forEach((component) => {
            if (eventType === 'mousemove') {
                const exist = this.enteredComponents.some((enteredComponent) => enteredComponent === component);
                if ((0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_9__.isMouseInRect)(component.rect, mousePosition)) {
                    newEnteredComponents.push(component);
                    if (!exist && component.onMouseenterComponent) {
                        component.onMouseenterComponent();
                    }
                }
                else if (exist && component.onMouseoutComponent) {
                    component.onMouseoutComponent();
                }
            }
            else if (eventType === 'mouseout' && component.onMouseoutComponent) {
                component.onMouseoutComponent();
            }
        });
        this.enteredComponents = newEnteredComponents;
    }
    handleResponderEvent(event, mousePosition) {
        const eventType = event.type;
        const delegationMethod = `on${eventType[0].toUpperCase() + eventType.substring(1)}`;
        const allResponders = [];
        this.componentManager.forEach((component) => {
            if (!component[delegationMethod]) {
                return;
            }
            if (!_responderDetectors__WEBPACK_IMPORTED_MODULE_10__.responderDetectors.rect(mousePosition, component.rect)) {
                return;
            }
            const detected = (component.responders || []).filter((m) => {
                return _responderDetectors__WEBPACK_IMPORTED_MODULE_10__.responderDetectors[m.type](mousePosition, m, component.rect);
            });
            if (detected.length) {
                allResponders.push({ component, detected });
            }
            component[delegationMethod]({ mousePosition, responders: detected }, event);
        });
        if (this.handleEventForAllResponders) {
            this.handleEventForAllResponders(event, allResponders, delegationMethod, mousePosition);
        }
    }
    handleEvent(event) {
        const { clientX, clientY, type: eventType } = event;
        const canvas = this.painter.ctx.canvas;
        const { width, height, left, top } = canvas.getBoundingClientRect();
        // Calculate scale for chart affected by a CSS transform.
        const scaleX = width / canvas.offsetWidth;
        const scaleY = height / canvas.offsetHeight;
        const mousePosition = {
            x: (clientX - left) / scaleX,
            y: (clientY - top) / scaleY,
        };
        if (eventType === 'mousemove' || eventType === 'mouseout') {
            this.handleCanvasMouseEvent(eventType, mousePosition);
        }
        this.handleResponderEvent(event, mousePosition);
    }
    initStore() {
        [
            _store_root__WEBPACK_IMPORTED_MODULE_11__["default"],
            _store_options__WEBPACK_IMPORTED_MODULE_12__["default"],
            _store_theme__WEBPACK_IMPORTED_MODULE_13__["default"],
            _store_seriesData__WEBPACK_IMPORTED_MODULE_14__["default"],
            _store_legend__WEBPACK_IMPORTED_MODULE_15__["default"],
            _store_layout__WEBPACK_IMPORTED_MODULE_16__["default"],
            _store_category__WEBPACK_IMPORTED_MODULE_17__["default"],
            ...this.modules,
        ].forEach((module) => this.store.setModule(module));
    }
    initialize() {
        this.initStore();
        this.store.dispatch('initChartSize', this.containerEl);
    }
    draw() {
        this.painter.beforeFrame();
        this.componentManager.forEach((component) => {
            if (!component.isShow) {
                return;
            }
            this.painter.beforeDraw(component.rect.x, component.rect.y);
            if (component.beforeDraw) {
                component.beforeDraw(this.painter);
            }
            component.draw(this.painter);
            this.painter.afterDraw();
        });
    }
    update(delta) {
        this.componentManager.invoke('update', delta);
    }
    initUpdate(delta) {
        this.componentManager.invoke('initUpdate', delta);
    }
    isSelectableSeries() {
        var _a;
        return (_a = this.store.initStoreState.options.series) === null || _a === void 0 ? void 0 : _a.selectable;
    }
    /**
     * Set tooltip offset.
     * @param {Object} offset - Offset size
     *   @param {number} [offset.x] Offset value to move title horizontally
     *   @param {number} [offset.y] Offset value to move title vertically
     * @api
     * @example
     * chart.setTooltipOffset({x: 10, y: -20});
     */
    setTooltipOffset(offset) {
        const { x: offsetX, y: offsetY } = offset;
        this.store.dispatch('updateOptions', { options: { tooltip: { offsetX, offsetY } } });
    }
    dispatchOptionsEvent(eventName, options) {
        this.setResizeEventListeners(eventName, options);
        const { offsetWidth, offsetHeight } = this.containerEl;
        this.store.dispatch(eventName, {
            options,
            containerSize: { width: offsetWidth, height: offsetHeight },
        });
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/columnChart.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/columnChart.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ColumnChart)
/* harmony export */ });
/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart */ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js");
/* harmony import */ var _store_dataRange__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/dataRange */ "./node_modules/@toast-ui/chart/dist/esm/store/dataRange.js");
/* harmony import */ var _store_stackSeriesData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/stackSeriesData */ "./node_modules/@toast-ui/chart/dist/esm/store/stackSeriesData.js");
/* harmony import */ var _store_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/scale */ "./node_modules/@toast-ui/chart/dist/esm/store/scale.js");
/* harmony import */ var _store_axes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store/axes */ "./node_modules/@toast-ui/chart/dist/esm/store/axes.js");
/* harmony import */ var _store_plot__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../store/plot */ "./node_modules/@toast-ui/chart/dist/esm/store/plot.js");
/* harmony import */ var _component_axis__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../component/axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");
/* harmony import */ var _component_boxSeries__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component/boxSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/boxSeries.js");
/* harmony import */ var _component_boxStackSeries__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/boxStackSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/boxStackSeries.js");
/* harmony import */ var _component_plot__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/plot */ "./node_modules/@toast-ui/chart/dist/esm/component/plot.js");
/* harmony import */ var _component_tooltip__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../component/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js");
/* harmony import */ var _component_legend__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/legend */ "./node_modules/@toast-ui/chart/dist/esm/component/legend.js");
/* harmony import */ var _component_dataLabels__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../component/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/component/dataLabels.js");
/* harmony import */ var _component_title__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/title */ "./node_modules/@toast-ui/chart/dist/esm/component/title.js");
/* harmony import */ var _component_axisTitle__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../component/axisTitle */ "./node_modules/@toast-ui/chart/dist/esm/component/axisTitle.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _component_zeroAxis__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../component/zeroAxis */ "./node_modules/@toast-ui/chart/dist/esm/component/zeroAxis.js");
/* harmony import */ var _component_hoveredSeries__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../component/hoveredSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js");
/* harmony import */ var _component_selectedSeries__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../component/selectedSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js");
/* harmony import */ var _component_background__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component/background */ "./node_modules/@toast-ui/chart/dist/esm/component/background.js");
/* harmony import */ var _component_noDataText__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../component/noDataText */ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js");
/* harmony import */ var _component_rangeSelection__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../component/rangeSelection */ "./node_modules/@toast-ui/chart/dist/esm/component/rangeSelection.js");
/* harmony import */ var _brushes_basic__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../brushes/basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _brushes_axis__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../brushes/axis */ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../brushes/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js");
/* harmony import */ var _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../brushes/dataLabel */ "./node_modules/@toast-ui/chart/dist/esm/brushes/dataLabel.js");




























/**
 * @class
 * @classdesc Column Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Column Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {string} props.data.series.colorByCategories - Paint Rect with color based on categories.
 *       @param {Array<number|Array<number>>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Column Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.rangeSelectable=false] - Whether to use range selection feature or not.
 *       @param {number} [props.options.series.barWidth] - Bar width.
 *       @param {boolean} [props.options.series.diverging] - Whether to use diverging chart or not.
 *       @param {Object} [props.options.series.stack] - Option to use the stack chart or, if so, what type of stack to use.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'grouped', 'point' is available.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Bar Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
class ColumnChart extends _chart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ el, options, data }) {
        super({
            el,
            options,
            series: {
                column: data.series,
            },
            categories: data.categories,
            modules: [_store_stackSeriesData__WEBPACK_IMPORTED_MODULE_1__["default"], _store_dataRange__WEBPACK_IMPORTED_MODULE_2__["default"], _store_scale__WEBPACK_IMPORTED_MODULE_3__["default"], _store_axes__WEBPACK_IMPORTED_MODULE_4__["default"], _store_plot__WEBPACK_IMPORTED_MODULE_5__["default"]],
        });
    }
    initialize() {
        var _a;
        super.initialize();
        const stackChart = !!((_a = this.store.initStoreState.options.series) === null || _a === void 0 ? void 0 : _a.stack);
        this.componentManager.add(_component_background__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.componentManager.add(_component_title__WEBPACK_IMPORTED_MODULE_7__["default"]);
        this.componentManager.add(_component_plot__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.componentManager.add(_component_legend__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.componentManager.add(_component_boxStackSeries__WEBPACK_IMPORTED_MODULE_10__["default"], { name: 'column', stackChart });
        this.componentManager.add(_component_boxSeries__WEBPACK_IMPORTED_MODULE_11__["default"], { name: 'column', stackChart });
        this.componentManager.add(_component_zeroAxis__WEBPACK_IMPORTED_MODULE_12__["default"]);
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_13__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_13__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_14__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_14__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_exportMenu__WEBPACK_IMPORTED_MODULE_15__["default"], { chartEl: this.el });
        this.componentManager.add(_component_hoveredSeries__WEBPACK_IMPORTED_MODULE_16__["default"]);
        this.componentManager.add(_component_selectedSeries__WEBPACK_IMPORTED_MODULE_17__["default"]);
        this.componentManager.add(_component_dataLabels__WEBPACK_IMPORTED_MODULE_18__["default"]);
        this.componentManager.add(_component_tooltip__WEBPACK_IMPORTED_MODULE_19__["default"], { chartEl: this.el });
        this.componentManager.add(_component_noDataText__WEBPACK_IMPORTED_MODULE_20__["default"]);
        this.componentManager.add(_component_rangeSelection__WEBPACK_IMPORTED_MODULE_21__["default"]);
        this.painter.addGroups([
            _brushes_basic__WEBPACK_IMPORTED_MODULE_22__,
            _brushes_axis__WEBPACK_IMPORTED_MODULE_23__,
            _brushes_legend__WEBPACK_IMPORTED_MODULE_24__,
            _brushes_label__WEBPACK_IMPORTED_MODULE_25__,
            _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_26__,
            _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_27__,
        ]);
    }
    /**
     * Add data.
     * @param {Array<number|Array<number>>} data - Array of data to be added
     * @param {string} category - Category to be added
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */
    addData(data, category) {
        this.animationControlFlag.updating = true;
        this.resetSeries();
        this.store.dispatch('addData', { data, category });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added
     *   @param {string} data.name - Series name
     *   @param {Array<number|Array<number>>} data.data - Array of data to be added
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */
    addSeries(data) {
        this.resetSeries();
        this.store.dispatch('addSeries', { data });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */
    setData(data) {
        const { categories, series } = data;
        this.resetSeries();
        this.store.dispatch('setData', { series: { column: series }, categories });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */
    hideSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: false } } },
        });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */
    showSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: true } } },
        });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    setOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    updateOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
     *      @param {number} [seriesInfo.seriesIndex] - Index of series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */
    showTooltip(seriesInfo) {
        this.eventBus.emit('showTooltip', Object.assign({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */
    hideTooltip() {
        this.eventBus.emit('hideTooltip');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/columnLineChart.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/columnLineChart.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ColumnLineChart)
/* harmony export */ });
/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chart */ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js");
/* harmony import */ var _store_stackSeriesData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/stackSeriesData */ "./node_modules/@toast-ui/chart/dist/esm/store/stackSeriesData.js");
/* harmony import */ var _store_plot__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../store/plot */ "./node_modules/@toast-ui/chart/dist/esm/store/plot.js");
/* harmony import */ var _store_axes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../store/axes */ "./node_modules/@toast-ui/chart/dist/esm/store/axes.js");
/* harmony import */ var _store_scale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store/scale */ "./node_modules/@toast-ui/chart/dist/esm/store/scale.js");
/* harmony import */ var _store_dataRange__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/dataRange */ "./node_modules/@toast-ui/chart/dist/esm/store/dataRange.js");
/* harmony import */ var _component_legend__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/legend */ "./node_modules/@toast-ui/chart/dist/esm/component/legend.js");
/* harmony import */ var _component_boxStackSeries__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component/boxStackSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/boxStackSeries.js");
/* harmony import */ var _component_boxSeries__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../component/boxSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/boxSeries.js");
/* harmony import */ var _component_lineSeries__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../component/lineSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/lineSeries.js");
/* harmony import */ var _component_plot__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/plot */ "./node_modules/@toast-ui/chart/dist/esm/component/plot.js");
/* harmony import */ var _component_title__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/title */ "./node_modules/@toast-ui/chart/dist/esm/component/title.js");
/* harmony import */ var _component_zeroAxis__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../component/zeroAxis */ "./node_modules/@toast-ui/chart/dist/esm/component/zeroAxis.js");
/* harmony import */ var _component_axis__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../component/axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");
/* harmony import */ var _component_axisTitle__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../component/axisTitle */ "./node_modules/@toast-ui/chart/dist/esm/component/axisTitle.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _component_selectedSeries__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../component/selectedSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js");
/* harmony import */ var _component_hoveredSeries__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../component/hoveredSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js");
/* harmony import */ var _component_dataLabels__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../component/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/component/dataLabels.js");
/* harmony import */ var _component_tooltip__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../component/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js");
/* harmony import */ var _component_background__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/background */ "./node_modules/@toast-ui/chart/dist/esm/component/background.js");
/* harmony import */ var _component_rangeSelection__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../component/rangeSelection */ "./node_modules/@toast-ui/chart/dist/esm/component/rangeSelection.js");
/* harmony import */ var _component_noDataText__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../component/noDataText */ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js");
/* harmony import */ var _brushes_basic__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../brushes/basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _brushes_axis__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../brushes/axis */ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../brushes/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js");
/* harmony import */ var _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../brushes/dataLabel */ "./node_modules/@toast-ui/chart/dist/esm/brushes/dataLabel.js");
/* harmony import */ var _brushes_lineSeries__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ../brushes/lineSeries */ "./node_modules/@toast-ui/chart/dist/esm/brushes/lineSeries.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");































function hasPointEventType(respondersModel, name) {
    return respondersModel.find(({ component }) => component.name === name && component.eventDetectType === 'point');
}
function hasColumnLineUsingPointEventType(respondersModel) {
    return ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isExist)(hasPointEventType(respondersModel, 'column')) &&
        (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isExist)(hasPointEventType(respondersModel, 'line')));
}
/**
 * @class
 * @classdesc ColumnLine Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making ColumnLine Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {Array<Object>} props.data.series.line - Line series data. Coordinate types data is not possible.
 *       @param {Array<Object>} props.data.series.column - Column series data.
 *   @param {Object} [props.options] - Options for making ColumnLine Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series] - Write common options in the upper depth and separate options to be applied to each chart.
 *       @param {Object} [props.options.series.line] - Options to be applied to the line chart. 'spline', 'showDot', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Line Chart guide} on github.
 *       @param {Object} [props.options.series.column] - Options to be applied to the column chart. 'barWidth', 'stack', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Column Chart guide} on github.
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.rangeSelectable=false] - Whether to use range selection feature or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'near', 'nearest', 'grouped', 'point' is available.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *       @param {Array<Object>} [props.options.plot.lines] - Plot lines information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|ColumnLine Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme. Each theme to be applied to the two charts should be written separately.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
class ColumnLineChart extends _chart__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor({ el, options, data: { series, categories } }) {
        super({
            el,
            options,
            series: series,
            categories,
            modules: [_store_stackSeriesData__WEBPACK_IMPORTED_MODULE_2__["default"], _store_dataRange__WEBPACK_IMPORTED_MODULE_3__["default"], _store_scale__WEBPACK_IMPORTED_MODULE_4__["default"], _store_axes__WEBPACK_IMPORTED_MODULE_5__["default"], _store_plot__WEBPACK_IMPORTED_MODULE_6__["default"]],
        });
    }
    initialize() {
        super.initialize();
        this.componentManager.add(_component_background__WEBPACK_IMPORTED_MODULE_7__["default"]);
        this.componentManager.add(_component_title__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.componentManager.add(_component_plot__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.componentManager.add(_component_legend__WEBPACK_IMPORTED_MODULE_10__["default"]);
        this.componentManager.add(_component_boxStackSeries__WEBPACK_IMPORTED_MODULE_11__["default"], { name: 'column' });
        this.componentManager.add(_component_boxSeries__WEBPACK_IMPORTED_MODULE_12__["default"], { name: 'column' });
        this.componentManager.add(_component_lineSeries__WEBPACK_IMPORTED_MODULE_13__["default"]);
        this.componentManager.add(_component_zeroAxis__WEBPACK_IMPORTED_MODULE_14__["default"]);
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_15__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_15__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_15__["default"], { name: 'secondaryYAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_16__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_16__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_16__["default"], { name: 'secondaryYAxis' });
        this.componentManager.add(_component_exportMenu__WEBPACK_IMPORTED_MODULE_17__["default"], { chartEl: this.el });
        this.componentManager.add(_component_hoveredSeries__WEBPACK_IMPORTED_MODULE_18__["default"]);
        this.componentManager.add(_component_selectedSeries__WEBPACK_IMPORTED_MODULE_19__["default"]);
        this.componentManager.add(_component_dataLabels__WEBPACK_IMPORTED_MODULE_20__["default"]);
        this.componentManager.add(_component_rangeSelection__WEBPACK_IMPORTED_MODULE_21__["default"]);
        this.componentManager.add(_component_tooltip__WEBPACK_IMPORTED_MODULE_22__["default"], { chartEl: this.el });
        this.componentManager.add(_component_noDataText__WEBPACK_IMPORTED_MODULE_23__["default"]);
        this.painter.addGroups([
            _brushes_basic__WEBPACK_IMPORTED_MODULE_24__,
            _brushes_axis__WEBPACK_IMPORTED_MODULE_25__,
            _brushes_legend__WEBPACK_IMPORTED_MODULE_26__,
            _brushes_label__WEBPACK_IMPORTED_MODULE_27__,
            _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_28__,
            _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_29__,
            _brushes_lineSeries__WEBPACK_IMPORTED_MODULE_30__,
        ]);
    }
    handleEventForAllResponders(event, responderModels, delegationMethod, mousePosition) {
        if (hasColumnLineUsingPointEventType(responderModels)) {
            const columnSeries = responderModels.find(({ component }) => component.name === 'column');
            columnSeries.component[delegationMethod]({ mousePosition, responders: [] }, event);
        }
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @param {string} chartType - Which type of chart to add.
     * @api
     * @example
     * chart.addData([10, 20], '6', 'line');
     */
    addData(data, category, chartType) {
        this.animationControlFlag.updating = true;
        this.resetSeries();
        this.store.dispatch('addData', { data, category, chartType });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     * @param {string} data.name - Series name.
     * @param {Array<number>} data.data - Array of data to be added.
     * @param {Object} dataInfo - Which type of chart to add.
     * @param {Object} dataInfo.chartType - Chart type.
     * @api
     * @example
     * chart.addSeries(
     *   {
     *     name: 'newSeries',
     *     data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     *   },
     *   {
     *     chartType: 'line'
     *   });
     */
    addSeries(data, dataInfo) {
        this.resetSeries();
        this.store.dispatch('addSeries', Object.assign({ data }, dataInfo));
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: {
     *     column: [
     *       {
     *         name: 'A',
     *         data: [1, 2, 3],
     *       }
     *     ],
     *     line: [
     *       {
     *         name: 'B',
     *         data: [4, 5, 6],
     *       }
     *     ]
     *   }
     * });
     */
    setData(data) {
        this.resetSeries();
        this.store.dispatch('setData', data);
    }
    /**
     * Add plot line.
     * @param {Object} data - Plot info.
     *   @param {string|number} data.value - The value where the plot line will be drawn.
     *   @param {string} data.color - Plot line color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
     * @api
     * @example
     * chart.addPlotLine({
     *   value: 2,
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */
    addPlotLine(data) {
        this.store.dispatch('addPlotLine', { data });
    }
    /**
     * Remove plot line with id.
     * @param {string} id - Id of the plot line to be removed
     * @api
     * @example
     * chart.removePlotLine('plot-1');
     */
    removePlotLine(id) {
        this.store.dispatch('removePlotLine', { id });
    }
    /**
     * Add plot band.
     * @param {Object} data - plot info
     *   @param {Array<string|number>} data.range - The range to be drawn
     *   @param {string} data.color - Plot band color
     *   @param {string} [data.id] - Plot id. The value on which the removePlotBand is based
     * @api
     * @example
     * chart.addPlotBand({
     *   value: [2, 4],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */
    addPlotBand(data) {
        this.store.dispatch('addPlotBand', { data });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - id of the plot band to be removed
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */
    removePlotBand(id) {
        this.store.dispatch('removePlotBand', { id });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */
    hideSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: false } } },
        });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */
    showSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: true } } },
        });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     line: {
     *       showDot: true,
     *     },
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    setOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     line: {
     *       showDot: true,
     *     },
     *   },
     * });
     */
    updateOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     *      @param {string} seriesInfo.chartType - Specify which chart to select.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2, chartType: 'column'});
     */
    showTooltip(seriesInfo) {
        this.eventBus.emit('showTooltip', Object.assign({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */
    hideTooltip() {
        this.eventBus.emit('hideTooltip');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/gaugeChart.js":
/*!********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/gaugeChart.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GaugeChart)
/* harmony export */ });
/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart */ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js");
/* harmony import */ var _store_dataRange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/dataRange */ "./node_modules/@toast-ui/chart/dist/esm/store/dataRange.js");
/* harmony import */ var _store_scale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/scale */ "./node_modules/@toast-ui/chart/dist/esm/store/scale.js");
/* harmony import */ var _store_gaugeAxes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/gaugeAxes */ "./node_modules/@toast-ui/chart/dist/esm/store/gaugeAxes.js");
/* harmony import */ var _component_tooltip__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../component/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js");
/* harmony import */ var _component_gaugeSeries__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/gaugeSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/gaugeSeries.js");
/* harmony import */ var _component_title__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../component/title */ "./node_modules/@toast-ui/chart/dist/esm/component/title.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _component_hoveredSeries__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/hoveredSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js");
/* harmony import */ var _component_dataLabels__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../component/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/component/dataLabels.js");
/* harmony import */ var _component_axisTitle__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/axisTitle */ "./node_modules/@toast-ui/chart/dist/esm/component/axisTitle.js");
/* harmony import */ var _component_selectedSeries__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component/selectedSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js");
/* harmony import */ var _component_background__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../component/background */ "./node_modules/@toast-ui/chart/dist/esm/component/background.js");
/* harmony import */ var _component_radialAxis__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/radialAxis */ "./node_modules/@toast-ui/chart/dist/esm/component/radialAxis.js");
/* harmony import */ var _component_radialPlot__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component/radialPlot */ "./node_modules/@toast-ui/chart/dist/esm/component/radialPlot.js");
/* harmony import */ var _component_noDataText__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../component/noDataText */ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js");
/* harmony import */ var _brushes_basic__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../brushes/basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../brushes/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js");
/* harmony import */ var _brushes_sector__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../brushes/sector */ "./node_modules/@toast-ui/chart/dist/esm/brushes/sector.js");
/* harmony import */ var _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../brushes/dataLabel */ "./node_modules/@toast-ui/chart/dist/esm/brushes/dataLabel.js");
/* harmony import */ var _brushes_axis__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../brushes/axis */ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js");
/* harmony import */ var _brushes_gauge__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../brushes/gauge */ "./node_modules/@toast-ui/chart/dist/esm/brushes/gauge.js");
























/**
 * @class
 * @classdesc Gauge Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Gauge Chart.
 *     @param {Array<string>} [props.data.categories] - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {number} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Gauge Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Gauge Chart guide} on github.
 *       @param {Array<number>} [props.options.series.angleRange] - The range of angles to which the circle will be drawn. It is specified by putting number in start and end.
 *       @param {boolean} [props.options.series.clockwise] - Whether it will be drawn clockwise.
 *       @param {boolean | Object} [props.options.series.solid] - When this option is set, the radial bar is displayed. It can be used when there is one series data. The default value is 'false'.
 *     @param {Object} [props.options.circularAxis]
 *       @param {string|Object} [props.options.circularAxis.title] - Axis title.
 *       @param {Object} [props.options.circularAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.circularAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.circularAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Gauge Chart guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Gauge Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.circularAxis] - Circular Axis theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 *       @param {Object} [props.options.theme.plot] - Plot Theme.
 * @extends Chart
 */
class GaugeChart extends _chart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ el, options, data }) {
        super({
            el,
            options,
            series: {
                gauge: data.series,
            },
            categories: data.categories,
            modules: [_store_dataRange__WEBPACK_IMPORTED_MODULE_1__["default"], _store_scale__WEBPACK_IMPORTED_MODULE_2__["default"], _store_gaugeAxes__WEBPACK_IMPORTED_MODULE_3__["default"]],
        });
    }
    initialize() {
        super.initialize();
        this.componentManager.add(_component_background__WEBPACK_IMPORTED_MODULE_4__["default"]);
        this.componentManager.add(_component_title__WEBPACK_IMPORTED_MODULE_5__["default"]);
        this.componentManager.add(_component_radialPlot__WEBPACK_IMPORTED_MODULE_6__["default"], { name: 'gauge' });
        this.componentManager.add(_component_radialAxis__WEBPACK_IMPORTED_MODULE_7__["default"], { name: 'gauge' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_8__["default"], { name: 'circularAxis' });
        this.componentManager.add(_component_gaugeSeries__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.componentManager.add(_component_hoveredSeries__WEBPACK_IMPORTED_MODULE_10__["default"]);
        this.componentManager.add(_component_selectedSeries__WEBPACK_IMPORTED_MODULE_11__["default"]);
        this.componentManager.add(_component_dataLabels__WEBPACK_IMPORTED_MODULE_12__["default"]);
        this.componentManager.add(_component_exportMenu__WEBPACK_IMPORTED_MODULE_13__["default"], { chartEl: this.el });
        this.componentManager.add(_component_tooltip__WEBPACK_IMPORTED_MODULE_14__["default"], { chartEl: this.el });
        this.componentManager.add(_component_noDataText__WEBPACK_IMPORTED_MODULE_15__["default"]);
        this.painter.addGroups([
            _brushes_basic__WEBPACK_IMPORTED_MODULE_16__,
            _brushes_legend__WEBPACK_IMPORTED_MODULE_17__,
            _brushes_label__WEBPACK_IMPORTED_MODULE_18__,
            _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_19__,
            _brushes_sector__WEBPACK_IMPORTED_MODULE_20__,
            _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_21__,
            _brushes_axis__WEBPACK_IMPORTED_MODULE_22__,
            _brushes_gauge__WEBPACK_IMPORTED_MODULE_23__,
        ]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number|Array<number>>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 20],
     * });
     */
    addSeries(data) {
        this.resetSeries();
        this.store.dispatch('addSeries', { data });
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} [category] - Category to be added.
     * @api
     * @example
     * // without categories
     * chart.addData([10], '6');
     *
     * // with categories
     * chart.addData([10], '6');
     */
    addData(data, category) {
        this.resetSeries();
        this.animationControlFlag.updating = true;
        this.store.dispatch('addData', { data, category });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */
    setData(data) {
        const { categories, series } = data;
        this.resetSeries();
        this.store.dispatch('setData', { series: { gauge: series }, categories });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */
    hideSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: false } } },
        });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */
    showSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: true } } },
        });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 500,
     *     title: 'Olympic Medals',
     *   },
     *   series: {
     *     selectable: true
     *   }
     * });
     */
    setOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     title: 'Olympic Medals',
     *   }
     * });
     */
    updateOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.index - Index of data within series.
     * @api
     * @example
     * chart.showTooltip({index: 1});
     */
    showTooltip(seriesInfo) {
        this.eventBus.emit('showTooltip', Object.assign(Object.assign({}, seriesInfo), { state: this.store.state }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */
    hideTooltip() {
        this.eventBus.emit('hideTooltip');
    }
    /**
     * Add plot band.
     * @param {Object} data - Plot info.
     *   @param {Array<string|number>} data.range - The range to be drawn.
     *   @param {string} data.color - Plot band color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
     * @api
     * @example
     * chart.addPlotBand({
     *   range: [10, 20],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */
    addPlotBand(data) {
        this.store.dispatch('addGaugePlotBand', { data });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - id of the plot band to be removed
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */
    removePlotBand(id) {
        this.store.dispatch('removeGaugePlotBand', { id });
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/heatmapChart.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/heatmapChart.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HeatmapChart)
/* harmony export */ });
/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart */ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js");
/* harmony import */ var _store_heatmapAxes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/heatmapAxes */ "./node_modules/@toast-ui/chart/dist/esm/store/heatmapAxes.js");
/* harmony import */ var _store_heatmapSeriesData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/heatmapSeriesData */ "./node_modules/@toast-ui/chart/dist/esm/store/heatmapSeriesData.js");
/* harmony import */ var _store_colorValueScale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/colorValueScale */ "./node_modules/@toast-ui/chart/dist/esm/store/colorValueScale.js");
/* harmony import */ var _component_tooltip__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../component/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js");
/* harmony import */ var _component_title__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../component/title */ "./node_modules/@toast-ui/chart/dist/esm/component/title.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _component_hoveredSeries__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component/hoveredSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js");
/* harmony import */ var _component_dataLabels__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../component/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/component/dataLabels.js");
/* harmony import */ var _component_spectrumLegend__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component/spectrumLegend */ "./node_modules/@toast-ui/chart/dist/esm/component/spectrumLegend.js");
/* harmony import */ var _component_heatmapSeries__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/heatmapSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/heatmapSeries.js");
/* harmony import */ var _component_axisTitle__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/axisTitle */ "./node_modules/@toast-ui/chart/dist/esm/component/axisTitle.js");
/* harmony import */ var _component_axis__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");
/* harmony import */ var _component_selectedSeries__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../component/selectedSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js");
/* harmony import */ var _component_background__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../component/background */ "./node_modules/@toast-ui/chart/dist/esm/component/background.js");
/* harmony import */ var _component_noDataText__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../component/noDataText */ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js");
/* harmony import */ var _brushes_basic__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../brushes/basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../brushes/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js");
/* harmony import */ var _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../brushes/dataLabel */ "./node_modules/@toast-ui/chart/dist/esm/brushes/dataLabel.js");
/* harmony import */ var _brushes_spectrumLegend__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../brushes/spectrumLegend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/spectrumLegend.js");
/* harmony import */ var _brushes_axis__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../brushes/axis */ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js");























function getSeriesWithYCategory(series, categories) {
    return series.map((rowSeries, y) => ({
        data: rowSeries,
        yCategory: categories.y[y],
    }));
}
/**
 * @class
 * @classdesc Heatmap Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Heatmap Chart.
 *     @param {Object} props.data.categories
 *       @param {Array<string>} props.data.categories.x - X Categories.
 *       @param {Array<string>} props.data.categories.y - Y Categories.
 *     @param {Array<Array<number>>} props.data.series - Series data.
 *   @param {Object} [props.options] - Options for making Heatmap Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {boolean|Object} [props.options.yAxis.date] - Whether the y axis label is of date type. Format option used for date type. Whether the y axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Heatmap Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
class HeatmapChart extends _chart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(props) {
        super({
            el: props.el,
            categories: props.data.categories,
            options: props.options,
            series: {
                heatmap: getSeriesWithYCategory(props.data.series, props.data.categories),
            },
            modules: [_store_heatmapSeriesData__WEBPACK_IMPORTED_MODULE_1__["default"], _store_colorValueScale__WEBPACK_IMPORTED_MODULE_2__["default"], _store_heatmapAxes__WEBPACK_IMPORTED_MODULE_3__["default"]],
        });
    }
    initialize() {
        super.initialize();
        this.componentManager.add(_component_background__WEBPACK_IMPORTED_MODULE_4__["default"]);
        this.componentManager.add(_component_title__WEBPACK_IMPORTED_MODULE_5__["default"]);
        this.componentManager.add(_component_spectrumLegend__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.componentManager.add(_component_exportMenu__WEBPACK_IMPORTED_MODULE_7__["default"], { chartEl: this.el });
        this.componentManager.add(_component_heatmapSeries__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_9__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_9__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_10__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_10__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_hoveredSeries__WEBPACK_IMPORTED_MODULE_11__["default"]);
        this.componentManager.add(_component_selectedSeries__WEBPACK_IMPORTED_MODULE_12__["default"]);
        this.componentManager.add(_component_dataLabels__WEBPACK_IMPORTED_MODULE_13__["default"]);
        this.componentManager.add(_component_tooltip__WEBPACK_IMPORTED_MODULE_14__["default"], { chartEl: this.el });
        this.componentManager.add(_component_noDataText__WEBPACK_IMPORTED_MODULE_15__["default"]);
        this.painter.addGroups([
            _brushes_basic__WEBPACK_IMPORTED_MODULE_16__,
            _brushes_axis__WEBPACK_IMPORTED_MODULE_17__,
            _brushes_legend__WEBPACK_IMPORTED_MODULE_18__,
            _brushes_label__WEBPACK_IMPORTED_MODULE_19__,
            _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_20__,
            _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_21__,
            _brushes_spectrumLegend__WEBPACK_IMPORTED_MODULE_22__,
        ]);
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */
    addData(data, category) {
        this.animationControlFlag.updating = true;
        this.resetSeries();
        this.store.dispatch('addData', { data, category });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number>} data.data - Array of data to be added.
     * @param {Object} dataInfo - Category information of the series.
     *   @param {Object} dataInfo.category - Y category.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */
    addSeries(data, dataInfo) {
        this.resetSeries();
        this.store.dispatch('addHeatmapSeries', Object.assign({ data }, dataInfo));
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     *   @param {Array<string>} data.categories.x - X Categories.
     *   @param {Array<string>} data.categories.y - Y Categories.
     * @param {Array<Array<number>>} data.series - Series data.
     * @api
     * @example
     * chart.setData({
     *   categories: {
     *     x: ['1', '2', '3' ],
     *     y: ['A', 'B'],
     *   },
     *   series: [
     *     [1, 2, 3],
     *     [4, 5, 6],
     *   ]
     * });
     */
    setData(data) {
        const { categories, series } = data;
        this.resetSeries();
        this.store.dispatch('setData', {
            series: { heatmap: getSeriesWithYCategory(series, categories) },
            categories,
        });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */
    hideSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: false } } },
        });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */
    showSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: true } } },
        });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    setOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    updateOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */
    showTooltip(seriesInfo) {
        this.eventBus.emit('showTooltip', Object.assign(Object.assign({}, seriesInfo), { state: this.store.state }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */
    hideTooltip() {
        this.eventBus.emit('hideTooltip');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/lineAreaChart.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/lineAreaChart.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LineAreaChart)
/* harmony export */ });
/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart */ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js");
/* harmony import */ var _store_dataRange__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/dataRange */ "./node_modules/@toast-ui/chart/dist/esm/store/dataRange.js");
/* harmony import */ var _store_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/scale */ "./node_modules/@toast-ui/chart/dist/esm/store/scale.js");
/* harmony import */ var _store_axes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store/axes */ "./node_modules/@toast-ui/chart/dist/esm/store/axes.js");
/* harmony import */ var _store_plot__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../store/plot */ "./node_modules/@toast-ui/chart/dist/esm/store/plot.js");
/* harmony import */ var _store_stackSeriesData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/stackSeriesData */ "./node_modules/@toast-ui/chart/dist/esm/store/stackSeriesData.js");
/* harmony import */ var _component_tooltip__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../component/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js");
/* harmony import */ var _component_plot__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/plot */ "./node_modules/@toast-ui/chart/dist/esm/component/plot.js");
/* harmony import */ var _component_lineSeries__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component/lineSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/lineSeries.js");
/* harmony import */ var _component_areaSeries__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/areaSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/areaSeries.js");
/* harmony import */ var _component_axis__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../component/axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");
/* harmony import */ var _component_legend__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/legend */ "./node_modules/@toast-ui/chart/dist/esm/component/legend.js");
/* harmony import */ var _component_dataLabels__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../component/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/component/dataLabels.js");
/* harmony import */ var _component_axisTitle__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../component/axisTitle */ "./node_modules/@toast-ui/chart/dist/esm/component/axisTitle.js");
/* harmony import */ var _component_title__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/title */ "./node_modules/@toast-ui/chart/dist/esm/component/title.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _component_selectedSeries__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../component/selectedSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js");
/* harmony import */ var _component_hoveredSeries__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../component/hoveredSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js");
/* harmony import */ var _component_rangeSelection__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../component/rangeSelection */ "./node_modules/@toast-ui/chart/dist/esm/component/rangeSelection.js");
/* harmony import */ var _component_resetButton__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../component/resetButton */ "./node_modules/@toast-ui/chart/dist/esm/component/resetButton.js");
/* harmony import */ var _component_background__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component/background */ "./node_modules/@toast-ui/chart/dist/esm/component/background.js");
/* harmony import */ var _component_noDataText__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../component/noDataText */ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js");
/* harmony import */ var _brushes_lineSeries__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../brushes/lineSeries */ "./node_modules/@toast-ui/chart/dist/esm/brushes/lineSeries.js");
/* harmony import */ var _brushes_basic__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../brushes/basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _brushes_axis__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../brushes/axis */ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../brushes/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js");
/* harmony import */ var _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../brushes/dataLabel */ "./node_modules/@toast-ui/chart/dist/esm/brushes/dataLabel.js");
/* harmony import */ var _brushes_resetButton__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../brushes/resetButton */ "./node_modules/@toast-ui/chart/dist/esm/brushes/resetButton.js");






























/**
 * @class
 * @classdesc LineArea Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making LineArea Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {Array<Object>} props.data.series.line - Line series data. Coordinate types data is not possible.
 *       @param {Array<Object>} props.data.series.area - Area series data.
 *   @param {Object} [props.options] - Options for making LineArea Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series] - Write common options in the upper depth and separate options to be applied to each chart.
 *       @param {Object} [props.options.series.line] - Options to be applied to the line chart. 'spline', 'showDot', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Line Chart guide} on github.
 *       @param {Object} [props.options.series.area] - Options to be applied to the area chart. 'stack', 'spline', 'showDot', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Area Chart guide} on github.
 *       @param {boolean} [props.options.series.zoomable=false] - Whether to use zoom feature or not.
 *       @param {boolean} [props.options.series.rangeSelectable=false] - Whether to use range selection feature or not.
 *       @param {boolean} [props.options.series.showDot=false] - Whether to show dot or not.
 *       @param {boolean} [props.options.series.spline=false] - Whether to make spline chart or not.
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *       @param {Array<Object>} [props.options.plot.lines] - Plot lines information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|LineArea Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme. Each theme to be applied to the two charts should be written separately.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
class LineAreaChart extends _chart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(props) {
        super({
            el: props.el,
            options: props.options,
            series: props.data.series,
            categories: props.data.categories,
            modules: [_store_stackSeriesData__WEBPACK_IMPORTED_MODULE_1__["default"], _store_dataRange__WEBPACK_IMPORTED_MODULE_2__["default"], _store_scale__WEBPACK_IMPORTED_MODULE_3__["default"], _store_axes__WEBPACK_IMPORTED_MODULE_4__["default"], _store_plot__WEBPACK_IMPORTED_MODULE_5__["default"]],
        });
    }
    initialize() {
        super.initialize();
        this.componentManager.add(_component_background__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.componentManager.add(_component_title__WEBPACK_IMPORTED_MODULE_7__["default"]);
        this.componentManager.add(_component_plot__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.componentManager.add(_component_legend__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.componentManager.add(_component_areaSeries__WEBPACK_IMPORTED_MODULE_10__["default"]);
        this.componentManager.add(_component_lineSeries__WEBPACK_IMPORTED_MODULE_11__["default"]);
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_12__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_12__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_12__["default"], { name: 'secondaryYAxis' });
        this.componentManager.add(_component_dataLabels__WEBPACK_IMPORTED_MODULE_13__["default"]);
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_14__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_14__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_14__["default"], { name: 'secondaryYAxis' });
        this.componentManager.add(_component_exportMenu__WEBPACK_IMPORTED_MODULE_15__["default"], { chartEl: this.el });
        this.componentManager.add(_component_hoveredSeries__WEBPACK_IMPORTED_MODULE_16__["default"]);
        this.componentManager.add(_component_selectedSeries__WEBPACK_IMPORTED_MODULE_17__["default"]);
        this.componentManager.add(_component_tooltip__WEBPACK_IMPORTED_MODULE_18__["default"], { chartEl: this.el });
        this.componentManager.add(_component_rangeSelection__WEBPACK_IMPORTED_MODULE_19__["default"]);
        this.componentManager.add(_component_resetButton__WEBPACK_IMPORTED_MODULE_20__["default"]);
        this.componentManager.add(_component_noDataText__WEBPACK_IMPORTED_MODULE_21__["default"]);
        this.painter.addGroups([
            _brushes_basic__WEBPACK_IMPORTED_MODULE_22__,
            _brushes_axis__WEBPACK_IMPORTED_MODULE_23__,
            _brushes_lineSeries__WEBPACK_IMPORTED_MODULE_24__,
            _brushes_legend__WEBPACK_IMPORTED_MODULE_25__,
            _brushes_label__WEBPACK_IMPORTED_MODULE_26__,
            _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_27__,
            _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_28__,
            _brushes_resetButton__WEBPACK_IMPORTED_MODULE_29__,
        ]);
    }
    /**
     * Add data.
     * @param {Array<number>} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @param {string} chartType - Which type of chart to add.
     * @api
     * @example
     * chart.addData([10, 20], '6', 'line');
     */
    addData(data, category, chartType) {
        this.animationControlFlag.updating = true;
        this.resetSeries();
        this.store.dispatch('addData', { data, category, chartType });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number>} data.data - Array of data to be added.
     * @param {Object} dataInfo - Which type of chart to add.
     *   @param {Object} dataInfo.chartType - Chart type.
     * @api
     * @example
     * chart.addSeries(
     *   {
     *     name: 'newSeries',
     *     data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     *   },
     *   {
     *     chartType: 'line'
     *   });
     */
    addSeries(data, dataInfo) {
        this.resetSeries();
        this.store.dispatch('addSeries', Object.assign({ data }, dataInfo));
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: {
     *     line: [
     *       {
     *         name: 'A',
     *         data: [1, 2, 3],
     *       }
     *     ],
     *     area: [
     *       {
     *         name: 'B',
     *         data: [4, 5, 6],
     *       }
     *     ]
     *   }
     * });
     */
    setData(data) {
        this.resetSeries();
        this.store.dispatch('setData', data);
    }
    /**
     * Add plot line.
     * @param {Object} data - plot info
     *   @param {string|number} data.value - The value where the plot line will be drawn.
     *   @param {string} data.color - Plot line color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
     * @api
     * @example
     * chart.addPlotLine({
     *   value: 2,
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */
    addPlotLine(data) {
        this.store.dispatch('addPlotLine', { data });
    }
    /**
     * Remove plot line with id.
     * @param {string} id - Id of the plot line to be removed.
     * @api
     * @example
     * chart.removePlotLine('plot-1');
     */
    removePlotLine(id) {
        this.store.dispatch('removePlotLine', { id });
    }
    /**
     * Add plot band.
     * @param {Object} data - Plot info.
     * @param {Array<string|number>} data.range - The range to be drawn.
     * @param {string} data.color - Plot band color.
     * @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
     * @api
     * @example
     * chart.addPlotBand({
     *   value: [2, 4],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */
    addPlotBand(data) {
        this.store.dispatch('addPlotBand', { data });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - Id of the plot band to be removed.
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */
    removePlotBand(id) {
        this.store.dispatch('removePlotBand', { id });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */
    hideSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: false } } },
        });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */
    showSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: true } } },
        });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     line: {
     *       showDot: true
     *     },
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    setOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     line: {
     *       showDot: true,
     *     },
     *   },
     * });
     */
    updateOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     *      @param {string} seriesInfo.chartType - Specify which chart to select.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2, chartType: 'line'});
     */
    showTooltip(seriesInfo) {
        this.eventBus.emit('showTooltip', Object.assign({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */
    hideTooltip() {
        this.eventBus.emit('hideTooltip');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/lineChart.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/lineChart.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LineChart)
/* harmony export */ });
/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart */ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js");
/* harmony import */ var _store_dataRange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/dataRange */ "./node_modules/@toast-ui/chart/dist/esm/store/dataRange.js");
/* harmony import */ var _store_scale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/scale */ "./node_modules/@toast-ui/chart/dist/esm/store/scale.js");
/* harmony import */ var _store_axes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/axes */ "./node_modules/@toast-ui/chart/dist/esm/store/axes.js");
/* harmony import */ var _store_plot__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store/plot */ "./node_modules/@toast-ui/chart/dist/esm/store/plot.js");
/* harmony import */ var _component_tooltip__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../component/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js");
/* harmony import */ var _component_plot__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/plot */ "./node_modules/@toast-ui/chart/dist/esm/component/plot.js");
/* harmony import */ var _component_lineSeries__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/lineSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/lineSeries.js");
/* harmony import */ var _component_axis__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");
/* harmony import */ var _component_legend__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/legend */ "./node_modules/@toast-ui/chart/dist/esm/component/legend.js");
/* harmony import */ var _component_dataLabels__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/component/dataLabels.js");
/* harmony import */ var _component_axisTitle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../component/axisTitle */ "./node_modules/@toast-ui/chart/dist/esm/component/axisTitle.js");
/* harmony import */ var _component_title__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component/title */ "./node_modules/@toast-ui/chart/dist/esm/component/title.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _component_hoveredSeries__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../component/hoveredSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js");
/* harmony import */ var _component_rangeSelection__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../component/rangeSelection */ "./node_modules/@toast-ui/chart/dist/esm/component/rangeSelection.js");
/* harmony import */ var _component_resetButton__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../component/resetButton */ "./node_modules/@toast-ui/chart/dist/esm/component/resetButton.js");
/* harmony import */ var _component_selectedSeries__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../component/selectedSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js");
/* harmony import */ var _component_background__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../component/background */ "./node_modules/@toast-ui/chart/dist/esm/component/background.js");
/* harmony import */ var _component_noDataText__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../component/noDataText */ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js");
/* harmony import */ var _brushes_lineSeries__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../brushes/lineSeries */ "./node_modules/@toast-ui/chart/dist/esm/brushes/lineSeries.js");
/* harmony import */ var _brushes_basic__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../brushes/basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _brushes_axis__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../brushes/axis */ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../brushes/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js");
/* harmony import */ var _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../brushes/dataLabel */ "./node_modules/@toast-ui/chart/dist/esm/brushes/dataLabel.js");
/* harmony import */ var _brushes_resetButton__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../brushes/resetButton */ "./node_modules/@toast-ui/chart/dist/esm/brushes/resetButton.js");




























/**
 * @class
 * @classdesc Line Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Line Chart.
 *     @param {Array<string>} [props.data.categories] - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<number|Object|Array>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Line Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.showDot=false] - Whether to show dot or not.
 *       @param {boolean} [props.options.series.spline=false] - Whether to make spline chart or not.
 *       @param {boolean} [props.options.series.zoomable=false] - Whether to use zoom feature or not.
 *       @param {boolean} [props.options.series.rangeSelectable=false] - Whether to use range selection feature or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'near', 'nearest', 'grouped', 'point' is available.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *       @param {Array<Object>} [props.options.plot.lines] - Plot lines information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Line Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
class LineChart extends _chart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(props) {
        var _a;
        super({
            el: props.el,
            options: props.options,
            series: {
                line: props.data.series,
            },
            categories: (_a = props.data) === null || _a === void 0 ? void 0 : _a.categories,
            modules: [_store_dataRange__WEBPACK_IMPORTED_MODULE_1__["default"], _store_scale__WEBPACK_IMPORTED_MODULE_2__["default"], _store_axes__WEBPACK_IMPORTED_MODULE_3__["default"], _store_plot__WEBPACK_IMPORTED_MODULE_4__["default"]],
        });
    }
    initialize() {
        super.initialize();
        this.componentManager.add(_component_background__WEBPACK_IMPORTED_MODULE_5__["default"]);
        this.componentManager.add(_component_title__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.componentManager.add(_component_plot__WEBPACK_IMPORTED_MODULE_7__["default"]);
        this.componentManager.add(_component_legend__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.componentManager.add(_component_lineSeries__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_10__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_10__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_10__["default"], { name: 'secondaryYAxis' });
        this.componentManager.add(_component_dataLabels__WEBPACK_IMPORTED_MODULE_11__["default"]);
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_12__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_12__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_12__["default"], { name: 'secondaryYAxis' });
        this.componentManager.add(_component_exportMenu__WEBPACK_IMPORTED_MODULE_13__["default"], { chartEl: this.el });
        this.componentManager.add(_component_hoveredSeries__WEBPACK_IMPORTED_MODULE_14__["default"]);
        this.componentManager.add(_component_selectedSeries__WEBPACK_IMPORTED_MODULE_15__["default"]);
        this.componentManager.add(_component_tooltip__WEBPACK_IMPORTED_MODULE_16__["default"], { chartEl: this.el });
        this.componentManager.add(_component_rangeSelection__WEBPACK_IMPORTED_MODULE_17__["default"]);
        this.componentManager.add(_component_resetButton__WEBPACK_IMPORTED_MODULE_18__["default"]);
        this.componentManager.add(_component_noDataText__WEBPACK_IMPORTED_MODULE_19__["default"]);
        this.painter.addGroups([
            _brushes_basic__WEBPACK_IMPORTED_MODULE_20__,
            _brushes_axis__WEBPACK_IMPORTED_MODULE_21__,
            _brushes_lineSeries__WEBPACK_IMPORTED_MODULE_22__,
            _brushes_legend__WEBPACK_IMPORTED_MODULE_23__,
            _brushes_label__WEBPACK_IMPORTED_MODULE_24__,
            _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_25__,
            _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_26__,
            _brushes_resetButton__WEBPACK_IMPORTED_MODULE_27__,
        ]);
    }
    /**
     * Add data.
     * @param {Array<number|Object|Array>} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */
    addData(data, category) {
        var _a;
        if ((_a = this.store.state.options.series) === null || _a === void 0 ? void 0 : _a.showDot) {
            this.animationControlFlag.updating = true;
        }
        this.resetSeries();
        this.store.dispatch('addData', { data, category });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number|Object|Array>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */
    addSeries(data) {
        this.resetSeries();
        this.store.dispatch('addSeries', { data });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */
    setData(data) {
        const { categories, series } = data;
        this.resetSeries();
        this.store.dispatch('setData', { series: { line: series }, categories });
    }
    /**
     * Add plot line.
     * @param {Object} data - Plot info.
     *    @param {string|number} data.value - The value where the plot line will be drawn.
     *    @param {string} data.color - Plot line color.
     *    @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
     * @api
     * @example
     * chart.addPlotLine({
     *   value: 2,
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */
    addPlotLine(data) {
        this.store.dispatch('addPlotLine', { data });
    }
    /**
     * Remove plot line with id.
     * @param {string} id - Id of the plot line to be removed.
     * @api
     * @example
     * chart.removePlotLine('plot-1');
     */
    removePlotLine(id) {
        this.store.dispatch('removePlotLine', { id });
    }
    /**
     * Add plot band.
     * @param {Object} data - Plot info.
     *   @param {Array<string|number>} data.range - The range to be drawn.
     *   @param {string} data.color - Plot band color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
     * @api
     * @example
     * chart.addPlotBand({
     *   value: [2, 4],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */
    addPlotBand(data) {
        this.store.dispatch('addPlotBand', { data });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - id of the plot band to be removed
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */
    removePlotBand(id) {
        this.store.dispatch('removePlotBand', { id });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */
    hideSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: false } } },
        });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */
    showSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: true } } },
        });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    setOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    updateOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
     *      @param {number} [seriesInfo.seriesIndex] - Index of series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */
    showTooltip(seriesInfo) {
        this.eventBus.emit('showTooltip', Object.assign({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */
    hideTooltip() {
        this.eventBus.emit('hideTooltip');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/lineScatterChart.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/lineScatterChart.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LineScatterChart)
/* harmony export */ });
/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart */ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js");
/* harmony import */ var _store_dataRange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/dataRange */ "./node_modules/@toast-ui/chart/dist/esm/store/dataRange.js");
/* harmony import */ var _store_scale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/scale */ "./node_modules/@toast-ui/chart/dist/esm/store/scale.js");
/* harmony import */ var _store_axes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/axes */ "./node_modules/@toast-ui/chart/dist/esm/store/axes.js");
/* harmony import */ var _store_plot__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store/plot */ "./node_modules/@toast-ui/chart/dist/esm/store/plot.js");
/* harmony import */ var _component_tooltip__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../component/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js");
/* harmony import */ var _component_plot__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/plot */ "./node_modules/@toast-ui/chart/dist/esm/component/plot.js");
/* harmony import */ var _component_lineSeries__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/lineSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/lineSeries.js");
/* harmony import */ var _component_scatterSeries__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/scatterSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/scatterSeries.js");
/* harmony import */ var _component_axis__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component/axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");
/* harmony import */ var _component_legend__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/legend */ "./node_modules/@toast-ui/chart/dist/esm/component/legend.js");
/* harmony import */ var _component_dataLabels__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../component/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/component/dataLabels.js");
/* harmony import */ var _component_axisTitle__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../component/axisTitle */ "./node_modules/@toast-ui/chart/dist/esm/component/axisTitle.js");
/* harmony import */ var _component_title__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component/title */ "./node_modules/@toast-ui/chart/dist/esm/component/title.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _component_selectedSeries__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../component/selectedSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js");
/* harmony import */ var _component_hoveredSeries__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../component/hoveredSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js");
/* harmony import */ var _component_rangeSelection__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../component/rangeSelection */ "./node_modules/@toast-ui/chart/dist/esm/component/rangeSelection.js");
/* harmony import */ var _component_background__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../component/background */ "./node_modules/@toast-ui/chart/dist/esm/component/background.js");
/* harmony import */ var _component_noDataText__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../component/noDataText */ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js");
/* harmony import */ var _brushes_lineSeries__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../brushes/lineSeries */ "./node_modules/@toast-ui/chart/dist/esm/brushes/lineSeries.js");
/* harmony import */ var _brushes_basic__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../brushes/basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _brushes_axis__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../brushes/axis */ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../brushes/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js");
/* harmony import */ var _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../brushes/dataLabel */ "./node_modules/@toast-ui/chart/dist/esm/brushes/dataLabel.js");
/* harmony import */ var _brushes_resetButton__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../brushes/resetButton */ "./node_modules/@toast-ui/chart/dist/esm/brushes/resetButton.js");
/* harmony import */ var _brushes_scatterSeries__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../brushes/scatterSeries */ "./node_modules/@toast-ui/chart/dist/esm/brushes/scatterSeries.js");





























/**
 * @class
 * @classdesc LineScatter Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making LineArea Chart.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {Array<Object>} props.data.series.line - Line series data. Only coordinate type data is possible.
 *       @param {Array<Object>} props.data.series.scatter - Scatter series data.
 *   @param {Object} [props.options] - Options for making LineScatter Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series] - Write common options in the upper depth and separate options to be applied to each chart.
 *       @param {Object} [props.options.series.line] - Options to be applied to the line chart. 'spline', 'showDot' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Line Chart guide} on github.
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|LineScatter Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme. Each theme to be applied to the two charts should be written separately.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
class LineScatterChart extends _chart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(props) {
        super({
            el: props.el,
            options: props.options,
            series: props.data.series,
            modules: [_store_dataRange__WEBPACK_IMPORTED_MODULE_1__["default"], _store_scale__WEBPACK_IMPORTED_MODULE_2__["default"], _store_axes__WEBPACK_IMPORTED_MODULE_3__["default"], _store_plot__WEBPACK_IMPORTED_MODULE_4__["default"]],
        });
    }
    initialize() {
        super.initialize();
        this.componentManager.add(_component_background__WEBPACK_IMPORTED_MODULE_5__["default"]);
        this.componentManager.add(_component_title__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.componentManager.add(_component_plot__WEBPACK_IMPORTED_MODULE_7__["default"]);
        this.componentManager.add(_component_legend__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.componentManager.add(_component_lineSeries__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.componentManager.add(_component_scatterSeries__WEBPACK_IMPORTED_MODULE_10__["default"]);
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_11__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_11__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_11__["default"], { name: 'secondaryYAxis' });
        this.componentManager.add(_component_dataLabels__WEBPACK_IMPORTED_MODULE_12__["default"]);
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_13__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_13__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_13__["default"], { name: 'secondaryYAxis' });
        this.componentManager.add(_component_exportMenu__WEBPACK_IMPORTED_MODULE_14__["default"], { chartEl: this.el });
        this.componentManager.add(_component_hoveredSeries__WEBPACK_IMPORTED_MODULE_15__["default"]);
        this.componentManager.add(_component_selectedSeries__WEBPACK_IMPORTED_MODULE_16__["default"]);
        this.componentManager.add(_component_tooltip__WEBPACK_IMPORTED_MODULE_17__["default"], { chartEl: this.el });
        this.componentManager.add(_component_rangeSelection__WEBPACK_IMPORTED_MODULE_18__["default"]);
        this.componentManager.add(_component_noDataText__WEBPACK_IMPORTED_MODULE_19__["default"]);
        this.painter.addGroups([
            _brushes_basic__WEBPACK_IMPORTED_MODULE_20__,
            _brushes_axis__WEBPACK_IMPORTED_MODULE_21__,
            _brushes_lineSeries__WEBPACK_IMPORTED_MODULE_22__,
            _brushes_legend__WEBPACK_IMPORTED_MODULE_23__,
            _brushes_label__WEBPACK_IMPORTED_MODULE_24__,
            _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_25__,
            _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_26__,
            _brushes_resetButton__WEBPACK_IMPORTED_MODULE_27__,
            _brushes_scatterSeries__WEBPACK_IMPORTED_MODULE_28__,
        ]);
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} chartType - Which type of chart to add.
     * @api
     * @example
     * chart.addData([{x: 10, y: 20}, {x: 30, y: 40}], 'line');
     */
    addData(data, chartType) {
        this.animationControlFlag.updating = true;
        this.resetSeries();
        this.store.dispatch('addData', { data, chartType });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @param {Object} dataInfo - Which type of chart to add.
     *   @param {Object} dataInfo.chartType - Chart type.
     * @api
     * @example
     * chart.addSeries(
     *   {
     *     name: 'newSeries',
     *     data: [{x: 10, y: 20}, {x: 30, y: 40}],
     *   },
     *   {
     *     chartType: 'line'
     *   });
     */
    addSeries(data, dataInfo) {
        this.resetSeries();
        this.store.dispatch('addSeries', Object.assign({ data }, dataInfo));
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   series: {
     *     line: [
     *       {
     *         name: 'A',
     *         data: [{x: 10, y: 20}, {x: 30, y: 40}],
     *       }
     *     ],
     *     scatter: [
     *       {
     *         name: 'B',
     *         data: [{x: 30, y: 20}, {x: 40, y: 40}],
     *       }
     *     ]
     *   }
     * });
     */
    setData(data) {
        this.resetSeries();
        this.store.dispatch('setData', data);
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     line: {
     *       showDot: true,
     *     },
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    setOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     line: {
     *       showDot: true,
     *     },
     *   },
     * });
     */
    updateOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed
     *      @param {number} seriesInfo.seriesIndex - Index of series
     *      @param {number} seriesInfo.index - Index of data within series
     *      @param {string} seriesInfo.chartType - Specify which chart to select.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2, chartType: 'scatter'});
     */
    showTooltip(seriesInfo) {
        this.eventBus.emit('showTooltip', Object.assign(Object.assign({}, seriesInfo), { state: this.store.state }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */
    hideTooltip() {
        this.eventBus.emit('hideTooltip');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/nestedPieChart.js":
/*!************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/nestedPieChart.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ NestedPieChart)
/* harmony export */ });
/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart */ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js");
/* harmony import */ var _store_nestedPieSeriesData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/nestedPieSeriesData */ "./node_modules/@toast-ui/chart/dist/esm/store/nestedPieSeriesData.js");
/* harmony import */ var _component_tooltip__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js");
/* harmony import */ var _component_legend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../component/legend */ "./node_modules/@toast-ui/chart/dist/esm/component/legend.js");
/* harmony import */ var _component_title__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component/title */ "./node_modules/@toast-ui/chart/dist/esm/component/title.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _component_hoveredSeries__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/hoveredSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js");
/* harmony import */ var _component_dataLabels__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/component/dataLabels.js");
/* harmony import */ var _component_selectedSeries__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/selectedSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js");
/* harmony import */ var _component_background__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../component/background */ "./node_modules/@toast-ui/chart/dist/esm/component/background.js");
/* harmony import */ var _component_pieSeries__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../component/pieSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/pieSeries.js");
/* harmony import */ var _component_noDataText__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component/noDataText */ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js");
/* harmony import */ var _brushes_basic__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../brushes/basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../brushes/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js");
/* harmony import */ var _brushes_sector__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../brushes/sector */ "./node_modules/@toast-ui/chart/dist/esm/brushes/sector.js");
/* harmony import */ var _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../brushes/dataLabel */ "./node_modules/@toast-ui/chart/dist/esm/brushes/dataLabel.js");


















/**
 * @class
 * @classdesc NestedPie Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making NestedPie Chart.
 *     @param {Array<string>} [props.data.categories] - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {number} props.data.series.data - Series data.
 *       @param {string} [props.data.series.parentName] - Value specifying parent data when using group nested pie chart.
 *   @param {Object} [props.options] - Options for making NestedPie Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {Object} [props.options.series.aliasName] - Chart options are specified based on the alias name. 'radiusRange', 'angleRange', 'clockwise', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|NestedPie Chart guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|NestedPie Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
class NestedPieChart extends _chart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ el, options, data: { series, categories } }) {
        super({
            el,
            options,
            series: { pie: series },
            categories,
            modules: [_store_nestedPieSeriesData__WEBPACK_IMPORTED_MODULE_1__["default"]],
        });
    }
    initialize() {
        var _a;
        super.initialize();
        this.componentManager.add(_component_background__WEBPACK_IMPORTED_MODULE_2__["default"]);
        this.componentManager.add(_component_title__WEBPACK_IMPORTED_MODULE_3__["default"]);
        this.componentManager.add(_component_legend__WEBPACK_IMPORTED_MODULE_4__["default"]);
        (_a = this.store.initStoreState.series.pie, (_a !== null && _a !== void 0 ? _a : [])).forEach(({ name }) => {
            this.componentManager.add(_component_pieSeries__WEBPACK_IMPORTED_MODULE_5__["default"], { alias: name });
        });
        this.componentManager.add(_component_exportMenu__WEBPACK_IMPORTED_MODULE_6__["default"], { chartEl: this.el });
        this.componentManager.add(_component_hoveredSeries__WEBPACK_IMPORTED_MODULE_7__["default"]);
        this.componentManager.add(_component_selectedSeries__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.componentManager.add(_component_dataLabels__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.componentManager.add(_component_tooltip__WEBPACK_IMPORTED_MODULE_10__["default"], { chartEl: this.el });
        this.componentManager.add(_component_noDataText__WEBPACK_IMPORTED_MODULE_11__["default"]);
        this.painter.addGroups([
            _brushes_basic__WEBPACK_IMPORTED_MODULE_12__,
            _brushes_legend__WEBPACK_IMPORTED_MODULE_13__,
            _brushes_label__WEBPACK_IMPORTED_MODULE_14__,
            _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_15__,
            _brushes_sector__WEBPACK_IMPORTED_MODULE_16__,
            _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_17__,
        ]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @param {Object} dataInfo - Which name of chart to add.
     *   @param {string} dataInfo.name - Chart series name.
     * @api
     * @example
     * chart.addSeries(
     *   {
     *     name: 'newSeries',
     *     data: [
     *       { name: 'A', data: 10 },
     *       { name: 'B', data: 20 },
     *     ],
     *   },
     *   {
     *     name: 'series name'
     *   });
     */
    addSeries(data, dataInfo) {
        this.resetSeries();
        this.store.dispatch('addSeries', Object.assign({ data }, dataInfo));
        this.componentManager.add(_component_pieSeries__WEBPACK_IMPORTED_MODULE_5__["default"], { alias: data.name });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['A', 'B'],
     *   series: [
     *     {
     *       name: 'browsers',
     *       data: [
     *         {
     *           name: 'Chrome',
     *           data: 50,
     *         },
     *         {
     *           name: 'Safari',
     *           data: 20,
     *         },
     *       ]
     *     },
     *     {
     *       name: 'versions',
     *       data: [
     *         {
     *           name: '1',
     *           data: 50,
     *         },
     *         {
     *           name: '2',
     *           data: 20,
     *         },
     *       ]
     *     }
     *   ]
     * });
     */
    setData(data) {
        var _a;
        this.componentManager.remove(_component_pieSeries__WEBPACK_IMPORTED_MODULE_5__["default"]);
        this.resetSeries();
        this.store.dispatch('setData', { series: { pie: data.series } });
        (_a = this.store.initStoreState.series.pie, (_a !== null && _a !== void 0 ? _a : [])).forEach(({ name }) => {
            this.componentManager.add(_component_pieSeries__WEBPACK_IMPORTED_MODULE_5__["default"], { alias: name });
        });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */
    hideSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: false } } },
        });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */
    showSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: true } } },
        });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     alias2: {
     *       radiusRange: [20%, 50%],
     *     },
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    setOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     alias1: {
     *       showDot: true,
     *     },
     *   },
     * });
     */
    updateOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.alias - alias name.
     * @api
     * @example
     * chart.showTooltip({seriesIndex: 1, alias: 'name'});
     */
    showTooltip(seriesInfo) {
        this.eventBus.emit('showTooltip', Object.assign({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */
    hideTooltip() {
        this.eventBus.emit('hideTooltip');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/pieChart.js":
/*!******************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/pieChart.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PieChart)
/* harmony export */ });
/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart */ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js");
/* harmony import */ var _component_tooltip__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js");
/* harmony import */ var _component_legend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component/legend */ "./node_modules/@toast-ui/chart/dist/esm/component/legend.js");
/* harmony import */ var _component_pieSeries__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../component/pieSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/pieSeries.js");
/* harmony import */ var _component_title__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../component/title */ "./node_modules/@toast-ui/chart/dist/esm/component/title.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _component_hoveredSeries__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component/hoveredSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js");
/* harmony import */ var _component_dataLabels__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/component/dataLabels.js");
/* harmony import */ var _component_selectedSeries__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/selectedSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js");
/* harmony import */ var _component_background__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/background */ "./node_modules/@toast-ui/chart/dist/esm/component/background.js");
/* harmony import */ var _component_noDataText__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/noDataText */ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js");
/* harmony import */ var _brushes_basic__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../brushes/basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../brushes/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js");
/* harmony import */ var _brushes_sector__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../brushes/sector */ "./node_modules/@toast-ui/chart/dist/esm/brushes/sector.js");
/* harmony import */ var _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../brushes/dataLabel */ "./node_modules/@toast-ui/chart/dist/esm/brushes/dataLabel.js");

















/**
 * @class
 * @classdesc Pie Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Pie Chart.
 *     @param {Array<string>} [props.data.categories] - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {number} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Pie Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {Array<number>|Array<string>} [props.options.series.radiusRange] - Specifies the radius of the circle drawn. It is specified by entering a number or percent string value in start and end.
 *       @param {Array<number>} [props.options.series.angleRange] - The range of angles to which the circle will be drawn. It is specified by putting number in start and end.
 *       @param {boolean} [props.options.series.clockwise] - Whether it will be drawn clockwise.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Pie Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
class PieChart extends _chart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ el, options, data }) {
        super({
            el,
            options,
            series: {
                pie: data.series,
            },
            categories: data.categories,
        });
    }
    initialize() {
        super.initialize();
        this.componentManager.add(_component_background__WEBPACK_IMPORTED_MODULE_1__["default"]);
        this.componentManager.add(_component_title__WEBPACK_IMPORTED_MODULE_2__["default"]);
        this.componentManager.add(_component_legend__WEBPACK_IMPORTED_MODULE_3__["default"]);
        this.componentManager.add(_component_pieSeries__WEBPACK_IMPORTED_MODULE_4__["default"]);
        this.componentManager.add(_component_exportMenu__WEBPACK_IMPORTED_MODULE_5__["default"], { chartEl: this.el });
        this.componentManager.add(_component_hoveredSeries__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.componentManager.add(_component_selectedSeries__WEBPACK_IMPORTED_MODULE_7__["default"]);
        this.componentManager.add(_component_dataLabels__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.componentManager.add(_component_tooltip__WEBPACK_IMPORTED_MODULE_9__["default"], { chartEl: this.el });
        this.componentManager.add(_component_noDataText__WEBPACK_IMPORTED_MODULE_10__["default"]);
        this.painter.addGroups([
            _brushes_basic__WEBPACK_IMPORTED_MODULE_11__,
            _brushes_legend__WEBPACK_IMPORTED_MODULE_12__,
            _brushes_label__WEBPACK_IMPORTED_MODULE_13__,
            _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_14__,
            _brushes_sector__WEBPACK_IMPORTED_MODULE_15__,
            _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_16__,
        ]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: 10,
     * });
     */
    addSeries(data) {
        this.resetSeries();
        this.store.dispatch('addSeries', { data });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['A'],
     *   series: [
     *     {name: 'a', data: 10},
     *     {name: 'b', data: 20},
     *   ]
     * });
     */
    setData(data) {
        const { categories, series } = data;
        this.resetSeries();
        this.store.dispatch('setData', { series: { pie: series }, categories });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */
    hideSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: false } } },
        });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */
    showSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: true } } },
        });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    setOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    updateOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.alias - alias name.
     * @api
     * @example
     * chart.showTooltip({seriesIndex: 1, alias: 'name'});
     */
    showTooltip(seriesInfo) {
        this.eventBus.emit('showTooltip', Object.assign(Object.assign({}, seriesInfo), { state: this.store.state }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */
    hideTooltip() {
        this.eventBus.emit('hideTooltip');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/radarChart.js":
/*!********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/radarChart.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RadarChart)
/* harmony export */ });
/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart */ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js");
/* harmony import */ var _store_dataRange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/dataRange */ "./node_modules/@toast-ui/chart/dist/esm/store/dataRange.js");
/* harmony import */ var _store_scale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/scale */ "./node_modules/@toast-ui/chart/dist/esm/store/scale.js");
/* harmony import */ var _store_radialAxes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/radialAxes */ "./node_modules/@toast-ui/chart/dist/esm/store/radialAxes.js");
/* harmony import */ var _component_legend__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component/legend */ "./node_modules/@toast-ui/chart/dist/esm/component/legend.js");
/* harmony import */ var _component_radarSeries__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/radarSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/radarSeries.js");
/* harmony import */ var _component_radialPlot__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/radialPlot */ "./node_modules/@toast-ui/chart/dist/esm/component/radialPlot.js");
/* harmony import */ var _component_title__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../component/title */ "./node_modules/@toast-ui/chart/dist/esm/component/title.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _component_selectedSeries__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../component/selectedSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js");
/* harmony import */ var _component_hoveredSeries__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component/hoveredSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js");
/* harmony import */ var _component_tooltip__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../component/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js");
/* harmony import */ var _component_radialAxis__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/radialAxis */ "./node_modules/@toast-ui/chart/dist/esm/component/radialAxis.js");
/* harmony import */ var _component_background__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../component/background */ "./node_modules/@toast-ui/chart/dist/esm/component/background.js");
/* harmony import */ var _component_noDataText__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../component/noDataText */ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js");
/* harmony import */ var _brushes_basic__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../brushes/basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../brushes/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js");
/* harmony import */ var _brushes_polygon__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../brushes/polygon */ "./node_modules/@toast-ui/chart/dist/esm/brushes/polygon.js");
/* harmony import */ var _brushes_axis__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../brushes/axis */ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js");
/* harmony import */ var _brushes_lineSeries__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../brushes/lineSeries */ "./node_modules/@toast-ui/chart/dist/esm/brushes/lineSeries.js");






















/**
 * @class
 * @classdesc Radar Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Radar Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<number>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Radar Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.showDot=false] - Whether to show dot or not.
 *       @param {boolean} [props.options.series.showArea=false] - Whether to fill area or not.
 *     @param {Object} [props.options.circularAxis]
 *       @param {Object} [props.options.circularAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.circularAxis.label] - Option to adjust label interval.
 *     @param {Object} [props.options.verticalAxis]
 *       @param {Object} [props.options.verticalAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.verticalAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.verticalAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.type] - Radar plot type. 'spiderweb', 'circle' is available.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Radar Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.circularAxis] - Circular Axis theme.
 *       @param {Object} [props.options.theme.verticalAxis] - Vertical Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
class RadarChart extends _chart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ el, options, data }) {
        super({
            el,
            options,
            series: {
                radar: data.series,
            },
            categories: data.categories,
            modules: [_store_dataRange__WEBPACK_IMPORTED_MODULE_1__["default"], _store_scale__WEBPACK_IMPORTED_MODULE_2__["default"], _store_radialAxes__WEBPACK_IMPORTED_MODULE_3__["default"]],
        });
    }
    initialize() {
        super.initialize();
        this.componentManager.add(_component_background__WEBPACK_IMPORTED_MODULE_4__["default"]);
        this.componentManager.add(_component_title__WEBPACK_IMPORTED_MODULE_5__["default"]);
        this.componentManager.add(_component_legend__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.componentManager.add(_component_radialPlot__WEBPACK_IMPORTED_MODULE_7__["default"]);
        this.componentManager.add(_component_radialAxis__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.componentManager.add(_component_radarSeries__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.componentManager.add(_component_exportMenu__WEBPACK_IMPORTED_MODULE_10__["default"], { chartEl: this.el });
        this.componentManager.add(_component_hoveredSeries__WEBPACK_IMPORTED_MODULE_11__["default"]);
        this.componentManager.add(_component_selectedSeries__WEBPACK_IMPORTED_MODULE_12__["default"]);
        this.componentManager.add(_component_tooltip__WEBPACK_IMPORTED_MODULE_13__["default"], { chartEl: this.el });
        this.componentManager.add(_component_noDataText__WEBPACK_IMPORTED_MODULE_14__["default"]);
        this.painter.addGroups([
            _brushes_basic__WEBPACK_IMPORTED_MODULE_15__,
            _brushes_legend__WEBPACK_IMPORTED_MODULE_16__,
            _brushes_label__WEBPACK_IMPORTED_MODULE_17__,
            _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_18__,
            _brushes_polygon__WEBPACK_IMPORTED_MODULE_19__,
            _brushes_axis__WEBPACK_IMPORTED_MODULE_20__,
            _brushes_lineSeries__WEBPACK_IMPORTED_MODULE_21__,
        ]);
    }
    /**
     * Add data.
     * @param {Array<number>} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */
    addData(data, category) {
        this.animationControlFlag.updating = true;
        this.resetSeries();
        this.store.dispatch('addData', { data, category });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */
    addSeries(data) {
        this.resetSeries();
        this.store.dispatch('addSeries', { data });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */
    setData(data) {
        const { categories, series } = data;
        this.resetSeries();
        this.store.dispatch('setData', { series: { radar: series }, categories });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    setOptions(options) {
        this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    updateOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */
    showTooltip(seriesInfo) {
        this.eventBus.emit('showTooltip', Object.assign(Object.assign({}, seriesInfo), { state: this.store.state }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */
    hideTooltip() {
        this.eventBus.emit('hideTooltip');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/radialBarChart.js":
/*!************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/radialBarChart.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RadialBarChart)
/* harmony export */ });
/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart */ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js");
/* harmony import */ var _store_dataRange__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/dataRange */ "./node_modules/@toast-ui/chart/dist/esm/store/dataRange.js");
/* harmony import */ var _store_stackSeriesData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/stackSeriesData */ "./node_modules/@toast-ui/chart/dist/esm/store/stackSeriesData.js");
/* harmony import */ var _store_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/scale */ "./node_modules/@toast-ui/chart/dist/esm/store/scale.js");
/* harmony import */ var _store_radialAxes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store/radialAxes */ "./node_modules/@toast-ui/chart/dist/esm/store/radialAxes.js");
/* harmony import */ var _component_tooltip__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../component/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js");
/* harmony import */ var _component_legend__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/legend */ "./node_modules/@toast-ui/chart/dist/esm/component/legend.js");
/* harmony import */ var _component_radialBarSeries__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/radialBarSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/radialBarSeries.js");
/* harmony import */ var _component_title__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component/title */ "./node_modules/@toast-ui/chart/dist/esm/component/title.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _component_hoveredSeries__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/hoveredSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js");
/* harmony import */ var _component_dataLabels__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../component/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/component/dataLabels.js");
/* harmony import */ var _component_selectedSeries__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component/selectedSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js");
/* harmony import */ var _component_background__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../component/background */ "./node_modules/@toast-ui/chart/dist/esm/component/background.js");
/* harmony import */ var _component_radialPlot__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/radialPlot */ "./node_modules/@toast-ui/chart/dist/esm/component/radialPlot.js");
/* harmony import */ var _component_radialAxis__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../component/radialAxis */ "./node_modules/@toast-ui/chart/dist/esm/component/radialAxis.js");
/* harmony import */ var _component_noDataText__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../component/noDataText */ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js");
/* harmony import */ var _brushes_basic__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../brushes/basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../brushes/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js");
/* harmony import */ var _brushes_sector__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../brushes/sector */ "./node_modules/@toast-ui/chart/dist/esm/brushes/sector.js");
/* harmony import */ var _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../brushes/dataLabel */ "./node_modules/@toast-ui/chart/dist/esm/brushes/dataLabel.js");
/* harmony import */ var _brushes_axis__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../brushes/axis */ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js");
























/**
 * @class
 * @classdesc RadialBar Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making RadialBar Chart.
 *     @param {Array<string>} [props.data.categories] - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {number} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making RadialBar Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'grouped', 'point' is available.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {Array<number>|Array<string>} [props.options.series.radiusRange] - Specifies the radius of the circle drawn. It is specified by entering a number or percent string value in start and end.
 *       @param {Array<number>} [props.options.series.angleRange] - The range of angles to which the circle will be drawn. It is specified by putting number in start and end.
 *       @param {boolean} [props.options.series.clockwise] - Whether it will be drawn clockwise.
 *     @param {Object} [props.options.circularAxis]
 *       @param {Object} [props.options.circularAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.circularAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.circularAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *     @param {Object} [props.options.verticalAxis]
 *       @param {Object} [props.options.verticalAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.verticalAxis.label] - Option to adjust label interval.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|RadialBar Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.circularAxis] - Circular Axis theme.
 *       @param {Object} [props.options.theme.verticalAxis] - Vertical Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
class RadialBarChart extends _chart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ el, options, data }) {
        super({
            el,
            options,
            series: {
                radialBar: data.series,
            },
            categories: data.categories,
            modules: [_store_stackSeriesData__WEBPACK_IMPORTED_MODULE_1__["default"], _store_dataRange__WEBPACK_IMPORTED_MODULE_2__["default"], _store_scale__WEBPACK_IMPORTED_MODULE_3__["default"], _store_radialAxes__WEBPACK_IMPORTED_MODULE_4__["default"]],
        });
    }
    initialize() {
        super.initialize();
        this.componentManager.add(_component_background__WEBPACK_IMPORTED_MODULE_5__["default"]);
        this.componentManager.add(_component_title__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.componentManager.add(_component_legend__WEBPACK_IMPORTED_MODULE_7__["default"]);
        this.componentManager.add(_component_radialPlot__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.componentManager.add(_component_radialBarSeries__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.componentManager.add(_component_hoveredSeries__WEBPACK_IMPORTED_MODULE_10__["default"]);
        this.componentManager.add(_component_selectedSeries__WEBPACK_IMPORTED_MODULE_11__["default"]);
        this.componentManager.add(_component_dataLabels__WEBPACK_IMPORTED_MODULE_12__["default"]);
        this.componentManager.add(_component_radialAxis__WEBPACK_IMPORTED_MODULE_13__["default"]);
        this.componentManager.add(_component_exportMenu__WEBPACK_IMPORTED_MODULE_14__["default"], { chartEl: this.el });
        this.componentManager.add(_component_tooltip__WEBPACK_IMPORTED_MODULE_15__["default"], { chartEl: this.el });
        this.componentManager.add(_component_noDataText__WEBPACK_IMPORTED_MODULE_16__["default"]);
        this.painter.addGroups([
            _brushes_basic__WEBPACK_IMPORTED_MODULE_17__,
            _brushes_legend__WEBPACK_IMPORTED_MODULE_18__,
            _brushes_label__WEBPACK_IMPORTED_MODULE_19__,
            _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_20__,
            _brushes_sector__WEBPACK_IMPORTED_MODULE_21__,
            _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_22__,
            _brushes_axis__WEBPACK_IMPORTED_MODULE_23__,
        ]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 20, 30, 40],
     * });
     */
    addSeries(data) {
        this.resetSeries();
        this.store.dispatch('addSeries', { data });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */
    setData(data) {
        const { categories, series } = data;
        this.resetSeries();
        this.store.dispatch('setData', { series: { radialBar: series }, categories });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */
    hideSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: false } } },
        });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */
    showSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: true } } },
        });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 500,
     *     title: 'Olympic Medals',
     *   },
     *   series: {
     *     selectable: true
     *   }
     * });
     */
    setOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     title: 'Olympic Medals',
     *   },
     *   series: {
     *     eventDetectType: 'grouped'
     *   }
     * });
     */
    updateOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only index is needed.
     *      @param {number} [seriesInfo.seriesIndex] - Index of series
     * @api
     * @example
     * // eventDetectType is 'grouped'
     * chart.showTooltip({index: 1});
     *
     * // eventDetectType is 'point'
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */
    showTooltip(seriesInfo) {
        this.eventBus.emit('showTooltip', Object.assign(Object.assign({}, seriesInfo), { state: this.store.state }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */
    hideTooltip() {
        this.eventBus.emit('hideTooltip');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/scatterChart.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/scatterChart.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ScatterChart)
/* harmony export */ });
/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chart */ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js");
/* harmony import */ var _store_dataRange__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/dataRange */ "./node_modules/@toast-ui/chart/dist/esm/store/dataRange.js");
/* harmony import */ var _store_scale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store/scale */ "./node_modules/@toast-ui/chart/dist/esm/store/scale.js");
/* harmony import */ var _store_axes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../store/axes */ "./node_modules/@toast-ui/chart/dist/esm/store/axes.js");
/* harmony import */ var _store_plot__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../store/plot */ "./node_modules/@toast-ui/chart/dist/esm/store/plot.js");
/* harmony import */ var _component_tooltip__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../component/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js");
/* harmony import */ var _component_plot__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/plot */ "./node_modules/@toast-ui/chart/dist/esm/component/plot.js");
/* harmony import */ var _component_scatterSeries__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component/scatterSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/scatterSeries.js");
/* harmony import */ var _component_axis__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../component/axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");
/* harmony import */ var _component_legend__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/legend */ "./node_modules/@toast-ui/chart/dist/esm/component/legend.js");
/* harmony import */ var _component_title__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/title */ "./node_modules/@toast-ui/chart/dist/esm/component/title.js");
/* harmony import */ var _component_axisTitle__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../component/axisTitle */ "./node_modules/@toast-ui/chart/dist/esm/component/axisTitle.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _component_hoveredSeries__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../component/hoveredSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js");
/* harmony import */ var _component_selectedSeries__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../component/selectedSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js");
/* harmony import */ var _component_background__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/background */ "./node_modules/@toast-ui/chart/dist/esm/component/background.js");
/* harmony import */ var _component_noDataText__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../component/noDataText */ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js");
/* harmony import */ var _brushes_basic__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../brushes/basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _brushes_axis__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../brushes/axis */ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../brushes/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js");
/* harmony import */ var _brushes_scatterSeries__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../brushes/scatterSeries */ "./node_modules/@toast-ui/chart/dist/esm/brushes/scatterSeries.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_coordinate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/coordinate */ "./node_modules/@toast-ui/chart/dist/esm/helpers/coordinate.js");

























function clearUnnecessaryData(scatterSeries) {
    return scatterSeries.map((series) => {
        const exist = {};
        return Object.assign(Object.assign({}, series), { data: series.data
                .filter((datum) => !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNull)(datum))
                .reduce((acc, cur) => {
                const x = (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_1__.getCoordinateXValue)(cur);
                const y = (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_1__.getCoordinateYValue)(cur);
                const key = `${x}-${y}`;
                if (!exist[key]) {
                    exist[key] = true;
                    return [...acc, cur];
                }
                return acc;
            }, []) });
    });
}
/**
 * @class
 * @classdesc Scatter Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Scatter Chart.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<Object|Array<number>>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Scatter Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object} [props.options.yAxis]
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Scattter Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
class ScatterChart extends _chart__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(props) {
        var _a;
        super({
            el: props.el,
            options: props.options,
            series: {
                scatter: clearUnnecessaryData(props.data.series),
            },
            categories: (_a = props.data) === null || _a === void 0 ? void 0 : _a.categories,
            modules: [_store_dataRange__WEBPACK_IMPORTED_MODULE_3__["default"], _store_scale__WEBPACK_IMPORTED_MODULE_4__["default"], _store_axes__WEBPACK_IMPORTED_MODULE_5__["default"], _store_plot__WEBPACK_IMPORTED_MODULE_6__["default"]],
        });
    }
    initialize() {
        super.initialize();
        this.componentManager.add(_component_background__WEBPACK_IMPORTED_MODULE_7__["default"]);
        this.componentManager.add(_component_title__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.componentManager.add(_component_plot__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.componentManager.add(_component_legend__WEBPACK_IMPORTED_MODULE_10__["default"]);
        this.componentManager.add(_component_scatterSeries__WEBPACK_IMPORTED_MODULE_11__["default"]);
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_12__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axis__WEBPACK_IMPORTED_MODULE_12__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_13__["default"], { name: 'xAxis' });
        this.componentManager.add(_component_axisTitle__WEBPACK_IMPORTED_MODULE_13__["default"], { name: 'yAxis' });
        this.componentManager.add(_component_exportMenu__WEBPACK_IMPORTED_MODULE_14__["default"], { chartEl: this.el });
        this.componentManager.add(_component_hoveredSeries__WEBPACK_IMPORTED_MODULE_15__["default"]);
        this.componentManager.add(_component_selectedSeries__WEBPACK_IMPORTED_MODULE_16__["default"]);
        this.componentManager.add(_component_tooltip__WEBPACK_IMPORTED_MODULE_17__["default"], { chartEl: this.el });
        this.componentManager.add(_component_noDataText__WEBPACK_IMPORTED_MODULE_18__["default"]);
        this.painter.addGroups([
            _brushes_basic__WEBPACK_IMPORTED_MODULE_19__,
            _brushes_axis__WEBPACK_IMPORTED_MODULE_20__,
            _brushes_legend__WEBPACK_IMPORTED_MODULE_21__,
            _brushes_label__WEBPACK_IMPORTED_MODULE_22__,
            _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_23__,
            _brushes_scatterSeries__WEBPACK_IMPORTED_MODULE_24__,
        ]);
    }
    /**
     * Add data.
     * @param {Array<Object>} data - Array of data to be added.
     * @api
     * @example
     * chart.addData([
     *   {x: 10, y: 20},
     *   {x: 30, y: 40},
     * ]);
     */
    addData(data) {
        this.animationControlFlag.updating = true;
        this.resetSeries();
        this.store.dispatch('addData', { data });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [
     *     {x: 10, y: 20},
     *     {x: 30, y: 40},
     *   ],
     * });
     */
    addSeries(data) {
        this.resetSeries();
        this.store.dispatch('addSeries', { data });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   series: [
     *     {
     *       name: 'name'
     *       data: [
     *         {x: 10, y: 20},
     *         {x: 30, y: 40},
     *       ]
     *     }
     *   ]
     * });
     */
    setData(data) {
        const { categories, series } = data;
        this.resetSeries();
        this.store.dispatch('setData', { series: { scatter: series }, categories });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    setOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    updateOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */
    showTooltip(seriesInfo) {
        this.eventBus.emit('showTooltip', Object.assign(Object.assign({}, seriesInfo), { state: this.store.state }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */
    hideTooltip() {
        this.eventBus.emit('hideTooltip');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/charts/treemapChart.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/charts/treemapChart.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TreemapChart)
/* harmony export */ });
/* harmony import */ var _chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart */ "./node_modules/@toast-ui/chart/dist/esm/charts/chart.js");
/* harmony import */ var _store_colorValueScale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/colorValueScale */ "./node_modules/@toast-ui/chart/dist/esm/store/colorValueScale.js");
/* harmony import */ var _store_treemapSeriesData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/treemapSeriesData */ "./node_modules/@toast-ui/chart/dist/esm/store/treemapSeriesData.js");
/* harmony import */ var _component_tooltip__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../component/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js");
/* harmony import */ var _component_title__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../component/title */ "./node_modules/@toast-ui/chart/dist/esm/component/title.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _component_hoveredSeries__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../component/hoveredSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js");
/* harmony import */ var _component_dataLabels__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../component/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/component/dataLabels.js");
/* harmony import */ var _component_treemapSeries__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../component/treemapSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/treemapSeries.js");
/* harmony import */ var _component_spectrumLegend__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../component/spectrumLegend */ "./node_modules/@toast-ui/chart/dist/esm/component/spectrumLegend.js");
/* harmony import */ var _component_backButton__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../component/backButton */ "./node_modules/@toast-ui/chart/dist/esm/component/backButton.js");
/* harmony import */ var _component_selectedSeries__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../component/selectedSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js");
/* harmony import */ var _component_background__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component/background */ "./node_modules/@toast-ui/chart/dist/esm/component/background.js");
/* harmony import */ var _component_noDataText__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../component/noDataText */ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js");
/* harmony import */ var _brushes_basic__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../brushes/basic */ "./node_modules/@toast-ui/chart/dist/esm/brushes/basic.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../brushes/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/brushes/exportMenu.js");
/* harmony import */ var _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../brushes/dataLabel */ "./node_modules/@toast-ui/chart/dist/esm/brushes/dataLabel.js");
/* harmony import */ var _brushes_spectrumLegend__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../brushes/spectrumLegend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/spectrumLegend.js");
/* harmony import */ var _brushes_resetButton__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../brushes/resetButton */ "./node_modules/@toast-ui/chart/dist/esm/brushes/resetButton.js");





















/**
 * @class
 * @classdesc Treemap Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Treemap Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.label - Data name.
 *       @param {number} [props.data.series.data] - data value.
 *       @param {number} [props.data.series.colorValue] - color value. If you use the useColorValue option, the color is painted based on this value.
 *       @param {Array<Object>} [props.data.series.children] - Child element value.
 *   @param {Object} [props.options] - Options for making Treemap Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.useColorValue] - Whether to use color value or not.
 *       @param {boolean} [props.options.series.zoomable] - Whether to use zoom feature or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {boolean} [props.options.legend.visible=false] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Treemap Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
class TreemapChart extends _chart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(props) {
        super({
            el: props.el,
            options: props.options,
            series: {
                treemap: props.data.series,
            },
            modules: [_store_treemapSeriesData__WEBPACK_IMPORTED_MODULE_1__["default"], _store_colorValueScale__WEBPACK_IMPORTED_MODULE_2__["default"]],
        });
    }
    initialize() {
        super.initialize();
        this.componentManager.add(_component_background__WEBPACK_IMPORTED_MODULE_3__["default"]);
        this.componentManager.add(_component_title__WEBPACK_IMPORTED_MODULE_4__["default"]);
        this.componentManager.add(_component_spectrumLegend__WEBPACK_IMPORTED_MODULE_5__["default"]);
        this.componentManager.add(_component_treemapSeries__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.componentManager.add(_component_exportMenu__WEBPACK_IMPORTED_MODULE_7__["default"], { chartEl: this.el });
        this.componentManager.add(_component_hoveredSeries__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.componentManager.add(_component_selectedSeries__WEBPACK_IMPORTED_MODULE_9__["default"]);
        this.componentManager.add(_component_dataLabels__WEBPACK_IMPORTED_MODULE_10__["default"]);
        this.componentManager.add(_component_tooltip__WEBPACK_IMPORTED_MODULE_11__["default"], { chartEl: this.el });
        this.componentManager.add(_component_backButton__WEBPACK_IMPORTED_MODULE_12__["default"]);
        this.componentManager.add(_component_noDataText__WEBPACK_IMPORTED_MODULE_13__["default"]);
        this.painter.addGroups([
            _brushes_basic__WEBPACK_IMPORTED_MODULE_14__,
            _brushes_legend__WEBPACK_IMPORTED_MODULE_15__,
            _brushes_label__WEBPACK_IMPORTED_MODULE_16__,
            _brushes_exportMenu__WEBPACK_IMPORTED_MODULE_17__,
            _brushes_dataLabel__WEBPACK_IMPORTED_MODULE_18__,
            _brushes_spectrumLegend__WEBPACK_IMPORTED_MODULE_19__,
            _brushes_resetButton__WEBPACK_IMPORTED_MODULE_20__,
        ]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   label: 'Documents',
     *   children: [
     *     {label: 'A', data: 20},
     *     {label: 'B', data: 40},
     *   ],
     * });
     */
    addSeries(data, dataInfo) {
        this.resetSeries();
        this.store.dispatch('addTreemapSeries', Object.assign({ data }, dataInfo));
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData(
     *   series: [
     *     {
     *       label: 'Documents',
     *       children: [
     *         {label: 'A', data: 20},
     *         {label: 'B', data: 40},
     *       ],
     *     },
     *     {
     *       label: 'Documents',
     *       data: 30,
     *     }
     *   ]
     * );
     */
    setData(data) {
        this.resetSeries();
        this.store.dispatch('setData', { series: { treemap: data.series } });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */
    hideSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: false } } },
        });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */
    showSeriesDataLabel() {
        this.store.dispatch('updateOptions', {
            options: { series: { dataLabels: { visible: true } } },
        });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    setOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */
    updateOptions(options) {
        this.resetSeries();
        this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     * @api
     * @example
     * chart.showTooltip({seriesIndex: 1});
     */
    showTooltip(seriesInfo) {
        this.eventBus.emit('showTooltip', Object.assign(Object.assign({}, seriesInfo), { state: this.store.state }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */
    hideTooltip() {
        this.eventBus.emit('hideTooltip');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/areaSeries.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/areaSeries.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AreaSeries)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _helpers_color__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../helpers/color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_range__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/range */ "./node_modules/@toast-ui/chart/dist/esm/helpers/range.js");
/* harmony import */ var _helpers_legend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/legend */ "./node_modules/@toast-ui/chart/dist/esm/helpers/legend.js");
/* harmony import */ var _helpers_responders__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helpers/responders */ "./node_modules/@toast-ui/chart/dist/esm/helpers/responders.js");
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _helpers_dataLabels__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/helpers/dataLabels.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");
/* harmony import */ var _helpers_validation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/validation */ "./node_modules/@toast-ui/chart/dist/esm/helpers/validation.js");











const seriesOpacity = {
    INACTIVE: 0.06,
    ACTIVE: 1,
};
class AreaSeries extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.models = { rect: [], series: [], dot: [] };
        this.activatedResponders = [];
        this.eventDetectType = 'nearest';
        this.isStackChart = false;
        this.isRangeChart = false;
        this.isSplineChart = false;
        this.onMouseoutComponent = () => {
            this.eventBus.emit('seriesPointHovered', { models: [], name: this.name });
            this.eventBus.emit('renderHoveredSeries', {
                models: [],
                name: this.name,
                eventDetectType: this.eventDetectType,
            });
            this.eventBus.emit('needDraw');
        };
        this.selectSeries = (info) => {
            const { index, seriesIndex } = info;
            if (!(0,_helpers_validation__WEBPACK_IMPORTED_MODULE_1__.isAvailableSelectSeries)(info, 'area')) {
                return;
            }
            const category = this.getResponderCategoryByIndex(index);
            if (!category) {
                throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.SELECT_SERIES_API_INDEX_ERROR);
            }
            const model = this.tooltipCircleMap[category][seriesIndex];
            if (!model) {
                throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.SELECT_SERIES_API_INDEX_ERROR);
            }
            const models = this.getResponderSeriesWithTheme([model], 'select');
            this.eventBus.emit('renderSelectedSeries', { models, name: this.name });
            this.eventBus.emit('needDraw');
        };
        this.showTooltip = (info) => {
            const { index, seriesIndex } = info;
            if (!(0,_helpers_validation__WEBPACK_IMPORTED_MODULE_1__.isAvailableShowTooltipInfo)(info, this.eventDetectType, 'area')) {
                return;
            }
            const category = this.getResponderCategoryByIndex(index);
            if (!category) {
                return;
            }
            const models = this.eventDetectType === 'grouped'
                ? this.tooltipCircleMap[category]
                : [this.tooltipCircleMap[category][seriesIndex]];
            if (!models.length) {
                return;
            }
            this.onMousemoveNearType(models);
            this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });
            this.eventBus.emit('needDraw');
        };
    }
    initialize() {
        this.type = 'series';
        this.name = 'area';
        this.eventBus.on('selectSeries', this.selectSeries);
        this.eventBus.on('showTooltip', this.showTooltip);
        this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
    initUpdate(delta) {
        if (!this.drawModels) {
            return;
        }
        this.drawModels.rect[0].width = this.models.rect[0].width * delta;
    }
    getBaseYPosition(limit) {
        const baseValue = limit.min >= 0 ? limit.min : Math.min(limit.max, 0);
        const intervalSize = this.rect.height / (limit.max - limit.min);
        return (limit.max - baseValue) * intervalSize;
    }
    getStackValue(areaStackSeries, seriesIndex, index) {
        const { type } = areaStackSeries.stack;
        const { values, sum: sumValue } = areaStackSeries.stackData[index];
        const stackedValue = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.sum)(values.slice(0, seriesIndex + 1));
        return type === 'percent' ? (stackedValue * 100) / sumValue : stackedValue;
    }
    setEventDetectType(series, options) {
        var _a, _b;
        if ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.eventDetectType) {
            this.eventDetectType = options.series.eventDetectType;
        }
        if (series.line || this.isStackChart) {
            this.eventDetectType = 'grouped';
        }
    }
    getAreaOptions(options) {
        var _a;
        const newOptions = Object.assign({}, options);
        if ((_a = newOptions.series) === null || _a === void 0 ? void 0 : _a.area) {
            newOptions.series = Object.assign(Object.assign({}, newOptions.series), newOptions.series.area);
        }
        return newOptions;
    }
    render(chartState, computed) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const { viewRange } = computed;
        const { layout, series, scale, axes, legend, stackSeries, theme } = chartState;
        if (!series.area) {
            throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.noDataError(this.name));
        }
        let areaStackSeries;
        const options = this.getAreaOptions(chartState.options);
        const categories = chartState.categories;
        const rawCategories = (_a = chartState.rawCategories, (_a !== null && _a !== void 0 ? _a : []));
        this.theme = theme.series.area;
        this.rect = layout.plot;
        this.activeSeriesMap = (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_4__.getActiveSeriesMap)(legend);
        this.startIndex = (_c = (_b = viewRange) === null || _b === void 0 ? void 0 : _b[0], (_c !== null && _c !== void 0 ? _c : 0));
        this.selectable = this.getSelectableOption(options);
        this.isSplineChart = (_e = (_d = options.series) === null || _d === void 0 ? void 0 : _d.spline, (_e !== null && _e !== void 0 ? _e : false));
        const { limit } = scale[(0,_helpers_axes__WEBPACK_IMPORTED_MODULE_5__.getValueAxisName)(options, this.name, 'yAxis')];
        const { tickDistance, pointOnColumn, tickCount } = axes.xAxis;
        const areaData = series.area.data;
        this.baseYPosition = this.getBaseYPosition(limit);
        if ((_f = stackSeries) === null || _f === void 0 ? void 0 : _f.area) {
            this.isStackChart = true;
            areaStackSeries = stackSeries.area;
        }
        else if ((0,_helpers_range__WEBPACK_IMPORTED_MODULE_6__.isRangeData)((_g = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.getFirstValidValue)(areaData)) === null || _g === void 0 ? void 0 : _g.data)) {
            this.isRangeChart = true;
        }
        this.setEventDetectType(series, options);
        const renderOptions = {
            pointOnColumn,
            options: options.series || {},
            tickDistance,
            tickCount,
            areaStackSeries,
        };
        this.linePointsModel = this.renderLinePointsModel(areaData, limit, renderOptions);
        const areaSeriesModel = this.renderAreaPointsModel();
        const showDot = !!((_h = options.series) === null || _h === void 0 ? void 0 : _h.showDot);
        const { dotSeriesModel, responderModel } = this.renderCircleModel(showDot);
        const tooltipDataArr = this.makeTooltipData(areaData, rawCategories);
        this.models = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.deepCopy)({
            rect: [this.renderClipRectAreaModel()],
            series: [...this.linePointsModel, ...areaSeriesModel],
            dot: dotSeriesModel,
        });
        if (!this.drawModels) {
            this.drawModels = Object.assign(Object.assign({}, this.models), { rect: [this.renderClipRectAreaModel(true)] });
        }
        if ((0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_7__.getDataLabelsOptions)(options, this.name).visible) {
            this.renderDataLabels(this.getDataLabels(areaSeriesModel));
        }
        this.tooltipCircleMap = (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_8__.makeTooltipCircleMap)(responderModel, tooltipDataArr);
        this.responders = this.getResponders(responderModel, tooltipDataArr, categories, rawCategories, axes.xAxis);
    }
    getResponders(responderModel, tooltipDataArr, categories, rawCategories, axisData) {
        if (this.eventDetectType === 'near') {
            return this.makeNearTypeResponderModel(responderModel, tooltipDataArr, rawCategories);
        }
        if (this.eventDetectType === 'point') {
            return this.makeNearTypeResponderModel(responderModel, tooltipDataArr, rawCategories, 0);
        }
        return (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_8__.makeRectResponderModel)(this.rect, axisData, categories);
    }
    makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr, categories, detectionSize) {
        const tooltipDataLength = tooltipDataArr.length;
        return seriesCircleModel.map((m, dataIndex) => (Object.assign(Object.assign({}, m), { data: tooltipDataArr[dataIndex % tooltipDataLength], detectionSize, label: categories[m.index] })));
    }
    renderClipRectAreaModel(isDrawModel) {
        return {
            type: 'clipRectArea',
            x: 0,
            y: 0,
            width: isDrawModel ? 0 : this.rect.width,
            height: this.rect.height,
        };
    }
    makeTooltipData(areaData, categories) {
        return areaData.flatMap(({ rawData, name, color }, seriesIndex) => {
            const tooltipData = [];
            rawData.forEach((datum, index) => {
                if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.isNull)(datum)) {
                    const value = this.isRangeChart ? `${datum[0]} ~ ${datum[1]}` : datum;
                    tooltipData.push({
                        label: name,
                        color,
                        value,
                        category: categories[index],
                        seriesIndex,
                        index,
                    });
                }
            });
            return tooltipData;
        });
    }
    getLinePointModelValue(datum, pairModel) {
        if (this.isRangeChart) {
            return pairModel ? datum[0] : datum[1];
        }
        return datum;
    }
    getLinePointModel(series, seriesIndex, limit, renderOptions) {
        const { pointOnColumn, tickDistance, pairModel, areaStackSeries } = renderOptions;
        const { rawData, name, color: seriesColor } = series;
        const active = this.activeSeriesMap[name];
        const points = [];
        const color = (0,_helpers_color__WEBPACK_IMPORTED_MODULE_9__.getRGBA)(seriesColor, active ? seriesOpacity.ACTIVE : seriesOpacity.INACTIVE);
        const { lineWidth, dashSegments } = this.theme;
        rawData.forEach((datum, idx) => {
            if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.isNull)(datum)) {
                points.push(null);
                return;
            }
            const value = this.getLinePointModelValue(datum, pairModel);
            const stackedValue = this.isStackChart
                ? this.getStackValue(areaStackSeries, seriesIndex, idx)
                : value;
            const valueRatio = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_10__.getValueRatio)(stackedValue, limit);
            const x = tickDistance * (idx - this.startIndex) + (pointOnColumn ? tickDistance / 2 : 0);
            const y = (1 - valueRatio) * this.rect.height;
            points.push({ x, y, value });
        });
        if (pairModel) {
            points.reverse(); // for range spline
        }
        if (this.isSplineChart) {
            (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_10__.setSplineControlPoint)(points);
        }
        return {
            type: 'linePoints',
            lineWidth,
            dashSegments,
            color,
            points,
            seriesIndex,
            name,
        };
    }
    renderLinePointsModel(seriesRawData, limit, renderOptions) {
        const linePointsModels = seriesRawData.map((series, seriesIndex) => this.getLinePointModel(series, seriesIndex, limit, renderOptions));
        if (this.isRangeChart) {
            const renderOptionsForPair = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.deepMergedCopy)(renderOptions, { pairModel: true });
            const pair = seriesRawData.map((series, seriesIndex) => this.getLinePointModel(series, seriesIndex, limit, renderOptionsForPair));
            linePointsModels.push(...pair);
        }
        return linePointsModels;
    }
    getCombinedPoints(start, end) {
        const startPoints = start >= 0 ? this.linePointsModel[start].points : [];
        const reversedEndPoints = [...this.linePointsModel[end].points].reverse();
        return [...startPoints, ...reversedEndPoints];
    }
    renderRangeAreaSeries(linePointsModel) {
        const model = [];
        linePointsModel.forEach((m) => {
            let areaPoints = [];
            const { points } = m;
            points.slice(0, points.length / 2 + 1).forEach((point, i) => {
                const lastPoint = i === points.length / 2 - 1;
                const nullPoint = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.isNull)(point);
                if (!nullPoint) {
                    areaPoints.push(point);
                }
                if (areaPoints.length && (lastPoint || nullPoint)) {
                    const pairPoints = areaPoints
                        .map((areaPoint, idx) => {
                        const curIdx = points.length / 2 + i - areaPoints.length + idx + (!nullPoint && lastPoint ? 1 : 0);
                        return points[curIdx];
                    })
                        .reverse();
                    model.push(Object.assign(Object.assign({}, m), { type: 'areaPoints', lineWidth: 0, color: 'rgba(0, 0, 0, 0)', fillColor: this.getAreaOpacity(m.name, m.color), points: [...areaPoints, ...pairPoints] }));
                    areaPoints = [];
                }
            });
        });
        return model;
    }
    renderAreaSeries(linePointsModel) {
        const model = [];
        const bottomYPoint = [];
        linePointsModel.forEach((m) => {
            let areaPoints = [];
            const curBottomYPoint = [...bottomYPoint];
            const { points } = m;
            points.forEach((point, i) => {
                const lastPoint = i === points.length - 1;
                const nullPoint = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.isNull)(point);
                if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.isNull)(point)) {
                    areaPoints.push(point);
                }
                if (areaPoints.length && (nullPoint || lastPoint)) {
                    const pairPoints = areaPoints
                        .map((areaPoint, idx) => {
                        const curIdx = i - areaPoints.length + idx + (!nullPoint && lastPoint ? 1 : 0);
                        const bottom = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(curBottomYPoint[curIdx])
                            ? this.baseYPosition
                            : curBottomYPoint[curIdx];
                        if (this.isStackChart) {
                            bottomYPoint[curIdx] = areaPoint.y;
                        }
                        return { x: areaPoint.x, y: bottom };
                    })
                        .reverse();
                    if (this.isStackChart && this.isSplineChart) {
                        (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_10__.setSplineControlPoint)(pairPoints); // set spline for new stack pair points
                    }
                    model.push(Object.assign(Object.assign({}, m), { type: 'areaPoints', lineWidth: 0, color: 'rgba(0, 0, 0, 0)', fillColor: this.getAreaOpacity(m.name, m.color), points: [...areaPoints, ...pairPoints] }));
                    areaPoints = [];
                }
            });
        });
        return model;
    }
    getCombinedLinePointsModel() {
        if (!this.isRangeChart) {
            return this.linePointsModel;
        }
        const len = this.linePointsModel.length / 2;
        return (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.range)(0, len).reduce((acc, i) => {
            const start = i;
            const end = len + i;
            const points = this.getCombinedPoints(start, end);
            return [...acc, Object.assign(Object.assign({}, this.linePointsModel[i]), { points })];
        }, []);
    }
    getAreaOpacity(name, color) {
        const { select, areaOpacity } = this.theme;
        const active = this.activeSeriesMap[name];
        const selected = Object.values(this.activeSeriesMap).some((elem) => !elem);
        return selected
            ? (0,_helpers_color__WEBPACK_IMPORTED_MODULE_9__.getRGBA)(color, active ? select.areaOpacity : select.restSeries.areaOpacity)
            : (0,_helpers_color__WEBPACK_IMPORTED_MODULE_9__.getRGBA)(color, areaOpacity);
    }
    renderAreaPointsModel() {
        const combinedLinePointsModel = this.getCombinedLinePointsModel();
        return this.isRangeChart
            ? this.renderRangeAreaSeries(combinedLinePointsModel)
            : this.renderAreaSeries(combinedLinePointsModel);
    }
    renderCircleModel(showDot) {
        const dotSeriesModel = [];
        const responderModel = [];
        const { dot: dotTheme } = this.theme;
        this.linePointsModel.forEach(({ points, color, seriesIndex, name }, modelIndex) => {
            const isPairLinePointsModel = this.isRangeChart && modelIndex >= this.linePointsModel.length / 2;
            const active = this.activeSeriesMap[name];
            points.forEach((point, index) => {
                var _a;
                if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.isNull)(point)) {
                    return;
                }
                const model = Object.assign(Object.assign({ type: 'circle' }, point), { seriesIndex,
                    name, index: isPairLinePointsModel ? points.length - index - 1 : index });
                if (showDot) {
                    dotSeriesModel.push(Object.assign(Object.assign({}, model), { radius: dotTheme.radius, color: (0,_helpers_color__WEBPACK_IMPORTED_MODULE_9__.getRGBA)(color, active ? 1 : 0.3), style: [
                            { lineWidth: dotTheme.borderWidth, strokeStyle: (_a = dotTheme.borderColor, (_a !== null && _a !== void 0 ? _a : color)) },
                        ] }));
                }
                responderModel.push(...this.getResponderSeriesWithTheme([model], 'hover', color));
            });
        });
        return { dotSeriesModel, responderModel };
    }
    getPairCircleModel(circleModels) {
        const pairCircleModels = [];
        circleModels.forEach((circle) => {
            const { seriesIndex, y, data } = circle;
            const { category } = data;
            const pairCircleModel = this.tooltipCircleMap[category].find((model) => model.seriesIndex === seriesIndex && model.y !== y);
            pairCircleModels.push(pairCircleModel);
        });
        return pairCircleModels;
    }
    getCircleModelsFromRectResponders(responders, mousePositions) {
        var _a;
        if (!responders.length || !responders[0].label) {
            return [];
        }
        const models = (_a = this.tooltipCircleMap[responders[0].label], (_a !== null && _a !== void 0 ? _a : []));
        return this.eventDetectType === 'grouped'
            ? models
            : (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_8__.getNearestResponder)(models, mousePositions, this.rect);
    }
    onMousemoveGroupedType(responders) {
        const circleModels = this.getCircleModelsFromRectResponders(responders);
        this.eventBus.emit('renderHoveredSeries', {
            models: circleModels,
            name: this.name,
            eventDetectType: this.eventDetectType,
        });
        this.activatedResponders = this.isRangeChart
            ? circleModels.slice(0, circleModels.length / 2) // for rendering unique tooltip data
            : circleModels;
    }
    onMousemoveNearestType(responders, mousePositions) {
        const circleModels = this.getCircleModelsFromRectResponders(responders, mousePositions);
        this.onMousemoveNearType(circleModels);
    }
    onMousemoveNearType(responders) {
        let pairCircleModels = [];
        if (this.isRangeChart) {
            pairCircleModels = this.getPairCircleModel(responders);
        }
        const hoveredSeries = [...responders, ...pairCircleModels];
        this.eventBus.emit('renderHoveredSeries', {
            models: hoveredSeries,
            name: this.name,
            eventDetectType: this.eventDetectType,
        });
        this.activatedResponders = responders;
    }
    onMousemove({ responders, mousePosition }) {
        if (this.eventDetectType === 'nearest') {
            this.onMousemoveNearestType(responders, mousePosition);
        }
        else if (['near', 'point'].includes(this.eventDetectType)) {
            this.onMousemoveNearType(responders);
        }
        else {
            this.onMousemoveGroupedType(responders);
        }
        this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });
        this.eventBus.emit('needDraw');
    }
    getDataLabels(seriesModels) {
        const dataLabelTheme = this.theme.dataLabels;
        return seriesModels.flatMap(({ points, name, fillColor }) => points.map((point) => (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.isNull)(point)
            ? {}
            : Object.assign(Object.assign({ type: 'point' }, point), { name, theme: Object.assign(Object.assign({}, dataLabelTheme), { color: dataLabelTheme.useSeriesColor ? (0,_helpers_color__WEBPACK_IMPORTED_MODULE_9__.getRGBA)(fillColor, 1) : dataLabelTheme.color }) })));
    }
    getResponderSeriesWithTheme(models, type, seriesColor) {
        const { radius, color, borderWidth, borderColor } = this.theme[type].dot;
        return models.map((model) => {
            var _a;
            const modelColor = (_a = (color !== null && color !== void 0 ? color : model.color), (_a !== null && _a !== void 0 ? _a : seriesColor));
            return Object.assign(Object.assign({}, model), { radius, color: modelColor, style: [{ lineWidth: borderWidth, strokeStyle: (borderColor !== null && borderColor !== void 0 ? borderColor : (0,_helpers_color__WEBPACK_IMPORTED_MODULE_9__.getRGBA)(modelColor, 0.5)) }] });
        });
    }
    onClick({ responders, mousePosition }) {
        if (this.selectable) {
            let models;
            if (this.eventDetectType === 'near') {
                models = responders;
            }
            else {
                models = this.getCircleModelsFromRectResponders(responders, mousePosition);
            }
            this.eventBus.emit('renderSelectedSeries', {
                models: this.getResponderSeriesWithTheme(models, 'select'),
                name: this.name,
            });
            this.eventBus.emit('needDraw');
        }
    }
    getResponderCategoryByIndex(index) {
        var _a, _b;
        const responder = Object.values(this.tooltipCircleMap)
            .flatMap((val) => val)
            .find((model) => model.index === index);
        return (_b = (_a = responder) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.category;
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/axis.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AxisType": () => (/* binding */ AxisType),
/* harmony export */   "default": () => (/* binding */ Axis)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _brushes_axis__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../brushes/axis */ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");






var AxisType;
(function (AxisType) {
    AxisType["X"] = "xAxis";
    AxisType["Y"] = "yAxis";
    AxisType["SECONDARY_Y"] = "secondaryYAxis";
    AxisType["CIRCULAR"] = "circularAxis";
    AxisType["VERTICAL"] = "verticalAxis";
})(AxisType || (AxisType = {}));
function getOffsetAndAnchorKey(hasBasedYAxis) {
    return {
        offsetKey: hasBasedYAxis ? 'y' : 'x',
        anchorKey: hasBasedYAxis ? 'x' : 'y',
    };
}
class Axis extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.models = { label: [], tick: [], axisLine: [] };
        this.axisSize = 0;
    }
    initialize({ name }) {
        this.type = 'axis';
        this.name = name;
        this.yAxisComponent = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.includes)([AxisType.Y, AxisType.SECONDARY_Y], name);
    }
    render({ layout, axes, theme, scale }) {
        var _a;
        if (axes.centerYAxis || !axes[this.name]) {
            return;
        }
        this.theme = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_2__.getAxisTheme)(theme, this.name);
        this.rect = layout[this.name];
        this.axisSize = this.yAxisComponent ? this.rect.height : this.rect.width;
        const { viewLabels } = axes[this.name];
        const { offsetKey, anchorKey } = getOffsetAndAnchorKey(this.yAxisComponent);
        const renderOptions = this.makeRenderOptions(axes[this.name], (_a = scale) === null || _a === void 0 ? void 0 : _a[this.name]);
        const hasOnlyAxisLine = this.hasOnlyAxisLine();
        if (!hasOnlyAxisLine) {
            this.models.label = this.renderLabelModels(viewLabels, offsetKey, anchorKey, renderOptions);
            this.models.tick = this.renderTickModels(offsetKey, anchorKey, renderOptions);
        }
        this.models.axisLine = [this.renderAxisLineModel()];
        if (!this.drawModels) {
            this.drawModels = {
                tick: [],
                label: [],
                axisLine: this.models.axisLine,
            };
            ['tick', 'label'].forEach((type) => {
                this.drawModels[type] = this.models[type].map((m) => {
                    const drawModel = Object.assign({}, m);
                    if (this.yAxisComponent) {
                        drawModel.y = 0;
                    }
                    else {
                        drawModel.x = 0;
                    }
                    return drawModel;
                });
            });
        }
    }
    renderAxisLineModel() {
        const zeroPixel = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(0);
        let lineModel;
        const { color: strokeStyle, width: lineWidth } = this.theme;
        if (this.yAxisComponent) {
            const x = this.getYAxisXPoint();
            lineModel = {
                type: 'line',
                x,
                y: zeroPixel,
                x2: x,
                y2: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(this.axisSize),
                strokeStyle,
                lineWidth,
            };
        }
        else {
            lineModel = {
                type: 'line',
                x: zeroPixel,
                y: zeroPixel,
                x2: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(this.axisSize),
                y2: zeroPixel,
                strokeStyle,
                lineWidth,
            };
        }
        return lineModel;
    }
    renderTickModels(offsetKey, anchorKey, renderOptions) {
        const tickAnchorPoint = this.yAxisComponent ? this.getYAxisXPoint() : (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(0);
        const { tickInterval, relativePositions } = renderOptions;
        const tickSize = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.includes)([AxisType.SECONDARY_Y, AxisType.X], this.name)
            ? _brushes_axis__WEBPACK_IMPORTED_MODULE_4__.TICK_SIZE
            : -_brushes_axis__WEBPACK_IMPORTED_MODULE_4__.TICK_SIZE;
        return relativePositions.reduce((positions, position, index) => {
            return index % tickInterval
                ? positions
                : [
                    ...positions,
                    {
                        type: 'tick',
                        isYAxis: this.yAxisComponent,
                        tickSize,
                        [offsetKey]: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(position),
                        [anchorKey]: tickAnchorPoint,
                        strokeStyle: this.theme.color,
                        lineWidth: this.theme.width,
                    },
                ];
        }, []);
    }
    renderLabelModels(labels, offsetKey, anchorKey, renderOptions) {
        const { needRotateLabel, radian, offsetY } = renderOptions;
        const labelTheme = this.theme.label;
        const font = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_5__.getTitleFontString)(labelTheme);
        const textAlign = this.getLabelTextAlign(needRotateLabel);
        const style = ['default', { textAlign, font, fillStyle: labelTheme.color }];
        const labelAnchorPoint = this.yAxisComponent ? this.getYAxisAnchorPoint() : offsetY;
        return labels.map(({ text, offsetPos }) => ({
            type: 'label',
            text,
            style,
            radian,
            [offsetKey]: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(offsetPos),
            [anchorKey]: labelAnchorPoint,
        }));
    }
    makeRenderOptions(axisData, scale) {
        var _a, _b, _c, _d;
        const { tickCount, tickInterval } = axisData;
        const sizeRatio = (_b = (_a = scale) === null || _a === void 0 ? void 0 : _a.sizeRatio, (_b !== null && _b !== void 0 ? _b : 1));
        const positionRatio = (_d = (_c = scale) === null || _c === void 0 ? void 0 : _c.positionRatio, (_d !== null && _d !== void 0 ? _d : 0));
        const relativePositions = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.makeTickPixelPositions)(this.axisSize * sizeRatio, tickCount, this.axisSize * positionRatio);
        if (this.yAxisComponent) {
            return {
                relativePositions,
                tickInterval,
            };
        }
        const { needRotateLabel, radian, offsetY } = axisData;
        return {
            relativePositions,
            tickInterval,
            needRotateLabel,
            radian,
            offsetY,
        };
    }
    getYAxisAnchorPoint() {
        return this.isRightSide() ? (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(this.rect.width) : (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(0);
    }
    getLabelTextAlign(needRotateLabel) {
        const yAxisTextAlign = this.isRightSide() ? 'right' : 'left';
        const xAxisTextAlign = needRotateLabel ? 'left' : 'center';
        return this.yAxisComponent ? yAxisTextAlign : xAxisTextAlign;
    }
    isRightSide() {
        return this.name === AxisType.SECONDARY_Y;
    }
    getYAxisXPoint() {
        return this.isRightSide() ? (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(0) : (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(this.rect.width);
    }
    hasOnlyAxisLine() {
        return ((this.yAxisComponent && !this.rect.width) || (this.name === AxisType.X && !this.rect.height));
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/axisTitle.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/axisTitle.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AxisTitle)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _axis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");





class AxisTitle extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    initialize({ name }) {
        this.type = 'axisTitle';
        this.name = name;
        this.isYAxis = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.includes)([_axis__WEBPACK_IMPORTED_MODULE_2__.AxisType.Y, _axis__WEBPACK_IMPORTED_MODULE_2__.AxisType.SECONDARY_Y], name);
        this.isCircularAxis = this.name === _axis__WEBPACK_IMPORTED_MODULE_2__.AxisType.CIRCULAR;
    }
    getTitlePosition(offsetX, offsetY) {
        if (this.isCircularAxis) {
            return [this.rect.width / 2 + offsetX, this.rect.height / 2 + offsetY];
        }
        return this.isYAxis
            ? [this.name === _axis__WEBPACK_IMPORTED_MODULE_2__.AxisType.Y ? offsetX : this.rect.width + offsetX, offsetY]
            : [this.rect.width + offsetX, offsetY];
    }
    renderAxisTitle(option, textAlign) {
        const { text, offsetX, offsetY } = option;
        const [x, y] = this.getTitlePosition(offsetX, offsetY);
        const font = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_3__.getTitleFontString)(this.theme);
        const fillStyle = this.theme.color;
        return [
            {
                type: 'label',
                text,
                x,
                y,
                style: ['axisTitle', { textAlign, fillStyle, font }],
            },
        ];
    }
    getTextAlign(hasCenterYAxis = false) {
        if (this.name === _axis__WEBPACK_IMPORTED_MODULE_2__.AxisType.Y) {
            return hasCenterYAxis ? 'center' : 'left';
        }
        if (this.isCircularAxis) {
            return 'center';
        }
        return 'right';
    }
    getCircularAxisTitleRect(option, plotRect, circularAxisData) {
        const { x, y } = plotRect;
        const { centerX, centerY, axisSize, radius: { outer: outerRadius }, } = circularAxisData;
        const { offsetY } = option;
        return {
            x: centerX + x - axisSize / 2,
            y: centerY + y - outerRadius / 2,
            width: axisSize,
            height: this.theme.fontSize + offsetY,
        };
    }
    render({ axes, radialAxes, layout, theme }) {
        var _a, _b, _c;
        const titleOption = this.isCircularAxis ? (_a = radialAxes[this.name]) === null || _a === void 0 ? void 0 : _a.title : (_b = axes[this.name]) === null || _b === void 0 ? void 0 : _b.title;
        this.isShow = !!titleOption;
        if (!this.isShow) {
            return;
        }
        this.theme = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_4__.getAxisTheme)(theme, this.name).title;
        this.rect = layout[`${this.name}Title`];
        this.models = this.renderAxisTitle(titleOption, this.getTextAlign(!!((_c = axes) === null || _c === void 0 ? void 0 : _c.centerYAxis)));
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/axisUsingCenterY.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/axisUsingCenterY.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AxisUsingCenterY)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");





class AxisUsingCenterY extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.models = { label: [], tick: [], axisLine: [] };
    }
    initialize({ name }) {
        this.type = 'axis';
        this.name = name;
        this.yAxisComponent = name === _axis__WEBPACK_IMPORTED_MODULE_1__.AxisType.Y;
    }
    render({ layout, axes, theme }) {
        const { centerYAxis } = axes;
        if (!centerYAxis) {
            return;
        }
        this.theme = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_2__.getAxisTheme)(theme, this.name);
        this.rect = layout[this.name];
        if (this.name === 'yAxis') {
            this.rect = Object.assign(Object.assign({}, this.rect), { x: centerYAxis.x });
        }
        const { viewLabels, tickCount, tickInterval, needRotateLabel, radian, offsetY } = axes[this.name];
        const renderOptions = {
            tickInterval,
            centerYAxis,
            needRotateLabel,
            radian,
            offsetY,
            relativePositions: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.makeTickPixelPositions)(this.axisSize(centerYAxis), tickCount),
        };
        const offsetKey = this.yAxisComponent ? 'y' : 'x';
        const anchorKey = this.yAxisComponent ? 'x' : 'y';
        this.models.label = this.renderLabelModels(viewLabels, offsetKey, anchorKey, renderOptions);
        this.models.tick = this.renderTickModels(offsetKey, anchorKey, renderOptions);
        this.models.axisLine = this.renderAxisLineModel(centerYAxis);
        if (!this.drawModels) {
            this.drawModels = {
                tick: [],
                label: [],
                axisLine: this.models.axisLine,
            };
            ['tick', 'label'].forEach((type) => {
                this.drawModels[type] = this.models[type].map((m) => {
                    const drawModel = Object.assign({}, m);
                    if (this.yAxisComponent) {
                        drawModel.y = 0;
                    }
                    else {
                        drawModel.x = 0;
                    }
                    return drawModel;
                });
            });
        }
    }
    renderAxisLineModel({ xAxisHalfSize, secondStartX }) {
        const zeroPixel = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(0);
        const widthPixel = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(this.rect.width);
        let axisLine;
        if (this.yAxisComponent) {
            const heightPixel = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(this.rect.height);
            axisLine = [
                {
                    type: 'line',
                    x: widthPixel,
                    y: zeroPixel,
                    x2: widthPixel,
                    y2: heightPixel,
                },
                {
                    type: 'line',
                    x: zeroPixel,
                    y: zeroPixel,
                    x2: zeroPixel,
                    y2: heightPixel,
                },
            ];
        }
        else {
            axisLine = [
                {
                    type: 'line',
                    x: zeroPixel,
                    y: zeroPixel,
                    x2: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(xAxisHalfSize),
                    y2: zeroPixel,
                },
                {
                    type: 'line',
                    x: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(secondStartX),
                    y: zeroPixel,
                    x2: widthPixel,
                    y2: zeroPixel,
                },
            ];
        }
        return axisLine;
    }
    renderTickModels(offsetKey, anchorKey, renderOptions) {
        const tickAnchorPoint = this.yAxisComponent ? (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(this.rect.width) : (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(0);
        const { tickInterval, centerYAxis: { secondStartX }, relativePositions, } = renderOptions;
        return relativePositions.reduce((positions, position, index) => {
            if (index % tickInterval) {
                return positions;
            }
            const model = {
                type: 'tick',
                isYAxis: this.yAxisComponent,
                tickSize: this.yAxisComponent ? -5 : 5,
                [offsetKey]: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(position),
                [anchorKey]: tickAnchorPoint,
            };
            const addedTickModel = Object.assign({}, model);
            if (this.yAxisComponent) {
                addedTickModel[anchorKey] = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(0);
                addedTickModel.tickSize = 5;
            }
            else {
                addedTickModel[offsetKey] = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(position + secondStartX);
            }
            return [...positions, model, addedTickModel];
        }, []);
    }
    renderLabelModels(labels, offsetKey, anchorKey, renderOptions) {
        const { centerYAxis: { secondStartX, yAxisLabelAnchorPoint }, offsetY, needRotateLabel, radian, } = renderOptions;
        const labelTheme = this.theme.label;
        const font = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_4__.getTitleFontString)(labelTheme);
        let labelAnchorPoint, textAlign, textLabels;
        if (this.yAxisComponent) {
            labelAnchorPoint = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(yAxisLabelAnchorPoint);
            textAlign = 'center';
            textLabels = labels;
        }
        else {
            labelAnchorPoint = offsetY;
            textLabels = [...labels].reverse();
            textAlign = needRotateLabel ? 'left' : 'center';
        }
        const style = ['default', { textAlign, font, fillStyle: labelTheme.color }];
        return textLabels.reduce((positions, { text, offsetPos }, index) => {
            const model = {
                type: 'label',
                text,
                style,
                [offsetKey]: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(offsetPos) + (this.yAxisComponent ? 0 : secondStartX),
                [anchorKey]: labelAnchorPoint,
                radian,
            };
            const models = [model];
            if (!this.yAxisComponent) {
                const addedLabelModel = Object.assign(Object.assign({}, model), { text: labels[index].text, [offsetKey]: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(model[offsetKey] - secondStartX) });
                models.push(addedLabelModel);
            }
            return [...positions, ...models];
        }, []);
    }
    axisSize(centerYAxis) {
        let size;
        if (this.yAxisComponent) {
            size = this.rect.height;
        }
        else {
            size = centerYAxis.xAxisHalfSize;
        }
        return size;
    }
    beforeDraw(painter) {
        painter.ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
        painter.ctx.lineWidth = 1;
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/backButton.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/backButton.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BackButton)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _store_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/layout */ "./node_modules/@toast-ui/chart/dist/esm/store/layout.js");
/* harmony import */ var _exportMenu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");



class BackButton extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    initialize() {
        this.type = 'backButton';
        this.name = 'backButton';
    }
    onClick({ responders }) {
        if (responders.length) {
            this.store.dispatch('zoomBack');
            this.eventBus.emit('resetSelectedSeries');
        }
    }
    render({ options, layout }, computed) {
        if (!(0,_store_layout__WEBPACK_IMPORTED_MODULE_1__.isUsingResetButton)(options)) {
            return;
        }
        this.rect = layout.resetButton;
        this.isShow = computed.isTreemapSeriesZooming;
        this.models = this.isShow ? [{ type: 'backButton', x: 0, y: 0 }] : [];
        this.responders = this.isShow
            ? [{ type: 'rect', x: 0, y: 0, width: _exportMenu__WEBPACK_IMPORTED_MODULE_2__.BUTTON_RECT_SIZE, height: _exportMenu__WEBPACK_IMPORTED_MODULE_2__.BUTTON_RECT_SIZE }]
            : [];
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/background.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/background.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Background)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");

class Background extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    initialize() {
        this.type = 'background';
        this.name = 'background';
    }
    render({ layout, theme }) {
        const { width, height } = layout.chart;
        this.theme = theme.chart;
        this.rect = { x: 0, y: 0, width, height };
        this.models = [
            Object.assign(Object.assign({ type: 'rect' }, this.rect), { color: this.theme.backgroundColor }),
        ];
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/boxPlotSeries.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/boxPlotSeries.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BoxPlotSeries)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_legend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/legend */ "./node_modules/@toast-ui/chart/dist/esm/helpers/legend.js");
/* harmony import */ var _helpers_color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");







const MIN_BAR_WIDTH = 5;
function getPadding(tickDistance, barWidth, seriesLength) {
    return (tickDistance - barWidth * seriesLength) / (seriesLength + 1);
}
function getDefaultColor(defaultColor, color) {
    return (color !== null && color !== void 0 ? color : defaultColor);
}
class BoxPlotSeries extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.models = { rect: [], line: [], circle: [] };
        this.activatedResponders = [];
        this.eventDetectType = 'point';
        this.onMouseoutComponent = () => {
            this.eventBus.emit('seriesPointHovered', { models: [], name: this.name });
            this.eventBus.emit('renderHoveredSeries', {
                models: [],
                name: this.name,
                eventDetectType: this.eventDetectType,
            });
            this.eventBus.emit('needDraw');
        };
        this.selectSeries = ({ index, seriesIndex, state, }) => {
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(index) || !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(seriesIndex)) {
                return;
            }
            const { name } = state.series.boxPlot[seriesIndex];
            const models = this.getRespondersWithTheme(this.tooltipRectMap[`${name}-${index}`], 'select');
            this.eventBus.emit('renderSelectedSeries', {
                models,
                name: this.name,
                eventDetectType: this.eventDetectType,
            });
            this.eventBus.emit('needDraw');
        };
        this.showTooltip = ({ index, seriesIndex, state }) => {
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(index) || !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(seriesIndex)) {
                return;
            }
            const { name } = state.series.boxPlot[seriesIndex];
            const models = this.getRespondersWithTheme(this.tooltipRectMap[`${name}-${index}`], 'hover');
            this.eventBus.emit('renderHoveredSeries', {
                models,
                name: this.name,
                eventDetectType: this.eventDetectType,
            });
            this.activatedResponders = models;
            this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });
            this.eventBus.emit('needDraw');
        };
    }
    initialize() {
        this.type = 'series';
        this.name = 'boxPlot';
        this.eventBus.on('selectSeries', this.selectSeries);
        this.eventBus.on('showTooltip', this.showTooltip);
        this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
    render(state) {
        var _a, _b;
        const { layout, axes, series, scale, legend, options, theme } = state;
        if (!series.boxPlot) {
            throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.noDataError(this.name));
        }
        if ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.eventDetectType) {
            this.eventDetectType = options.series.eventDetectType;
        }
        this.theme = theme.series.boxPlot;
        this.rect = layout.plot;
        this.activeSeriesMap = (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_3__.getActiveSeriesMap)(legend);
        this.selectable = this.getSelectableOption(options);
        const categories = state.categories;
        const { tickDistance } = axes.xAxis;
        const { min, max } = scale.yAxis.limit;
        const boxPlotData = series.boxPlot.data;
        const seriesLength = boxPlotData.length;
        const renderOptions = Object.assign({ ratio: this.rect.height / (max - min), tickDistance }, this.getBarWidths(tickDistance, seriesLength));
        const boxPlotModelData = this.makeBoxPlots(boxPlotData, renderOptions);
        const seriesModels = this.renderSeriesModels(boxPlotModelData);
        this.models = seriesModels;
        if (!this.drawModels) {
            this.drawModels = {
                rect: seriesModels.rect.map((m) => (Object.assign(Object.assign({}, m), { y: m.y + m.height, height: 0 }))),
                line: seriesModels.line,
                circle: seriesModels.circle,
            };
        }
        const tooltipData = this.makeTooltipModel(boxPlotData, categories);
        this.tooltipRectMap = this.makeTooltipRectMap(boxPlotModelData, tooltipData);
        this.responders =
            this.eventDetectType === 'grouped'
                ? this.makeGroupedResponderModel(boxPlotModelData)
                : this.makeDefaultResponderModel(boxPlotModelData, tooltipData);
    }
    makeTooltipRectMap(boxPlotModelData, tooltipData) {
        const result = {};
        boxPlotModelData.forEach((m, tooltipIndex) => {
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(m)) {
                const propName = `${m.name}-${m.index}`;
                if (!result[propName]) {
                    result[propName] = [];
                }
                result[propName].push(Object.assign(Object.assign({}, this.makeHoveredModel(m)), { data: tooltipData[tooltipIndex] }));
            }
        });
        return result;
    }
    makeGroupedResponderModel(boxPlotModelData) {
        const result = [];
        boxPlotModelData.forEach((m) => {
            const { type, index, name } = m;
            const propName = `${name}-${index}`;
            if (type === 'boxPlot' && !result[propName]) {
                const { boxPlotDetection } = m;
                result.push(Object.assign(Object.assign({ type: 'rect', name: propName }, boxPlotDetection), { y: 0, height: this.rect.height }));
            }
        });
        return result;
    }
    makeDefaultResponderModel(boxPlotModelData, tooltipDataArr) {
        return boxPlotModelData.map((m, index) => (Object.assign(Object.assign({}, this.makeHoveredModel(m)), { data: tooltipDataArr[index], color: (0,_helpers_color__WEBPACK_IMPORTED_MODULE_4__.getRGBA)(m.color, 1) })));
    }
    makeHoveredModel(model) {
        const point = model.type === 'boxPlot' && model.rect
            ? { x: model.rect.x, y: model.rect.y }
            : { x: model.x, y: model.y };
        const hoveredModel = Object.assign({}, model);
        if (model.type === 'boxPlot') {
            ['lowerWhisker', 'upperWhisker', 'maximum', 'minimum', 'median'].forEach((prop) => {
                if (model[prop]) {
                    model[prop].detectionSize = 3;
                }
            });
            model.color = (0,_helpers_color__WEBPACK_IMPORTED_MODULE_4__.getRGBA)(hoveredModel.color, 1);
        }
        return Object.assign(Object.assign({}, hoveredModel), point);
    }
    getResponderModelFromMap(responders) {
        if (!responders.length) {
            return [];
        }
        const propName = responders[0].name;
        return this.tooltipRectMap[propName];
    }
    onMousemove({ responders }) {
        if (this.eventDetectType === 'grouped') {
            const models = this.getResponderModelFromMap(responders);
            this.eventBus.emit('renderHoveredSeries', {
                models: this.getRespondersWithTheme(models, 'select'),
                name: this.name,
                eventDetectType: this.eventDetectType,
            });
            this.activatedResponders = models;
        }
        else {
            this.eventBus.emit('renderHoveredSeries', {
                models: this.getRespondersWithTheme(responders, 'hover'),
                name: this.name,
                eventDetectType: this.eventDetectType,
            });
            this.activatedResponders = responders;
        }
        this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });
        this.eventBus.emit('needDraw');
    }
    onClick({ responders }) {
        if (this.selectable) {
            let models;
            if (this.eventDetectType === 'grouped') {
                models = this.getRespondersWithTheme(this.getResponderModelFromMap(responders), 'select');
            }
            else {
                models = this.getRespondersWithTheme(responders, 'select');
            }
            this.eventBus.emit('renderSelectedSeries', {
                models,
                name: this.name,
                eventDetectType: this.eventDetectType,
            });
            this.eventBus.emit('needDraw');
        }
    }
    renderSeriesModels(boxPlots) {
        return boxPlots.reduce((acc, cur) => {
            const { type, name } = cur;
            if (type === 'boxPlot') {
                acc.rect.push(Object.assign({ name }, cur.rect));
                ['maximum', 'minimum', 'median', 'upperWhisker', 'lowerWhisker'].forEach((prop) => {
                    acc.line.push(Object.assign({ name }, cur[prop]));
                });
            }
            else {
                acc.circle.push(Object.assign({}, cur));
            }
            return acc;
        }, { rect: [], line: [], circle: [] });
    }
    makeBoxPlots(seriesData, renderOptions) {
        const { ratio, barWidth } = renderOptions;
        const boxPlotModels = [];
        const seriesLength = seriesData.length;
        const { dot } = this.theme;
        seriesData.forEach(({ outliers, data, name, color }, seriesIndex) => {
            const seriesColor = this.getSeriesColor(name, color);
            ((data !== null && data !== void 0 ? data : [])).forEach((datum, dataIndex) => {
                if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(datum)) {
                    const startX = this.getStartX(seriesIndex, dataIndex, renderOptions, seriesLength);
                    const rect = this.getRect(datum, startX, seriesColor, renderOptions);
                    boxPlotModels.push(Object.assign(Object.assign({ type: 'boxPlot', color: seriesColor, name,
                        rect, median: this.getMedian(datum, startX, seriesColor, renderOptions), minimum: this.getMinimum(datum, startX, seriesColor, renderOptions), maximum: this.getMaximum(datum, startX, seriesColor, renderOptions) }, this.getWhisker(datum, startX, seriesColor, renderOptions, rect)), { index: dataIndex, boxPlotDetection: {
                            x: startX,
                            width: barWidth,
                        } }));
                }
            });
            const { color: dotColor, radius, borderColor, borderWidth, useSeriesColor, } = dot;
            ((outliers !== null && outliers !== void 0 ? outliers : [])).forEach((datum) => {
                const [dataIndex, value] = datum;
                const startX = this.getStartX(seriesIndex, dataIndex, renderOptions, seriesLength);
                boxPlotModels.push({
                    type: 'circle',
                    name,
                    x: startX + barWidth / 2,
                    y: this.getYPos(value, ratio),
                    radius: radius,
                    style: [{ strokeStyle: (borderColor !== null && borderColor !== void 0 ? borderColor : seriesColor), lineWidth: borderWidth }],
                    color: useSeriesColor ? seriesColor : dotColor,
                    index: dataIndex,
                });
            });
        });
        return boxPlotModels;
    }
    makeTooltipModel(seriesData, categories) {
        const tooltipData = [];
        seriesData.forEach(({ outliers, data, name, color }) => {
            ((data !== null && data !== void 0 ? data : [])).forEach((datum, dataIndex) => {
                if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(datum)) {
                    const boxPlotData = [...datum].reverse();
                    tooltipData.push({
                        label: name,
                        color: color,
                        value: [
                            'Maximum',
                            'Upper Quartile',
                            'Median',
                            'Lower Quartile',
                            'Minimum',
                        ].reduce((acc, title, index) => {
                            const value = boxPlotData[index];
                            return (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(value) ? acc : [...acc, { title, value }];
                        }, []),
                        category: categories[dataIndex],
                        templateType: 'boxPlot',
                    });
                }
            });
            ((outliers !== null && outliers !== void 0 ? outliers : [])).forEach((datum) => {
                if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(datum)) {
                    const [dataIndex, dataValue] = datum;
                    tooltipData.push({
                        label: name,
                        color: color,
                        value: [{ title: 'Outlier', value: dataValue }],
                        category: categories[dataIndex],
                        templateType: 'boxPlot',
                    });
                }
            });
        });
        return tooltipData;
    }
    getStartX(seriesIndex, dataIndex, renderOptions, seriesLength) {
        const { tickDistance, barWidth } = renderOptions;
        const padding = getPadding(tickDistance, barWidth, seriesLength);
        return dataIndex * tickDistance + (seriesIndex + 1) * padding + barWidth * seriesIndex;
    }
    getYPos(value, ratio, lineWidth) {
        return (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(lineWidth)
            ? (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_5__.crispPixel)(this.rect.height - value * ratio, lineWidth)
            : this.rect.height - value * ratio;
    }
    getBarWidths(tickDistance, seriesLength) {
        const { barWidth: barThemeWidth, barWidthRatios } = this.theme;
        const { barRatio, minMaxBarRatio } = barWidthRatios;
        const defaultBarWidth = Math.max((tickDistance - (0,_helpers_style__WEBPACK_IMPORTED_MODULE_6__.getBoxTypeSeriesPadding)(tickDistance) * (2 + (seriesLength - 1))) /
            seriesLength, MIN_BAR_WIDTH);
        const barWidth = barThemeWidth
            ? (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.calculateSizeWithPercentString)(tickDistance / seriesLength, barThemeWidth)
            : defaultBarWidth;
        return {
            barWidth: barWidth * barRatio,
            minMaxBarWidth: barWidth * minMaxBarRatio,
        };
    }
    getRespondersWithTheme(responders, type) {
        const { color, rect, dot, line, shadowColor, shadowOffsetX, shadowOffsetY, shadowBlur, } = this.theme[type];
        const { whisker, median, maximum, minimum } = line;
        const { color: dotColor, radius, borderColor, borderWidth, useSeriesColor, } = dot;
        return responders.map((m) => {
            const { type: modelType, data } = m;
            let seriesColor = m.color;
            let model;
            if (modelType === 'circle') {
                seriesColor = data.color;
                model = Object.assign(Object.assign({}, m), { radius, color: useSeriesColor ? seriesColor : dotColor, style: [
                        { strokeStyle: getDefaultColor(seriesColor, borderColor), lineWidth: borderWidth },
                    ] });
            }
            else {
                const { rect: seriesRect, upperWhisker, lowerWhisker, median: seriesMedian, maximum: seriesMaximum, minimum: seriesMinimum, } = m;
                model = Object.assign(Object.assign({}, m), { rect: Object.assign(Object.assign({}, seriesRect), { color: (color !== null && color !== void 0 ? color : (0,_helpers_color__WEBPACK_IMPORTED_MODULE_4__.getRGBA)(seriesColor, 1)), thickness: rect.borderWidth, borderColor: rect.borderColor, style: [{ shadowColor, shadowOffsetX, shadowOffsetY, shadowBlur }] }), upperWhisker: Object.assign(Object.assign({}, upperWhisker), { strokeStyle: getDefaultColor(seriesColor, whisker.color), lineWidth: whisker.lineWidth }), lowerWhisker: Object.assign(Object.assign({}, lowerWhisker), { strokeStyle: getDefaultColor(seriesColor, whisker.color), lineWidth: whisker.lineWidth }), median: Object.assign(Object.assign({}, seriesMedian), { strokeStyle: getDefaultColor(seriesColor, median.color), lineWidth: median.lineWidth }), maximum: Object.assign(Object.assign({}, seriesMaximum), { strokeStyle: getDefaultColor(seriesColor, maximum.color), lineWidth: maximum.lineWidth }), minimum: Object.assign(Object.assign({}, seriesMinimum), { strokeStyle: getDefaultColor(seriesColor, minimum.color), lineWidth: minimum.lineWidth }) });
            }
            return model;
        });
    }
    getRect(datum, startX, seriesColor, { barWidth, ratio }) {
        const { rect } = this.theme;
        const [, lowerQuartile, , highQuartile] = datum;
        return {
            type: 'rect',
            x: startX,
            y: this.getYPos(highQuartile, ratio),
            width: barWidth,
            height: (highQuartile - lowerQuartile) * ratio,
            thickness: rect.borderWidth,
            borderColor: rect.borderColor,
            color: seriesColor,
        };
    }
    getWhisker(datum, startX, seriesColor, { barWidth, ratio }, rect) {
        const [minimum, , , , maximum] = datum;
        const { lineWidth, color } = this.theme.line.whisker;
        const x = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_5__.crispPixel)(startX + barWidth / 2, lineWidth);
        return {
            upperWhisker: {
                type: 'line',
                x,
                y: this.getYPos(maximum, ratio, lineWidth),
                x2: x,
                y2: rect.y,
                strokeStyle: (color !== null && color !== void 0 ? color : seriesColor),
                lineWidth,
            },
            lowerWhisker: {
                type: 'line',
                x,
                y: this.getYPos(minimum, ratio, lineWidth),
                x2: x,
                y2: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_5__.crispPixel)(rect.y + rect.height, lineWidth),
                strokeStyle: (color !== null && color !== void 0 ? color : seriesColor),
                lineWidth,
            },
        };
    }
    getMedian(datum, startX, seriesColor, { barWidth, ratio }) {
        const median = datum[2];
        const { lineWidth, color } = this.theme.line.median;
        return {
            type: 'line',
            x: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_5__.crispPixel)(startX, lineWidth),
            y: this.getYPos(median, ratio, lineWidth),
            x2: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_5__.crispPixel)(startX + barWidth, lineWidth),
            y2: this.getYPos(median, ratio, lineWidth),
            strokeStyle: (color !== null && color !== void 0 ? color : seriesColor),
            lineWidth: lineWidth,
        };
    }
    getMinimum(datum, startX, seriesColor, { barWidth, ratio, minMaxBarWidth }) {
        const minimum = datum[0];
        const { lineWidth, color } = this.theme.line.minimum;
        return {
            type: 'line',
            x: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_5__.crispPixel)(startX + (barWidth - minMaxBarWidth) / 2, lineWidth),
            y: this.getYPos(minimum, ratio, lineWidth),
            x2: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_5__.crispPixel)(startX + (barWidth - minMaxBarWidth) / 2 + minMaxBarWidth, lineWidth),
            y2: this.getYPos(minimum, ratio, lineWidth),
            strokeStyle: (color !== null && color !== void 0 ? color : seriesColor),
            lineWidth: lineWidth,
        };
    }
    getMaximum(datum, startX, seriesColor, { barWidth, ratio, minMaxBarWidth }) {
        const maximum = datum[4];
        const { lineWidth, color } = this.theme.line.maximum;
        return {
            type: 'line',
            x: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_5__.crispPixel)(startX + (barWidth - minMaxBarWidth) / 2, lineWidth),
            y: this.getYPos(maximum, ratio, lineWidth),
            x2: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_5__.crispPixel)(startX + (barWidth - minMaxBarWidth) / 2 + minMaxBarWidth, lineWidth),
            y2: this.getYPos(maximum, ratio, lineWidth),
            strokeStyle: (color !== null && color !== void 0 ? color : seriesColor),
            lineWidth: lineWidth,
        };
    }
    getSeriesColor(seriesName, seriesColor) {
        const { select, areaOpacity } = this.theme;
        const active = this.activeSeriesMap[seriesName];
        const selected = Object.values(this.activeSeriesMap).some((elem) => !elem);
        const selectedOpacity = active ? select.areaOpacity : select.restSeries.areaOpacity;
        const opacity = selected ? selectedOpacity : areaOpacity;
        return (0,_helpers_color__WEBPACK_IMPORTED_MODULE_4__.getRGBA)(seriesColor, opacity);
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/boxSeries.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/boxSeries.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SeriesDirection": () => (/* binding */ SeriesDirection),
/* harmony export */   "isLeftBottomSide": () => (/* binding */ isLeftBottomSide),
/* harmony export */   "default": () => (/* binding */ BoxSeries)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _helpers_color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");
/* harmony import */ var _helpers_range__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/range */ "./node_modules/@toast-ui/chart/dist/esm/helpers/range.js");
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _helpers_boxSeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/boxSeries */ "./node_modules/@toast-ui/chart/dist/esm/helpers/boxSeries.js");
/* harmony import */ var _helpers_dataLabels__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../helpers/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/helpers/dataLabels.js");
/* harmony import */ var _helpers_legend__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/legend */ "./node_modules/@toast-ui/chart/dist/esm/helpers/legend.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _helpers_responders__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../helpers/responders */ "./node_modules/@toast-ui/chart/dist/esm/helpers/responders.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");
/* harmony import */ var _helpers_validation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/validation */ "./node_modules/@toast-ui/chart/dist/esm/helpers/validation.js");













var SeriesDirection;
(function (SeriesDirection) {
    SeriesDirection[SeriesDirection["POSITIVE"] = 0] = "POSITIVE";
    SeriesDirection[SeriesDirection["NEGATIVE"] = 1] = "NEGATIVE";
    SeriesDirection[SeriesDirection["BOTH"] = 2] = "BOTH";
})(SeriesDirection || (SeriesDirection = {}));
const BOX = {
    BAR: 'bar',
    COLUMN: 'column',
};
function isLeftBottomSide(seriesIndex) {
    return !!(seriesIndex % 2);
}
function calculateBarLength(value, min, max) {
    if ((0,_helpers_range__WEBPACK_IMPORTED_MODULE_0__.isRangeValue)(value)) {
        let [start, end] = value;
        if (start < min) {
            start = min;
        }
        if (end > max) {
            end = max;
        }
        return end - start;
    }
    return (0,_helpers_boxSeries__WEBPACK_IMPORTED_MODULE_1__.calibrateDrawingValue)(value, min, max);
}
class BoxSeries extends _component__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super(...arguments);
        this.models = { series: [] };
        this.activatedResponders = [];
        this.isBar = true;
        this.valueAxis = 'xAxis';
        this.labelAxis = 'yAxis';
        this.anchorSizeKey = 'height';
        this.offsetSizeKey = 'width';
        this.basePosition = 0;
        this.leftBasePosition = 0;
        this.rightBasePosition = 0;
        this.isRangeData = false;
        this.offsetKey = 'x';
        this.eventDetectType = 'point';
        this.onMouseoutComponent = () => {
            this.eventBus.emit('seriesPointHovered', { models: [], name: this.name });
            this.eventBus.emit('renderHoveredSeries', {
                models: [],
                name: this.name,
                eventDetectType: this.eventDetectType,
            });
            this.eventBus.emit('needDraw');
        };
        this.selectSeries = (info) => {
            const { index, seriesIndex } = info;
            if (!(0,_helpers_validation__WEBPACK_IMPORTED_MODULE_3__.isAvailableSelectSeries)(info, 'column')) {
                return;
            }
            const model = this.tooltipRectMap[seriesIndex][index];
            if (!model) {
                throw new Error(_message__WEBPACK_IMPORTED_MODULE_4__.message.SELECT_SERIES_API_INDEX_ERROR);
            }
            this.eventBus.emit('renderSelectedSeries', {
                models: this.getRespondersWithTheme([model], 'select'),
                name: this.name,
            });
            this.eventBus.emit('needDraw');
        };
        this.showTooltip = (info) => {
            const { index, seriesIndex } = info;
            if (!(0,_helpers_validation__WEBPACK_IMPORTED_MODULE_3__.isAvailableShowTooltipInfo)(info, this.eventDetectType, 'column')) {
                return;
            }
            const models = this.eventDetectType === 'grouped'
                ? this.getGroupedRect([this.responders[index]], 'hover')
                : this.getRespondersWithTheme([this.tooltipRectMap[index][seriesIndex]], 'hover');
            if (!models.length) {
                return;
            }
            this.eventBus.emit('renderHoveredSeries', {
                models,
                name: this.name,
                eventDetectType: this.eventDetectType,
            });
            this.activatedResponders =
                this.eventDetectType === 'grouped' ? this.tooltipRectMap[index] : models;
            this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });
            this.eventBus.emit('needDraw');
        };
    }
    initialize({ name, stackChart }) {
        this.initializeFields(name);
        if (!stackChart) {
            this.eventBus.on('selectSeries', this.selectSeries);
            this.eventBus.on('showTooltip', this.showTooltip);
            this.eventBus.on('hideTooltip', this.onMouseoutComponent);
        }
    }
    initializeFields(name) {
        this.type = 'series';
        this.name = name;
        this.isBar = name === BOX.BAR;
        this.offsetKey = this.isBar ? 'x' : 'y';
        this.valueAxis = this.isBar ? 'xAxis' : 'yAxis';
        this.labelAxis = this.isBar ? 'yAxis' : 'xAxis';
        this.anchorSizeKey = this.isBar ? 'height' : 'width';
        this.offsetSizeKey = this.isBar ? 'width' : 'height';
    }
    initUpdate(delta) {
        if (!this.drawModels) {
            return;
        }
        if (this.isRangeData) {
            this.initUpdateRangeData(delta);
            return;
        }
        this.initUpdateClipRect(delta);
        this.initUpdateConnector(delta);
    }
    initUpdateRangeData(delta) {
        const { series } = this.drawModels;
        this.drawModels.clipRect = this.models.clipRect;
        const target = this.models.series;
        series.forEach((current, index) => {
            const targetModel = target[index];
            if (delta === 0) {
                current[this.offsetSizeKey] = 0;
            }
            const offsetSize = current[this.offsetSizeKey] +
                (targetModel[this.offsetSizeKey] - current[this.offsetSizeKey]) * delta;
            current[this.offsetSizeKey] = offsetSize;
            if (!this.isBar) {
                current[this.offsetKey] =
                    targetModel[this.offsetKey] + targetModel[this.offsetSizeKey] - offsetSize;
            }
        });
    }
    initUpdateClipRect(delta) {
        const { clipRect } = this.drawModels;
        if (!clipRect) {
            return;
        }
        const current = clipRect[0];
        const key = this.offsetSizeKey;
        const target = this.models.clipRect[0];
        const offsetSize = current[key] + (target[key] - current[key]) * delta;
        current[key] = offsetSize;
        current[this.offsetKey] = Math.max(this.basePosition - (offsetSize * this.basePosition) / target[key], 0);
    }
    initUpdateConnector(delta) {
        const { connector } = this.drawModels;
        if (!connector) {
            return;
        }
        const target = this.models.connector;
        connector.forEach((current, index) => {
            const alpha = (0,_helpers_color__WEBPACK_IMPORTED_MODULE_5__.getAlpha)(target[index].strokeStyle) * delta;
            current.strokeStyle = (0,_helpers_color__WEBPACK_IMPORTED_MODULE_5__.getRGBA)(current.strokeStyle, alpha);
        });
    }
    setEventDetectType(series, options) {
        var _a, _b;
        if (series.line) {
            this.eventDetectType = 'grouped';
        }
        if ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.eventDetectType) {
            this.eventDetectType = options.series.eventDetectType;
        }
    }
    getOptions(chartOptions) {
        var _a;
        const options = Object.assign({}, chartOptions);
        if (((_a = options) === null || _a === void 0 ? void 0 : _a.series) && options.series.column) {
            options.series = Object.assign(Object.assign({}, options.series), options.series.column);
        }
        return options;
    }
    render(chartState, computed) {
        var _a, _b;
        const { layout, series, axes, stackSeries, legend, theme, scale } = chartState;
        this.isShow = !(stackSeries && stackSeries[this.name]);
        if (!this.isShow) {
            return;
        }
        const categories = (_a = chartState.categories, (_a !== null && _a !== void 0 ? _a : []));
        const options = this.getOptions(chartState.options);
        this.setEventDetectType(series, options);
        this.theme = theme.series[this.name];
        this.rect = layout.plot;
        this.activeSeriesMap = (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_6__.getActiveSeriesMap)(legend);
        this.selectable = this.getSelectableOption(options);
        this.valueAxis = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_7__.getValueAxisName)(options, this.name, this.isBar ? 'xAxis' : 'yAxis');
        const seriesData = series[this.name].data.map((seriesDatum) => (Object.assign(Object.assign({}, seriesDatum), { data: (0,_helpers_range__WEBPACK_IMPORTED_MODULE_0__.getDataInRange)(seriesDatum.data, computed.viewRange) })));
        if (axes.centerYAxis) {
            this.valueAxis = 'centerYAxis';
        }
        const { tickDistance } = axes[this.labelAxis];
        const diverging = !!((_b = options.series) === null || _b === void 0 ? void 0 : _b.diverging);
        const { limit, stepSize } = this.getScaleData(scale);
        const labels = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_8__.makeLabelsFromLimit)(limit, stepSize);
        const { min, max } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_7__.getLimitOnAxis)(labels);
        this.basePosition = this.getBasePosition(axes[this.valueAxis]);
        let offsetSize = this.getOffsetSize();
        const { centerYAxis } = axes;
        if (diverging) {
            const [left, right] = this.getDivergingBasePosition(centerYAxis);
            this.basePosition = this.getOffsetSize() / 2;
            this.leftBasePosition = left;
            this.rightBasePosition = right;
            offsetSize = this.getOffsetSizeWithDiverging(centerYAxis);
        }
        const renderOptions = {
            min,
            max,
            tickDistance,
            diverging,
            ratio: this.getValueRatio(min, max, offsetSize),
            hasNegativeValue: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_9__.hasNegative)(labels),
            seriesDirection: this.getSeriesDirection(labels),
            defaultPadding: (0,_helpers_style__WEBPACK_IMPORTED_MODULE_10__.getBoxTypeSeriesPadding)(tickDistance),
        };
        const seriesModels = this.renderSeriesModel(seriesData, renderOptions);
        const tooltipData = this.makeTooltipData(seriesData, renderOptions, categories);
        const clipRect = this.renderClipRectAreaModel();
        this.models = {
            clipRect: [clipRect],
            series: seriesModels,
        };
        if (!this.drawModels) {
            this.drawModels = {
                clipRect: [this.initClipRect(clipRect)],
                series: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_9__.deepCopyArray)(seriesModels),
            };
        }
        if ((0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_11__.getDataLabelsOptions)(options, this.name).visible) {
            const dataLabelData = seriesModels.reduce((acc, data) => {
                return (0,_helpers_range__WEBPACK_IMPORTED_MODULE_0__.isRangeValue)(data.value)
                    ? [...acc, ...this.makeDataLabelRangeData(data)]
                    : [...acc, this.makeDataLabel(data, centerYAxis)];
            }, []);
            this.renderDataLabels(dataLabelData);
        }
        this.tooltipRectMap = this.makeTooltipRectMap(seriesModels, tooltipData);
        this.responders = this.getBoxSeriesResponders(seriesModels, tooltipData, axes, categories);
    }
    getScaleData(scale) {
        return scale[this.valueAxis === 'centerYAxis' ? 'xAxis' : this.valueAxis];
    }
    getBoxSeriesResponders(seriesModels, tooltipData, axes, categories) {
        const hoveredSeries = this.renderHoveredSeriesModel(seriesModels);
        return this.eventDetectType === 'grouped'
            ? (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_12__.makeRectResponderModel)(this.rect, (this.isBar ? axes.yAxis : axes.xAxis), categories, !this.isBar)
            : hoveredSeries.map((m, index) => (Object.assign(Object.assign({}, m), { data: tooltipData[index] })));
    }
    makeTooltipRectMap(seriesModels, tooltipDataArr) {
        return seriesModels.reduce((acc, cur, dataIndex) => {
            const index = cur.index;
            const tooltipModel = Object.assign(Object.assign({}, cur), { data: tooltipDataArr[dataIndex] });
            if (!acc[index]) {
                acc[index] = [];
            }
            acc[index].push(tooltipModel);
            return acc;
        }, []);
    }
    renderClipRectAreaModel() {
        return {
            type: 'clipRectArea',
            x: 0,
            y: 0,
            width: this.rect.width,
            height: this.rect.height,
        };
    }
    initClipRect(clipRect) {
        return {
            type: 'clipRectArea',
            width: this.isBar ? 0 : clipRect.width,
            height: this.isBar ? clipRect.height : 0,
            x: this.isBar ? 0 : clipRect.x,
            y: this.isBar ? clipRect.y : 0,
        };
    }
    renderSeriesModel(seriesData, renderOptions) {
        const { tickDistance, diverging } = renderOptions;
        const seriesLength = seriesData.length;
        const validDiverging = diverging && seriesData.length === 2;
        const columnWidth = this.getColumnWidth(renderOptions, seriesLength, validDiverging);
        const seriesModels = [];
        const padding = (tickDistance - columnWidth * (validDiverging ? 1 : seriesLength)) / 2;
        seriesData.forEach(({ data, color: seriesColor, name, colorByCategories }, seriesIndex) => {
            const seriesPos = (diverging ? 0 : seriesIndex) * columnWidth + padding;
            const isLBSideWithDiverging = diverging && isLeftBottomSide(seriesIndex);
            const colorLength = colorByCategories ? seriesColor.length : 1;
            this.isRangeData = (0,_helpers_range__WEBPACK_IMPORTED_MODULE_0__.isRangeData)(data);
            data.forEach((value, index) => {
                const dataStart = seriesPos + index * tickDistance;
                const barLength = this.makeBarLength(value, renderOptions);
                const color = this.getSeriesColor(name, colorByCategories ? seriesColor[index % colorLength] : seriesColor);
                if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_9__.isNumber)(barLength)) {
                    const startPosition = this.getStartPosition(barLength, value, renderOptions, isLBSideWithDiverging);
                    seriesModels.push(Object.assign(Object.assign({ type: 'rect', color,
                        value }, this.getAdjustedRect(dataStart, startPosition, barLength, columnWidth)), { name,
                        index }));
                }
            });
        });
        return seriesModels;
    }
    renderHoveredSeriesModel(seriesModel) {
        return seriesModel.map((data) => {
            return this.makeHoveredSeriesModel(data);
        });
    }
    makeHoveredSeriesModel(data) {
        const { x, y, width, height, color, index } = data;
        return {
            type: 'rect',
            color: (0,_helpers_color__WEBPACK_IMPORTED_MODULE_5__.getRGBA)(color, 1),
            x,
            y,
            width,
            height,
            index,
        };
    }
    getRectModelsFromRectResponders(responders) {
        var _a;
        if (!responders.length) {
            return [];
        }
        return _a = this.tooltipRectMap[responders[0].index], (_a !== null && _a !== void 0 ? _a : []);
    }
    getGroupedRect(responders, type) {
        const rectModels = this.getRectModelsFromRectResponders(responders);
        const { color, opacity } = this.theme[type].groupedRect;
        return rectModels.length
            ? responders.map((m) => (Object.assign(Object.assign({}, m), { color: (0,_helpers_color__WEBPACK_IMPORTED_MODULE_5__.getRGBA)(color, opacity) })))
            : [];
    }
    onMousemoveGroupedType(responders) {
        const rectModels = this.getRectModelsFromRectResponders(responders);
        this.eventBus.emit('renderHoveredSeries', {
            models: this.getGroupedRect(responders, 'hover'),
            name: this.name,
            eventDetectType: this.eventDetectType,
        });
        this.activatedResponders = rectModels;
    }
    onMousemove({ responders }) {
        if (this.eventDetectType === 'grouped') {
            this.onMousemoveGroupedType(responders);
        }
        else {
            this.eventBus.emit('renderHoveredSeries', {
                models: this.getRespondersWithTheme(responders, 'hover'),
                name: this.name,
                eventDetectType: this.eventDetectType,
            });
            this.activatedResponders = responders;
        }
        this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });
        this.eventBus.emit('needDraw');
    }
    makeTooltipData(seriesData, renderOptions, categories) {
        const tooltipData = [];
        seriesData.forEach(({ data, name, color, colorByCategories }) => {
            data.forEach((value, dataIndex) => {
                if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_9__.isNull)(value)) {
                    const barLength = this.makeBarLength(value, renderOptions);
                    if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_9__.isNumber)(barLength)) {
                        tooltipData.push({
                            label: name,
                            color: colorByCategories ? color[dataIndex] : color,
                            value: this.getTooltipValue(value),
                            category: categories.length ? categories[dataIndex] : '',
                        });
                    }
                }
            });
        });
        return tooltipData;
    }
    getTooltipValue(value) {
        return (0,_helpers_range__WEBPACK_IMPORTED_MODULE_0__.isRangeValue)(value) ? `${value[0]} ~ ${value[1]}` : value;
    }
    getBasePosition({ labels, tickCount, zeroPosition }) {
        const valueLabels = this.isBar ? labels : [...labels].reverse();
        const tickPositions = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_8__.makeTickPixelPositions)(this.getOffsetSize(), tickCount);
        const seriesDirection = this.getSeriesDirection(valueLabels);
        return zeroPosition
            ? zeroPosition
            : this.getTickPositionIfNotZero(tickPositions, seriesDirection);
    }
    getDivergingBasePosition(centerYAxis) {
        let leftZeroPosition, rightZeroPosition;
        if (centerYAxis) {
            leftZeroPosition = centerYAxis.xAxisHalfSize;
            rightZeroPosition = centerYAxis.secondStartX;
        }
        else {
            const divergingZeroPosition = this.getOffsetSize() / 2;
            leftZeroPosition = rightZeroPosition = divergingZeroPosition;
        }
        return [leftZeroPosition, rightZeroPosition];
    }
    getOffsetSize() {
        return this.rect[this.offsetSizeKey];
    }
    getValueRatio(min, max, size) {
        return size / (max - min);
    }
    makeBarLength(value, renderOptions) {
        if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_9__.isNull)(value)) {
            return null;
        }
        const { min, max, ratio } = renderOptions;
        const calculatedValue = calculateBarLength(value, min, max);
        return Math.max(this.getBarLength(calculatedValue, ratio), 2);
    }
    getBarLength(value, ratio) {
        return value < 0 ? Math.abs(value) * ratio : value * ratio;
    }
    getStartPositionWithRangeValue(value, barLength, renderOptions) {
        const { min, ratio } = renderOptions;
        let [start] = value;
        if (start < min) {
            start = min;
        }
        const startPosition = (start - min) * ratio;
        return this.isBar ? startPosition : this.getOffsetSize() - startPosition - barLength;
    }
    getStartPosition(barLength, value, renderOptions, isLBSideWithDiverging) {
        const { diverging, seriesDirection } = renderOptions;
        let startPos;
        if ((0,_helpers_range__WEBPACK_IMPORTED_MODULE_0__.isRangeValue)(value)) {
            startPos = this.getStartPositionWithRangeValue(value, barLength, renderOptions);
        }
        else if (diverging) {
            startPos = isLBSideWithDiverging
                ? this.getStartPosOnLeftBottomSide(barLength, diverging)
                : this.getStartPosOnRightTopSide(barLength, diverging);
        }
        else if (seriesDirection === SeriesDirection.POSITIVE) {
            startPos = this.getStartPosOnRightTopSide(barLength);
        }
        else if (seriesDirection === SeriesDirection.NEGATIVE) {
            startPos = this.getStartPosOnLeftBottomSide(barLength);
        }
        else {
            startPos =
                value < 0
                    ? this.getStartPosOnLeftBottomSide(barLength)
                    : this.getStartPosOnRightTopSide(barLength);
        }
        return startPos;
    }
    getStartPosOnRightTopSide(barLength, diverging = false) {
        let pos;
        if (diverging) {
            pos = this.isBar ? this.rightBasePosition : this.rightBasePosition - barLength;
        }
        else {
            pos = this.isBar ? this.basePosition : this.basePosition - barLength;
        }
        return pos;
    }
    getStartPosOnLeftBottomSide(barLength, diverging = false) {
        let pos;
        if (diverging) {
            pos = this.isBar ? this.leftBasePosition - barLength : this.leftBasePosition;
        }
        else {
            pos = this.isBar ? this.basePosition - barLength : this.basePosition;
        }
        return pos;
    }
    getAdjustedRect(seriesPosition, dataPosition, barLength, columnWidth) {
        return {
            x: this.isBar ? dataPosition : seriesPosition,
            y: this.isBar ? seriesPosition : dataPosition,
            width: this.isBar ? barLength : columnWidth,
            height: this.isBar ? columnWidth : barLength,
        };
    }
    getColumnWidth(renderOptions, seriesLength, validDiverging = false) {
        const { tickDistance, defaultPadding } = renderOptions;
        seriesLength = validDiverging ? 1 : seriesLength;
        const themeBarWidth = this.theme.barWidth;
        return themeBarWidth
            ? (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_9__.calculateSizeWithPercentString)(tickDistance, themeBarWidth)
            : (tickDistance - defaultPadding * 2) / seriesLength;
    }
    getSeriesDirection(labels) {
        let result = SeriesDirection.BOTH;
        if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_9__.hasPositiveOnly)(labels)) {
            result = SeriesDirection.POSITIVE;
        }
        else if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_9__.hasNegativeOnly)(labels)) {
            result = SeriesDirection.NEGATIVE;
        }
        return result;
    }
    getTickPositionIfNotZero(tickPositions, direction) {
        if (!tickPositions.length) {
            return 0;
        }
        const firstTickPosition = Number((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_9__.first)(tickPositions));
        const lastTickPosition = Number((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_9__.last)(tickPositions));
        if (direction === SeriesDirection.POSITIVE) {
            return this.isBar ? firstTickPosition : lastTickPosition;
        }
        if (direction === SeriesDirection.NEGATIVE) {
            return this.isBar ? lastTickPosition : firstTickPosition;
        }
        return 0;
    }
    makeDataLabel(rect, centerYAxis) {
        const { dataLabels } = this.theme;
        return Object.assign(Object.assign({}, rect), { direction: this.getDataLabelDirection(rect, centerYAxis), plot: { x: 0, y: 0, size: this.getOffsetSize() }, theme: Object.assign(Object.assign({}, (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_9__.omit)(dataLabels, 'stackTotal')), { color: dataLabels.useSeriesColor ? rect.color : dataLabels.color }) });
    }
    makeDataLabelRangeData(rect) {
        const { dataLabels } = this.theme;
        return rect.value.reduce((acc, value, index) => [
            ...acc,
            Object.assign(Object.assign({}, rect), { value, direction: this.getDataLabelRangeDataDirection(index % 2 === 0), plot: { x: 0, y: 0, size: this.getOffsetSize() }, theme: Object.assign(Object.assign({}, (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_9__.omit)(dataLabels, 'stackTotal')), { color: dataLabels.useSeriesColor ? rect.color : dataLabels.color }) }),
        ], []);
    }
    getDataLabelRangeDataDirection(isEven) {
        let direction;
        if (this.isBar) {
            direction = isEven ? 'left' : 'right';
        }
        else {
            direction = isEven ? 'bottom' : 'top';
        }
        return direction;
    }
    getDataLabelDirection(rect, centerYAxis) {
        let direction;
        if (this.isBar) {
            const basePos = centerYAxis ? this.leftBasePosition : this.basePosition;
            direction = rect.x < basePos ? 'left' : 'right';
        }
        else {
            direction = rect.y >= this.basePosition ? 'bottom' : 'top';
        }
        return direction;
    }
    getOffsetSizeWithDiverging(centerYAxis) {
        return centerYAxis ? centerYAxis.xAxisHalfSize : this.getOffsetSize() / 2;
    }
    onClick({ responders }) {
        if (this.selectable) {
            let models;
            if (this.eventDetectType === 'grouped') {
                models = [
                    ...this.getGroupedRect(responders, 'select'),
                    ...this.getRectModelsFromRectResponders(responders),
                ];
            }
            else {
                models = this.getRespondersWithTheme(responders, 'select');
            }
            this.eventBus.emit('renderSelectedSeries', {
                models,
                name: this.name,
                eventDetectType: this.eventDetectType,
            });
            this.eventBus.emit('needDraw');
        }
    }
    getRespondersWithTheme(responders, type) {
        const { color, borderColor, borderWidth, shadowBlur, shadowColor, shadowOffsetX, shadowOffsetY, } = this.theme[type];
        return responders.map((model) => (Object.assign(Object.assign({}, model), { color: (color !== null && color !== void 0 ? color : model.color), thickness: borderWidth, borderColor, style: [
                {
                    shadowBlur,
                    shadowColor,
                    shadowOffsetX,
                    shadowOffsetY,
                },
            ] })));
    }
    getSeriesColor(name, color) {
        const { select, areaOpacity } = this.theme;
        const active = this.activeSeriesMap[name];
        const selected = Object.values(this.activeSeriesMap).some((elem) => !elem);
        return selected
            ? (0,_helpers_color__WEBPACK_IMPORTED_MODULE_5__.getRGBA)(color, active ? select.areaOpacity : select.restSeries.areaOpacity)
            : (0,_helpers_color__WEBPACK_IMPORTED_MODULE_5__.getRGBA)(color, areaOpacity);
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/boxStackSeries.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/boxStackSeries.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BoxStackSeries)
/* harmony export */ });
/* harmony import */ var _boxSeries__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./boxSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/boxSeries.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _store_stackSeriesData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../store/stackSeriesData */ "./node_modules/@toast-ui/chart/dist/esm/store/stackSeriesData.js");
/* harmony import */ var _helpers_boxSeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/boxSeries */ "./node_modules/@toast-ui/chart/dist/esm/helpers/boxSeries.js");
/* harmony import */ var _helpers_dataLabels__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../helpers/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/helpers/dataLabels.js");
/* harmony import */ var _helpers_color__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../helpers/color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");
/* harmony import */ var _helpers_legend__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/legend */ "./node_modules/@toast-ui/chart/dist/esm/helpers/legend.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _helpers_range__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/range */ "./node_modules/@toast-ui/chart/dist/esm/helpers/range.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");












function calibrateDrawingValue(values, seriesIndex, renderOptions) {
    const { stack, min, max } = renderOptions;
    return (0,_store_stackSeriesData__WEBPACK_IMPORTED_MODULE_0__.isPercentStack)(stack)
        ? values[seriesIndex]
        : (0,_helpers_boxSeries__WEBPACK_IMPORTED_MODULE_1__.calibrateBoxStackDrawingValue)(values, seriesIndex, min, max);
}
function getDivisorForPercent(total, scaleType) {
    const { positive, negative } = total;
    let divisor = positive + Math.abs(negative);
    if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.includes)(['dualPercentStack', 'divergingPercentStack'], scaleType)) {
        divisor *= 2;
    }
    return divisor;
}
function getDirectionKeys(seriesDirection) {
    let result = ['positive', 'negative'];
    if (seriesDirection === _boxSeries__WEBPACK_IMPORTED_MODULE_3__.SeriesDirection.POSITIVE) {
        result = ['positive'];
    }
    else if (seriesDirection === _boxSeries__WEBPACK_IMPORTED_MODULE_3__.SeriesDirection.NEGATIVE) {
        result = ['negative'];
    }
    return result;
}
function getStackSeriesDataInViewRange(stackSeriesData, viewRange) {
    if (!viewRange) {
        return stackSeriesData;
    }
    const stackData = Array.isArray(stackSeriesData.stackData)
        ? (0,_helpers_range__WEBPACK_IMPORTED_MODULE_4__.getDataInRange)(stackSeriesData.stackData, viewRange)
        : Object.assign({}, Object.keys(stackSeriesData.stackData).reduce((acc, name) => (Object.assign(Object.assign({}, acc), { [name]: (0,_helpers_range__WEBPACK_IMPORTED_MODULE_4__.getDataInRange)(stackSeriesData.stackData[name], viewRange) })), {}));
    const data = stackSeriesData.data.map((seriesDatum) => (Object.assign(Object.assign({}, seriesDatum), { data: (0,_helpers_range__WEBPACK_IMPORTED_MODULE_4__.getDataInRange)(seriesDatum.data, viewRange) })));
    return Object.assign(Object.assign({}, stackSeriesData), { data, stackData });
}
class BoxStackSeries extends _boxSeries__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor() {
        super(...arguments);
        this.selectSeries = ({ index, seriesIndex, state, }) => {
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.isNumber)(index) || !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.isNumber)(seriesIndex)) {
                return;
            }
            const { stackSeries } = state;
            const stackSeriesData = stackSeries[this.name];
            const { name } = stackSeriesData.data[seriesIndex];
            const model = this.tooltipRectMap[index].find(({ name: seriesName }) => seriesName === name);
            if (!model) {
                throw new Error(_message__WEBPACK_IMPORTED_MODULE_5__.message.SELECT_SERIES_API_INDEX_ERROR);
            }
            this.eventBus.emit('renderSelectedSeries', {
                models: this.getRespondersWithTheme([model], 'select'),
                name: this.name,
                eventDetectType: this.eventDetectType,
            });
            this.eventBus.emit('needDraw');
        };
    }
    initialize({ name, stackChart }) {
        this.initializeFields(name);
        if (stackChart) {
            this.eventBus.on('selectSeries', this.selectSeries);
            this.eventBus.on('showTooltip', this.showTooltip);
            this.eventBus.on('hideTooltip', this.onMouseoutComponent);
        }
    }
    render(chartState, computed) {
        var _a, _b;
        const { layout, series: seriesData, axes, stackSeries, legend, theme, scale } = chartState;
        const { viewRange } = computed;
        this.isShow = !!stackSeries[this.name];
        if (!this.isShow) {
            return;
        }
        const categories = (_a = chartState.categories, (_a !== null && _a !== void 0 ? _a : []));
        const options = this.getOptions(chartState.options);
        this.setEventDetectType(seriesData, options);
        this.theme = theme.series[this.name];
        this.rect = layout.plot;
        this.activeSeriesMap = (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_6__.getActiveSeriesMap)(legend);
        this.selectable = this.getSelectableOption(options);
        const stackSeriesData = getStackSeriesDataInViewRange(stackSeries[this.name], viewRange);
        const { tickDistance } = axes[this.labelAxis];
        const diverging = !!((_b = options.series) === null || _b === void 0 ? void 0 : _b.diverging);
        const { limit, stepSize } = this.getScaleData(scale);
        const labels = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_7__.makeLabelsFromLimit)(limit, stepSize);
        const { min, max } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_8__.getLimitOnAxis)(labels);
        const { stack, scaleType } = stackSeriesData;
        this.basePosition = this.getBasePosition(axes[this.valueAxis]);
        let offsetSize = this.getOffsetSize();
        const { centerYAxis } = axes;
        if (diverging) {
            const [left, right] = this.getDivergingBasePosition(centerYAxis);
            this.basePosition = this.getOffsetSize() / 2;
            this.leftBasePosition = left;
            this.rightBasePosition = right;
            offsetSize = this.getOffsetSizeWithDiverging(centerYAxis);
        }
        const renderOptions = {
            stack,
            scaleType,
            tickDistance,
            min,
            max,
            diverging,
            hasNegativeValue: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.hasNegative)(labels),
            seriesDirection: this.getSeriesDirection(labels),
            defaultPadding: (0,_helpers_style__WEBPACK_IMPORTED_MODULE_9__.getBoxTypeSeriesPadding)(tickDistance),
            offsetSize,
            centerYAxis,
        };
        const { series, connector } = this.renderStackSeriesModel(stackSeriesData, renderOptions);
        const clipRect = this.renderClipRectAreaModel();
        const tooltipData = this.getTooltipData(stackSeriesData, categories);
        this.models = {
            clipRect: [clipRect],
            series,
            connector,
        };
        if (!this.drawModels) {
            this.drawModels = {
                clipRect: [this.initClipRect(clipRect)],
                series: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.deepCopyArray)(series),
                connector: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.deepCopyArray)(connector),
            };
        }
        if ((0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_10__.getDataLabelsOptions)(options, this.name).visible) {
            const dataLabelData = this.getDataLabels(series, renderOptions);
            const stackTotalData = this.getTotalDataLabels(stackSeriesData, renderOptions);
            this.renderDataLabels([...dataLabelData, ...stackTotalData]);
        }
        this.tooltipRectMap = this.makeTooltipRectMap(series, tooltipData);
        this.responders = this.getBoxSeriesResponders(series, tooltipData, axes, categories);
    }
    renderStackSeriesModel(seriesData, renderOptions) {
        const { stackData } = seriesData;
        return (0,_store_stackSeriesData__WEBPACK_IMPORTED_MODULE_0__.isGroupStack)(stackData)
            ? this.makeStackGroupSeriesModel(seriesData, renderOptions)
            : this.makeStackSeriesModel(stackData, renderOptions, seriesData.data);
    }
    makeStackSeriesModel(stackData, renderOptions, seriesRawData, stackGroupCount = 1, stackGroupIndex = 0) {
        const seriesModels = [];
        const columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);
        const { diverging } = renderOptions;
        const isLBSideWithDiverging = diverging && (0,_boxSeries__WEBPACK_IMPORTED_MODULE_3__.isLeftBottomSide)(stackGroupIndex);
        stackData.forEach(({ values, total }, dataIndex) => {
            const seriesPos = this.getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount);
            const ratio = this.getStackValueRatio(total, renderOptions);
            values.forEach((value, seriesIndex) => {
                const { barLength, dataPosition } = this.getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging);
                const { name, colorByCategories, color: rawColor } = seriesRawData[seriesIndex];
                const active = this.activeSeriesMap[name];
                const colorLength = rawColor.length || 1;
                const hexColor = colorByCategories ? rawColor[dataIndex % colorLength] : rawColor;
                const color = (0,_helpers_color__WEBPACK_IMPORTED_MODULE_11__.getRGBA)(hexColor, active ? 1 : 0.2);
                seriesModels.push(Object.assign(Object.assign({ type: 'rect', color,
                    name,
                    value }, this.getAdjustedRect(seriesPos, dataPosition, (barLength !== null && barLength !== void 0 ? barLength : 0), columnWidth)), { index: dataIndex }));
            });
        });
        return {
            series: seriesModels,
            connector: this.makeConnectorSeriesModel(stackData, renderOptions, stackGroupCount, stackGroupIndex),
        };
    }
    makeStackGroupSeriesModel(stackSeries, renderOptions) {
        const { stack } = renderOptions;
        const stackGroupData = stackSeries.stackData;
        const seriesRawData = stackSeries.data;
        const stackGroupIds = Object.keys(stackGroupData);
        let seriesModels = [];
        let connectorModels = [];
        stackGroupIds.forEach((groupId, groupIndex) => {
            const filtered = seriesRawData.filter(({ stackGroup }) => stackGroup === groupId);
            const { series, connector } = this.makeStackSeriesModel(stackGroupData[groupId], renderOptions, filtered, stackGroupIds.length, groupIndex);
            seriesModels = [...seriesModels, ...series];
            if (stack.connector) {
                connectorModels = [...connectorModels, ...connector];
            }
        });
        return {
            series: seriesModels,
            connector: connectorModels,
        };
    }
    makeConnectorSeriesModel(stackData, renderOptions, stackGroupCount = 1, stackGroupIndex = 0) {
        const { diverging, stack: { connector }, } = renderOptions;
        if (!connector) {
            return [];
        }
        const columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);
        const isLBSideWithDiverging = diverging && (0,_boxSeries__WEBPACK_IMPORTED_MODULE_3__.isLeftBottomSide)(stackGroupIndex);
        const connectorPoints = [];
        stackData.forEach(({ values, total }, index) => {
            const seriesPos = this.getSeriesPosition(renderOptions, columnWidth, index, stackGroupIndex, stackGroupCount);
            const points = [];
            const ratio = this.getStackValueRatio(total, renderOptions);
            values.forEach((value, seriesIndex) => {
                const { barLength, dataPosition } = this.getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging);
                const { x, y } = this.getAdjustedRect(seriesPos, dataPosition, barLength, columnWidth);
                const xPos = !isLBSideWithDiverging && this.isBar ? x + barLength : x;
                const yPos = isLBSideWithDiverging && !this.isBar ? y + barLength : y;
                points.push({ x: xPos, y: yPos });
            });
            connectorPoints.push(points);
        });
        return this.makeConnectorModel(connectorPoints, connector, columnWidth);
    }
    getTooltipData(seriesData, categories) {
        const seriesRawData = seriesData.data;
        const { stackData } = seriesData;
        const colors = seriesRawData.map(({ color }) => color);
        return (0,_store_stackSeriesData__WEBPACK_IMPORTED_MODULE_0__.isGroupStack)(stackData)
            ? this.makeGroupStackTooltipData(seriesRawData, stackData, categories)
            : this.makeStackTooltipData(seriesRawData, stackData, colors, categories);
    }
    makeGroupStackTooltipData(seriesRawData, stackData, categories) {
        return Object.keys(stackData).flatMap((groupId) => {
            const rawDataWithSameGroupId = seriesRawData.filter(({ stackGroup }) => stackGroup === groupId);
            const colors = rawDataWithSameGroupId.map(({ color }) => color);
            return this.makeStackTooltipData(rawDataWithSameGroupId, stackData[groupId], colors, categories);
        });
    }
    makeStackTooltipData(seriesRawData, stackData, colors, categories) {
        const tooltipData = [];
        stackData.forEach(({ values }, dataIndex) => {
            values.forEach((value, seriesIndex) => {
                tooltipData.push({
                    label: seriesRawData[seriesIndex].name,
                    color: colors[seriesIndex],
                    value,
                    category: categories.length ? categories[dataIndex] : '',
                });
            });
        });
        return tooltipData;
    }
    makeConnectorModel(pointsForConnector, connector, columnWidth) {
        if (!connector || !pointsForConnector.length) {
            return [];
        }
        const { color, lineWidth, dashSegments } = this.theme.connector;
        const connectorModels = [];
        const seriesDataCount = pointsForConnector.length;
        const seriesCount = pointsForConnector[0].length;
        for (let seriesIndex = 0; seriesIndex < seriesCount; seriesIndex += 1) {
            const points = [];
            for (let dataIndex = 0; dataIndex < seriesDataCount; dataIndex += 1) {
                points.push(pointsForConnector[dataIndex][seriesIndex]);
            }
            points.forEach((point, index) => {
                const { x, y } = point;
                if (index < points.length - 1) {
                    const { x: nextX, y: nextY } = points[index + 1];
                    connectorModels.push({
                        type: 'line',
                        x: this.isBar ? x : x + columnWidth,
                        y: this.isBar ? y + columnWidth : y,
                        x2: nextX,
                        y2: nextY,
                        dashSegments,
                        strokeStyle: color,
                        lineWidth,
                    });
                }
            });
        }
        return connectorModels;
    }
    getStackValueRatio(total, renderOptions) {
        const { stack: { type: stackType }, scaleType, min, max, offsetSize, } = renderOptions;
        if (stackType === 'percent') {
            return offsetSize / getDivisorForPercent(total, scaleType);
        }
        return this.getValueRatio(min, max, offsetSize);
    }
    getStackBarLength(values, seriesIndex, ratio, renderOptions) {
        const value = calibrateDrawingValue(values, seriesIndex, renderOptions);
        return (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.isNumber)(value) ? this.getBarLength(value, ratio) : null;
    }
    getStackColumnWidth(renderOptions, stackGroupCount) {
        const { tickDistance, diverging, defaultPadding } = renderOptions;
        const divisor = diverging ? 1 : stackGroupCount;
        const themeBarWidth = this.theme.barWidth;
        return themeBarWidth
            ? (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.calculateSizeWithPercentString)(tickDistance, themeBarWidth)
            : (tickDistance - defaultPadding * 2) / divisor;
    }
    getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount) {
        const { tickDistance, diverging } = renderOptions;
        const groupIndex = diverging ? 0 : stackGroupIndex;
        const groupCount = diverging ? 1 : stackGroupCount;
        const padding = (tickDistance - columnWidth * groupCount) / 2;
        return dataIndex * tickDistance + padding + columnWidth * groupIndex;
    }
    getStackStartPosition(values, currentIndex, ratio, renderOptions, isLBSideWithDiverging) {
        const { stack, diverging, seriesDirection } = renderOptions;
        let startPos;
        if (diverging) {
            startPos = isLBSideWithDiverging
                ? this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio)
                : this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);
        }
        else if ((0,_store_stackSeriesData__WEBPACK_IMPORTED_MODULE_0__.isPercentStack)(stack)) {
            startPos = this.calcStartPositionWithPercent(values, currentIndex, ratio);
        }
        else if (seriesDirection === _boxSeries__WEBPACK_IMPORTED_MODULE_3__.SeriesDirection.POSITIVE) {
            startPos = this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);
        }
        else if (seriesDirection === _boxSeries__WEBPACK_IMPORTED_MODULE_3__.SeriesDirection.NEGATIVE) {
            startPos = this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio);
        }
        else {
            startPos = this.calcStartPositionWithStack(values, currentIndex, renderOptions, ratio);
        }
        return startPos;
    }
    calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio) {
        const { min, max, diverging } = renderOptions;
        const basePosition = diverging ? this.leftBasePosition : this.basePosition;
        const totalOfIndexBefore = (0,_helpers_boxSeries__WEBPACK_IMPORTED_MODULE_1__.sumValuesBeforeIndex)(values, currentIndex, false);
        const totalOfValues = (0,_helpers_boxSeries__WEBPACK_IMPORTED_MODULE_1__.sumValuesBeforeIndex)(values, currentIndex, true);
        const collideEdge = totalOfValues < min;
        const usingValue = this.isBar ? totalOfValues : totalOfIndexBefore;
        const result = max < 0 ? Math.min(usingValue - max, 0) : usingValue;
        let pos;
        if (this.isBar) {
            pos = collideEdge ? 0 : basePosition - Math.abs(result) * ratio;
        }
        else {
            pos = basePosition + Math.abs(result) * ratio;
        }
        return pos;
    }
    calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio) {
        const { min, max, diverging } = renderOptions;
        const basePosition = diverging ? this.rightBasePosition : this.basePosition;
        const totalOfIndexBefore = (0,_helpers_boxSeries__WEBPACK_IMPORTED_MODULE_1__.sumValuesBeforeIndex)(values, currentIndex, false);
        const totalOfValues = (0,_helpers_boxSeries__WEBPACK_IMPORTED_MODULE_1__.sumValuesBeforeIndex)(values, currentIndex, true);
        const collideEdge = totalOfValues > max;
        const usingValue = this.isBar ? totalOfIndexBefore : totalOfValues;
        const result = min > 0 ? Math.max(usingValue - min, 0) : usingValue;
        const barLength = result * ratio;
        let pos;
        if (this.isBar) {
            pos = basePosition + barLength;
        }
        else {
            pos = collideEdge ? 0 : basePosition - barLength;
        }
        return pos;
    }
    calcStartPositionWithStack(values, currentIndex, renderOptions, ratio) {
        return values[currentIndex] < 0
            ? this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio)
            : this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);
    }
    calcStartPositionWithPercent(values, currentIndex, ratio) {
        const basePosition = this.basePosition;
        const totalPrevValues = (0,_helpers_boxSeries__WEBPACK_IMPORTED_MODULE_1__.sumValuesBeforeIndex)(values, currentIndex, this.isBar ? values[currentIndex] < 0 : values[currentIndex] > 0);
        return this.isBar
            ? totalPrevValues * ratio + basePosition
            : basePosition - totalPrevValues * ratio;
    }
    getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging) {
        const barLength = this.getStackBarLength(values, seriesIndex, ratio, renderOptions);
        const dataPosition = this.getStackStartPosition(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging);
        return {
            barLength,
            dataPosition,
        };
    }
    getDataLabels(seriesModels, renderOptions) {
        return seriesModels.map((data) => this.makeDataLabel(data, renderOptions.centerYAxis));
    }
    getTotalDataLabels(seriesData, renderOptions) {
        const { stackData, stack } = seriesData;
        if ((0,_store_stackSeriesData__WEBPACK_IMPORTED_MODULE_0__.isPercentStack)(stack)) {
            return [];
        }
        return (0,_store_stackSeriesData__WEBPACK_IMPORTED_MODULE_0__.isGroupStack)(stackData)
            ? this.makeGroupTotalDataLabels(seriesData, renderOptions)
            : this.makeTotalDataLabels(stackData, renderOptions);
    }
    makeGroupTotalDataLabels(stackSeries, renderOptions) {
        let dataLabels = [];
        const stackGroupData = stackSeries.stackData;
        const stackGroupIds = Object.keys(stackGroupData);
        stackGroupIds.forEach((groupId, groupIndex) => {
            const totalDataLabels = this.makeTotalDataLabels(stackGroupData[groupId], renderOptions, stackGroupIds.length, groupIndex);
            dataLabels = [...dataLabels, ...totalDataLabels];
        });
        return dataLabels;
    }
    makeTotalDataLabels(stackData, renderOptions, stackGroupCount = 1, stackGroupIndex = 0) {
        const dataLabels = [];
        const { min, max, seriesDirection, diverging, centerYAxis } = renderOptions;
        const columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);
        stackData.forEach((data, dataIndex) => {
            const { total } = data;
            const seriesPos = this.getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount);
            const ratio = this.getStackValueRatio(total, renderOptions);
            const directionKeys = getDirectionKeys(seriesDirection);
            directionKeys.forEach((key) => {
                const value = total[key];
                if (!value) {
                    return;
                }
                const barLength = this.makeBarLength(value, {
                    min,
                    max,
                    ratio,
                });
                const dataPosition = this.getStartPosition(barLength, value, renderOptions, diverging && (0,_boxSeries__WEBPACK_IMPORTED_MODULE_3__.isLeftBottomSide)(stackGroupIndex));
                const stackTotal = Object.assign({ type: 'stackTotal', value, name: `totalLabel-${key}`, theme: this.theme.dataLabels.stackTotal }, this.getAdjustedRect(seriesPos, dataPosition, barLength, columnWidth));
                dataLabels.push(this.makeTotalDataLabel(stackTotal, centerYAxis));
            });
        });
        return dataLabels;
    }
    makeTotalDataLabel(totalLabel, centerYAxis) {
        return Object.assign(Object.assign({}, totalLabel), { direction: this.getDataLabelDirection(totalLabel, centerYAxis), plot: {
                x: 0,
                y: 0,
                size: this.getOffsetSize(),
            } });
    }
    onMousemoveGroupedType(responders) {
        const rectModels = this.getRectModelsFromRectResponders(responders);
        this.eventBus.emit('renderHoveredSeries', {
            models: [...rectModels, ...this.getGroupedRect(responders, 'hover')],
            name: this.name,
            eventDetectType: this.eventDetectType,
        });
        this.activatedResponders = rectModels;
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/bubbleSeries.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/bubbleSeries.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getMaxRadius": () => (/* binding */ getMaxRadius),
/* harmony export */   "default": () => (/* binding */ BubbleSeries)
/* harmony export */ });
/* harmony import */ var _helpers_coordinate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/coordinate */ "./node_modules/@toast-ui/chart/dist/esm/helpers/coordinate.js");
/* harmony import */ var _helpers_color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_legend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/legend */ "./node_modules/@toast-ui/chart/dist/esm/helpers/legend.js");
/* harmony import */ var _helpers_responders__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/responders */ "./node_modules/@toast-ui/chart/dist/esm/helpers/responders.js");
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");








const MINIMUM_RADIUS = 0.5;
const MINIMUM_DETECTING_AREA_RADIUS = 1;
function getMaxRadius(bubbleData) {
    return bubbleData.reduce((acc, cur) => {
        const NonNullData = cur.data.filter((datum) => !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNull)(datum));
        return Math.max(acc, ...NonNullData.map(({ r }) => r));
    }, 0);
}
class BubbleSeries extends _component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(...arguments);
        this.models = { series: [] };
        this.activatedResponders = [];
        this.maxRadius = -1;
        this.maxValue = -1;
        this.onMouseoutComponent = () => {
            this.eventBus.emit('seriesPointHovered', { models: [], name: this.name });
            this.eventBus.emit('renderHoveredSeries', {
                models: [],
                name: this.name,
            });
            this.eventBus.emit('needDraw');
        };
        this.selectSeries = ({ index, seriesIndex, state }) => {
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(index) || !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(seriesIndex)) {
                return;
            }
            const { name } = state.series.bubble.data[index];
            const model = this.responders.filter(({ name: dataName }) => dataName === name)[seriesIndex];
            if (!model) {
                throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.SELECT_SERIES_API_INDEX_ERROR);
            }
            const models = this.getResponderAppliedTheme([model], 'select');
            this.eventBus.emit('renderSelectedSeries', { models, name: this.name });
            this.eventBus.emit('needDraw');
        };
        this.showTooltip = (info) => {
            const { index, seriesIndex, state } = info;
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(index) || !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(seriesIndex)) {
                return;
            }
            const { name } = state.series.bubble.data[seriesIndex];
            const models = [this.responders.filter(({ name: dataName }) => dataName === name)[index]];
            if (!models.length) {
                return;
            }
            this.eventBus.emit('renderHoveredSeries', { models, name: this.name });
            this.activatedResponders = models;
            this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });
            this.eventBus.emit('needDraw');
        };
    }
    initialize() {
        this.type = 'series';
        this.name = 'bubble';
        this.eventBus.on('selectSeries', this.selectSeries);
        this.eventBus.on('showTooltip', this.showTooltip);
        this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
    initUpdate(delta) {
        this.drawModels.series.forEach((model, index) => {
            model.radius = this.models.series[index].radius * delta;
        });
    }
    render(chartState) {
        const { layout, series, scale, axes, circleLegend, legend, options, theme } = chartState;
        const { plot } = layout;
        if (!series.bubble) {
            throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.noDataError(this.name));
        }
        const { xAxis, yAxis } = axes;
        const bubbleData = series.bubble.data;
        this.theme = theme.series.bubble;
        this.rect = plot;
        this.activeSeriesMap = (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_3__.getActiveSeriesMap)(legend);
        this.selectable = this.getSelectableOption(options);
        const xAxisTickSize = this.rect.width / xAxis.tickCount;
        const yAxisTickSize = this.rect.height / yAxis.tickCount;
        this.maxRadius = circleLegend.radius
            ? circleLegend.radius
            : Math.min(xAxisTickSize, yAxisTickSize);
        this.maxValue = getMaxRadius(bubbleData);
        const seriesModel = this.renderBubblePointsModel(bubbleData, scale);
        const tooltipModel = this.makeTooltipModel(bubbleData);
        this.models.series = seriesModel;
        if (!this.drawModels) {
            this.drawModels = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.deepCopy)(this.models);
        }
        this.responders = seriesModel.map((m, index) => (Object.assign(Object.assign({}, m), { type: 'circle', detectionSize: 0, radius: m.radius + MINIMUM_DETECTING_AREA_RADIUS, color: (0,_helpers_color__WEBPACK_IMPORTED_MODULE_4__.getRGBA)(m.color, 0.85), data: tooltipModel[index], index })));
    }
    renderBubblePointsModel(seriesRawData, scale) {
        const xAxisLimit = scale.xAxis.limit;
        const yAxisLimit = scale.yAxis.limit;
        const { borderWidth, borderColor } = this.theme;
        return seriesRawData.flatMap(({ data, name, color: seriesColor }, seriesIndex) => {
            const circleModels = [];
            const active = this.activeSeriesMap[name];
            const color = (0,_helpers_color__WEBPACK_IMPORTED_MODULE_4__.getRGBA)(seriesColor, active ? 0.8 : 0.1);
            const nonNullData = data.filter((datum) => !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNull)(datum));
            nonNullData.forEach((datum) => {
                const rawXValue = (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_5__.getCoordinateXValue)(datum);
                const xValue = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(rawXValue) ? Number(new Date(rawXValue)) : Number(rawXValue);
                const yValue = (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_5__.getCoordinateYValue)(datum);
                const xValueRatio = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_6__.getValueRatio)(xValue, xAxisLimit);
                const yValueRatio = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_6__.getValueRatio)(yValue, yAxisLimit);
                const x = xValueRatio * this.rect.width;
                const y = (1 - yValueRatio) * this.rect.height;
                const radius = Math.max(MINIMUM_RADIUS, (datum.r / this.maxValue) * this.maxRadius);
                circleModels.push({
                    x,
                    y,
                    type: 'circle',
                    radius,
                    color,
                    style: ['default'],
                    seriesIndex,
                    name,
                    borderWidth,
                    borderColor,
                });
            });
            return circleModels;
        });
    }
    makeTooltipModel(circleData) {
        return [...circleData].flatMap(({ data, name, color }) => {
            const tooltipData = [];
            const nonNullData = data.filter((datum) => !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNull)(datum));
            nonNullData.forEach((datum) => {
                const { r, label } = datum;
                tooltipData.push({
                    label: `${name}/${label}`,
                    color,
                    value: {
                        x: (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_5__.getCoordinateXValue)(datum),
                        y: (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_5__.getCoordinateYValue)(datum),
                        r,
                    },
                });
            });
            return tooltipData;
        });
    }
    getResponderAppliedTheme(responders, type) {
        return responders.map((responder) => (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.deepMergedCopy)(responder, this.theme[type]));
    }
    onMousemove({ responders, mousePosition }) {
        const closestResponder = (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_7__.getNearestResponder)(responders, mousePosition, this.rect);
        const responderWithTheme = this.getResponderAppliedTheme(closestResponder, 'hover');
        this.eventBus.emit('renderHoveredSeries', { models: responderWithTheme, name: this.name });
        this.activatedResponders = closestResponder;
        this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });
        this.eventBus.emit('needDraw');
    }
    onClick({ responders, mousePosition }) {
        if (this.selectable) {
            const closestResponder = (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_7__.getNearestResponder)(responders, mousePosition, this.rect);
            const responderWithTheme = this.getResponderAppliedTheme(closestResponder, 'select');
            this.eventBus.emit('renderSelectedSeries', {
                models: responderWithTheme,
                name: this.name,
            });
            this.eventBus.emit('needDraw');
        }
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/bulletSeries.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/bulletSeries.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BulletSeries)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_legend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/legend */ "./node_modules/@toast-ui/chart/dist/esm/helpers/legend.js");
/* harmony import */ var _helpers_color__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _helpers_dataLabels__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/helpers/dataLabels.js");
/* harmony import */ var _helpers_theme__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helpers/theme */ "./node_modules/@toast-ui/chart/dist/esm/helpers/theme.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");
/* harmony import */ var _helpers_responders__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/responders */ "./node_modules/@toast-ui/chart/dist/esm/helpers/responders.js");









const DEFAULT_WIDTH_RATIO = 0.6;
const MARKER_LINE_DETECTION_SIZE = 5;
function getRectSize(vertical, barWidth, barLength) {
    return {
        width: vertical ? barWidth : barLength,
        height: vertical ? barLength : barWidth,
    };
}
function getStartX(seriesIndex, tickDistance, barWidth) {
    return seriesIndex * tickDistance + (tickDistance - barWidth) / 2;
}
function makeBulletResponderModel(models, tooltipData) {
    const { range, marker, bullet } = models;
    const { range: tooltipRange, marker: tooltipMarker, bullet: tooltipBullet } = tooltipData;
    return [
        ...range.map((m, index) => (Object.assign(Object.assign({}, m), { data: tooltipRange[index] }))),
        ...bullet.map((m, index) => (Object.assign(Object.assign({}, m), { data: tooltipBullet[index] }))),
        ...marker.map((m, index) => (Object.assign(Object.assign({}, m), { detectionSize: MARKER_LINE_DETECTION_SIZE, data: tooltipMarker[index] }))),
    ];
}
class BulletSeries extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.models = { range: [], bullet: [], marker: [] };
        this.activatedResponders = [];
        this.eventDetectType = 'point';
        this.vertical = false;
        this.onMouseoutComponent = () => {
            this.eventBus.emit('seriesPointHovered', { models: [], name: this.name });
            this.eventBus.emit('renderHoveredSeries', {
                models: [],
                name: this.name,
            });
            this.eventBus.emit('needDraw');
        };
        this.selectSeries = ({ seriesIndex, state }) => {
            var _a;
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(seriesIndex)) {
                return;
            }
            const { name } = (_a = state.series.bullet) === null || _a === void 0 ? void 0 : _a[seriesIndex];
            const model = this.filterBulletResponder(this.responders).filter(({ name: dataName }) => dataName === name);
            if (!model) {
                throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.SELECT_SERIES_API_INDEX_ERROR);
            }
            this.eventBus.emit('renderSelectedSeries', {
                models: this.getRespondersWithTheme(model, 'select'),
                name: this.name,
            });
            this.eventBus.emit('needDraw');
        };
        this.showTooltip = ({ seriesIndex, state }) => {
            var _a;
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(seriesIndex)) {
                return;
            }
            const { name } = (_a = state.series.bullet) === null || _a === void 0 ? void 0 : _a[seriesIndex];
            const models = this.filterBulletResponder(this.responders).filter(({ name: dataName }) => dataName === name);
            if (!models.length) {
                return;
            }
            this.onMousemove({ responders: models });
        };
    }
    initialize() {
        this.type = 'series';
        this.name = 'bullet';
        this.eventBus.on('selectSeries', this.selectSeries);
        this.eventBus.on('showTooltip', this.showTooltip);
        this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
    initUpdate(delta) {
        if (!this.drawModels) {
            return;
        }
        const { clipRect } = this.drawModels;
        if (!clipRect) {
            return;
        }
        const offsetKey = this.vertical ? 'y' : 'x';
        const key = this.vertical ? 'height' : 'width';
        const current = clipRect[0];
        const target = this.models.clipRect[0];
        const offsetSize = current[key] + (target[key] - current[key]) * delta;
        current[key] = offsetSize;
        current[offsetKey] = Math.max(this.basePosition - (offsetSize * this.basePosition) / target[key], 0);
    }
    render(state) {
        var _a, _b;
        const { layout, axes, series, scale, legend, options, theme, categories } = state;
        if (!series.bullet) {
            throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.noDataError(this.name));
        }
        this.setEventDetectType(series, options);
        this.theme = theme.series.bullet;
        this.rect = layout.plot;
        this.activeSeriesMap = (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_3__.getActiveSeriesMap)(legend);
        this.selectable = this.getSelectableOption(options);
        this.vertical = !!((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.vertical);
        const labelAxisOnYAxis = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_4__.isLabelAxisOnYAxis)({ series, options });
        const { labelAxisName, valueAxisName } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_4__.getAxisName)(labelAxisOnYAxis, series);
        const { valueSizeKey } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_4__.getSizeKey)(labelAxisOnYAxis);
        const { tickDistance } = axes[labelAxisName];
        const { zeroPosition } = axes[valueAxisName];
        const { min, max } = scale[valueAxisName].limit;
        const bulletData = series.bullet.data;
        this.basePosition = (zeroPosition !== null && zeroPosition !== void 0 ? zeroPosition : 0);
        const renderOptions = Object.assign({ ratio: this.rect[valueSizeKey] / (max - min), tickDistance,
            zeroPosition }, this.getBulletBarWidths(tickDistance));
        const rangeModels = this.renderRanges(bulletData, renderOptions);
        const bulletModels = this.renderBullet(bulletData, renderOptions);
        const markerModels = this.renderMarkers(bulletData, renderOptions);
        const clipRect = this.renderClipRectArea();
        this.models.clipRect = [clipRect];
        this.models.range = rangeModels;
        this.models.bullet = bulletModels;
        this.models.marker = markerModels;
        if (!this.drawModels) {
            this.drawModels = {
                clipRect: [this.makeInitialClipRectModel(clipRect)],
                range: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.deepCopyArray)(rangeModels),
                bullet: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.deepCopyArray)(bulletModels),
                marker: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.deepCopyArray)(markerModels),
            };
        }
        const models = {
            range: rangeModels,
            bullet: bulletModels,
            marker: markerModels,
        };
        const tooltipData = this.makeTooltipModel(models);
        this.tooltipRectMap = this.makeTooltipRectMap(models, tooltipData);
        this.responders = this.getBulletSeriesResponders(models, tooltipData, axes, categories);
        if ((0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_5__.getDataLabelsOptions)(options, this.name).visible) {
            this.renderDataLabels(this.getDataLabels([...rangeModels, ...bulletModels, ...markerModels], this.vertical, this.rect[valueSizeKey]));
        }
    }
    renderClipRectArea() {
        return {
            type: 'clipRectArea',
            x: 0,
            y: 0,
            width: this.rect.width,
            height: this.rect.height,
        };
    }
    makeInitialClipRectModel(clipRect) {
        const width = this.vertical ? clipRect.width : 0;
        const height = this.vertical ? 0 : clipRect.height;
        const x = this.vertical ? clipRect.x : 0;
        const y = this.vertical ? 0 : clipRect.y;
        return { type: 'clipRectArea', width, height, x, y };
    }
    getDataLabels(seriesModels, vertical, size) {
        const { dataLabels: dataLabelTheme } = this.theme;
        const bulletLabelTheme = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.omit)(dataLabelTheme, 'marker');
        const { useSeriesColor, color } = bulletLabelTheme;
        const { marker } = dataLabelTheme;
        return seriesModels
            .filter((m) => m.type === 'line' || m.modelType !== 'range')
            .map((m) => {
            var _a;
            if (m.type === 'line') {
                return Object.assign(Object.assign({}, m), { x: vertical ? (m.x + m.x2) / 2 : m.x, theme: Object.assign(Object.assign({}, marker), { color: marker.useSeriesColor ? m.strokeStyle : marker.color }) });
            }
            const isValueNegative = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(m.value) && ((_a = m) === null || _a === void 0 ? void 0 : _a.value) < 0;
            let direction = vertical ? 'top' : 'right';
            if (isValueNegative) {
                direction = vertical ? 'bottom' : 'left';
            }
            return Object.assign(Object.assign({}, m), { direction, plot: {
                    x: 0,
                    y: 0,
                    size,
                }, theme: Object.assign(Object.assign({}, bulletLabelTheme), { color: useSeriesColor ? m.color : color }) });
        });
    }
    setEventDetectType(series, options) {
        var _a, _b;
        if ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.eventDetectType) {
            this.eventDetectType = options.series.eventDetectType;
        }
    }
    getBulletSeriesResponders(models, tooltipData, axes, categories) {
        return this.eventDetectType === 'grouped'
            ? (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_6__.makeRectResponderModel)(this.rect, (this.vertical ? axes.xAxis : axes.yAxis), categories, this.vertical)
            : makeBulletResponderModel(models, tooltipData);
    }
    makeTooltipRectMap(models, tooltipData) {
        const result = {};
        Object.keys(models).forEach((seriesType) => {
            models[seriesType].forEach((m, index) => {
                const label = m.name;
                if (!result[label]) {
                    result[label] = [];
                }
                const tooltipModel = Object.assign(Object.assign({}, m), { data: tooltipData[seriesType][index] });
                result[label].push(tooltipModel);
            });
        });
        return result;
    }
    getBulletSeriesModelsFromRectResponders(responders) {
        var _a;
        if (!responders.length) {
            return [];
        }
        return _a = this.tooltipRectMap[responders[0].label], (_a !== null && _a !== void 0 ? _a : []);
    }
    getGroupedRect(responders, type) {
        const bulletSeriesModels = this.getBulletSeriesModelsFromRectResponders(responders);
        const { color, opacity } = this.theme[type].groupedRect;
        return bulletSeriesModels.length
            ? responders.map((m) => (Object.assign(Object.assign({}, m), { color: (0,_helpers_color__WEBPACK_IMPORTED_MODULE_7__.getRGBA)(color, opacity) })))
            : [];
    }
    onMousemoveGroupedType(responders) {
        const bulletSeriesModels = this.getBulletSeriesModelsFromRectResponders(responders);
        this.eventBus.emit('renderHoveredSeries', {
            models: [
                ...this.getGroupedRect(responders, 'hover'),
                ...this.getRespondersWithTheme(bulletSeriesModels, 'hover'),
            ],
            name: this.name,
            eventDetectType: this.eventDetectType,
        });
        this.activatedResponders = bulletSeriesModels;
    }
    onMousemove({ responders }) {
        if (this.eventDetectType === 'grouped') {
            this.onMousemoveGroupedType(responders);
        }
        else {
            this.eventBus.emit('renderHoveredSeries', {
                models: this.getRespondersWithTheme(responders, 'hover'),
                name: this.name,
            });
            this.activatedResponders = responders.length ? [responders[responders.length - 1]] : [];
        }
        this.eventBus.emit('seriesPointHovered', {
            models: this.activatedResponders,
            name: this.name,
        });
        this.eventBus.emit('needDraw');
    }
    onClick({ responders }) {
        if (this.selectable) {
            const models = this.eventDetectType === 'grouped'
                ? [
                    ...this.getGroupedRect(responders, 'select'),
                    ...this.getRespondersWithTheme(this.getBulletSeriesModelsFromRectResponders(responders), 'select'),
                ]
                : this.getRespondersWithTheme(responders, 'select');
            this.eventBus.emit('renderSelectedSeries', {
                models,
                name: this.name,
                eventDetectType: this.eventDetectType,
            });
            this.eventBus.emit('needDraw');
        }
    }
    filterBulletResponder(responders) {
        return responders.filter((model) => { var _a; return ((_a = model) === null || _a === void 0 ? void 0 : _a.modelType) === 'bullet'; });
    }
    renderRanges(bulletData, { tickDistance, ratio, zeroPosition, rangeWidth }) {
        const rangeModels = [];
        bulletData.forEach(({ ranges, color, name }, seriesIndex) => {
            ((ranges !== null && ranges !== void 0 ? ranges : [])).forEach((range, rangeIndex) => {
                if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(range)) {
                    const [start, end] = range;
                    const barLength = (end - start) * ratio;
                    const rangeStartX = getStartX(seriesIndex, tickDistance, rangeWidth);
                    rangeModels.push(Object.assign(Object.assign({ type: 'rect', name, color: this.getRangeColor((0,_helpers_color__WEBPACK_IMPORTED_MODULE_7__.getRGBA)(color, this.getSeriesOpacity(name)), rangeIndex, name), x: this.vertical ? rangeStartX : start * ratio + zeroPosition, y: this.vertical ? zeroPosition - end * ratio : rangeStartX }, getRectSize(this.vertical, rangeWidth, barLength)), { modelType: 'range', seriesColor: color, tooltipColor: this.getRangeColor(color, rangeIndex, name, true), value: range }));
                }
            });
        });
        return rangeModels;
    }
    renderBullet(bulletData, { tickDistance, ratio, zeroPosition, bulletWidth }) {
        const { borderColor, borderWidth: thickness } = this.theme;
        return bulletData.reduce((acc, { data, color, name }, seriesIndex) => {
            if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(data)) {
                return [...acc];
            }
            const bulletLength = Math.max(Math.abs(data * ratio), 2);
            const bulletStartX = getStartX(seriesIndex, tickDistance, bulletWidth);
            const x = this.vertical ? bulletStartX : zeroPosition - (data < 0 ? bulletLength : 0);
            const y = this.vertical
                ? zeroPosition - bulletLength + (data < 0 ? bulletLength : 0)
                : bulletStartX;
            const bullet = Object.assign({ type: 'rect', name, color: (0,_helpers_color__WEBPACK_IMPORTED_MODULE_7__.getRGBA)(color, this.getSeriesOpacity(name)), x,
                y,
                thickness,
                borderColor, modelType: 'bullet', seriesColor: color, tooltipColor: color, value: data }, getRectSize(this.vertical, bulletWidth, bulletLength));
            return [...acc, bullet];
        }, []);
    }
    renderMarkers(bulletData, { tickDistance, ratio, zeroPosition, markerWidth }) {
        const { markerLineWidth } = this.theme;
        const markerModels = [];
        bulletData.forEach(({ markers, color, name }, seriesIndex) => {
            const markerStartX = getStartX(seriesIndex, tickDistance, markerWidth);
            ((markers !== null && markers !== void 0 ? markers : [])).forEach((marker) => {
                if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(marker)) {
                    const dataPosition = marker * ratio;
                    const x = this.vertical ? markerStartX : dataPosition + zeroPosition;
                    const y = this.vertical ? zeroPosition - dataPosition : markerStartX;
                    markerModels.push({
                        type: 'line',
                        name,
                        x,
                        y,
                        x2: this.vertical ? x + markerWidth : x,
                        y2: this.vertical ? y : y + markerWidth,
                        strokeStyle: (0,_helpers_color__WEBPACK_IMPORTED_MODULE_7__.getRGBA)(color, this.getSeriesOpacity(name)),
                        lineWidth: markerLineWidth,
                        seriesColor: color,
                        tooltipColor: color,
                        value: marker,
                    });
                }
            });
        });
        return markerModels;
    }
    makeTooltipModel(seriesModels) {
        const { range, bullet, marker } = seriesModels;
        return {
            range: this.makeTooltipData(range, 'Range'),
            bullet: this.makeTooltipData(bullet, 'Actual'),
            marker: this.makeTooltipData(marker, 'Marker'),
        };
    }
    makeTooltipData(data, title) {
        return data.map((m) => {
            const { name, seriesColor, tooltipColor, value } = m;
            return {
                label: name,
                color: (0,_helpers_color__WEBPACK_IMPORTED_MODULE_7__.getRGBA)(seriesColor, 1),
                value: [{ title, value, color: tooltipColor }],
                templateType: 'bullet',
            };
        });
    }
    getBulletBarWidths(tickDistance) {
        const { barWidth: barThemeWidth, barWidthRatios } = this.theme;
        const { rangeRatio, bulletRatio, markerRatio } = barWidthRatios;
        const barWidth = barThemeWidth
            ? (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.calculateSizeWithPercentString)(tickDistance, barThemeWidth)
            : tickDistance * DEFAULT_WIDTH_RATIO;
        return {
            rangeWidth: barWidth * rangeRatio,
            bulletWidth: barWidth * bulletRatio,
            markerWidth: barWidth * markerRatio,
        };
    }
    getRangeColor(seriesColor, rangeIndex, seriesName, ignoreRestSeriesOpacity = false) {
        const { rangeColors } = this.theme;
        const hasThemeRangeColor = Array.isArray(rangeColors) && rangeColors[rangeIndex];
        const color = hasThemeRangeColor ? rangeColors[rangeIndex] : seriesColor;
        const opacity = hasThemeRangeColor
            ? (0,_helpers_color__WEBPACK_IMPORTED_MODULE_7__.getAlpha)(rangeColors[rangeIndex])
            : _helpers_theme__WEBPACK_IMPORTED_MODULE_8__.DEFAULT_BULLET_RANGE_OPACITY[rangeIndex];
        return (0,_helpers_color__WEBPACK_IMPORTED_MODULE_7__.getRGBA)(color, opacity * this.getSeriesOpacity(seriesName, ignoreRestSeriesOpacity));
    }
    getSeriesOpacity(seriesName, ignoreRestSeriesOpacity = false) {
        const { select, areaOpacity } = this.theme;
        const active = this.activeSeriesMap[seriesName];
        const selected = Object.values(this.activeSeriesMap).some((elem) => !elem);
        const restOpacity = ignoreRestSeriesOpacity ? areaOpacity : select.restSeries.areaOpacity;
        const selectedOpacity = active ? select.areaOpacity : restOpacity;
        return selected ? selectedOpacity : areaOpacity;
    }
    getRespondersWithTheme(responders, type) {
        const { color, borderColor, borderWidth: thickness } = this.theme[type];
        return this.filterBulletResponder(responders).map((model) => {
            return Object.assign(Object.assign({}, model), { color: (color !== null && color !== void 0 ? color : model.tooltipColor), thickness,
                borderColor, style: [
                    Object.assign({}, (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.pick)(this.theme[type], 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY')),
                ] });
        });
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/circleLegend.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/circleLegend.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CircleLegend)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _bubbleSeries__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bubbleSeries */ "./node_modules/@toast-ui/chart/dist/esm/component/bubbleSeries.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");



class CircleLegend extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.models = { circleLegend: [] };
    }
    initialize() {
        this.type = 'circleLegend';
    }
    render({ layout, series, circleLegend }) {
        if (!series.bubble) {
            throw new Error(_message__WEBPACK_IMPORTED_MODULE_1__.message.CIRCLE_LEGEND_RENDER_ERROR);
        }
        this.isShow = circleLegend.visible;
        if (!this.isShow) {
            return;
        }
        const bubbleData = series.bubble.data;
        this.rect = layout.circleLegend;
        this.renderCircleLegend(bubbleData, circleLegend);
    }
    renderCircleLegend(bubbleData, circleLegend) {
        const value = (0,_bubbleSeries__WEBPACK_IMPORTED_MODULE_2__.getMaxRadius)(bubbleData);
        const { radius } = circleLegend;
        this.models.circleLegend = [
            {
                type: 'circleLegend',
                radius,
                value,
                x: radius,
                y: this.rect.height - radius,
            },
        ];
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/component.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/component.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Component)
/* harmony export */ });
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _helpers_arrayUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/arrayUtil */ "./node_modules/@toast-ui/chart/dist/esm/helpers/arrayUtil.js");



class Component {
    constructor({ store, eventBus }) {
        this.name = 'Component';
        this.type = 'component';
        this.rect = {
            x: 0,
            y: 0,
            height: 0,
            width: 0,
        };
        this.isShow = true;
        this.store = store;
        this.eventBus = eventBus;
    }
    update(delta) {
        if (!this.drawModels) {
            return;
        }
        if (Array.isArray(this.models)) {
            this.updateModels(this.drawModels, this.models, delta);
        }
        else {
            Object.keys(this.models).forEach((type) => {
                const currentModels = this.drawModels[type];
                const targetModels = this.models[type];
                this.updateModels(currentModels, targetModels, delta);
            });
        }
    }
    initUpdate(delta) {
        this.update(delta);
    }
    updateModels(currentModels, targetModels, delta) {
        currentModels.forEach((current, index) => {
            const target = targetModels[index];
            Object.keys(current).forEach((key) => {
                var _a;
                if (!current || !target) {
                    return;
                }
                if (key[0] !== '_') {
                    if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(current[key])) {
                        current[key] = current[key] + (target[key] - current[key]) * delta;
                    }
                    else if (key === 'points') {
                        const matchedModel = this.getCurrentModelToMatchTargetModel(current[key], current[key], target[key]);
                        const newPoints = matchedModel.map((curPoint, idx) => {
                            const next = target[key][idx];
                            if (curPoint && next) {
                                const { x, y } = curPoint;
                                const { x: nextX, y: nextY } = next;
                                return Object.assign(Object.assign({}, next), { x: x + (nextX - x) * delta, y: y + (nextY - y) * delta });
                            }
                            return next;
                        });
                        if ((_a = this.store.state.options.series) === null || _a === void 0 ? void 0 : _a.spline) {
                            (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_1__.setSplineControlPoint)(newPoints);
                        }
                        current[key] = newPoints;
                    }
                    else {
                        current[key] = target[key];
                    }
                }
            });
        });
    }
    sync() {
        if (!this.drawModels) {
            return;
        }
        if (Array.isArray(this.models)) {
            this.syncModels(this.drawModels, this.models);
        }
        else if (!Object.keys(this.models).length) {
            this.drawModels = this.models;
        }
        else {
            Object.keys(this.models).forEach((type) => {
                const currentModels = this.drawModels[type];
                const targetModels = this.models[type];
                this.syncModels(currentModels, targetModels, type);
            });
        }
    }
    getCurrentModelToMatchTargetModel(models, currentModels, targetModels) {
        var _a;
        if (!models || !currentModels) {
            return [...targetModels];
        }
        if ((_a = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.getFirstValidValue)(targetModels)) === null || _a === void 0 ? void 0 : _a.name) {
            const modelNames = [...new Set(models.map(({ name }) => name))];
            const targetNames = [...new Set(targetModels.map(({ name }) => name))];
            const same = (0,_helpers_arrayUtil__WEBPACK_IMPORTED_MODULE_2__.isSameArray)(modelNames, targetNames);
            if (!same) {
                return this.getCurrentModelWithDifferentModel(models, currentModels, targetModels, modelNames, targetNames);
            }
        }
        const currentLength = currentModels.length;
        const targetLength = targetModels.length;
        if (currentLength < targetLength) {
            return [...currentModels, ...targetModels.slice(currentLength, targetLength)];
        }
        if (currentLength > targetLength) {
            return currentModels.slice(0, targetLength);
        }
        return models;
    }
    getCurrentModelWithDifferentModel(models, currentModels, targetModels, modelNames, targetNames) {
        const currentLength = currentModels.length;
        const targetLength = targetModels.length;
        if (currentLength > targetLength) {
            const newModels = models.filter(({ name }) => (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.includes)(targetNames, name));
            return newModels.length !== targetModels.length ? targetModels : newModels;
        }
        if (currentLength < targetLength) {
            const notIncludedModels = targetModels.reduce((acc, cur, idx) => {
                const notIncluded = !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.includes)(modelNames, cur.name);
                return notIncluded
                    ? {
                        models: [...acc.models, cur],
                        modelIdx: [...acc.modelIdx, idx],
                    }
                    : acc;
            }, { models: [], modelIdx: [] });
            if (models.length + notIncludedModels.models.length === targetLength) {
                const newModels = [...models];
                notIncludedModels.models.forEach((model, idx) => {
                    newModels.splice(notIncludedModels.modelIdx[idx], 0, model);
                });
                return newModels;
            }
            return targetModels;
        }
        return models;
    }
    syncModels(currentModels, targetModels, type) {
        const drawModels = type ? this.drawModels[type] : this.drawModels;
        const model = this.getCurrentModelToMatchTargetModel(drawModels, currentModels, targetModels);
        if (type) {
            this.drawModels[type] = model;
        }
        else {
            this.drawModels = model;
        }
    }
    getSelectableOption(options) {
        var _a, _b, _c;
        return _c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.selectable, (_c !== null && _c !== void 0 ? _c : false);
    }
    renderDataLabels(data, name) {
        setTimeout(() => {
            this.eventBus.emit('renderDataLabels', { data, name: (name !== null && name !== void 0 ? name : this.name) });
        }, 0);
    }
    draw(painter) {
        const models = this.drawModels ? this.drawModels : this.models;
        if (Array.isArray(models)) {
            painter.paintForEach(models);
        }
        else if (models) {
            Object.keys(models).forEach((item) => {
                painter.paintForEach(models[item]);
            });
        }
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/componentManager.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/componentManager.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ComponentManager)
/* harmony export */ });
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");

class ComponentManager {
    constructor({ store, eventBus }) {
        this.components = [];
        this.store = store;
        this.eventBus = eventBus;
    }
    add(ComponentCtor, initialParam) {
        const component = new ComponentCtor({
            store: this.store,
            eventBus: this.eventBus,
        });
        if (component.initialize) {
            component.initialize(initialParam);
        }
        let proc = (...args) => {
            component.render(args[0], args[1]); // rest쓰면 에러남
            component.sync();
            this.eventBus.emit('needLoop');
        };
        this.store.observe((...args) => {
            proc(...args);
        });
        proc = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.debounce)(proc);
        this.components.push(component);
    }
    remove(ComponentCtor) {
        this.components = this.components.filter((component) => !(component instanceof ComponentCtor));
    }
    clear() {
        this.components = [];
        this.eventBus.emit('needDraw');
    }
    invoke(method, params) {
        this.components.forEach((component) => {
            const fn = component[method];
            if (fn) {
                fn.call(component, params);
            }
        });
    }
    forEach(iteratee) {
        this.components.forEach(iteratee);
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/dataLabels.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/dataLabels.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DataLabels)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_coordinate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/coordinate */ "./node_modules/@toast-ui/chart/dist/esm/helpers/coordinate.js");
/* harmony import */ var _helpers_dataLabels__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/helpers/dataLabels.js");
/* harmony import */ var _store_stackSeriesData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/stackSeriesData */ "./node_modules/@toast-ui/chart/dist/esm/store/stackSeriesData.js");





function getLabelInfo(model, labelOptions, rect, name) {
    var _a;
    const { type } = model;
    const dataLabel = [];
    if (type === 'point') {
        dataLabel.push((0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_0__.makePointLabelInfo)(model, labelOptions, rect));
    }
    else if (type === 'sector') {
        if (name === 'radialBar') {
            dataLabel.push((0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_0__.makeSectorBarLabelInfo)(model, labelOptions));
        }
        else {
            dataLabel.push((0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_0__.makeSectorLabelInfo)(model, labelOptions));
            if ((_a = labelOptions.pieSeriesName) === null || _a === void 0 ? void 0 : _a.visible) {
                const seriesNameLabel = (0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_0__.makePieSeriesNameLabelInfo)(model, labelOptions);
                dataLabel.push(seriesNameLabel);
            }
        }
    }
    else if (type === 'line') {
        dataLabel.push((0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_0__.makeLineLabelInfo)(model, labelOptions));
    }
    else {
        dataLabel.push((0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_0__.makeRectLabelInfo)(model, labelOptions));
    }
    return dataLabel;
}
class DataLabels extends _component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(...arguments);
        this.dataLabelsMap = {};
        this.renderSeriesDataLabels = (seriesDataLabel) => {
            this.appendDataLabels(seriesDataLabel);
            this.models = this.renderLabelModel();
            if (!this.drawModels) {
                this.drawModels = this.getDrawModelsAppliedOpacity(0);
            }
            else {
                this.sync();
            }
        };
    }
    initialize() {
        this.type = 'dataLabels';
        this.name = 'dataLabels';
        this.eventBus.on('renderDataLabels', this.renderSeriesDataLabels);
    }
    initUpdate(delta) {
        if (!this.drawModels) {
            return;
        }
        this.drawModels = this.getDrawModelsAppliedOpacity(delta);
    }
    render({ layout, options, series, nestedPieSeries }) {
        this.rect = layout.plot;
        this.options = options;
        this.isShow = this.visibleDataLabels(series, nestedPieSeries);
    }
    visibleDataLabels(series, nestedPieSeries) {
        var _a, _b;
        const visibleCommonSeriesDataLabels = !!((_b = (_a = this.options.series) === null || _a === void 0 ? void 0 : _a.dataLabels) === null || _b === void 0 ? void 0 : _b.visible);
        const visibleComboSeriesDataLabels = Object.keys(series).some((seriesName) => { var _a, _b, _c; return !!((_c = (_b = (_a = this.options.series) === null || _a === void 0 ? void 0 : _a[seriesName]) === null || _b === void 0 ? void 0 : _b.dataLabels) === null || _c === void 0 ? void 0 : _c.visible); });
        const visibleNestedPieSeriesDataLabels = !!(nestedPieSeries &&
            Object.keys(nestedPieSeries).some((alias) => {
                var _a, _b, _c;
                return !!((_c = (_b = (_a = this.options.series) === null || _a === void 0 ? void 0 : _a[alias]) === null || _b === void 0 ? void 0 : _b.dataLabels) === null || _c === void 0 ? void 0 : _c.visible);
            }));
        return (visibleCommonSeriesDataLabels ||
            visibleComboSeriesDataLabels ||
            visibleNestedPieSeriesDataLabels);
    }
    appendDataLabels({ name, data }) {
        const dataLabelOptions = (0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_0__.getDataLabelsOptions)(this.options, name);
        const withStack = !!(0,_store_stackSeriesData__WEBPACK_IMPORTED_MODULE_2__.pickStackOption)(this.options);
        const labels = [];
        data.forEach((model) => {
            var _a;
            const { type, value } = model;
            const labelOptions = (0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_0__.getDefaultDataLabelsOptions)(dataLabelOptions, type, withStack);
            const disableStackTotal = type === 'stackTotal' && !((_a = labelOptions.stackTotal) === null || _a === void 0 ? void 0 : _a.visible);
            if (disableStackTotal || (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(value)) {
                return;
            }
            labels.splice(labels.length, 0, ...getLabelInfo(model, labelOptions, this.rect, name));
        });
        this.dataLabelsMap[name] = { data: labels, options: dataLabelOptions };
    }
    getDrawModelsAppliedOpacity(opacity) {
        return Object.keys(this.models).reduce((acc, key) => (Object.assign(Object.assign({}, acc), { [key]: this.models[key].map((m) => (Object.assign(Object.assign({}, m), { opacity }))) })), { series: [], total: [] });
    }
    renderLabelModel() {
        return Object.keys(this.dataLabelsMap)
            .map((seriesName) => {
            const { data } = this.dataLabelsMap[seriesName];
            return this.makeLabelModel(data);
        })
            .reduce((acc, cur) => ({
            series: [...acc.series, ...cur.series],
            total: [...acc.total, ...cur.total],
        }), { series: [], total: [] });
    }
    makeLabelModel(dataLabels) {
        return dataLabels.reduce((acc, dataLabel) => {
            var _a;
            const { type, x, y, text, textAlign, textBaseline, name, callout, theme, radian, } = dataLabel;
            if (!(0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_4__.isModelExistingInRect)(this.rect, { x, y })) {
                return acc;
            }
            const modelName = type === 'stackTotal' ? 'total' : 'series';
            return Object.assign(Object.assign({}, acc), { [modelName]: [
                    ...(_a = acc[modelName], (_a !== null && _a !== void 0 ? _a : [])),
                    {
                        type: 'dataLabel',
                        dataLabelType: type,
                        text,
                        x,
                        y,
                        textAlign,
                        textBaseline,
                        opacity: 1,
                        name,
                        callout,
                        theme,
                        radian,
                    },
                ] });
        }, { series: [], total: [] });
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BUTTON_RECT_SIZE": () => (/* binding */ BUTTON_RECT_SIZE),
/* harmony export */   "default": () => (/* binding */ ExportMenu)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _store_layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/layout */ "./node_modules/@toast-ui/chart/dist/esm/store/layout.js");
/* harmony import */ var _helpers_downloader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/downloader */ "./node_modules/@toast-ui/chart/dist/esm/helpers/downloader.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");





const EXPORT_MENU_WIDTH = 140;
const exportExtensions = {
    IMAGES: ['png', 'jpeg'],
    SPREAD_SHEETS: ['xls', 'csv'],
};
const BUTTON_RECT_SIZE = 24;
class ExportMenu extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.models = { exportMenuButton: [] };
        this.opened = false;
        this.chartWidth = 0;
        this.toggleExportMenu = () => {
            this.opened = !this.opened;
            this.models.exportMenuButton[0].opened = this.opened;
            this.eventBus.emit('needDraw');
            if (this.opened) {
                this.applyPanelWrapperStyle();
                this.chartEl.appendChild(this.exportMenuEl);
            }
            else {
                this.chartEl.removeChild(this.exportMenuEl);
            }
        };
        this.getCanvasExportBtnRemoved = () => {
            const canvas = this.chartEl.getElementsByTagName('canvas')[0];
            const ctx = canvas.getContext('2d');
            const { x, y, height: h, width: w } = this.rect;
            ctx.clearRect(x, y, w, h);
            ctx.fillStyle = this.chartBackgroundColor;
            ctx.fillRect(x, y, w, h);
            return canvas;
        };
        this.onClickExportButton = (ev) => {
            const { id } = ev.target;
            const isImageExtension = exportExtensions.IMAGES.includes(id);
            const isSpreadSheetExtension = exportExtensions.SPREAD_SHEETS.includes(id);
            if (isImageExtension) {
                const canvas = this.getCanvasExportBtnRemoved();
                (0,_helpers_downloader__WEBPACK_IMPORTED_MODULE_1__.execDownload)(this.fileName, id, canvas.toDataURL(`image/${id}`, 1));
            }
            else if (isSpreadSheetExtension) {
                (0,_helpers_downloader__WEBPACK_IMPORTED_MODULE_1__.downloadSpreadSheet)(this.fileName, id, this.data);
            }
            if (isImageExtension || isSpreadSheetExtension) {
                this.toggleExportMenu();
            }
        };
    }
    applyExportButtonPanelStyle() {
        const exportMenuTitle = this.exportMenuEl.querySelector('.toastui-chart-export-menu-title');
        const menuBtnWrapper = this.exportMenuEl.querySelector('.toastui-chart-export-menu-btn-wrapper');
        exportMenuTitle.setAttribute('style', this.makePanelStyle('header'));
        menuBtnWrapper.setAttribute('style', this.makePanelStyle('body'));
    }
    makeExportMenuButton() {
        const el = document.createElement('div');
        el.onclick = this.onClickExportButton;
        el.innerHTML = `
        <div class="toastui-chart-export-menu">
          <p class="toastui-chart-export-menu-title">Export to</p>
          <div class="toastui-chart-export-menu-btn-wrapper">
            <button class="toastui-chart-export-menu-btn" id="xls">xls</button>
            <button class="toastui-chart-export-menu-btn" id="csv">csv</button>
            <button class="toastui-chart-export-menu-btn" id="png">png</button>
            <button class="toastui-chart-export-menu-btn" id="jpeg">jpeg</button>
          </div>
        </div>
      `;
        return el;
    }
    initialize({ chartEl }) {
        this.chartEl = chartEl;
        this.type = 'exportMenu';
        this.name = 'exportMenu';
        this.exportMenuEl = this.makeExportMenuButton();
    }
    onClick({ responders }) {
        if (responders.length) {
            this.toggleExportMenu();
        }
    }
    getFileName(title) {
        var _a, _b;
        return (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(title) ? title : (_b = (_a = title) === null || _a === void 0 ? void 0 : _a.text, (_b !== null && _b !== void 0 ? _b : 'toast-ui-chart'));
    }
    render({ options, layout, chart, series, rawCategories, theme }) {
        var _a, _b;
        this.isShow = (0,_store_layout__WEBPACK_IMPORTED_MODULE_3__.isExportMenuVisible)(options);
        this.chartWidth = chart.width;
        if (!this.isShow) {
            return;
        }
        this.chartBackgroundColor = theme.chart.backgroundColor;
        this.theme = theme.exportMenu;
        this.data = { series, categories: rawCategories };
        this.fileName = this.getFileName(((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.exportMenu) === null || _b === void 0 ? void 0 : _b.filename) || chart.title);
        this.applyExportButtonPanelStyle();
        this.rect = layout.exportMenu;
        this.models.exportMenuButton = [
            {
                type: 'exportMenuButton',
                x: 0,
                y: 0,
                opened: this.opened,
                theme: this.theme.button,
            },
        ];
        this.responders = [
            {
                type: 'rect',
                width: BUTTON_RECT_SIZE,
                height: BUTTON_RECT_SIZE,
                x: 0,
                y: 0,
            },
        ];
    }
    applyPanelWrapperStyle() {
        const exportMenu = this.exportMenuEl.querySelector('.toastui-chart-export-menu');
        const x = this.chartWidth - EXPORT_MENU_WIDTH - _store_layout__WEBPACK_IMPORTED_MODULE_3__.padding.X;
        const y = _store_layout__WEBPACK_IMPORTED_MODULE_3__.padding.Y + BUTTON_RECT_SIZE + 5;
        const { borderRadius, borderWidth, borderColor } = this.theme.panel;
        const style = `
      transform: ${(0,_helpers_style__WEBPACK_IMPORTED_MODULE_4__.getTranslateString)(x, y)};
      border: ${borderWidth}px solid ${borderColor};
      border-radius: ${borderRadius}px;`;
        exportMenu.setAttribute('style', style);
    }
    makePanelStyle(type) {
        const sectionTheme = this.theme.panel[type];
        const direction = type === 'header' ? 'top' : 'bottom';
        const { borderRadius, borderWidth } = this.theme.panel;
        const borderRadiusPx = `${borderRadius - borderWidth}px`;
        return [
            `${(0,_helpers_style__WEBPACK_IMPORTED_MODULE_4__.getFontStyleString)(sectionTheme)}`,
            `border-${direction}-left-radius: ${borderRadiusPx};`,
            `border-${direction}-right-radius: ${borderRadiusPx};`,
            `background-color: ${sectionTheme.backgroundColor};`,
        ].join('');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/gaugeSeries.js":
/*!************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/gaugeSeries.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GaugeSeries)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");
/* harmony import */ var _helpers_sector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/sector */ "./node_modules/@toast-ui/chart/dist/esm/helpers/sector.js");
/* harmony import */ var _helpers_legend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/legend */ "./node_modules/@toast-ui/chart/dist/esm/helpers/legend.js");
/* harmony import */ var _helpers_color__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helpers/color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");
/* harmony import */ var _helpers_pieSeries__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../helpers/pieSeries */ "./node_modules/@toast-ui/chart/dist/esm/helpers/pieSeries.js");
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _radialPlot__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./radialPlot */ "./node_modules/@toast-ui/chart/dist/esm/component/radialPlot.js");
/* harmony import */ var _helpers_dataLabels__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/helpers/dataLabels.js");
/* harmony import */ var _store_gaugeAxes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../store/gaugeAxes */ "./node_modules/@toast-ui/chart/dist/esm/store/gaugeAxes.js");











const DETECTION_SIZE_MARGIN = 3;
class GaugeSeries extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.models = { clockHand: [], solid: [], backgroundSolid: [] };
        this.activatedResponders = [];
        this.onMouseoutComponent = () => {
            this.eventBus.emit('seriesPointHovered', { models: [], name: this.name });
            this.eventBus.emit('renderHoveredSeries', { models: [], name: this.name });
            this.eventBus.emit('needDraw');
        };
        this.selectSeries = (info) => {
            var _a;
            const { index } = info;
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(index)) {
                return;
            }
            const model = (_a = this.tooltipMap.clockHand[index], (_a !== null && _a !== void 0 ? _a : this.tooltipMap.solid[index]));
            if (!model) {
                return;
            }
            const models = this.getResponderModelsWithTheme(this.getResponderModels([model]), 'select');
            if (!models.length) {
                throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.SELECT_SERIES_API_INDEX_ERROR);
            }
            this.eventBus.emit('renderSelectedSeries', {
                models: models,
                name: this.name,
            });
            this.eventBus.emit('needDraw');
        };
        this.showTooltip = (info) => {
            const { index } = info;
            const models = this.getResponderModelsWithTheme([this.tooltipMap.clockHand[index]], 'hover');
            if (!models.length) {
                return;
            }
            this.eventBus.emit('renderHoveredSeries', {
                models,
                name: this.name,
            });
            this.activatedResponders = models;
            this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });
            this.eventBus.emit('needDraw');
        };
    }
    initialize() {
        this.type = 'series';
        this.name = 'gauge';
        this.eventBus.on('selectSeries', this.selectSeries);
        this.eventBus.on('showTooltip', this.showTooltip);
        this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
    initUpdate(delta) {
        if (!this.drawModels) {
            return;
        }
        const { angle: { start: startAngle, total: totalAngle }, clockwise, } = this.circularAxis;
        const currentDegree = clockwise
            ? startAngle + totalAngle * delta
            : startAngle - totalAngle * delta;
        this.models.clockHand.forEach((model, index) => {
            const { x, y, animationDegree, handSize } = model;
            if ((clockwise && animationDegree < currentDegree) ||
                (!clockwise && animationDegree > currentDegree)) {
                this.syncEndAngle(index);
                return;
            }
            const { x: x2, y: y2 } = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.getRadialPosition)(x, y, handSize, (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.calculateDegreeToRadian)((0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.calculateValidAngle)(currentDegree)));
            this.drawModels.clockHand[index].x2 = x2;
            this.drawModels.clockHand[index].y2 = y2;
        });
        this.models.solid.forEach(() => {
            const index = this.models.solid.findIndex(({ animationDegree }) => {
                const { start, end } = animationDegree;
                return (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.withinRadian)(clockwise, start, end, currentDegree);
            });
            this.syncSectorEndAngle(index < 0 ? this.models.solid.length : index);
            if (index !== -1) {
                this.drawModels.solid[index].degree.end = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.calculateValidAngle)(currentDegree);
            }
        });
    }
    updateModels(current, target, delta) {
        const { angle: { total }, } = this.circularAxis;
        Object.keys(current).forEach((key) => {
            if (!current || !target) {
                return;
            }
            if (key[0] !== '_') {
                if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(current[key])) {
                    current[key] = current[key] + (target[key] - current[key]) * delta;
                }
                else if (key === 'degree') {
                    if (total < _helpers_sector__WEBPACK_IMPORTED_MODULE_3__.DEGREE_360 && current.degree.end < _helpers_sector__WEBPACK_IMPORTED_MODULE_3__.DEGREE_90) {
                        current[key].end =
                            _helpers_sector__WEBPACK_IMPORTED_MODULE_3__.DEGREE_360 +
                                current[key].end -
                                (_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.DEGREE_360 - target[key].end + current[key].end) * delta;
                    }
                    else {
                        current[key].end = current[key].end + (target[key].end - current[key].end) * delta;
                    }
                }
                else {
                    current[key] = target[key];
                }
            }
        });
    }
    update(delta) {
        this.models.clockHand.forEach((model, index) => {
            this.updateModels(this.drawModels.clockHand[index], model, delta);
        });
        this.models.solid.forEach((model, index) => {
            this.updateModels(this.drawModels.solid[index], model, delta);
        });
    }
    syncEndAngle(index) {
        const model = this.models.clockHand[index];
        const drawModel = this.drawModels.clockHand[index];
        if (model.x2 !== drawModel.x2 || model.y2 !== drawModel.y2) {
            drawModel.x2 = model.x2;
            drawModel.y2 = model.y2;
        }
    }
    syncSectorEndAngle(index) {
        if (!index) {
            return;
        }
        for (let i = 0; i < index; i += 1) {
            const prevTargetEndDegree = this.models.solid[i].degree.end;
            if (this.drawModels.solid[i].degree.end !== prevTargetEndDegree) {
                this.drawModels.solid[i].degree.end = prevTargetEndDegree;
            }
        }
    }
    render(chartState) {
        var _a, _b;
        const { layout, series, legend, options, theme, scale, radialAxes } = chartState;
        const categories = (_a = chartState.categories, (_a !== null && _a !== void 0 ? _a : []));
        if (!series.gauge) {
            throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.noDataError(this.name));
        }
        this.theme = theme.series.gauge;
        this.rect = layout.plot;
        this.circularAxis = radialAxes.circularAxis;
        this.activeSeriesMap = (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_4__.getActiveSeriesMap)(legend);
        this.selectable = this.getSelectableOption(options);
        const seriesData = series.gauge.data;
        const hasCategoryAxis = !(0,_helpers_axes__WEBPACK_IMPORTED_MODULE_5__.isLabelAxisOnYAxis)({ series, categories });
        const renderOptions = this.makeRenderOptions(hasCategoryAxis, categories, scale, (_b = options) === null || _b === void 0 ? void 0 : _b.series);
        const clockHandModels = this.renderClockHands(seriesData, renderOptions);
        this.models.clockHand = renderOptions.useClockHand ? clockHandModels : [];
        const solidModels = this.renderSolidModels(seriesData, clockHandModels, renderOptions);
        const tooltipData = this.makeTooltipData(clockHandModels);
        if (!this.drawModels) {
            this.initDrawModels();
        }
        if ((0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_6__.getDataLabelsOptions)(options, this.name).visible) {
            const { value, name, x, y, seriesData: data } = clockHandModels[0];
            this.renderDataLabels([
                {
                    type: 'point',
                    theme: this.theme.dataLabels,
                    value,
                    name,
                    x,
                    y: y + _store_gaugeAxes__WEBPACK_IMPORTED_MODULE_7__.DATA_LABEL_MARGIN,
                    data,
                },
            ]);
        }
        this.tooltipMap = this.makeTooltipMap(tooltipData, renderOptions);
        this.responders = this.getResponders(clockHandModels, solidModels, tooltipData, renderOptions.useClockHand);
    }
    renderSolidModels(seriesData, clockHandModels, renderOptions) {
        let solidModels = [];
        this.models.clockHand = renderOptions.useClockHand ? clockHandModels : [];
        if (renderOptions.solidData.visible) {
            solidModels = this.renderSectors(seriesData, renderOptions);
            this.models.backgroundSolid = this.renderBackgroundSolid(renderOptions);
            this.models.solid = solidModels;
        }
        return solidModels;
    }
    initDrawModels() {
        const { angle: { start }, } = this.circularAxis;
        this.drawModels = {
            clockHand: this.models.clockHand.map((m) => {
                const { x: x2, y: y2 } = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.getRadialPosition)(m.x, m.y, m.handSize, (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.calculateDegreeToRadian)(start));
                return Object.assign(Object.assign({}, m), { x2, y2, testDegree: 0 });
            }),
            backgroundSolid: this.models.backgroundSolid,
            solid: this.models.solid.map((m) => (Object.assign(Object.assign({}, m), { degree: Object.assign(Object.assign({}, m.degree), { end: m.degree.start }) }))),
        };
    }
    getResponders(clockHandModels, sectorModels, tooltipData, useClockHand = true) {
        const clockHandResponders = !useClockHand
            ? []
            : clockHandModels.map((m, index) => (Object.assign(Object.assign({}, m), { detectionSize: m.baseLine + DETECTION_SIZE_MARGIN, data: Object.assign({}, tooltipData[index]) })));
        return sectorModels.length
            ? [
                ...sectorModels.map((m, index) => (Object.assign(Object.assign({}, m), { data: Object.assign({}, tooltipData[index]) }))),
                ...clockHandResponders,
            ]
            : clockHandResponders;
    }
    getHandSize(size, index = 0) {
        const maxClockHandSize = this.circularAxis.maxClockHandSize;
        if (size) {
            return Array.isArray(size)
                ? (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.calculateSizeWithPercentString)(maxClockHandSize, size[index])
                : (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.calculateSizeWithPercentString)(maxClockHandSize, size);
        }
        return maxClockHandSize;
    }
    renderClockHands(seriesData, renderOptions) {
        const { centerX, centerY, totalAngle, clockwise, scaleMaxLimitValue, categories, drawingStartAngle, } = renderOptions;
        const seriesModels = [];
        const { size, baseLine, color: clockHandColor } = this.theme.clockHand;
        const { radius, color: pinColor, borderWidth, borderColor } = this.theme.pin;
        seriesData.forEach(({ name, data, color }, seriesIndex) => {
            const seriesColor = this.getSeriesColor(name, color);
            data.forEach((value, index) => {
                const val = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(value)
                    ? categories.findIndex((category) => category === value)
                    : value;
                const degree = drawingStartAngle + (val / scaleMaxLimitValue) * totalAngle * (clockwise ? 1 : -1);
                const validDegree = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.calculateValidAngle)(degree);
                const handSize = this.getHandSize(size, index);
                const { x: x2, y: y2 } = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.getRadialPosition)(centerX, centerY, handSize, (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.calculateDegreeToRadian)(validDegree));
                seriesModels.push({
                    type: 'clockHand',
                    color: (clockHandColor !== null && clockHandColor !== void 0 ? clockHandColor : seriesColor),
                    name,
                    value,
                    x: centerX,
                    y: centerY,
                    x2,
                    y2,
                    pin: {
                        radius: radius,
                        color: (pinColor !== null && pinColor !== void 0 ? pinColor : seriesColor),
                        style: [
                            {
                                strokeStyle: (borderColor !== null && borderColor !== void 0 ? borderColor : (0,_helpers_color__WEBPACK_IMPORTED_MODULE_8__.getRGBA)(seriesColor, 0.1)),
                                lineWidth: borderWidth ? borderWidth + radius : 0,
                            },
                        ],
                    },
                    degree: validDegree,
                    animationDegree: degree,
                    baseLine: baseLine,
                    handSize,
                    seriesData: data,
                    index,
                    seriesIndex,
                });
            });
        });
        return seriesModels;
    }
    renderBackgroundSolid(renderOptions) {
        const { centerX, centerY, startAngle, totalAngle, clockwise, solidData } = renderOptions;
        const { color } = this.theme.solid.backgroundSolid;
        return [
            {
                type: 'sector',
                color: color,
                x: centerX,
                y: centerY,
                clockwise,
                degree: {
                    start: startAngle,
                    end: startAngle + totalAngle,
                },
                radius: solidData.radiusRange,
            },
        ];
    }
    renderSectors(seriesData, renderOptions) {
        const sectors = [];
        const { centerX, centerY, clockwise, totalAngle, scaleMaxLimitValue, startAngle, categories, solidData, } = renderOptions;
        const { radiusRange } = solidData;
        const { lineWidth, strokeStyle } = this.theme.solid;
        seriesData.forEach(({ name, data, color }, index) => {
            const seriesColor = this.getSeriesColor(name, color);
            const value = data[0];
            const val = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(value) ? categories.findIndex((category) => category === value) : value;
            const degree = (val / scaleMaxLimitValue) * totalAngle * (clockwise ? 1 : -1);
            const validDegree = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.calculateValidAngle)(degree);
            const startDegree = startAngle;
            const endDegree = startDegree + degree;
            const animationStartDegree = startAngle;
            const animationEndDegree = animationStartDegree + validDegree;
            sectors.push({
                type: 'sector',
                color: seriesColor,
                x: centerX,
                y: centerY,
                clockwise,
                degree: {
                    start: startDegree,
                    end: endDegree,
                },
                radius: radiusRange,
                animationDegree: {
                    start: animationStartDegree,
                    end: animationEndDegree,
                },
                drawingStartAngle: _helpers_sector__WEBPACK_IMPORTED_MODULE_3__.DEGREE_NEGATIVE_90,
                style: [{ strokeStyle }],
                lineWidth,
                index,
            });
        });
        return sectors;
    }
    makeTooltipMap(tooltipData, renderOptions) {
        const { clockHand, solid } = this.models;
        const { useClockHand } = renderOptions;
        return tooltipData.reduce((acc, data, index) => {
            if (useClockHand) {
                acc.clockHand.push(Object.assign(Object.assign({}, clockHand[index]), { detectionSize: clockHand[index].baseLine + 3, data }));
            }
            if (solid[index]) {
                acc.solid.push(Object.assign(Object.assign({}, solid[index]), { data }));
            }
            return acc;
        }, { solid: [], clockHand: [] });
    }
    makeRenderOptions(hasCategoryAxis, categories, scale, options) {
        var _a, _b;
        const { centerX, centerY, solidData, angle: { start, end, drawingStart }, radius: { outer }, } = this.circularAxis;
        const solid = this.circularAxis.solidData;
        const clockwise = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.clockwise, (_b !== null && _b !== void 0 ? _b : true));
        const totalAngle = (0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_9__.getTotalAngle)(clockwise, start, end);
        return {
            clockwise,
            centerX,
            centerY,
            angleRange: { start, end },
            totalAngle,
            scaleMaxLimitValue: hasCategoryAxis
                ? categories.length
                : (0,_radialPlot__WEBPACK_IMPORTED_MODULE_10__.getScaleMaxLimitValue)(scale.circularAxis, totalAngle),
            startAngle: start,
            categories,
            drawingStartAngle: drawingStart,
            outerRadius: outer,
            useClockHand: solid.visible ? solid.clockHand : true,
            solidData: solidData,
        };
    }
    getSeriesColor(name, color) {
        const { select, areaOpacity } = this.theme;
        const active = this.activeSeriesMap[name];
        const selected = Object.values(this.activeSeriesMap).some((elem) => !elem);
        return selected
            ? (0,_helpers_color__WEBPACK_IMPORTED_MODULE_8__.getRGBA)(color, active ? select.areaOpacity : select.restSeries.areaOpacity)
            : (0,_helpers_color__WEBPACK_IMPORTED_MODULE_8__.getRGBA)(color, areaOpacity);
    }
    makeTooltipData(seriesModels) {
        return seriesModels.reduce((acc, { color, name, value, index, seriesIndex }) => (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(value) ? acc : [...acc, { label: name, color, value: value, index, seriesIndex }], []);
    }
    onMousemove({ responders }) {
        this.eventBus.emit('renderHoveredSeries', {
            models: this.getResponderModelsWithTheme(this.getResponderModels(responders), 'hover'),
            name: this.name,
        });
        this.activatedResponders = responders.map((responder) => (Object.assign({}, responder)));
        this.eventBus.emit('seriesPointHovered', {
            models: this.activatedResponders,
            name: this.name,
        });
        this.eventBus.emit('needDraw');
    }
    getResponderModels(responders) {
        const { clockHand, solid } = this.tooltipMap;
        return responders.reduce((acc, responder) => {
            const index = responder.index;
            const clockHandModel = clockHand[index] ? [clockHand[index]] : [];
            const solidModel = solid[index] ? [solid[index]] : [];
            return [...acc, ...clockHandModel, ...solidModel];
        }, []);
    }
    onClick({ responders }) {
        if (this.selectable) {
            const models = this.getResponderModelsWithTheme(this.getResponderModels(responders), 'select');
            this.eventBus.emit('renderSelectedSeries', {
                models,
                name: this.name,
            });
            this.eventBus.emit('needDraw');
        }
    }
    getResponderModelsWithSolidTheme(responder, type) {
        var _a;
        const solidTheme = this.theme[type].solid;
        const lineWidth = solidTheme.lineWidth;
        const isSameLineWidth = this.theme.solid === lineWidth;
        const thickness = isSameLineWidth ? 0 : lineWidth * 0.5;
        return Object.assign(Object.assign({}, responder), { color: (_a = solidTheme.color, (_a !== null && _a !== void 0 ? _a : responder.color)), lineWidth, style: [
                (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.pick)(solidTheme, 'strokeStyle', 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY'),
            ], radius: {
                inner: Math.max(responder.radius.inner - thickness, 0),
                outer: responder.radius.outer + thickness,
            } });
    }
    getResponderWithClockHandTheme(responder, type) {
        const { clockHand, pin } = this.theme[type];
        const { size, baseLine, color: clockHandColor } = clockHand;
        const { radius, color: pinColor, borderWidth, borderColor } = pin;
        const pinRadius = (radius !== null && radius !== void 0 ? radius : responder.pin.radius);
        const pinStyle = [
            {
                strokeStyle: (borderColor !== null && borderColor !== void 0 ? borderColor : (0,_helpers_color__WEBPACK_IMPORTED_MODULE_8__.getRGBA)(responder.pin.style[0].strokeStyle, 0.3)),
                lineWidth: borderWidth ? borderWidth + pinRadius : 0,
            },
        ];
        return Object.assign(Object.assign({}, responder), { color: (clockHandColor !== null && clockHandColor !== void 0 ? clockHandColor : responder.color), pin: {
                radius: pinRadius,
                color: (pinColor !== null && pinColor !== void 0 ? pinColor : responder.pin.color),
                style: pinStyle,
            }, baseLine: (baseLine !== null && baseLine !== void 0 ? baseLine : responder.baseLine), handSize: size ? this.getHandSize(size, responder.index) : responder.handSize });
    }
    getResponderModelsWithTheme(responders, type) {
        return responders.map((m) => {
            var _a;
            return ((_a = m) === null || _a === void 0 ? void 0 : _a.type) === 'sector'
                ? this.getResponderModelsWithSolidTheme(m, type)
                : this.getResponderWithClockHandTheme(m, type);
        });
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/heatmapSeries.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/heatmapSeries.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HeatmapSeries)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");
/* harmony import */ var _helpers_dataLabels__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/helpers/dataLabels.js");
/* harmony import */ var _helpers_colorSpectrum__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/colorSpectrum */ "./node_modules/@toast-ui/chart/dist/esm/helpers/colorSpectrum.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_theme__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/theme */ "./node_modules/@toast-ui/chart/dist/esm/helpers/theme.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");







class HeatmapSeries extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.activatedResponders = [];
        this.onMouseoutComponent = () => {
            this.emitMouseEvent([]);
        };
        this.selectSeries = ({ index, seriesIndex, state, }) => {
            var _a;
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(index) || !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(seriesIndex)) {
                return;
            }
            const dataSize = (_a = state.series.heatmap) === null || _a === void 0 ? void 0 : _a[0].data.length;
            const responderIndex = seriesIndex * dataSize + index;
            const model = this.responders[responderIndex];
            if (!model) {
                throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.SELECT_SERIES_API_INDEX_ERROR);
            }
            this.eventBus.emit('renderSelectedSeries', {
                models: this.getRespondersWithTheme([model], 'select'),
                name: this.name,
            });
            this.eventBus.emit('needDraw');
        };
        this.showTooltip = ({ index, seriesIndex, state }) => {
            var _a;
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(index) || !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(seriesIndex)) {
                return;
            }
            const dataSize = (_a = state.series.heatmap) === null || _a === void 0 ? void 0 : _a[0].data.length;
            const responderIndex = seriesIndex * dataSize + index;
            const model = this.responders[responderIndex];
            if (model) {
                this.emitMouseEvent([model]);
            }
        };
    }
    initialize() {
        this.type = 'series';
        this.name = 'heatmap';
        this.eventBus.on('selectSeries', this.selectSeries);
        this.eventBus.on('showTooltip', this.showTooltip);
        this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
    render(chartState) {
        const { layout, heatmapSeries, axes, theme, colorValueScale, options } = chartState;
        if (!heatmapSeries) {
            throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.noDataError(this.name));
        }
        this.theme = theme.series.heatmap;
        this.selectable = this.getSelectableOption(options);
        this.rect = layout.plot;
        const cellSize = {
            height: axes.yAxis.tickDistance,
            width: axes.xAxis.tickDistance,
        };
        this.models = {
            series: this.renderHeatmapSeries(heatmapSeries, cellSize, colorValueScale),
        };
        if ((0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_3__.getDataLabelsOptions)(options, this.name).visible) {
            this.renderDataLabels(this.makeDataLabels());
        }
        this.responders = this.makeHeatmapSeriesResponder();
    }
    makeDataLabels() {
        const dataLabelTheme = this.theme.dataLabels;
        return this.models.series.reduce((acc, m) => {
            return (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(m.colorValue)
                ? acc
                : [
                    ...acc,
                    Object.assign(Object.assign({}, m), { type: 'treemapSeriesName', value: m.colorValue, direction: 'left', plot: { x: 0, y: 0, size: 0 }, theme: Object.assign(Object.assign({}, dataLabelTheme), { color: dataLabelTheme.useSeriesColor ? m.color : dataLabelTheme.color }) }),
                ];
        }, []);
    }
    makeHeatmapSeriesResponder() {
        return this.models.series.reduce((acc, model) => {
            return (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(model.colorValue)
                ? acc
                : [
                    ...acc,
                    Object.assign(Object.assign({}, model), { data: Object.assign(Object.assign({}, model), { label: model.name, value: model.colorValue, templateType: 'heatmap' }), thickness: _helpers_theme__WEBPACK_IMPORTED_MODULE_4__.boxDefault.HOVER_THICKNESS, style: ['shadow'] }),
                ];
        }, []);
    }
    renderHeatmapSeries(seriesData, cellSize, colorValueScale) {
        const { startColor, endColor, borderColor, borderWidth } = this.theme;
        const startRGB = (0,_helpers_color__WEBPACK_IMPORTED_MODULE_5__.hexToRGB)(startColor);
        const distances = (0,_helpers_colorSpectrum__WEBPACK_IMPORTED_MODULE_6__.makeDistances)(startRGB, (0,_helpers_color__WEBPACK_IMPORTED_MODULE_5__.hexToRGB)(endColor));
        const { height, width } = cellSize;
        return seriesData.flatMap((data) => {
            return data.flatMap((datum) => {
                const { indexes, colorValue, category } = datum;
                const name = `${category.x}, ${category.y}`;
                const [xIndex, yIndex] = indexes;
                const colorRatio = (0,_helpers_colorSpectrum__WEBPACK_IMPORTED_MODULE_6__.getColorRatio)(colorValueScale.limit, colorValue);
                const color = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(colorValue)
                    ? 'rgba(0, 0, 0, 0)'
                    : (0,_helpers_colorSpectrum__WEBPACK_IMPORTED_MODULE_6__.getSpectrumColor)(colorRatio, distances, startRGB);
                const thickness = borderWidth;
                return {
                    type: 'rect',
                    name,
                    width: width - thickness * 2,
                    height: height - thickness * 2,
                    x: width * xIndex + thickness,
                    y: height * yIndex + thickness,
                    colorValue,
                    colorRatio,
                    color,
                    thickness,
                    borderColor,
                };
            });
        });
    }
    getRespondersWithTheme(responders, type) {
        return responders.map((responder) => (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.deepMergedCopy)(responder, Object.assign(Object.assign({}, this.theme[type]), { style: ['shadow'] })));
    }
    onClick({ responders }) {
        if (this.selectable) {
            this.eventBus.emit('renderSelectedSeries', {
                models: this.getRespondersWithTheme(responders, 'select'),
                name: this.name,
            });
            this.eventBus.emit('needDraw');
        }
    }
    onMousemove({ responders }) {
        this.activatedResponders = responders;
        this.emitMouseEvent(responders);
    }
    emitMouseEvent(responders) {
        this.eventBus.emit('renderHoveredSeries', {
            models: this.getRespondersWithTheme(responders, 'hover'),
            name: this.name,
        });
        this.eventBus.emit('seriesPointHovered', {
            models: responders,
            name: this.name,
        });
        this.eventBus.emit('renderSpectrumTooltip', responders);
        this.eventBus.emit('needDraw');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/hoveredSeries.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HoveredSeries)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_responders__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/responders */ "./node_modules/@toast-ui/chart/dist/esm/helpers/responders.js");
/* harmony import */ var _store_reactive__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/reactive */ "./node_modules/@toast-ui/chart/dist/esm/store/reactive.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





const guideLineType = {
    line: 'circle',
    area: 'circle',
    boxPlot: 'boxPlot',
};
class HoveredSeries extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.models = { guideLine: [] };
        this.isShow = false;
        this.renderHoveredSeries = ({ models, name, eventDetectType, }) => {
            var _a, _b;
            const prevModels = this.getSeriesModels(name);
            this.models[name] = [...models];
            this.isShow = !!this.getSeriesModels().length;
            const isSame = !!((_a = prevModels) === null || _a === void 0 ? void 0 : _a.length) &&
                !!models.length &&
                (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_1__.isSameSeriesResponder)({ models, comparisonModel: prevModels, eventDetectType, name });
            if (((_b = prevModels) === null || _b === void 0 ? void 0 : _b.length) && !models.length) {
                this.eventBus.emit('unhoverSeries', (0,_store_reactive__WEBPACK_IMPORTED_MODULE_2__.makeObservableObjectToNormal)(prevModels));
            }
            else if (models.length && !isSame) {
                this.eventBus.emit('hoverSeries', (0,_store_reactive__WEBPACK_IMPORTED_MODULE_2__.makeObservableObjectToNormal)(models));
            }
            this.modelForGuideLine = this.getModelForGuideLine(name);
            if (eventDetectType === 'grouped') {
                this.renderGroupedModels(name);
            }
        };
        this.resetHoveredSeries = () => {
            this.models = { guideLine: [] };
        };
    }
    getSeriesModels(type) {
        var _a;
        const _b = this.models, { guideLine } = _b, models = __rest(_b, ["guideLine"]);
        return (_a = (type ? models[type] : Object.values(models))) === null || _a === void 0 ? void 0 : _a.flatMap((val) => val);
    }
    hasGuideLine() {
        const [rectModel] = this.getSeriesModels().filter(({ type }) => type === 'rect');
        return !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(this.modelForGuideLine) && (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(rectModel);
    }
    getModelForGuideLine(name) {
        return this.getSeriesModels().filter(({ type }) => type === guideLineType[name])[0];
    }
    renderGroupedModels(name) {
        if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.includes)(Object.keys(guideLineType), name)) {
            if (this.isShow && this.hasGuideLine()) {
                this.models.guideLine = [this.renderGuideLineModel(this.modelForGuideLine)];
            }
            else {
                this.models.guideLine = [];
            }
        }
    }
    renderGuideLineModel(model) {
        const x = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_4__.crispPixel)(model.type === 'boxPlot' && model.boxPlotDetection
            ? model.boxPlotDetection.x + model.boxPlotDetection.width / 2
            : model.x);
        return {
            type: 'line',
            x,
            y: 0,
            x2: x,
            y2: this.rect.height,
            strokeStyle: '#ddd',
            lineWidth: 1,
        };
    }
    initialize() {
        this.type = 'hoveredSeries';
        this.name = 'hoveredSeries';
        this.eventBus.on('renderHoveredSeries', this.renderHoveredSeries);
        this.eventBus.on('resetHoveredSeries', this.resetHoveredSeries);
    }
    render({ layout }) {
        this.rect = layout.plot;
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/legend.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/legend.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Legend)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _store_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store/layout */ "./node_modules/@toast-ui/chart/dist/esm/store/layout.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _store_reactive__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/reactive */ "./node_modules/@toast-ui/chart/dist/esm/store/reactive.js");







class Legend extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.activatedResponders = [];
        this.seriesColorMap = {};
        this.seriesIconTypeMap = {};
        this.onClickCheckbox = (responders) => {
            const { label, checked } = responders[0];
            this.store.dispatch('setAllLegendActiveState', true);
            this.store.dispatch('setLegendCheckedState', { name: label, checked: !checked });
            if (checked) {
                this.store.dispatch('disableSeries', label);
            }
            else {
                this.store.dispatch('enableSeries', label);
            }
            this.eventBus.emit('needDraw');
        };
        this.onClickLabel = (responders) => {
            const { label } = responders[0];
            this.eventBus.emit('resetSelectedSeries');
            if (this.activatedResponders.length && this.activatedResponders[0].label === label) {
                this.store.dispatch('setAllLegendActiveState', true);
                this.activatedResponders = [];
            }
            else {
                this.store.dispatch('setAllLegendActiveState', false);
                this.store.dispatch('setLegendActiveState', { name: label, active: true });
                this.activatedResponders = responders;
            }
            this.eventBus.emit('needDraw');
        };
    }
    onClick({ responders }) {
        var _a;
        if (responders.length) {
            const { data } = responders[0];
            if (((_a = data) === null || _a === void 0 ? void 0 : _a.name) === 'checkbox') {
                this.eventBus.emit('clickLegendCheckbox', (0,_store_reactive__WEBPACK_IMPORTED_MODULE_1__.makeObservableObjectToNormal)(responders));
            }
            else {
                this.eventBus.emit('clickLegendLabel', (0,_store_reactive__WEBPACK_IMPORTED_MODULE_1__.makeObservableObjectToNormal)(responders));
            }
        }
    }
    initialize() {
        this.type = 'legend';
        this.name = 'legend';
        this.eventBus.on('clickLegendCheckbox', this.onClickCheckbox);
        this.eventBus.on('clickLegendLabel', this.onClickLabel);
    }
    initColorAndIconTypeMap(legendData) {
        this.seriesColorMap = {};
        this.seriesIconTypeMap = {};
        legendData.forEach(({ label, color, iconType }) => {
            this.seriesColorMap[label] = color;
            this.seriesIconTypeMap[label] = iconType;
        });
    }
    getXPositionWhenVerticalAlign(data) {
        const { offset, rowWidths } = data.reduce((acc, datum) => {
            const { rowIndex, columnIndex, width } = datum;
            if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(acc.rowWidths[rowIndex])) {
                acc.rowWidths[rowIndex] = 0;
                acc.offset[rowIndex] = [0];
            }
            acc.rowWidths[rowIndex] += width + (columnIndex ? _brushes_legend__WEBPACK_IMPORTED_MODULE_3__.LEGEND_ITEM_MARGIN_X : 0);
            acc.offset[rowIndex][columnIndex + 1] =
                acc.offset[rowIndex][columnIndex] + _brushes_legend__WEBPACK_IMPORTED_MODULE_3__.LEGEND_ITEM_MARGIN_X + width;
            return acc;
        }, { offset: [], rowWidths: [] });
        const { width } = this.rect;
        rowWidths.forEach((rowWidth, rowIndex) => {
            const xMargin = (width - rowWidth) / 2;
            offset[rowIndex] = offset[rowIndex].map((xOffset) => xOffset + xMargin);
        });
        return offset;
    }
    getXPositionWhenHorizontalAlign(data) {
        const maxWidths = data.reduce((acc, datum) => {
            const { columnIndex, width } = datum;
            if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(acc[columnIndex])) {
                acc[columnIndex] = 0;
            }
            acc[columnIndex] = Math.max(acc[columnIndex], width);
            return acc;
        }, []);
        return data.reduce((acc, datum) => {
            const { rowIndex, columnIndex } = datum;
            if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(acc[rowIndex])) {
                acc[rowIndex] = [0];
            }
            acc[rowIndex][columnIndex + 1] =
                acc[rowIndex][columnIndex] + _brushes_legend__WEBPACK_IMPORTED_MODULE_3__.LEGEND_ITEM_MARGIN_X + maxWidths[columnIndex];
            return acc;
        }, []);
    }
    renderLegendModel(legend) {
        const { data, showCheckbox, align, useScatterChartIcon } = legend;
        const verticalAlign = (0,_store_layout__WEBPACK_IMPORTED_MODULE_4__.isVerticalAlign)(align);
        const itemHeight = (0,_brushes_legend__WEBPACK_IMPORTED_MODULE_3__.getLegendItemHeight)(this.theme.label.fontSize);
        const xPosition = verticalAlign
            ? this.getXPositionWhenVerticalAlign(data)
            : this.getXPositionWhenHorizontalAlign(data);
        return [
            Object.assign({ type: 'legend', align,
                showCheckbox, data: data.map((datum) => {
                    var _a;
                    const { label, iconType, rowIndex, columnIndex } = datum;
                    return Object.assign(Object.assign({}, datum), { iconType: (_a = this.seriesIconTypeMap[label], (_a !== null && _a !== void 0 ? _a : iconType)), color: this.seriesColorMap[label], x: xPosition[rowIndex][columnIndex], y: _store_layout__WEBPACK_IMPORTED_MODULE_4__.padding.Y + itemHeight * rowIndex, useScatterChartIcon });
                }) }, this.theme.label),
        ];
    }
    makeCheckboxResponder(data, showCheckbox) {
        return showCheckbox
            ? data.map((m) => (Object.assign(Object.assign({}, m), { type: 'rect', x: m.x, y: m.y, width: _brushes_legend__WEBPACK_IMPORTED_MODULE_3__.LEGEND_CHECKBOX_SIZE, height: _brushes_legend__WEBPACK_IMPORTED_MODULE_3__.LEGEND_CHECKBOX_SIZE, data: { name: 'checkbox' } })))
            : [];
    }
    makeLabelResponder(data, showCheckbox) {
        const font = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_5__.getTitleFontString)(this.theme.label);
        return data.map((m) => (Object.assign(Object.assign({}, m), { type: 'rect', x: m.x +
                (showCheckbox ? _brushes_legend__WEBPACK_IMPORTED_MODULE_3__.LEGEND_CHECKBOX_SIZE + _brushes_legend__WEBPACK_IMPORTED_MODULE_3__.LEGEND_MARGIN_X : 0) +
                _brushes_legend__WEBPACK_IMPORTED_MODULE_3__.LEGEND_ICON_SIZE +
                _brushes_legend__WEBPACK_IMPORTED_MODULE_3__.LEGEND_MARGIN_X, y: m.y, width: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_6__.getTextWidth)(m.label, font), data: { name: 'label' }, height: _brushes_legend__WEBPACK_IMPORTED_MODULE_3__.LEGEND_CHECKBOX_SIZE })));
    }
    render({ layout, legend, theme }) {
        this.isShow = legend.visible && !!legend.data.length;
        if (!this.isShow) {
            return;
        }
        // @TODO: stack 일 떄 라벨 순서 역순으로(스택이 쌓인 순서대로) 되어야
        const { showCheckbox, data: legendData } = legend;
        this.rect = layout.legend;
        this.theme = theme.legend;
        this.initColorAndIconTypeMap(legendData);
        this.models = this.renderLegendModel(legend);
        const { data } = this.models[0];
        const checkboxResponder = this.makeCheckboxResponder(data, showCheckbox);
        const labelResponder = this.makeLabelResponder(data, showCheckbox);
        this.responders = [...checkboxResponder, ...labelResponder];
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/lineSeries.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/lineSeries.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LineSeries)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _helpers_coordinate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/coordinate */ "./node_modules/@toast-ui/chart/dist/esm/helpers/coordinate.js");
/* harmony import */ var _helpers_color__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../helpers/color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_legend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/legend */ "./node_modules/@toast-ui/chart/dist/esm/helpers/legend.js");
/* harmony import */ var _helpers_responders__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/responders */ "./node_modules/@toast-ui/chart/dist/esm/helpers/responders.js");
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _helpers_dataLabels__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/helpers/dataLabels.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");
/* harmony import */ var _helpers_validation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/validation */ "./node_modules/@toast-ui/chart/dist/esm/helpers/validation.js");











class LineSeries extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.models = { rect: [], series: [], dot: [] };
        this.activatedResponders = [];
        this.eventDetectType = 'nearest';
        this.yAxisName = 'yAxis';
        this.onMouseoutComponent = () => {
            this.eventBus.emit('seriesPointHovered', { models: [], name: this.name });
            this.eventBus.emit('renderHoveredSeries', {
                models: [],
                name: this.name,
                eventDetectType: this.eventDetectType,
            });
            this.eventBus.emit('needDraw');
        };
        this.selectSeries = (info) => {
            const { index, seriesIndex } = info;
            if (!(0,_helpers_validation__WEBPACK_IMPORTED_MODULE_1__.isAvailableSelectSeries)(info, 'line')) {
                return;
            }
            const category = this.getResponderCategoryByIndex(index);
            if (!category) {
                throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.SELECT_SERIES_API_INDEX_ERROR);
            }
            const model = this.tooltipCircleMap[category][seriesIndex];
            if (!model) {
                throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.SELECT_SERIES_API_INDEX_ERROR);
            }
            const models = this.getResponderSeriesWithTheme([model], 'select');
            this.eventBus.emit('renderSelectedSeries', { models, name: this.name });
            this.eventBus.emit('needDraw');
        };
        this.showTooltip = (info) => {
            var _a;
            const { index, seriesIndex } = info;
            if (!(0,_helpers_validation__WEBPACK_IMPORTED_MODULE_1__.isAvailableShowTooltipInfo)(info, this.eventDetectType, 'line')) {
                return;
            }
            const category = this.getResponderCategoryByIndex(index);
            if (!category) {
                return;
            }
            const models = this.eventDetectType === 'grouped'
                ? this.tooltipCircleMap[category]
                : [this.tooltipCircleMap[category][seriesIndex]];
            if (!((_a = models) === null || _a === void 0 ? void 0 : _a.length)) {
                return;
            }
            this.onMousemoveNearType(models);
            this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });
            this.eventBus.emit('needDraw');
        };
    }
    initialize() {
        this.type = 'series';
        this.name = 'line';
        this.eventBus.on('selectSeries', this.selectSeries);
        this.eventBus.on('showTooltip', this.showTooltip);
        this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
    initUpdate(delta) {
        this.drawModels.rect[0].width = this.models.rect[0].width * delta;
    }
    setEventDetectType(series, options) {
        var _a, _b;
        if (series.area || series.column) {
            this.eventDetectType = 'grouped';
        }
        if ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.eventDetectType) {
            this.eventDetectType = options.series.eventDetectType;
        }
        if (series.scatter) {
            this.eventDetectType = 'near';
        }
    }
    render(chartState, computed) {
        var _a, _b, _c, _d, _e, _f;
        const { viewRange } = computed;
        const { layout, series, scale, axes, legend, theme } = chartState;
        if (!series.line) {
            throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.noDataError(this.name));
        }
        const categories = (_a = chartState.categories, (_a !== null && _a !== void 0 ? _a : []));
        const rawCategories = (_b = chartState.rawCategories, (_b !== null && _b !== void 0 ? _b : []));
        const options = Object.assign({}, chartState.options);
        if (((_c = options) === null || _c === void 0 ? void 0 : _c.series) && 'line' in options.series) {
            options.series = Object.assign(Object.assign({}, options.series), options.series.line);
        }
        this.setEventDetectType(series, options);
        const labelAxisData = axes.xAxis;
        const seriesOptions = (_d = options.series, (_d !== null && _d !== void 0 ? _d : {}));
        const lineSeriesData = series.line.data;
        this.theme = theme.series.line;
        this.rect = layout.plot;
        this.activeSeriesMap = (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_3__.getActiveSeriesMap)(legend);
        this.startIndex = (_f = (_e = viewRange) === null || _e === void 0 ? void 0 : _e[0], (_f !== null && _f !== void 0 ? _f : 0));
        this.selectable = this.getSelectableOption(options);
        this.yAxisName = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_4__.getValueAxisName)(options, this.name, 'yAxis');
        const lineSeriesModel = this.renderLinePointsModel(lineSeriesData, scale, labelAxisData, seriesOptions, categories);
        const { dotSeriesModel, responderModel } = this.renderCircleModel(lineSeriesModel, seriesOptions);
        const tooltipDataArr = this.makeTooltipData(lineSeriesData, categories);
        this.tooltipCircleMap = (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_5__.makeTooltipCircleMap)(responderModel, tooltipDataArr);
        this.models = {
            rect: [this.renderClipRectAreaModel()],
            series: lineSeriesModel,
            dot: dotSeriesModel,
        };
        if (!this.drawModels) {
            this.drawModels = Object.assign(Object.assign({}, this.models), { rect: [this.renderClipRectAreaModel(true)] });
        }
        if ((0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_6__.getDataLabelsOptions)(options, this.name).visible) {
            this.renderDataLabels(this.getDataLabels(lineSeriesModel));
        }
        const coordinateType = (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_7__.isCoordinateSeries)(series);
        this.responders = this.getResponders({
            labelAxisData,
            responderModel,
            tooltipDataArr,
            categories,
            rawCategories,
            coordinateType,
        });
    }
    getResponders({ labelAxisData, responderModel, tooltipDataArr, categories, rawCategories, coordinateType, }) {
        if (this.eventDetectType === 'near') {
            return this.makeNearTypeResponderModel(responderModel, tooltipDataArr, rawCategories);
        }
        if (this.eventDetectType === 'point') {
            return this.makeNearTypeResponderModel(responderModel, tooltipDataArr, rawCategories, 0);
        }
        if (coordinateType) {
            const rectResponderInfo = this.getRectResponderInfoForCoordinateType(responderModel, rawCategories);
            return (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_5__.makeRectResponderModelForCoordinateType)(rectResponderInfo, this.rect);
        }
        return (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_5__.makeRectResponderModel)(this.rect, labelAxisData, categories);
    }
    makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr, categories, detectionSize) {
        return seriesCircleModel.map((m, index) => (Object.assign(Object.assign({}, m), { data: tooltipDataArr[index], detectionSize, label: categories[m.index] })));
    }
    makeTooltipData(lineSeriesData, categories) {
        return lineSeriesData.flatMap(({ rawData, name, color }, seriesIndex) => {
            return rawData.map((datum, index) => (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_8__.isNull)(datum)
                ? {}
                : {
                    label: name,
                    color,
                    value: (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_7__.getCoordinateYValue)(datum),
                    category: categories[(0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_7__.getCoordinateDataIndex)(datum, categories, index, this.startIndex)],
                    seriesIndex,
                    index,
                });
        });
    }
    renderClipRectAreaModel(isDrawModel) {
        return {
            type: 'clipRectArea',
            x: 0,
            y: 0,
            width: isDrawModel ? 0 : this.rect.width,
            height: this.rect.height,
        };
    }
    renderLinePointsModel(seriesRawData, scale, axisData, options, categories) {
        const { spline } = options;
        const yAxisLimit = scale[this.yAxisName].limit;
        const { lineWidth, dashSegments } = this.theme;
        return seriesRawData.map(({ rawData, name, color: seriesColor }, seriesIndex) => {
            const points = [];
            const active = this.activeSeriesMap[name];
            rawData.forEach((datum, idx) => {
                if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_8__.isNull)(datum)) {
                    return points.push(null);
                }
                const value = (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_7__.getCoordinateYValue)(datum);
                const yValueRatio = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_9__.getValueRatio)(value, yAxisLimit);
                const y = (1 - yValueRatio) * this.rect.height;
                const x = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_9__.getXPosition)(axisData, this.rect.width, (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_7__.getCoordinateXValue)(datum), (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_7__.getCoordinateDataIndex)(datum, categories, idx, this.startIndex));
                points.push({ x, y, value });
            });
            if (spline) {
                (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_9__.setSplineControlPoint)(points);
            }
            return {
                type: 'linePoints',
                points,
                seriesIndex,
                name,
                color: (0,_helpers_color__WEBPACK_IMPORTED_MODULE_10__.getRGBA)(seriesColor, active ? 1 : 0.3),
                lineWidth,
                dashSegments,
            };
        });
    }
    getRectResponderInfoForCoordinateType(circleModel, categories) {
        const duplicateCheckMap = {};
        const modelInRange = circleModel.filter(({ x }) => x >= 0 && x <= this.rect.width);
        return modelInRange.reduce((acc, model) => {
            const { index, x } = model;
            if (!duplicateCheckMap[x]) {
                const label = categories[index];
                duplicateCheckMap[x] = true;
                acc.push({ x, label });
            }
            return acc;
        }, []);
    }
    renderCircleModel(lineSeriesModel, options) {
        const dotSeriesModel = [];
        const responderModel = [];
        const showDot = !!options.showDot;
        const { hover, dot: dotTheme } = this.theme;
        const hoverDotTheme = hover.dot;
        lineSeriesModel.forEach(({ color, name, points }, seriesIndex) => {
            const active = this.activeSeriesMap[name];
            points.forEach((point, index) => {
                var _a, _b;
                if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_8__.isNull)(point)) {
                    return;
                }
                const { x, y } = point;
                const model = { type: 'circle', x, y, seriesIndex, name, index };
                if (showDot) {
                    dotSeriesModel.push(Object.assign(Object.assign({}, model), { radius: dotTheme.radius, color: (0,_helpers_color__WEBPACK_IMPORTED_MODULE_10__.getRGBA)(color, active ? 1 : 0.3), style: [
                            { lineWidth: dotTheme.borderWidth, strokeStyle: (_a = dotTheme.borderColor, (_a !== null && _a !== void 0 ? _a : color)) },
                        ] }));
                }
                responderModel.push(Object.assign(Object.assign({}, model), { radius: hoverDotTheme.radius, color: (_b = hoverDotTheme.color, (_b !== null && _b !== void 0 ? _b : (0,_helpers_color__WEBPACK_IMPORTED_MODULE_10__.getRGBA)(color, 1))), style: ['default'] }));
            });
        });
        return { dotSeriesModel, responderModel };
    }
    getCircleModelsFromRectResponders(responders, mousePositions) {
        var _a, _b;
        if (!responders.length || !responders[0].label) {
            return [];
        }
        const models = (_b = this.tooltipCircleMap[(_a = responders[0]) === null || _a === void 0 ? void 0 : _a.label], (_b !== null && _b !== void 0 ? _b : []));
        return this.eventDetectType === 'grouped'
            ? models
            : (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_5__.getNearestResponder)(models, mousePositions, this.rect);
    }
    onMousemoveNearType(responders) {
        this.eventBus.emit('renderHoveredSeries', {
            models: this.getResponderSeriesWithTheme(responders, 'hover'),
            name: this.name,
            eventDetectType: this.eventDetectType,
        });
        this.activatedResponders = responders;
    }
    onMousemoveNearestType(responders, mousePositions) {
        const circleModels = this.getCircleModelsFromRectResponders(responders, mousePositions);
        this.onMousemoveNearType(circleModels);
    }
    onMousemoveGroupedType(responders) {
        const circleModels = this.getCircleModelsFromRectResponders(responders);
        this.onMousemoveNearType(circleModels);
    }
    onMousemove({ responders, mousePosition }) {
        if (this.eventDetectType === 'nearest') {
            this.onMousemoveNearestType(responders, mousePosition);
        }
        else if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_8__.includes)(['near', 'point'], this.eventDetectType)) {
            this.onMousemoveNearType(responders);
        }
        else {
            this.onMousemoveGroupedType(responders);
        }
        this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });
        this.eventBus.emit('needDraw');
    }
    getDataLabels(seriesModels) {
        const dataLabelTheme = this.theme.dataLabels;
        return seriesModels.flatMap(({ points, name, color }) => points.map((point) => (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_8__.isNull)(point)
            ? {}
            : Object.assign(Object.assign({ type: 'point' }, point), { name, theme: Object.assign(Object.assign({}, dataLabelTheme), { color: dataLabelTheme.useSeriesColor ? color : dataLabelTheme.color }) })));
    }
    getResponderSeriesWithTheme(models, type) {
        const { radius, color, borderWidth, borderColor } = this.theme[type].dot;
        return models.map((model) => {
            const modelColor = (color !== null && color !== void 0 ? color : model.color);
            return Object.assign(Object.assign({}, model), { radius, color: modelColor, style: [{ lineWidth: borderWidth, strokeStyle: (borderColor !== null && borderColor !== void 0 ? borderColor : (0,_helpers_color__WEBPACK_IMPORTED_MODULE_10__.getRGBA)(modelColor, 0.5)) }] });
        });
    }
    onClick({ responders, mousePosition }) {
        if (this.selectable) {
            let models;
            if (this.eventDetectType === 'near') {
                models = responders;
            }
            else {
                models = this.getCircleModelsFromRectResponders(responders, mousePosition);
            }
            this.eventBus.emit('renderSelectedSeries', {
                models: this.getResponderSeriesWithTheme(models, 'select'),
                name: this.name,
            });
            this.eventBus.emit('needDraw');
        }
    }
    getResponderCategoryByIndex(index) {
        var _a, _b;
        const responder = Object.values(this.tooltipCircleMap)
            .flatMap((val) => val)
            .find((model) => model.index === index);
        return (_b = (_a = responder) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.category;
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/noDataText.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ NoDataText)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _helpers_validation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/validation */ "./node_modules/@toast-ui/chart/dist/esm/helpers/validation.js");




const DEFAULT_NO_DATA_TEXT = 'No data to display';
class NoDataText extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    initialize() {
        this.type = 'noDataText';
        this.name = 'noDataText';
    }
    getCenterPosition(text, font) {
        const textWidth = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_1__.getTextWidth)(text, font);
        const textHeight = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_1__.getTextHeight)(text, font);
        return {
            x: (this.rect.width - textWidth) / 2,
            y: (this.rect.height - textHeight) / 2,
        };
    }
    render({ layout, series, options, theme }) {
        var _a, _b, _c;
        const text = (_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.lang) === null || _b === void 0 ? void 0 : _b.noData, (_c !== null && _c !== void 0 ? _c : DEFAULT_NO_DATA_TEXT));
        const labelTheme = theme.noData;
        const font = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_2__.getTitleFontString)(labelTheme);
        const fillStyle = labelTheme.color;
        this.isShow = (0,_helpers_validation__WEBPACK_IMPORTED_MODULE_3__.isNoData)(series);
        this.rect = layout.plot;
        this.models = [
            Object.assign(Object.assign({ type: 'label' }, this.getCenterPosition(text, font)), { text, style: [{ font, fillStyle }] }),
        ];
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/pieSeries.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/pieSeries.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PieSeries)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_color__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../helpers/color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");
/* harmony import */ var _helpers_sector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/sector */ "./node_modules/@toast-ui/chart/dist/esm/helpers/sector.js");
/* harmony import */ var _helpers_legend__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/legend */ "./node_modules/@toast-ui/chart/dist/esm/helpers/legend.js");
/* harmony import */ var _helpers_dataLabels__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/helpers/dataLabels.js");
/* harmony import */ var _helpers_pieSeries__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helpers/pieSeries */ "./node_modules/@toast-ui/chart/dist/esm/helpers/pieSeries.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");











function getCalculatedRadiusRange({ alias, renderOptions, radiusRangeMap, pieIndex, radiusRanges, totalPieAliasCount, }) {
    var _a, _b, _c, _d, _e;
    const radiusRangeLength = Object.keys(radiusRangeMap).length;
    const { defaultRadius = 0 } = renderOptions;
    let { inner, outer } = renderOptions.radiusRange;
    if (!radiusRangeMap[alias]) {
        if (!radiusRangeLength) {
            const radius = defaultRadius / totalPieAliasCount;
            inner = pieIndex * radius;
            outer = (pieIndex + 1) * radius;
        }
        else {
            if (pieIndex && radiusRanges[pieIndex - 1].outer) {
                inner = radiusRanges[pieIndex - 1].outer;
            }
            if ((_a = radiusRanges[pieIndex + 1]) === null || _a === void 0 ? void 0 : _a.inner) {
                outer = radiusRanges[pieIndex + 1].inner;
            }
            else if (pieIndex === totalPieAliasCount - 1) {
                outer = defaultRadius;
            }
            else {
                const radius = (defaultRadius -
                    (_c = (_b = radiusRanges[pieIndex - 1]) === null || _b === void 0 ? void 0 : _b.outer, (_c !== null && _c !== void 0 ? _c : 0)) -
                    (_e = (_d = radiusRanges[pieIndex + 1]) === null || _d === void 0 ? void 0 : _d.inner, (_e !== null && _e !== void 0 ? _e : 0))) /
                    (totalPieAliasCount - radiusRangeLength);
                outer = inner + radius;
            }
        }
    }
    return { inner, outer };
}
function getPieSeriesOpacityByDepth(originAlpha, depth, indexOfGroup, brightness = 0.85) {
    const depthAlpha = Number((originAlpha * Math.pow(brightness, depth)).toFixed(2));
    return Number((Math.pow(depthAlpha, (indexOfGroup + 1))).toFixed(2));
}
function getMaxDataLabelSize(seriesNameLabels, options, dataLabelTheme) {
    var _a, _b;
    const outerLabels = [
        {
            hasOuterLabel: options.visible && options.anchor === 'outer',
            labels: ['00.00%'],
            theme: dataLabelTheme,
        },
        {
            hasOuterLabel: ((_a = options.pieSeriesName) === null || _a === void 0 ? void 0 : _a.visible) && ((_b = options.pieSeriesName) === null || _b === void 0 ? void 0 : _b.anchor) === 'outer',
            labels: seriesNameLabels,
            theme: dataLabelTheme.pieSeriesName,
        },
    ];
    return outerLabels.reduce((acc, cur) => {
        const { width, height } = acc;
        const { hasOuterLabel, labels, theme } = cur;
        if (hasOuterLabel) {
            const { maxLabelWidth, maxLabelHeight } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_0__.getMaxLabelSize)(labels, 0, (0,_helpers_style__WEBPACK_IMPORTED_MODULE_1__.getFont)(theme));
            return {
                width: Math.max(maxLabelWidth + _helpers_dataLabels__WEBPACK_IMPORTED_MODULE_2__.RADIUS_PADDING, width),
                height: Math.max(maxLabelHeight + _helpers_dataLabels__WEBPACK_IMPORTED_MODULE_2__.RADIUS_PADDING, height),
            };
        }
        return acc;
    }, { width: 0, height: 0 });
}
class PieSeries extends _component__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor() {
        super(...arguments);
        this.models = { series: [] };
        this.activatedResponders = [];
        this.onMouseoutComponent = () => {
            this.eventBus.emit('seriesPointHovered', { models: [], name: this.alias || this.name });
            this.eventBus.emit('renderHoveredSeries', { models: [], name: this.alias || this.name });
            this.eventBus.emit('needDraw');
        };
        this.selectSeries = ({ seriesIndex, name }) => {
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_4__.isNumber)(seriesIndex) || (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_4__.isUndefined)(name) && name !== this.alias)) {
                return;
            }
            const model = this.responders[seriesIndex];
            if (!model) {
                throw new Error(_message__WEBPACK_IMPORTED_MODULE_5__.message.SELECT_SERIES_API_INDEX_ERROR);
            }
            this.eventBus.emit('renderSelectedSeries', {
                models: this.getResponderModelsWithTheme([model], 'select'),
                name: this.name,
                alias: this.alias,
            });
            this.eventBus.emit('needDraw');
        };
        this.showTooltip = ({ seriesIndex, name }) => {
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_4__.isNumber)(seriesIndex) || (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_4__.isUndefined)(name) && name !== this.alias)) {
                return;
            }
            const models = [this.responders[seriesIndex]];
            if (!models.length) {
                return;
            }
            this.eventBus.emit('renderHoveredSeries', {
                models: this.getResponderModelsWithTheme(models, 'hover'),
                name: this.name,
                alias: this.alias,
            });
            this.activatedResponders = this.makeTooltipResponder(models);
            this.eventBus.emit('seriesPointHovered', {
                models: this.activatedResponders,
                name: this.alias || this.name,
            });
            this.eventBus.emit('needDraw');
        };
    }
    initUpdate(delta) {
        if (!this.drawModels) {
            return;
        }
        let currentDegree;
        const index = this.models.series.findIndex(({ clockwise, degree: { start, end }, totalAngle }) => {
            currentDegree = clockwise ? totalAngle * delta : _helpers_sector__WEBPACK_IMPORTED_MODULE_6__.DEGREE_360 - totalAngle * delta;
            return (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_6__.withinRadian)(clockwise, start, end, currentDegree);
        });
        this.syncEndAngle(index < 0 ? this.models.series.length : index);
        if (~index) {
            this.drawModels.series[index].degree.end = currentDegree;
        }
    }
    syncEndAngle(index) {
        if (index < 1) {
            return;
        }
        for (let i = 0; i < index; i += 1) {
            const prevTargetEndDegree = this.models.series[i].degree.end;
            if (this.drawModels.series[i].degree.end !== prevTargetEndDegree) {
                this.drawModels.series[i].degree.end = prevTargetEndDegree;
            }
        }
    }
    initialize(param) {
        var _a, _b;
        this.type = 'series';
        this.name = 'pie';
        this.alias = (_b = (_a = param) === null || _a === void 0 ? void 0 : _a.alias, (_b !== null && _b !== void 0 ? _b : ''));
        this.eventBus.on('selectSeries', this.selectSeries);
        this.eventBus.on('showTooltip', this.showTooltip);
        this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
    render(chartState) {
        var _a, _b, _c, _d;
        const { layout, series, legend, options, nestedPieSeries, theme } = chartState;
        const categories = (_a = chartState.categories, (_a !== null && _a !== void 0 ? _a : []));
        if (!series.pie) {
            throw new Error(_message__WEBPACK_IMPORTED_MODULE_5__.message.noDataError(this.name));
        }
        const pieTheme = theme.series.pie;
        this.theme = this.alias ? pieTheme[this.alias] : pieTheme;
        this.rect = layout.plot;
        this.activeSeriesMap = (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_7__.getActiveSeriesMap)(legend);
        this.selectable = this.getSelectableOption(options);
        let seriesModel, tooltipDataModel;
        const dataLabelsOptions = (0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_2__.getDataLabelsOptions)(options, this.alias);
        if (nestedPieSeries) {
            const { data } = nestedPieSeries[this.alias];
            const pieAlias = Object.keys(nestedPieSeries);
            const pieIndex = pieAlias.findIndex((alias) => alias === this.alias);
            // check the data label of the last Pie series
            const lastAlias = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_4__.last)(pieAlias);
            const lastSeries = nestedPieSeries[lastAlias];
            const maxPieDataLabelSize = getMaxDataLabelSize(lastSeries.data.map(({ name }) => name), (0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_2__.getDataLabelsOptions)(options, lastAlias), this.theme.dataLabels);
            const renderOptionsMap = this.getRenderOptionsMap(options, pieAlias, maxPieDataLabelSize);
            seriesModel = this.renderPieModel(data, renderOptionsMap[this.alias], pieIndex);
            tooltipDataModel = (0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_8__.makePieTooltipData)(data, (_b = categories) === null || _b === void 0 ? void 0 : _b[pieIndex]);
        }
        else {
            const pieData = (_c = series.pie) === null || _c === void 0 ? void 0 : _c.data;
            const { width, height } = getMaxDataLabelSize(pieData.map(({ name }) => name), dataLabelsOptions, this.theme.dataLabels);
            const renderOptions = this.makeRenderOptions(options, width, height);
            seriesModel = this.renderPieModel(pieData, renderOptions);
            tooltipDataModel = (0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_8__.makePieTooltipData)(pieData, (_d = categories) === null || _d === void 0 ? void 0 : _d[0]);
        }
        this.models.series = seriesModel;
        if (!this.drawModels) {
            this.drawModels = {
                series: this.models.series.map((m) => (Object.assign(Object.assign({}, m), { degree: Object.assign(Object.assign({}, m.degree), { end: m.degree.start }) }))),
            };
        }
        if (dataLabelsOptions.visible) {
            const dataLabelData = seriesModel.map((m) => (Object.assign(Object.assign({}, m), { value: `${(0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_8__.pieTooltipLabelFormatter)(m.percentValue)}`, theme: this.theme.dataLabels })));
            this.renderDataLabels(dataLabelData, this.alias);
        }
        this.responders = seriesModel.map((m, index) => (Object.assign(Object.assign({}, m), { type: 'sector', radius: m.radius, seriesIndex: index, data: Object.assign(Object.assign({}, tooltipDataModel[index]), { percentValue: m.percentValue }), color: (0,_helpers_color__WEBPACK_IMPORTED_MODULE_9__.getRGBA)(m.color, 1) })));
    }
    getRadiusRangeMap(options, pieAlias) {
        return pieAlias.reduce((acc, alias) => {
            var _a, _b;
            const seriesOptions = this.getOptions(options, alias).series;
            if ((_a = seriesOptions) === null || _a === void 0 ? void 0 : _a.radiusRange) {
                acc[alias] = (_b = seriesOptions) === null || _b === void 0 ? void 0 : _b.radiusRange;
            }
            return acc;
        }, {});
    }
    getRenderOptionsMap(options, pieAlias, maxPieDataLabelSize) {
        const renderOptionsMap = this.initRenderOptionsMap(options, pieAlias, maxPieDataLabelSize);
        const radiusRangeMap = this.getRadiusRangeMap(options, pieAlias);
        pieAlias.forEach((alias, pieIndex) => {
            const radiusRanges = Object.values(renderOptionsMap).map(({ radiusRange }) => radiusRange);
            renderOptionsMap[alias].radiusRange = getCalculatedRadiusRange({
                alias,
                renderOptions: renderOptionsMap[alias],
                radiusRangeMap,
                pieIndex,
                radiusRanges,
                totalPieAliasCount: pieAlias.length,
            });
        });
        return renderOptionsMap;
    }
    initRenderOptionsMap(options, pieAlias, { width, height }) {
        return pieAlias.reduce((acc, alias) => (Object.assign(Object.assign({}, acc), { [alias]: this.makeRenderOptions(this.getOptions(options, alias), width, height) })), {});
    }
    getOptions(chartOptions, alias) {
        var _a;
        const options = Object.assign({}, chartOptions);
        if (((_a = options) === null || _a === void 0 ? void 0 : _a.series) && alias) {
            options.series = Object.assign(Object.assign({}, options.series), options.series[alias]);
        }
        return options;
    }
    makeRenderOptions(options, maxDataLabelWidth = 0, maxDataLabelHeight = 0) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const seriesOptions = options.series;
        const clockwise = (_b = (_a = seriesOptions) === null || _a === void 0 ? void 0 : _a.clockwise, (_b !== null && _b !== void 0 ? _b : true));
        const startAngle = (_e = (_d = (_c = seriesOptions) === null || _c === void 0 ? void 0 : _c.angleRange) === null || _d === void 0 ? void 0 : _d.start, (_e !== null && _e !== void 0 ? _e : _helpers_sector__WEBPACK_IMPORTED_MODULE_6__.DEGREE_0));
        const endAngle = (_h = (_g = (_f = seriesOptions) === null || _f === void 0 ? void 0 : _f.angleRange) === null || _g === void 0 ? void 0 : _g.end, (_h !== null && _h !== void 0 ? _h : _helpers_sector__WEBPACK_IMPORTED_MODULE_6__.DEGREE_360));
        const totalAngle = (0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_8__.getTotalAngle)(clockwise, startAngle, endAngle);
        const isSemiCircular = (0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_8__.isSemiCircle)(clockwise, startAngle, endAngle);
        const { width, height } = this.rect;
        const defaultRadius = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_6__.getDefaultRadius)(this.rect, isSemiCircular, maxDataLabelWidth, maxDataLabelHeight);
        const innerRadius = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_4__.calculateSizeWithPercentString)(defaultRadius, (_l = (_k = (_j = seriesOptions) === null || _j === void 0 ? void 0 : _j.radiusRange) === null || _k === void 0 ? void 0 : _k.inner, (_l !== null && _l !== void 0 ? _l : 0)));
        const outerRadius = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_4__.calculateSizeWithPercentString)(defaultRadius, (_p = (_o = (_m = seriesOptions) === null || _m === void 0 ? void 0 : _m.radiusRange) === null || _o === void 0 ? void 0 : _o.outer, (_p !== null && _p !== void 0 ? _p : (this.alias ? 0 : defaultRadius))));
        const cx = width / 2;
        const cy = isSemiCircular ? (0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_8__.getSemiCircleCenterY)(this.rect.height, clockwise) : height / 2;
        return {
            clockwise,
            cx,
            cy,
            drawingStartAngle: startAngle - _helpers_sector__WEBPACK_IMPORTED_MODULE_6__.DEGREE_90,
            radiusRange: {
                inner: innerRadius,
                outer: outerRadius,
            },
            angleRange: {
                start: startAngle,
                end: endAngle,
            },
            totalAngle,
            defaultRadius,
        };
    }
    renderPieModel(seriesRawData, renderOptions, pieIndex) {
        const sectorModels = [];
        const total = seriesRawData.reduce((sum, { data }) => sum + ((data !== null && data !== void 0 ? data : 0)), 0);
        const { clockwise, cx, cy, drawingStartAngle, radiusRange: { inner, outer }, totalAngle, } = renderOptions;
        const defaultStartDegree = clockwise ? _helpers_sector__WEBPACK_IMPORTED_MODULE_6__.DEGREE_0 : _helpers_sector__WEBPACK_IMPORTED_MODULE_6__.DEGREE_360;
        const { lineWidth, strokeStyle } = this.theme;
        seriesRawData.forEach((rawData, seriesIndex) => {
            const color = this.alias
                ? this.getAliasSeriesColor(rawData, seriesRawData, pieIndex)
                : this.getSeriesColor(rawData);
            const { data, name } = rawData;
            if (data) {
                const degree = Math.max((data / total) * totalAngle, 1) * (clockwise ? 1 : -1);
                const percentValue = (data / total) * 100;
                const prevModel = sectorModels[sectorModels.length - 1];
                const startDegree = seriesIndex && prevModel ? prevModel.degree.end : defaultStartDegree;
                const endDegree = clockwise
                    ? Math.min(startDegree + degree, _helpers_sector__WEBPACK_IMPORTED_MODULE_6__.DEGREE_360)
                    : Math.max(startDegree + degree, _helpers_sector__WEBPACK_IMPORTED_MODULE_6__.DEGREE_0);
                sectorModels.push({
                    type: 'sector',
                    name,
                    color,
                    x: cx,
                    y: cy,
                    degree: {
                        start: startDegree,
                        end: endDegree,
                    },
                    radius: {
                        inner,
                        outer,
                    },
                    value: data,
                    style: [{ strokeStyle }],
                    lineWidth,
                    clockwise,
                    drawingStartAngle,
                    totalAngle,
                    percentValue,
                });
            }
        });
        return sectorModels;
    }
    makeTooltipResponder(responders) {
        return responders.map((responder) => (Object.assign(Object.assign({}, responder), (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_6__.getRadialAnchorPosition)((0,_helpers_sector__WEBPACK_IMPORTED_MODULE_6__.makeAnchorPositionParam)('center', this.models.series[responder.seriesIndex])))));
    }
    onMousemove({ responders }) {
        this.eventBus.emit('renderHoveredSeries', {
            models: this.getResponderModelsWithTheme(responders, 'hover'),
            name: this.alias || this.name,
        });
        this.activatedResponders = this.makeTooltipResponder(responders);
        this.eventBus.emit('seriesPointHovered', {
            models: this.activatedResponders,
            name: this.alias || this.name,
        });
        this.eventBus.emit('needDraw');
    }
    onClick({ responders }) {
        if (this.selectable) {
            this.eventBus.emit('renderSelectedSeries', {
                models: this.getResponderModelsWithTheme(responders, 'select'),
                name: this.name,
                alias: this.alias,
            });
            this.eventBus.emit('needDraw');
        }
    }
    getResponderModelsWithTheme(responders, type) {
        const theme = this.theme[type];
        const lineWidth = theme.lineWidth;
        const isSameLineWidth = this.theme.lineWidth === lineWidth;
        const thickness = isSameLineWidth ? 0 : lineWidth * 0.5;
        return responders.map((m) => {
            var _a, _b;
            return (Object.assign(Object.assign({}, m), { color: (_b = (_a = theme) === null || _a === void 0 ? void 0 : _a.color, (_b !== null && _b !== void 0 ? _b : m.color)), lineWidth, style: [
                    (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_4__.pick)(theme, 'strokeStyle', 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY'),
                ], radius: {
                    inner: Math.max(m.radius.inner - thickness, 0),
                    outer: m.radius.outer + thickness,
                } }));
        });
    }
    getOpacity(active, selectedState) {
        const { select, areaOpacity } = this.theme;
        const { areaOpacity: selectedAreaOpacity, restSeries: { areaOpacity: restAreaOpacity }, } = select;
        const selectThemeOpacity = active ? selectedAreaOpacity : restAreaOpacity;
        return selectedState ? selectThemeOpacity : areaOpacity;
    }
    getIndexOfGroup(seriesRawData, parentName, name) {
        return seriesRawData
            .filter((datum) => parentName === datum.parentName)
            .findIndex((datum) => name === datum.name);
    }
    getSeriesColor(rawData) {
        const { color, name } = rawData;
        const active = this.activeSeriesMap[name];
        const opacity = this.getOpacity(active, this.hasActiveSeries());
        return (0,_helpers_color__WEBPACK_IMPORTED_MODULE_9__.getRGBA)(color, opacity);
    }
    getAliasSeriesColor(rawData, seriesRawData, pieIndex) {
        const { color, name } = rawData;
        const { select: { color: selectedColor }, } = this.theme;
        const { rootParentName, parentName } = rawData;
        const indexOfGroup = this.getIndexOfGroup(seriesRawData, parentName, name);
        const opacity = this.getAliasSeriesOpacity(rootParentName, parentName, pieIndex, indexOfGroup, name);
        const active = this.activeSeriesMap[(rootParentName !== null && rootParentName !== void 0 ? rootParentName : name)];
        const seriesColor = active ? (selectedColor !== null && selectedColor !== void 0 ? selectedColor : color) : color;
        return (0,_helpers_color__WEBPACK_IMPORTED_MODULE_9__.getRGBA)(seriesColor, opacity);
    }
    getAliasSeriesOpacity(rootParentName, parentName, pieIndex, indexOfGroup, name) {
        const active = this.activeSeriesMap[(rootParentName !== null && rootParentName !== void 0 ? rootParentName : name)];
        const opacity = this.getOpacity(active, this.hasActiveSeries());
        return pieIndex && parentName
            ? getPieSeriesOpacityByDepth(opacity, pieIndex, indexOfGroup)
            : opacity;
    }
    hasActiveSeries() {
        return Object.values(this.activeSeriesMap).some((elem) => !elem);
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/plot.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/plot.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Plot)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");



function getValidIndex(index, startIndex = 0) {
    return ~~index ? index - startIndex : index;
}
function validXPosition({ axisData, offsetSize, value, startIndex = 0 }) {
    const dataIndex = getValidIndex(value, startIndex);
    const x = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.getXPosition)(axisData, offsetSize, value, dataIndex);
    return x > 0 ? Math.min(offsetSize, x) : 0;
}
function getPlotAxisData(vertical, axes) {
    return vertical ? axes.xAxis : axes.yAxis;
}
class Plot extends _component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(...arguments);
        this.models = { plot: [], line: [], band: [] };
        this.startIndex = 0;
    }
    initialize() {
        this.type = 'plot';
    }
    getPlotAxisSize(vertical) {
        return {
            offsetSize: vertical ? this.rect.width : this.rect.height,
            anchorSize: vertical ? this.rect.height : this.rect.width,
        };
    }
    renderLines(axes, categories, lines = []) {
        return lines.map(({ value, color }) => {
            const { offsetSize } = this.getPlotAxisSize(true);
            const position = validXPosition({
                axisData: getPlotAxisData(true, axes),
                offsetSize,
                value,
                categories,
                startIndex: this.startIndex,
            });
            return this.makeLineModel(true, position, { color });
        });
    }
    renderBands(axes, categories, bands = []) {
        const { offsetSize, anchorSize } = this.getPlotAxisSize(true);
        return bands.map(({ range, color }) => {
            const [start, end] = range.map((value) => validXPosition({
                axisData: getPlotAxisData(true, axes),
                offsetSize,
                value,
                categories,
                startIndex: this.startIndex,
            }));
            return {
                type: 'rect',
                x: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.crispPixel)(start),
                y: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.crispPixel)(0),
                width: end - start,
                height: anchorSize,
                color,
            };
        });
    }
    renderPlotLineModels(relativePositions, vertical, options = {}) {
        var _a, _b, _c;
        const { size, startPosition, axes } = options;
        const { lineColor: color, lineWidth, dashSegments } = this.theme[vertical ? 'vertical' : 'horizontal'];
        const tickInterval = ((_c = (vertical ? (_a = axes) === null || _a === void 0 ? void 0 : _a.xAxis : (_b = axes) === null || _b === void 0 ? void 0 : _b.yAxis)) === null || _c === void 0 ? void 0 : _c.tickInterval) || 1;
        return relativePositions
            .filter((_, idx) => !(idx % tickInterval))
            .map((position) => this.makeLineModel(vertical, position, { color, lineWidth, dashSegments }, (size !== null && size !== void 0 ? size : this.rect.width), (startPosition !== null && startPosition !== void 0 ? startPosition : 0)));
    }
    renderPlotsForCenterYAxis(axes) {
        const { xAxisHalfSize, secondStartX, yAxisHeight } = axes.centerYAxis;
        // vertical
        const xAxisTickCount = axes.xAxis.tickCount;
        const verticalLines = [
            ...this.renderPlotLineModels((0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.makeTickPixelPositions)(xAxisHalfSize, xAxisTickCount), true),
            ...this.renderPlotLineModels((0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.makeTickPixelPositions)(xAxisHalfSize, xAxisTickCount, secondStartX), true),
        ];
        // horizontal
        const yAxisTickCount = axes.yAxis.tickCount;
        const yAxisTickPixelPositions = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.makeTickPixelPositions)(yAxisHeight, yAxisTickCount);
        const horizontalLines = [
            ...this.renderPlotLineModels(yAxisTickPixelPositions, false, { size: xAxisHalfSize }),
            ...this.renderPlotLineModels(yAxisTickPixelPositions, false, {
                size: xAxisHalfSize,
                startPosition: secondStartX,
            }),
        ];
        return [...verticalLines, ...horizontalLines];
    }
    renderPlots(axes, scale) {
        const vertical = true;
        return axes.centerYAxis
            ? this.renderPlotsForCenterYAxis(axes)
            : [
                ...this.renderPlotLineModels(this.getHorizontalTickPixelPositions(axes), !vertical, {
                    axes,
                }),
                ...this.renderPlotLineModels(this.getVerticalTickPixelPositions(axes, scale), vertical, {
                    axes,
                }),
            ];
    }
    getVerticalTickPixelPositions(axes, scale) {
        var _a, _b, _c, _d, _e, _f, _g;
        const { offsetSize } = this.getPlotAxisSize(true);
        const axisData = getPlotAxisData(true, axes);
        if ((_a = axisData) === null || _a === void 0 ? void 0 : _a.labelRange) {
            const sizeRatio = (_d = (_c = (_b = scale) === null || _b === void 0 ? void 0 : _b.xAxis) === null || _c === void 0 ? void 0 : _c.sizeRatio, (_d !== null && _d !== void 0 ? _d : 1));
            const positionRatio = (_g = (_f = (_e = scale) === null || _e === void 0 ? void 0 : _e.xAxis) === null || _f === void 0 ? void 0 : _f.positionRatio, (_g !== null && _g !== void 0 ? _g : 0));
            const axisSizeAppliedRatio = offsetSize * sizeRatio;
            const additional = offsetSize * positionRatio;
            return (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.makeTickPixelPositions)(axisSizeAppliedRatio, axisData.tickCount, additional);
        }
        return (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.makeTickPixelPositions)(offsetSize, axisData.tickCount);
    }
    getHorizontalTickPixelPositions(axes) {
        const { offsetSize } = this.getPlotAxisSize(false);
        const axisData = getPlotAxisData(false, axes);
        return (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.makeTickPixelPositions)(offsetSize, axisData.tickCount);
    }
    renderPlotBackgroundRect() {
        return Object.assign(Object.assign({ type: 'rect', x: 0, y: 0 }, (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.pick)(this.rect, 'width', 'height')), { color: this.theme.backgroundColor });
    }
    render(state) {
        var _a, _b, _c;
        const { layout, axes, plot, zoomRange, theme, scale } = state;
        if (!plot) {
            return;
        }
        this.rect = layout.plot;
        this.startIndex = (_b = (_a = zoomRange) === null || _a === void 0 ? void 0 : _a[0], (_b !== null && _b !== void 0 ? _b : 0));
        this.theme = theme.plot;
        const categories = (_c = state.categories, (_c !== null && _c !== void 0 ? _c : []));
        const { lines, bands, visible } = plot;
        this.models.line = this.renderLines(axes, categories, lines);
        this.models.band = this.renderBands(axes, categories, bands);
        if (visible) {
            this.models.plot = [this.renderPlotBackgroundRect(), ...this.renderPlots(axes, scale)];
        }
    }
    makeLineModel(vertical, position, { color, dashSegments = [], lineWidth = 1, }, sizeWidth, xPos = 0) {
        const x = vertical ? (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.crispPixel)(position) : (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.crispPixel)(xPos);
        const y = vertical ? (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.crispPixel)(0) : (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_0__.crispPixel)(position);
        const width = vertical ? 0 : (sizeWidth !== null && sizeWidth !== void 0 ? sizeWidth : this.rect.width);
        const height = vertical ? this.rect.height : 0;
        return {
            type: 'line',
            x,
            y,
            x2: x + width,
            y2: y + height,
            strokeStyle: color,
            lineWidth,
            dashSegments,
        };
    }
    beforeDraw(painter) {
        painter.ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
        painter.ctx.lineWidth = 1;
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/radarSeries.js":
/*!************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/radarSeries.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RadarSeries)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_legend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/legend */ "./node_modules/@toast-ui/chart/dist/esm/helpers/legend.js");
/* harmony import */ var _helpers_sector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/sector */ "./node_modules/@toast-ui/chart/dist/esm/helpers/sector.js");
/* harmony import */ var _helpers_color__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _helpers_theme__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helpers/theme */ "./node_modules/@toast-ui/chart/dist/esm/helpers/theme.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");









const NONE_AREA_OPACITY = 0;
const seriesOpacity = {
    INACTIVE: 0.2,
    ACTIVE: 1,
};
class RadarSeries extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.models = { area: [], line: [], dot: [] };
        this.activatedResponders = [];
        this.onMouseoutComponent = () => {
            this.eventBus.emit('seriesPointHovered', { models: [], name: this.name });
            this.eventBus.emit('renderHoveredSeries', {
                models: [],
                name: this.name,
            });
            this.eventBus.emit('needDraw');
        };
        this.selectSeries = ({ index, seriesIndex, state }) => {
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(index) || !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(seriesIndex)) {
                return;
            }
            const { name } = state.series.radar.data[seriesIndex];
            const model = this.responders.filter(({ name: dataName }) => dataName === name)[index];
            if (!model) {
                throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.SELECT_SERIES_API_INDEX_ERROR);
            }
            this.eventBus.emit('renderSelectedSeries', {
                models: this.getRespondersWithTheme([model], 'select'),
                name: this.name,
            });
            this.eventBus.emit('needDraw');
        };
        this.showTooltip = ({ index, seriesIndex, state }) => {
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(index) || !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(seriesIndex)) {
                return;
            }
            const { name } = state.series.radar.data[seriesIndex];
            const models = [this.responders.filter(({ name: dataName }) => dataName === name)[index]];
            if (!models.length) {
                return;
            }
            this.eventBus.emit('renderHoveredSeries', {
                models: this.getRespondersWithTheme(models, 'hover'),
                name: this.name,
            });
            this.activatedResponders = models;
            this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });
            this.eventBus.emit('needDraw');
        };
    }
    initialize() {
        this.type = 'series';
        this.name = 'radar';
        this.eventBus.on('selectSeries', this.selectSeries);
        this.eventBus.on('showTooltip', this.showTooltip);
        this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
    render(state) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const { layout, radialAxes, series, legend, options, theme, scale } = state;
        if (!series.radar) {
            throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.noDataError(this.name));
        }
        this.theme = theme.series.radar;
        this.rect = layout.plot;
        this.activeSeriesMap = (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_3__.getActiveSeriesMap)(legend);
        this.selectable = this.getSelectableOption(options);
        const categories = state.categories;
        const { axisSize, centerX, centerY } = radialAxes.verticalAxis;
        const { limit, stepSize } = scale.verticalAxis;
        const labels = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_4__.makeLabelsFromLimit)(limit, stepSize);
        const { min, max } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_5__.getLimitOnAxis)(labels);
        const renderOptions = {
            categories,
            degree: _helpers_sector__WEBPACK_IMPORTED_MODULE_6__.DEGREE_360 / categories.length,
            centerX,
            centerY,
            showArea: (_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.showArea, (_c !== null && _c !== void 0 ? _c : false)),
            ratio: axisSize / (max - min),
        };
        const radarData = (_d = series.radar) === null || _d === void 0 ? void 0 : _d.data;
        const radarPointsData = this.makeRadarPointsData(radarData, renderOptions);
        const circleModel = this.renderDotModels(radarPointsData);
        this.models.area = ((_f = (_e = options) === null || _e === void 0 ? void 0 : _e.series) === null || _f === void 0 ? void 0 : _f.showArea) ? this.renderAreaModels(radarPointsData) : [];
        this.models.line = this.renderLineModels(radarPointsData);
        this.models.dot = ((_h = (_g = options) === null || _g === void 0 ? void 0 : _g.series) === null || _h === void 0 ? void 0 : _h.showDot) ? circleModel : [];
        if (!this.drawModels) {
            this.drawModels = {
                area: this.initDrawModels('area', centerX, centerY),
                line: this.initDrawModels('line', centerX, centerY),
                dot: this.models.dot.map((m) => (Object.assign(Object.assign({}, m), { x: centerX, y: centerY }))),
            };
        }
        const tooltipDataArr = this.makeTooltipModel(circleModel, categories);
        this.responders = circleModel.map((m, index) => (Object.assign(Object.assign({}, m), { data: tooltipDataArr[index], color: (0,_helpers_color__WEBPACK_IMPORTED_MODULE_7__.getRGBA)(m.color, 1) })));
    }
    initDrawModels(modelName, centerX, centerY) {
        return this.models[modelName].map((m) => {
            var _a;
            return (Object.assign(Object.assign({}, m), { distances: (_a = m.distances) === null || _a === void 0 ? void 0 : _a.map(() => 0), points: m.points.map(() => ({ x: centerX, y: centerY })) }));
        });
    }
    makeTooltipModel(circleModel, categories) {
        return circleModel.map(({ name, color, value, index }) => ({
            label: name,
            color,
            value,
            category: categories[index],
        }));
    }
    getRespondersWithTheme(responders, type) {
        const { radius, borderWidth, borderColor, color } = this.theme[type].dot;
        return responders.map((responder) => {
            const modelColor = (color !== null && color !== void 0 ? color : responder.color);
            return Object.assign(Object.assign({}, responder), { radius, color: modelColor, borderColor: (borderColor !== null && borderColor !== void 0 ? borderColor : (0,_helpers_color__WEBPACK_IMPORTED_MODULE_7__.getRGBA)(modelColor, 0.5)), borderWidth });
        });
    }
    onClick({ responders }) {
        if (this.selectable) {
            this.eventBus.emit('renderSelectedSeries', {
                models: this.getRespondersWithTheme(responders, 'select'),
                name: this.name,
            });
            this.eventBus.emit('needDraw');
        }
    }
    onMousemove({ responders }) {
        this.eventBus.emit('renderHoveredSeries', {
            models: this.getRespondersWithTheme(responders, 'hover'),
            name: this.name,
        });
        this.activatedResponders = responders;
        this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });
        this.eventBus.emit('needDraw');
    }
    makeRadarPointsData(seriesData, renderOptions) {
        const { centerX, centerY, degree, ratio, showArea } = renderOptions;
        return seriesData.map(({ data, color: seriesColor, name }) => {
            const radarPoints = data.reduce((acc, value, index) => {
                if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(value)) {
                    return {
                        distances: [...acc.distances, 0],
                        linePoints: [...acc.linePoints, null],
                        areaPoints: [...acc.areaPoints, { x: centerX, y: centerY }],
                    };
                }
                const distance = value * ratio;
                const point = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_6__.getRadialPosition)(centerX, centerY, distance, (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_6__.calculateDegreeToRadian)(degree * index));
                return {
                    distances: [...acc.distances, distance],
                    linePoints: [...acc.linePoints, point],
                    areaPoints: [...acc.areaPoints, point],
                };
            }, { linePoints: [], distances: [], areaPoints: [] });
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(data[0]) && !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(data[data.length - 1])) {
                radarPoints.linePoints.push(radarPoints.linePoints[0]);
                radarPoints.areaPoints.push(radarPoints.areaPoints[0]);
            }
            return Object.assign(Object.assign({ name,
                seriesColor,
                data }, radarPoints), this.getSeriesColor(showArea, seriesColor, name));
        });
    }
    renderAreaModels(radarPointsData) {
        return radarPointsData.map(({ distances, areaPoints, name, fillColor, seriesColor }) => ({
            type: 'areaPoints',
            name,
            distances,
            points: areaPoints,
            fillColor,
            color: (0,_helpers_color__WEBPACK_IMPORTED_MODULE_7__.getRGBA)(seriesColor, 0),
            lineWidth: 0,
        }));
    }
    renderLineModels(radarPointsData) {
        const { lineWidth, dashSegments } = this.theme;
        return radarPointsData.map(({ distances, linePoints, name, lineColor }) => ({
            type: 'linePoints',
            lineWidth: (lineWidth !== null && lineWidth !== void 0 ? lineWidth : _helpers_theme__WEBPACK_IMPORTED_MODULE_8__.radarDefault.LINE_WIDTH),
            name,
            distances,
            points: linePoints,
            color: lineColor,
            dashSegments,
        }));
    }
    renderDotModels(radarPointsData) {
        const { radius, color: dotColor } = this.theme.dot;
        const result = [];
        radarPointsData.forEach(({ linePoints, lineColor, name, data }, seriesIndex) => linePoints.slice(0, linePoints.length - 1).forEach((point, index) => {
            var _a;
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(point)) {
                result.push(Object.assign(Object.assign({ type: 'circle' }, point), { radius, color: (dotColor !== null && dotColor !== void 0 ? dotColor : lineColor), style: [{ strokeStyle: 'rgba(0, 0, 0, 0)' }], name,
                    seriesIndex,
                    index, value: (_a = data) === null || _a === void 0 ? void 0 : _a[index] }));
            }
        }));
        return result;
    }
    getSeriesColor(showArea, seriesColor, name) {
        const active = this.activeSeriesMap[name];
        const { select, areaOpacity } = this.theme;
        const selected = Object.values(this.activeSeriesMap).some((elem) => !elem);
        const color = (0,_helpers_color__WEBPACK_IMPORTED_MODULE_7__.getRGBA)(seriesColor, active ? seriesOpacity.ACTIVE : seriesOpacity.INACTIVE);
        let fillOpacity = NONE_AREA_OPACITY;
        if (showArea) {
            const selectedAreaOpacity = active ? select.areaOpacity : select.restSeries.areaOpacity;
            fillOpacity = selected ? selectedAreaOpacity : areaOpacity;
        }
        return { lineColor: color, fillColor: (0,_helpers_color__WEBPACK_IMPORTED_MODULE_7__.getRGBA)(color, fillOpacity) };
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/radialAxis.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/radialAxis.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RadialAxis)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_sector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/sector */ "./node_modules/@toast-ui/chart/dist/esm/helpers/sector.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_validation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/validation */ "./node_modules/@toast-ui/chart/dist/esm/helpers/validation.js");





const RECT_SIZE = 4;
const HALF_TICK = 5;
function hasNeedRender(index, pointOnColumn, labelInterval, innerRadius, outerRadius) {
    return !pointOnColumn && index === 0
        ? false
        : !(index % labelInterval) &&
            ((pointOnColumn && innerRadius <= outerRadius) ||
                (!pointOnColumn && innerRadius < outerRadius));
}
class RadialAxis extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.models = {
            verticalAxisLabel: [],
            circularAxisLabel: [],
            dot: [],
            line: [],
            tick: [],
        };
    }
    initialize(initParam) {
        var _a, _b;
        this.type = 'axis';
        this.name = (_b = (_a = initParam) === null || _a === void 0 ? void 0 : _a.name, (_b !== null && _b !== void 0 ? _b : 'radial'));
    }
    render({ layout, radialAxes, theme, series }) {
        this.isShow = !(0,_helpers_validation__WEBPACK_IMPORTED_MODULE_1__.isNoData)(series);
        this.rect = layout.plot;
        if (!radialAxes) {
            return;
        }
        this.circularAxisTheme = theme.circularAxis;
        const { circularAxis, verticalAxis } = radialAxes;
        if (verticalAxis) {
            this.verticalAxisTheme = theme.verticalAxis;
            this.models.verticalAxisLabel = this.renderVerticalAxisLabel(verticalAxis);
        }
        this.models.circularAxisLabel = this.renderCircularAxisLabel(circularAxis);
        if (this.name === 'gauge') {
            this.models.line = this.renderArcLine(circularAxis);
            this.models.tick = this.renderTick(circularAxis);
        }
        else {
            this.models.dot = this.renderDotModel(circularAxis);
        }
    }
    getBubbleShadowStyle() {
        const { visible, shadowColor, shadowOffsetX, shadowOffsetY, shadowBlur, } = this.verticalAxisTheme.label.textBubble;
        return visible && shadowColor
            ? [
                {
                    shadowColor,
                    shadowOffsetX,
                    shadowOffsetY,
                    shadowBlur,
                },
            ]
            : null;
    }
    renderVerticalAxisLabel(verticalAxis) {
        const { radius: { ranges, outer }, label: { labels, interval, maxWidth, maxHeight, margin, align }, angle: { start }, pointOnColumn, centerX, centerY, tickDistance, } = verticalAxis;
        const labelAdjustment = pointOnColumn ? tickDistance / 2 : 0;
        const font = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_2__.getTitleFontString)(this.verticalAxisTheme.label);
        const { visible: textBubbleVisible, backgroundColor, borderRadius, borderColor, borderWidth, paddingX, paddingY, } = this.verticalAxisTheme.label.textBubble;
        const labelPaddingX = textBubbleVisible ? paddingX : 0;
        const labelPaddingY = textBubbleVisible ? paddingY : 0;
        const width = maxWidth + labelPaddingX * 2 - margin;
        const height = maxHeight + labelPaddingY * 2;
        const fontColor = this.verticalAxisTheme.label.color;
        return ranges.reduce((acc, radius, index) => {
            const { x, y } = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.getRadialPosition)(centerX, centerY, radius - labelAdjustment, (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.calculateDegreeToRadian)(start));
            const needRender = hasNeedRender(index, pointOnColumn, interval, radius, outer);
            let posX = x + margin;
            let labelPosX = x + margin + labelPaddingX;
            if (align === 'center') {
                posX = x - margin - width / 2;
                labelPosX = x - margin;
            }
            else if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_4__.includes)(['right', 'end'], align)) {
                posX = x - margin - width;
                labelPosX = x - margin - labelPaddingX;
            }
            return needRender
                ? [
                    ...acc,
                    {
                        type: 'bubbleLabel',
                        rotationPosition: { x, y },
                        radian: (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.calculateDegreeToRadian)(start, 0),
                        bubble: {
                            x: posX,
                            y: y - height / 2,
                            width,
                            height,
                            align,
                            radius: borderRadius,
                            fill: backgroundColor,
                            lineWidth: borderWidth,
                            strokeStyle: borderColor,
                            style: this.getBubbleShadowStyle(),
                        },
                        label: {
                            text: labels[index],
                            x: labelPosX,
                            y,
                            style: [{ font, fillStyle: fontColor, textAlign: align, textBaseline: 'middle' }],
                        },
                    },
                ]
                : acc;
        }, []);
    }
    renderDotModel(circularAxis) {
        const { angle: { central, drawingStart }, label: { labels, interval }, radius: { outer }, centerX, centerY, clockwise, } = circularAxis;
        const { dotColor } = this.circularAxisTheme;
        return labels.reduce((acc, cur, index) => {
            const startDegree = drawingStart + central * index * (clockwise ? 1 : -1);
            const { x, y } = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.getRadialPosition)(centerX, centerY, outer, (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.calculateDegreeToRadian)((0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.calculateValidAngle)(startDegree)));
            return index % interval === 0
                ? [
                    ...acc,
                    {
                        type: 'rect',
                        color: dotColor,
                        width: RECT_SIZE,
                        height: RECT_SIZE,
                        x: x - RECT_SIZE / 2,
                        y: y - RECT_SIZE / 2,
                    },
                ]
                : acc;
        }, []);
    }
    renderCircularAxisLabel(circularAxis) {
        const { centerX, centerY, clockwise, label: { labels, interval, margin, maxHeight }, angle: { drawingStart, central }, radius: { outer }, } = circularAxis;
        const radius = outer + (margin + maxHeight / 2) * (this.name === 'gauge' ? -1 : 1);
        const labelTheme = this.circularAxisTheme.label;
        const font = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_2__.getTitleFontString)(labelTheme);
        const degree = central * (clockwise ? 1 : -1);
        return labels.reduce((acc, text, index) => {
            const startDegree = drawingStart + degree * index;
            const validStartAngle = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.calculateValidAngle)(startDegree);
            return index % interval === 0
                ? [
                    ...acc,
                    Object.assign({ type: 'label', style: [
                            { textAlign: 'center', textBaseline: 'middle', font, fillStyle: labelTheme.color },
                        ], text }, (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.getRadialPosition)(centerX, centerY, radius, (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.calculateDegreeToRadian)(validStartAngle))),
                ]
                : acc;
        }, []);
    }
    renderTick(circularAxis) {
        const { centerX, centerY, tickInterval, clockwise, angle: { central, drawingStart }, label: { labels }, radius: { outer }, } = circularAxis;
        const { strokeStyle, lineWidth } = this.circularAxisTheme.tick;
        return labels.reduce((acc, cur, index) => {
            const startDegree = drawingStart + central * index * (clockwise ? 1 : -1);
            const { x, y } = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.getRadialPosition)(centerX, centerY, outer - HALF_TICK, (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.calculateDegreeToRadian)((0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.calculateValidAngle)(startDegree)));
            const { x: x2, y: y2 } = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.getRadialPosition)(centerX, centerY, outer + HALF_TICK, (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.calculateDegreeToRadian)((0,_helpers_sector__WEBPACK_IMPORTED_MODULE_3__.calculateValidAngle)(startDegree)));
            return index % tickInterval === 0
                ? [
                    ...acc,
                    {
                        type: 'line',
                        lineWidth,
                        strokeStyle,
                        x,
                        y,
                        x2,
                        y2,
                    },
                ]
                : acc;
        }, []);
    }
    renderArcLine(circularAxis) {
        const { centerX, centerY, clockwise, angle: { start, end, total }, radius: { outer }, } = circularAxis;
        const { strokeStyle, lineWidth } = this.circularAxisTheme;
        return total === _helpers_sector__WEBPACK_IMPORTED_MODULE_3__.DEGREE_360
            ? [
                {
                    type: 'circle',
                    x: centerX,
                    y: centerY,
                    radius: outer,
                    borderWidth: lineWidth,
                    borderColor: strokeStyle,
                    color: 'rgba(0, 0, 0, 0)',
                },
            ]
            : [
                {
                    type: 'arc',
                    borderWidth: lineWidth,
                    borderColor: strokeStyle,
                    x: centerX,
                    y: centerY,
                    angle: { start, end },
                    drawingStartAngle: _helpers_sector__WEBPACK_IMPORTED_MODULE_3__.DEGREE_NEGATIVE_90,
                    radius: outer,
                    clockwise,
                },
            ];
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/radialBarSeries.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/radialBarSeries.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RadialBarSeries)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");
/* harmony import */ var _helpers_responders__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/responders */ "./node_modules/@toast-ui/chart/dist/esm/helpers/responders.js");
/* harmony import */ var _helpers_sector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/sector */ "./node_modules/@toast-ui/chart/dist/esm/helpers/sector.js");
/* harmony import */ var _helpers_legend__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/legend */ "./node_modules/@toast-ui/chart/dist/esm/helpers/legend.js");
/* harmony import */ var _helpers_dataLabels__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/helpers/dataLabels.js");
/* harmony import */ var _helpers_color__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../helpers/color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");
/* harmony import */ var _helpers_pieSeries__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helpers/pieSeries */ "./node_modules/@toast-ui/chart/dist/esm/helpers/pieSeries.js");
/* harmony import */ var _helpers_validation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/validation */ "./node_modules/@toast-ui/chart/dist/esm/helpers/validation.js");










class RadialBarSeries extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.models = {};
        this.activatedResponders = [];
        this.eventDetectType = 'point';
        this.onMouseoutComponent = () => {
            this.eventBus.emit('seriesPointHovered', { models: [], name: this.name });
            this.eventBus.emit('renderHoveredSeries', { models: [], name: this.name });
            this.eventBus.emit('needDraw');
        };
        this.selectSeries = (info) => {
            var _a;
            const { index, seriesIndex } = info;
            const isAvailable = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(index) && (this.eventDetectType === 'grouped' || (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(seriesIndex));
            if (!isAvailable) {
                return;
            }
            const models = this.eventDetectType === 'grouped'
                ? [
                    ...this.getGroupedSector([this.responders[index]], 'select'),
                    ...this.getRadialBarSectorModelsFromResponders([this.responders[index]]),
                ]
                : (_a = this.getResponderModelsWithTheme([this.tooltipSectorMap[index][seriesIndex]], 'select'), (_a !== null && _a !== void 0 ? _a : []));
            if (!models.length) {
                throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.SELECT_SERIES_API_INDEX_ERROR);
            }
            this.eventBus.emit('renderSelectedSeries', {
                models: models,
                name: this.name,
                eventDetectType: this.eventDetectType,
            });
            this.eventBus.emit('needDraw');
        };
        this.showTooltip = (info) => {
            const { index, seriesIndex } = info;
            if (!(0,_helpers_validation__WEBPACK_IMPORTED_MODULE_3__.isAvailableShowTooltipInfo)(info, this.eventDetectType, 'radialBar')) {
                return;
            }
            const models = this.eventDetectType === 'grouped'
                ? this.getGroupedSector([this.responders[index]], 'hover')
                : this.getResponderModelsWithTheme([this.tooltipSectorMap[index][seriesIndex]], 'hover');
            if (!models.length) {
                return;
            }
            this.eventBus.emit('renderHoveredSeries', {
                models,
                name: this.name,
                eventDetectType: this.eventDetectType,
            });
            this.activatedResponders =
                this.eventDetectType === 'grouped' ? this.tooltipSectorMap[index] : models;
            this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });
            this.eventBus.emit('needDraw');
        };
    }
    initUpdate(delta) {
        if (!this.drawModels) {
            return;
        }
        const { angle: { start: startAngle, total: totalAngle }, } = this.circularAxis;
        let currentDegree;
        Object.keys(this.models).forEach((category) => {
            const index = this.models[category].findIndex(({ clockwise, degree: { start, end } }) => {
                currentDegree = clockwise
                    ? startAngle + totalAngle * delta
                    : startAngle - totalAngle * delta;
                return (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_4__.withinRadian)(clockwise, start, end, currentDegree);
            });
            this.syncEndAngle(index < 0 ? this.models[category].length : index, category);
            if (index !== -1) {
                this.drawModels[category][index].degree.end = currentDegree;
            }
        });
    }
    syncEndAngle(index, category) {
        if (index < 1) {
            return;
        }
        for (let i = 0; i < index; i += 1) {
            const prevTargetEndDegree = this.models[category][i].degree.end;
            if (this.drawModels[category][i].degree.end !== prevTargetEndDegree) {
                this.drawModels[category][i].degree.end = prevTargetEndDegree;
            }
        }
    }
    initialize() {
        this.type = 'series';
        this.name = 'radialBar';
        this.eventBus.on('selectSeries', this.selectSeries);
        this.eventBus.on('showTooltip', this.showTooltip);
        this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
    render(chartState) {
        var _a, _b;
        const { layout, series, legend, options, theme, stackSeries, scale, radialAxes } = chartState;
        const categories = (_a = chartState.categories, (_a !== null && _a !== void 0 ? _a : []));
        if (!series.radialBar || !stackSeries.radialBar) {
            throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.noDataError(this.name));
        }
        this.theme = theme.series.radialBar;
        this.rect = layout.plot;
        this.activeSeriesMap = (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_5__.getActiveSeriesMap)(legend);
        this.selectable = this.getSelectableOption(options);
        this.setEventDetectType(options);
        const initialCategoryMap = categories.reduce((acc, category) => {
            if (!acc[category]) {
                acc[category] = [];
            }
            return acc;
        }, {});
        const seriesData = series.radialBar.data;
        this.circularAxis = radialAxes.circularAxis;
        const verticalAxisData = radialAxes.verticalAxis;
        const renderOptions = this.makeRenderOptions(verticalAxisData, scale.circularAxis, (_b = options) === null || _b === void 0 ? void 0 : _b.series);
        const { categoryMap, seriesModels } = this.makeSeriesModelData(seriesData, stackSeries.radialBar.stackData, renderOptions, initialCategoryMap);
        const tooltipData = this.makeTooltipData(seriesModels, categories);
        this.models = categoryMap;
        if (!this.drawModels) {
            this.initDrawModels(categoryMap);
        }
        if ((0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_6__.getDataLabelsOptions)(options, this.name).visible) {
            const dataLabelData = seriesModels.reduce((acc, data) => {
                return [...acc, Object.assign(Object.assign({}, data), { type: 'sector', theme: this.theme.dataLabels })];
            }, []);
            this.renderDataLabels(dataLabelData);
        }
        this.tooltipSectorMap = this.makeTooltipSectorMap(seriesModels, tooltipData);
        this.responders = this.makeResponders(verticalAxisData.radius.ranges, seriesModels, renderOptions, categories, tooltipData);
    }
    initDrawModels(categoryMap) {
        this.drawModels = {};
        Object.keys(categoryMap).forEach((category) => {
            this.drawModels[category] = categoryMap[category].map((m) => (Object.assign(Object.assign({}, m), { degree: Object.assign(Object.assign({}, m.degree), { end: m.degree.start }) })));
        });
    }
    makeResponders(radiusRanges, seriesModels, renderOptions, categories, tooltipData) {
        return this.eventDetectType === 'grouped'
            ? (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_7__.makeGroupedSectorResponderModel)(radiusRanges, renderOptions, categories)
            : seriesModels.map((m, index) => (Object.assign(Object.assign({}, m), { data: Object.assign({}, tooltipData[index]) })));
    }
    makeTooltipSectorMap(seriesModels, tooltipData) {
        return seriesModels.reduce((acc, cur, index) => {
            const categoryIndex = cur.index;
            if (!acc[categoryIndex]) {
                acc[categoryIndex] = [];
            }
            acc[categoryIndex].push(Object.assign(Object.assign({}, cur), { data: Object.assign({}, tooltipData[index]) }));
            return acc;
        }, {});
    }
    setEventDetectType(options) {
        var _a, _b;
        if ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.eventDetectType) {
            this.eventDetectType = options.series.eventDetectType;
        }
    }
    getBarWidth(tickDistance, axisSize) {
        const { barWidth } = this.theme;
        const DEFAULT_PADDING = 5;
        return barWidth
            ? Math.min(tickDistance, (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.calculateSizeWithPercentString)(axisSize, barWidth))
            : tickDistance - DEFAULT_PADDING * 2;
    }
    makeRenderOptions({ axisSize, centerX, centerY, tickDistance, radius: { ranges }, angle: { start, end }, }, scale, options) {
        var _a, _b;
        const { limit: { max }, stepSize, } = scale;
        const clockwise = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.clockwise, (_b !== null && _b !== void 0 ? _b : true));
        const totalAngle = (0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_8__.getTotalAngle)(clockwise, start, end);
        const barWidth = this.getBarWidth(tickDistance, axisSize);
        const padding = (tickDistance - barWidth) / 2;
        const scaleMaxLimitValue = max + (totalAngle < _helpers_sector__WEBPACK_IMPORTED_MODULE_4__.DEGREE_360 ? _helpers_sector__WEBPACK_IMPORTED_MODULE_4__.DEGREE_0 : stepSize);
        return {
            clockwise,
            centerX,
            centerY,
            radiusRanges: (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_4__.getRadiusRanges)(ranges, padding),
            angleRange: {
                start,
                end,
            },
            totalAngle,
            scaleMaxLimitValue,
            startAngle: start,
        };
    }
    makeSeriesModelData(seriesData, stackSeriesData, renderOptions, initialCategoryMap) {
        const { clockwise, centerX, centerY, radiusRanges, totalAngle, scaleMaxLimitValue, startAngle, } = renderOptions;
        const defaultStartDegree = startAngle;
        const { lineWidth, strokeStyle } = this.theme;
        const sectorModels = [];
        const categories = Object.keys(initialCategoryMap);
        const categoryMap = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.deepCopy)(initialCategoryMap);
        stackSeriesData.forEach(({ values }, categoryIndex) => {
            const { inner, outer } = radiusRanges[categoryIndex];
            values.forEach((value, seriesIndex) => {
                if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(value)) {
                    const degree = Math.max((value / scaleMaxLimitValue) * totalAngle, 1) * (clockwise ? 1 : -1);
                    const prevModel = sectorModels[sectorModels.length - 1];
                    const startDegree = seriesIndex && prevModel ? prevModel.degree.end : defaultStartDegree;
                    const endDegree = clockwise
                        ? Math.min(startDegree + degree, _helpers_sector__WEBPACK_IMPORTED_MODULE_4__.DEGREE_360)
                        : Math.max(startDegree + degree, _helpers_sector__WEBPACK_IMPORTED_MODULE_4__.DEGREE_0);
                    const { name, color: seriesColor } = seriesData[seriesIndex];
                    const color = this.getSeriesColor(name, seriesColor);
                    const sectorModel = {
                        type: 'sector',
                        name,
                        color: color,
                        x: centerX,
                        y: centerY,
                        degree: {
                            start: startDegree,
                            end: endDegree,
                        },
                        radius: {
                            inner,
                            outer,
                        },
                        value,
                        style: [{ strokeStyle }],
                        lineWidth,
                        clockwise,
                        totalAngle,
                        seriesColor,
                        seriesIndex,
                        index: categoryIndex,
                        drawingStartAngle: _helpers_sector__WEBPACK_IMPORTED_MODULE_4__.DEGREE_NEGATIVE_90,
                    };
                    categoryMap[categories[categoryIndex]].push(sectorModel);
                    sectorModels.push(sectorModel);
                }
            });
        });
        return { seriesModels: sectorModels, categoryMap };
    }
    getSeriesColor(name, color) {
        const { select, areaOpacity } = this.theme;
        const active = this.activeSeriesMap[name];
        const selected = Object.values(this.activeSeriesMap).some((elem) => !elem);
        return selected
            ? (0,_helpers_color__WEBPACK_IMPORTED_MODULE_9__.getRGBA)(color, active ? select.areaOpacity : select.restSeries.areaOpacity)
            : (0,_helpers_color__WEBPACK_IMPORTED_MODULE_9__.getRGBA)(color, areaOpacity);
    }
    makeTooltipData(seriesModels, categories) {
        const tooltipData = [];
        seriesModels.forEach(({ seriesColor, name, value, index }) => {
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(value)) {
                tooltipData.push({
                    label: name,
                    color: seriesColor,
                    value: value,
                    category: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(index) ? categories[index] : '',
                });
            }
        });
        return tooltipData;
    }
    makeTooltipResponder(responders) {
        const categories = Object.keys(this.models);
        return responders.map((responder) => (Object.assign(Object.assign({}, responder), (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_4__.getRadialAnchorPosition)((0,_helpers_sector__WEBPACK_IMPORTED_MODULE_4__.makeAnchorPositionParam)('center', this.models[categories[responder.index]].find(({ name }) => name === responder.name))))));
    }
    getRadialBarSectorModelsFromResponders(responders) {
        var _a;
        if (!responders.length) {
            return [];
        }
        return _a = this.tooltipSectorMap[responders[0].index], (_a !== null && _a !== void 0 ? _a : []);
    }
    getGroupedSector(responders, type) {
        const RadialBarSectorModels = this.getRadialBarSectorModelsFromResponders(responders);
        const { color, opacity } = this.theme[type].groupedSector;
        return RadialBarSectorModels.length
            ? responders.map((m) => (Object.assign(Object.assign({}, m), { color: (0,_helpers_color__WEBPACK_IMPORTED_MODULE_9__.getRGBA)(color, opacity) })))
            : [];
    }
    onMousemoveGroupedType(responders) {
        const RadialBarSectorModels = this.getRadialBarSectorModelsFromResponders(responders);
        this.eventBus.emit('renderHoveredSeries', {
            models: this.getGroupedSector(responders, 'hover'),
            name: this.name,
            eventDetectType: this.eventDetectType,
        });
        this.activatedResponders = RadialBarSectorModels;
    }
    onMousemove({ responders }) {
        if (this.eventDetectType === 'grouped') {
            this.onMousemoveGroupedType(responders);
        }
        else {
            this.eventBus.emit('renderHoveredSeries', {
                models: this.getResponderModelsWithTheme(responders, 'hover'),
                name: this.name,
            });
            this.activatedResponders = this.makeTooltipResponder(responders);
        }
        this.eventBus.emit('seriesPointHovered', {
            models: this.activatedResponders,
            name: this.name,
            eventDetectType: this.eventDetectType,
        });
        this.eventBus.emit('needDraw');
    }
    onClick({ responders }) {
        if (this.selectable) {
            let models;
            if (this.eventDetectType === 'grouped') {
                models = [
                    ...this.getGroupedSector(responders, 'select'),
                    ...this.getRadialBarSectorModelsFromResponders(responders),
                ];
            }
            else {
                models = this.getResponderModelsWithTheme(responders, 'select');
            }
            this.eventBus.emit('renderSelectedSeries', {
                models,
                name: this.name,
                eventDetectType: this.eventDetectType,
            });
            this.eventBus.emit('needDraw');
        }
    }
    getResponderModelsWithTheme(responders, type) {
        const theme = this.theme[type];
        const lineWidth = theme.lineWidth;
        const isSameLineWidth = this.theme.lineWidth === lineWidth;
        const thickness = isSameLineWidth ? 0 : lineWidth * 0.5;
        return responders.map((m) => {
            var _a, _b;
            return (Object.assign(Object.assign({}, m), { color: (_b = (_a = theme) === null || _a === void 0 ? void 0 : _a.color, (_b !== null && _b !== void 0 ? _b : m.color)), lineWidth: lineWidth, style: [
                    (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.pick)(theme, 'strokeStyle', 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY'),
                ], radius: {
                    inner: Math.max(m.radius.inner - thickness, 0),
                    outer: m.radius.outer + thickness,
                } }));
        });
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/radialPlot.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/radialPlot.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getScaleMaxLimitValue": () => (/* binding */ getScaleMaxLimitValue),
/* harmony export */   "default": () => (/* binding */ RadarPlot)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_sector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/sector */ "./node_modules/@toast-ui/chart/dist/esm/helpers/sector.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");




function getScaleMaxLimitValue(scale, totalAngle) {
    const { limit: { max }, stepSize, } = scale;
    return max + (totalAngle < _helpers_sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_360 ? _helpers_sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_0 : stepSize);
}
function findCategoryIndex(categories, value) {
    return categories.findIndex((category) => category === value);
}
class RadarPlot extends _component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(...arguments);
        this.models = { plot: [], line: [], band: [] };
    }
    initialize(initParam) {
        var _a, _b;
        this.type = 'plot';
        this.name = (_b = (_a = initParam) === null || _a === void 0 ? void 0 : _a.name, (_b !== null && _b !== void 0 ? _b : 'radialPlot'));
    }
    render(state) {
        var _a, _b, _c, _d, _e, _f;
        const { layout, radialAxes, options, series, theme, scale } = state;
        this.rect = layout.plot;
        this.circularAxisTheme = theme.circularAxis;
        const categories = (_a = state.categories, (_a !== null && _a !== void 0 ? _a : []));
        if (this.name === 'gauge') {
            const bandData = (_d = (_c = (_b = options) === null || _b === void 0 ? void 0 : _b.plot) === null || _c === void 0 ? void 0 : _c.bands, (_d !== null && _d !== void 0 ? _d : []));
            const hasCategoryAxis = !(0,_helpers_axes__WEBPACK_IMPORTED_MODULE_2__.isLabelAxisOnYAxis)({ series, categories });
            const renderOptions = this.makeRenderOptionsOnGauge(hasCategoryAxis, radialAxes.circularAxis, categories, scale);
            this.models.band = this.renderBands(bandData, renderOptions, categories);
        }
        else {
            const isRadarChart = !!series.radar;
            const plotType = (_f = (_e = options.plot) === null || _e === void 0 ? void 0 : _e.type, (_f !== null && _f !== void 0 ? _f : (isRadarChart ? 'spiderweb' : 'circle')));
            const renderOptions = this.makeRenderOptions(radialAxes, plotType, categories);
            this.models.plot = this.renderPlot(renderOptions);
            this.models.line = series.radialBar ? this.renderLine(renderOptions) : [];
        }
    }
    makeRenderOptionsOnGauge(hasCategoryAxis, circularAxis, categories, scale) {
        const { angle: { total, start }, radius: { outer }, clockwise, centerX, centerY, } = circularAxis;
        const { width: bandWidth, margin: bandMargin } = circularAxis.band;
        return {
            centerX,
            centerY,
            clockwise,
            totalAngle: total,
            scaleMaxLimitValue: hasCategoryAxis
                ? categories.length
                : getScaleMaxLimitValue(scale.circularAxis, total),
            startAngle: start,
            outerRadius: outer,
            bandWidth,
            bandMargin,
            hasCategoryAxis,
        };
    }
    makeRenderOptions(radialAxes, type, categories = []) {
        const { centerX, centerY, radius: { ranges, inner, outer }, } = radialAxes.verticalAxis;
        const { angle: { central, total, start, end, drawingStart }, label: { labels }, tickInterval, clockwise, } = radialAxes.circularAxis;
        const usingArcPlot = total !== _helpers_sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_360;
        const lineCount = labels.length;
        return {
            type,
            categories,
            centralAngle: central,
            centerX,
            centerY,
            initialRadius: inner,
            radius: outer,
            radiusRanges: ranges,
            lineCount,
            tickInterval,
            drawingStartAngle: drawingStart,
            usingArcPlot,
            startAngle: start,
            endAngle: end,
            clockwise,
        };
    }
    renderPlot(renderOptions) {
        const { type, usingArcPlot } = renderOptions;
        if (usingArcPlot) {
            return this.makeArc(renderOptions);
        }
        if (type === 'spiderweb') {
            return this.makeSpiderwebPlot(renderOptions);
        }
        return this.makeCirclePlot(renderOptions);
    }
    makeSpiderwebPlot(renderOptions) {
        const { centralAngle, centerX, centerY, categories, radiusRanges } = renderOptions;
        const { strokeStyle, lineWidth } = this.circularAxisTheme;
        return radiusRanges.map((radius) => {
            const points = categories.map((_, index) => (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_0__.getRadialPosition)(centerX, centerY, radius, (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_0__.calculateDegreeToRadian)(centralAngle * index)));
            return {
                type: 'polygon',
                color: strokeStyle,
                lineWidth,
                points,
            };
        });
    }
    makeCirclePlot(renderOptions) {
        const { centerX, centerY, radiusRanges } = renderOptions;
        const { strokeStyle, lineWidth } = this.circularAxisTheme;
        return radiusRanges.map((radius) => ({
            type: 'circle',
            color: 'rgba(0, 0, 0, 0)',
            radius,
            x: centerX,
            y: centerY,
            borderColor: strokeStyle,
            borderWidth: lineWidth,
        }));
    }
    makeArc(renderOptions) {
        const { centerX, centerY, radiusRanges, startAngle, endAngle, clockwise } = renderOptions;
        const { strokeStyle, lineWidth } = this.circularAxisTheme;
        return radiusRanges.map((radius) => ({
            type: 'arc',
            borderWidth: lineWidth,
            borderColor: strokeStyle,
            x: centerX,
            y: centerY,
            angle: { start: startAngle, end: endAngle },
            drawingStartAngle: _helpers_sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_NEGATIVE_90,
            radius,
            clockwise,
        }));
    }
    renderLine(renderOptions) {
        const { centerX, centerY, initialRadius, radius, lineCount, centralAngle, tickInterval, drawingStartAngle, clockwise, } = renderOptions;
        const { strokeStyle, lineWidth } = this.circularAxisTheme;
        return (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.range)(0, lineCount).reduce((acc, cur, index) => {
            const startDegree = drawingStartAngle + centralAngle * index * (clockwise ? 1 : -1);
            const { x, y } = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_0__.getRadialPosition)(centerX, centerY, initialRadius, (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_0__.calculateDegreeToRadian)(startDegree));
            const { x: x2, y: y2 } = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_0__.getRadialPosition)(centerX, centerY, radius, (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_0__.calculateDegreeToRadian)(startDegree));
            return index % tickInterval === 0
                ? [
                    ...acc,
                    {
                        type: 'line',
                        x,
                        y,
                        x2,
                        y2,
                        strokeStyle,
                        lineWidth,
                    },
                ]
                : acc;
        }, []);
    }
    renderBands(bands, renderOptions, categories) {
        const sectors = [];
        const { centerX, centerY, clockwise, totalAngle, scaleMaxLimitValue, startAngle, outerRadius, bandWidth, bandMargin, hasCategoryAxis, } = renderOptions;
        bands.forEach(({ range: rangeData, color }, index) => {
            const value = hasCategoryAxis
                ? findCategoryIndex(categories, rangeData[1].toString()) -
                    findCategoryIndex(categories, rangeData[0].toString())
                : Number(rangeData[1]) - Number(rangeData[0]);
            const degree = (value / scaleMaxLimitValue) * totalAngle * (clockwise ? 1 : -1);
            const validDegree = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_0__.calculateValidAngle)(degree);
            const prevModel = sectors[sectors.length - 1];
            const startDegree = index && prevModel ? prevModel.degree.end : startAngle;
            const endDegree = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_0__.calculateValidAngle)(startDegree + validDegree);
            sectors.push({
                type: 'sector',
                color,
                x: centerX,
                y: centerY,
                clockwise,
                degree: {
                    start: startDegree,
                    end: endDegree,
                },
                radius: {
                    inner: outerRadius + bandMargin,
                    outer: outerRadius + bandWidth,
                },
            });
        });
        return sectors;
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/rangeSelection.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/rangeSelection.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RangeSelection)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _store_reactive__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../store/reactive */ "./node_modules/@toast-ui/chart/dist/esm/store/reactive.js");
/* harmony import */ var _helpers_coordinate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/coordinate */ "./node_modules/@toast-ui/chart/dist/esm/helpers/coordinate.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _helpers_responders__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/responders */ "./node_modules/@toast-ui/chart/dist/esm/helpers/responders.js");







const DRAG_MIN_WIDTH = 15;
class RangeSelection extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.models = { selectionArea: [] };
        this.dragStartPosition = null;
        this.dragStartPoint = null;
        this.isDragging = false;
    }
    initialize() {
        this.type = 'rangeSelection';
    }
    render(state, computed) {
        var _a, _b;
        if (!state.selectionRange && !state.zoomRange) {
            return;
        }
        this.resetSelectionArea();
        const { viewRange } = computed;
        const { layout, axes, series, scale } = state;
        const categories = state.categories;
        this.rect = layout.plot;
        this.startIndex = (_b = (_a = viewRange) === null || _a === void 0 ? void 0 : _a[0], (_b !== null && _b !== void 0 ? _b : 0));
        const coordinateChart = (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_1__.isCoordinateSeries)(series);
        if (coordinateChart) {
            const responderInfo = this.getRectResponderInfoForCoordinateType(series, scale, axes.xAxis, categories);
            this.responders = this.makeRectResponderModelForCoordinateType(responderInfo, categories);
        }
        else {
            this.responders = this.makeRectResponderModel(categories, axes.xAxis);
        }
    }
    getRectResponderInfoForCoordinateType(series, scale, axisData, categories) {
        const points = [];
        const duplicateCheckMap = {};
        Object.keys(series).forEach((seriesName) => {
            const data = series[seriesName].data;
            data.forEach(({ rawData }) => {
                rawData.forEach((datum, idx) => {
                    if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.isNull)(datum)) {
                        return;
                    }
                    const dataIndex = (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_1__.getCoordinateDataIndex)(datum, categories, idx, this.startIndex);
                    const x = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.getXPosition)(axisData, this.rect.width, (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_1__.getCoordinateXValue)(datum), dataIndex);
                    const xWithinRect = x >= 0 && x <= this.rect.width;
                    if (!duplicateCheckMap[x] && xWithinRect) {
                        duplicateCheckMap[x] = true;
                        points.push({ x, label: categories[dataIndex] });
                    }
                });
            });
        });
        return points;
    }
    resetSelectionArea() {
        this.dragStartPosition = null;
        this.dragStartPoint = null;
        this.models.selectionArea = [];
        this.isDragging = false;
    }
    onMousedown({ responders, mousePosition }) {
        if (responders.length) {
            this.dragStartPoint = responders.find((responder) => responder.data.name === 'selectionArea');
            this.dragStartPosition = mousePosition;
        }
    }
    onMouseup({ responders }) {
        var _a, _b;
        if (this.isDragging && this.dragStartPoint && responders.length) {
            const dragRange = [this.dragStartPoint, responders[0]]
                .sort((a, b) => a.index - b.index)
                .map((m) => { var _a; return (_a = m.data) === null || _a === void 0 ? void 0 : _a.value; });
            const { series, options } = this.store.state;
            const { series: seriesOptions } = options;
            if (!series.column && ((_a = seriesOptions) === null || _a === void 0 ? void 0 : _a.zoomable)) {
                this.store.dispatch('zoom', dragRange);
                this.eventBus.emit('zoom', (0,_store_reactive__WEBPACK_IMPORTED_MODULE_4__.makeObservableObjectToNormal)(dragRange));
            }
            if ((_b = seriesOptions) === null || _b === void 0 ? void 0 : _b.rangeSelectable) {
                this.eventBus.emit('rangeSelection', dragRange);
            }
            this.eventBus.emit('resetHoveredSeries');
            this.eventBus.emit('hideTooltip');
            // @TODO: Should occur after the series' click event
            // Additional logic to control the sequence of events with each other is required.
            setTimeout(() => {
                this.eventBus.emit('resetSelectedSeries');
            });
        }
        this.resetSelectionArea();
    }
    makeRectResponderModel(categories, axisData) {
        const categorySize = categories.length;
        const { pointOnColumn, tickDistance } = axisData;
        const { height } = this.rect;
        const halfDetectAreaIndex = pointOnColumn ? [] : [0, categorySize - 1];
        const halfWidth = tickDistance / 2;
        return (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.range)(0, categorySize).map((index) => {
            const half = halfDetectAreaIndex.includes(index);
            const width = half ? halfWidth : tickDistance;
            let startX = 0;
            if (index !== 0) {
                startX += pointOnColumn ? tickDistance * index : halfWidth + tickDistance * (index - 1);
            }
            return {
                type: 'rect',
                x: startX,
                y: 0,
                height,
                width,
                index,
                data: { name: 'selectionArea', value: categories[index] },
            };
        });
    }
    makeRectResponderModelForCoordinateType(responderInfo, categories) {
        const responders = (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_5__.makeRectResponderModelForCoordinateType)(responderInfo, this.rect);
        return responders.map((m, idx) => (Object.assign(Object.assign({}, m), { data: { name: 'selectionArea', value: categories[idx] } })));
    }
    onMousemove({ responders, mousePosition }) {
        if (!responders.length) {
            return;
        }
        if (this.dragStartPosition && !this.isDragging) {
            const { x } = mousePosition;
            const { x: startX } = this.dragStartPosition;
            this.isDragging = Math.abs(startX - x) > DRAG_MIN_WIDTH;
        }
        if (this.isDragging) {
            const startIndex = this.dragStartPoint.index;
            const endIndex = responders[0].index;
            const [start, end] = [startIndex, endIndex].sort(_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.sortNumber);
            const includedResponders = this.responders.slice(start, end + 1);
            this.models.selectionArea = [
                ...includedResponders.map((m) => (Object.assign(Object.assign({}, m), { x: m.x, y: 0, type: 'rect', color: 'rgba(0, 0, 0, 0.2)' }))),
            ];
            this.eventBus.emit('needDraw');
        }
    }
    onMouseoutComponent() {
        this.resetSelectionArea();
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/resetButton.js":
/*!************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/resetButton.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ResetButton)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _store_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/layout */ "./node_modules/@toast-ui/chart/dist/esm/store/layout.js");
/* harmony import */ var _exportMenu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");



class ResetButton extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    initialize() {
        this.type = 'resetButton';
        this.name = 'resetButton';
    }
    onClick({ responders }) {
        if (responders.length) {
            this.eventBus.emit('resetZoom');
            this.store.dispatch('resetZoom');
        }
    }
    render({ options, layout }, computed) {
        if (!(0,_store_layout__WEBPACK_IMPORTED_MODULE_1__.isUsingResetButton)(options)) {
            return;
        }
        this.rect = layout.resetButton;
        this.isShow = computed.isLineTypeSeriesZooming;
        this.models = this.isShow ? [{ type: 'resetButton', x: 0, y: 0 }] : [];
        this.responders = this.isShow
            ? [{ type: 'rect', x: 0, y: 0, width: _exportMenu__WEBPACK_IMPORTED_MODULE_2__.BUTTON_RECT_SIZE, height: _exportMenu__WEBPACK_IMPORTED_MODULE_2__.BUTTON_RECT_SIZE }]
            : [];
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/scatterSeries.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/scatterSeries.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ScatterSeries)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_coordinate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/coordinate */ "./node_modules/@toast-ui/chart/dist/esm/helpers/coordinate.js");
/* harmony import */ var _helpers_color__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_legend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/legend */ "./node_modules/@toast-ui/chart/dist/esm/helpers/legend.js");
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _helpers_responders__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../helpers/responders */ "./node_modules/@toast-ui/chart/dist/esm/helpers/responders.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");
/* harmony import */ var _helpers_validation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/validation */ "./node_modules/@toast-ui/chart/dist/esm/helpers/validation.js");










class ScatterSeries extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.models = { series: [] };
        this.activatedResponders = [];
        this.onMouseoutComponent = () => {
            this.eventBus.emit('seriesPointHovered', { models: [], name: this.name });
            this.eventBus.emit('renderHoveredSeries', {
                models: [],
                name: this.name,
            });
            this.eventBus.emit('needDraw');
        };
        this.getModelsForSelectInfo = (info) => {
            const { index, seriesIndex, state } = info;
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(index) || !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(seriesIndex) || !(0,_helpers_validation__WEBPACK_IMPORTED_MODULE_2__.isAvailableSelectSeries)(info, 'scatter')) {
                return;
            }
            const { name } = state.series.scatter.data[seriesIndex];
            return [this.responders.filter(({ name: dataName }) => dataName === name)[index]];
        };
        this.selectSeries = (info) => {
            const models = this.getModelsForSelectInfo(info);
            if (!models) {
                return;
            }
            const closestModel = this.getClosestModel(models);
            if (!models.length) {
                throw new Error(_message__WEBPACK_IMPORTED_MODULE_3__.message.SELECT_SERIES_API_INDEX_ERROR);
            }
            this.eventBus.emit('renderSelectedSeries', {
                models: this.getResponderAppliedTheme(closestModel, 'select'),
                name: this.name,
            });
            this.eventBus.emit('needDraw');
        };
        this.showTooltip = (info) => {
            const models = this.getModelsForSelectInfo(info);
            if (!models) {
                return;
            }
            this.eventBus.emit('renderHoveredSeries', { models, name: this.name });
            this.activatedResponders = models;
            this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });
            this.eventBus.emit('needDraw');
        };
    }
    initialize() {
        this.type = 'series';
        this.name = 'scatter';
        this.eventBus.on('selectSeries', this.selectSeries);
        this.eventBus.on('showTooltip', this.showTooltip);
        this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
    initUpdate(delta) {
        this.drawModels.series.forEach((model, index) => {
            model.size = this.models.series[index].size * delta;
        });
    }
    render(chartState) {
        var _a, _b;
        const { layout, series, scale, legend, options, theme, axes } = chartState;
        if (!series.scatter) {
            throw new Error(_message__WEBPACK_IMPORTED_MODULE_3__.message.noDataError(this.name));
        }
        const scatterData = series.scatter.data;
        this.theme = theme.series.scatter;
        this.rect = layout.plot;
        this.activeSeriesMap = (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_4__.getActiveSeriesMap)(legend);
        this.selectable = this.getSelectableOption(options);
        const limit = (_b = (_a = axes.xAxis) === null || _a === void 0 ? void 0 : _a.labelRange, (_b !== null && _b !== void 0 ? _b : scale.xAxis.limit)); // labelRange is created only for line scatter charts
        const seriesModel = this.renderScatterPointsModel(scatterData, limit, scale[(0,_helpers_axes__WEBPACK_IMPORTED_MODULE_5__.getValueAxisName)(options, this.name, 'yAxis')].limit);
        const tooltipModel = this.makeTooltipModel(scatterData);
        this.models.series = seriesModel;
        if (!this.drawModels) {
            this.drawModels = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.deepCopy)(this.models);
        }
        this.responders = seriesModel.map((m, index) => (Object.assign(Object.assign({}, m), { type: 'circle', detectionSize: 0, radius: this.theme.size / 2, color: m.fillColor, style: [{ strokeStyle: m.borderColor, lineWidth: m.borderWidth }], data: tooltipModel[index] })));
    }
    renderScatterPointsModel(seriesRawData, xAxisLimit, yAxisLimit) {
        return seriesRawData.flatMap(({ data, name, color: seriesColor, iconType }, seriesIndex) => {
            const models = [];
            const active = this.activeSeriesMap[name];
            const color = (0,_helpers_color__WEBPACK_IMPORTED_MODULE_6__.getRGBA)(seriesColor, active ? 1 : 0.3);
            data.forEach((datum, index) => {
                const rawXValue = (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_7__.getCoordinateXValue)(datum);
                const xValue = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(rawXValue) ? Number(new Date(rawXValue)) : Number(rawXValue);
                const yValue = (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_7__.getCoordinateYValue)(datum);
                const xValueRatio = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_8__.getValueRatio)(xValue, xAxisLimit);
                const yValueRatio = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_8__.getValueRatio)(yValue, yAxisLimit);
                const x = xValueRatio * this.rect.width;
                const y = (1 - yValueRatio) * this.rect.height;
                models.push(Object.assign({ x,
                    y, type: 'scatterSeries', iconType,
                    seriesIndex,
                    name, borderColor: color, index }, (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.pick)(this.theme, 'borderWidth', 'size', 'fillColor')));
            });
            return models;
        });
    }
    makeTooltipModel(circleData) {
        return [...circleData].flatMap(({ data, name, color }) => {
            const tooltipData = [];
            data.forEach((datum) => {
                const value = {
                    x: (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_7__.getCoordinateXValue)(datum),
                    y: (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_7__.getCoordinateYValue)(datum),
                };
                tooltipData.push({ label: name, color, value });
            });
            return tooltipData;
        });
    }
    getClosestModel(closestResponder) {
        if (!closestResponder.length) {
            return [];
        }
        const model = this.models.series.find(({ index, seriesIndex }) => (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(index) &&
            (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(seriesIndex) &&
            index === closestResponder[0].index &&
            seriesIndex === closestResponder[0].seriesIndex);
        return model ? [model] : [];
    }
    getResponderAppliedTheme(closestModel, type) {
        const { fillColor, size } = this.theme[type];
        return closestModel.map((m) => (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.deepMergedCopy)(m, Object.assign(Object.assign({}, this.theme[type]), { color: fillColor, radius: size / 2 })));
    }
    onMousemove({ responders, mousePosition }) {
        const closestResponder = (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_9__.getNearestResponder)(responders, mousePosition, this.rect);
        let closestModel = this.getClosestModel(closestResponder);
        closestModel = this.getResponderAppliedTheme(closestModel, 'hover');
        this.eventBus.emit('renderHoveredSeries', { models: closestModel, name: this.name });
        this.activatedResponders = closestResponder;
        this.eventBus.emit('seriesPointHovered', { models: this.activatedResponders, name: this.name });
        this.eventBus.emit('needDraw');
    }
    onClick({ responders, mousePosition }) {
        if (this.selectable) {
            const closestResponder = (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_9__.getNearestResponder)(responders, mousePosition, this.rect);
            let closestModel = this.getClosestModel(closestResponder);
            closestModel = this.getResponderAppliedTheme(closestModel, 'select');
            this.eventBus.emit('renderSelectedSeries', {
                models: closestModel,
                name: this.name,
            });
            this.eventBus.emit('needDraw');
        }
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/selectedSeries.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SelectedSeries)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_responders__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/responders */ "./node_modules/@toast-ui/chart/dist/esm/helpers/responders.js");
/* harmony import */ var _store_reactive__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store/reactive */ "./node_modules/@toast-ui/chart/dist/esm/store/reactive.js");




class SelectedSeries extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.models = {};
        this.seriesModels = {};
        this.activeSeriesNames = {};
        this.isShow = false;
        this.renderSelectedSeries = (selectedSeriesEventModel) => {
            const { name, alias } = selectedSeriesEventModel;
            const models = this.getSelectedSeriesModelsForRendering(selectedSeriesEventModel);
            this.models[alias || name] = (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_1__.isSameSeriesResponder)(Object.assign(Object.assign({}, selectedSeriesEventModel), { models, comparisonModel: this.models[alias || name] }))
                ? []
                : models;
            this.seriesModels[alias || name] = this.getSelectedSeriesModels(selectedSeriesEventModel);
            this.isShow = !!Object.values(this.models).flatMap((value) => value).length;
            this.eventBus.emit(this.isShow ? 'selectSeries' : 'unselectSeries', (0,_store_reactive__WEBPACK_IMPORTED_MODULE_2__.makeObservableObjectToNormal)(this.seriesModels));
            this.activeSeriesNames[name] = this.getSeriesNames(selectedSeriesEventModel.models, name);
            this.setActiveState();
        };
        this.resetSelectedSeries = () => {
            this.models = {};
            this.store.dispatch('setAllLegendActiveState', true);
        };
    }
    getSeriesNames(selectedSeries, name) {
        const names = [];
        if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.includes)(['line', 'area', 'radar', 'bubble', 'scatter', 'bullet', 'boxPlot'], name)) {
            selectedSeries.forEach((model) => {
                const label = model
                    .name;
                if (label) {
                    names.push(label);
                }
            });
        }
        else if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.includes)(['bar', 'column', 'radialBar'], name)) {
            selectedSeries.forEach((model) => {
                var _a;
                const label = (_a = model.data) === null || _a === void 0 ? void 0 : _a.label;
                if (label) {
                    names.push(label);
                }
            });
        }
        else if (name === 'pie') {
            Object.keys(this.models)
                .flatMap((key) => this.models[key])
                .forEach((model) => {
                var _a, _b;
                const label = ((_a = model.data) === null || _a === void 0 ? void 0 : _a.rootParentName) || ((_b = model.data) === null || _b === void 0 ? void 0 : _b.label);
                if (label) {
                    names.push(label);
                }
            });
        }
        return names;
    }
    getSelectedSeriesModelsForRendering(selectedSeriesEventModel) {
        const { models, eventDetectType, name } = selectedSeriesEventModel;
        let renderingModels = models;
        if ((name === 'column' || name === 'bar' || name === 'bullet') &&
            eventDetectType === 'grouped') {
            renderingModels = models.filter((model) => !model.data);
        }
        else if (name === 'radialBar' && eventDetectType === 'grouped') {
            renderingModels = models.filter((model) => !model.data);
        }
        return renderingModels;
    }
    getSelectedSeriesModels(selectedSeriesEventModel) {
        const { models, eventDetectType, name } = selectedSeriesEventModel;
        let selectedSeriesModels = models;
        if ((name === 'column' || name === 'bar' || name === 'bullet') &&
            eventDetectType === 'grouped') {
            selectedSeriesModels = models.filter((model) => model.data);
        }
        else if (name === 'radialBar' && eventDetectType === 'grouped') {
            selectedSeriesModels = models.filter((model) => model.data);
        }
        return selectedSeriesModels;
    }
    setActiveState() {
        if (this.isShow) {
            this.store.dispatch('setAllLegendActiveState', false);
            Object.values(this.activeSeriesNames).forEach((names) => {
                names.forEach((name) => {
                    this.store.dispatch('setLegendActiveState', { name, active: true });
                });
            });
        }
        else {
            this.store.dispatch('setAllLegendActiveState', true);
        }
        this.eventBus.emit('needDraw');
    }
    initialize() {
        this.type = 'selectedSeries';
        this.name = 'selectedSeries';
        this.eventBus.on('renderSelectedSeries', this.renderSelectedSeries);
        this.eventBus.on('resetSelectedSeries', this.resetSelectedSeries);
    }
    render({ layout }) {
        this.rect = layout.plot;
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/spectrumLegend.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/spectrumLegend.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SpectrumLegend)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _store_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/layout */ "./node_modules/@toast-ui/chart/dist/esm/store/layout.js");



class SpectrumLegend extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.labels = [];
        this.renderSpectrumTooltip = ([responderData]) => {
            if (responderData) {
                const { labels, align } = this;
                const { colorValue, color } = responderData;
                const { width, height } = this.rect;
                this.models.tooltip = [
                    {
                        type: 'spectrumTooltip',
                        width,
                        height,
                        x: 0,
                        y: 0,
                        labels,
                        align,
                        colorRatio: responderData.colorRatio,
                        color,
                        text: String(colorValue),
                        verticalAlign: (0,_store_layout__WEBPACK_IMPORTED_MODULE_1__.isVerticalAlign)(align),
                    },
                ];
            }
            else {
                this.models.tooltip = [];
            }
        };
    }
    initialize() {
        this.type = 'spectrumLegend';
        this.name = 'spectrumLegend';
    }
    makeLabels(scale) {
        const { stepCount, limit, stepSize } = scale;
        const minValue = limit.min;
        return (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.range)(0, stepCount + 1).reduce((labels, value) => {
            return [...labels, String(minValue + stepSize * value)];
        }, []);
    }
    renderSpectrumLegendModel(startColor, endColor) {
        const { labels, align } = this;
        const { width, height } = this.rect;
        return [
            {
                type: 'spectrumLegend',
                width,
                height,
                x: 0,
                y: 0,
                labels,
                align,
                startColor,
                endColor,
                verticalAlign: (0,_store_layout__WEBPACK_IMPORTED_MODULE_1__.isVerticalAlign)(this.align),
            },
        ];
    }
    render({ layout, legend, colorValueScale, theme }) {
        var _a, _b;
        this.rect = layout.legend;
        this.align = legend.align;
        this.isShow = legend.visible && !!legend.data.length;
        if (!this.isShow) {
            return;
        }
        this.labels = this.makeLabels(colorValueScale);
        const { startColor, endColor } = ((_a = theme.series) === null || _a === void 0 ? void 0 : _a.heatmap) || ((_b = theme.series) === null || _b === void 0 ? void 0 : _b.treemap);
        this.models = { legend: this.renderSpectrumLegendModel(startColor, endColor), tooltip: [] };
        this.eventBus.on('renderSpectrumTooltip', this.renderSpectrumTooltip);
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/title.js":
/*!******************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/title.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Title)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");




class Title extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    initialize() {
        this.type = 'title';
        this.name = 'title';
    }
    renderTitle(options) {
        var _a, _b, _c;
        let text = '';
        let x = 0;
        let y = 0;
        let align = 'left';
        if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(options)) {
            text = options;
        }
        else {
            text = options.text;
            align = (_a = options.align, (_a !== null && _a !== void 0 ? _a : 'left'));
            x += (_b = options.offsetX, (_b !== null && _b !== void 0 ? _b : 0));
            y += (_c = options.offsetY, (_c !== null && _c !== void 0 ? _c : 0));
        }
        const font = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_2__.getTitleFontString)(this.theme);
        const textWidth = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.getTextWidth)(text, font);
        if (align === 'center') {
            x += (this.rect.width - textWidth) / 2;
        }
        else if (align === 'right') {
            x += this.rect.width - textWidth;
        }
        return [
            {
                type: 'label',
                x,
                y,
                text,
                style: ['title', { font, fillStyle: this.theme.color }],
            },
        ];
    }
    render({ options, layout, theme }) {
        var _a;
        this.isShow = !!((_a = options.chart) === null || _a === void 0 ? void 0 : _a.title);
        if (!this.isShow) {
            return;
        }
        this.theme = theme.title;
        this.rect = layout.title;
        this.models = this.renderTitle(options.chart.title);
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js":
/*!********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/tooltip.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Tooltip)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_tooltip__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/tooltip */ "./node_modules/@toast-ui/chart/dist/esm/helpers/tooltip.js");
/* harmony import */ var _helpers_tooltipTemplate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/tooltipTemplate */ "./node_modules/@toast-ui/chart/dist/esm/helpers/tooltipTemplate.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _helpers_htmlSanitizer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/htmlSanitizer */ "./node_modules/@toast-ui/chart/dist/esm/helpers/htmlSanitizer.js");






const DEFAULT_TOOLTIP_TRANSITION = 'transform 0.2s ease';
class Tooltip extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.tooltipInfoModels = {};
        this.onSeriesPointHovered = ({ models, name }) => {
            var _a;
            this.tooltipInfoModels[name] = ((_a = models) === null || _a === void 0 ? void 0 : _a.length) ? [...models] : [];
            const isShow = !!this.getTooltipInfoModels().length;
            if (isShow) {
                this.renderTooltip();
            }
            else {
                this.removeTooltip();
            }
        };
    }
    isTooltipContainerOverflow(x, y) {
        const { width, height } = this.tooltipContainerEl.getBoundingClientRect();
        const { x: rectX, y: rectY, width: rectWidth, height: rectHeight } = this.rect;
        return {
            overflowX: x > rectX + rectWidth || x + width > rectX + rectWidth,
            overflowY: y > rectY + rectHeight || y + height > rectY + rectHeight,
        };
    }
    getPositionInRect(model) {
        const { target } = model;
        const startX = this.rect.x + model.x;
        const startY = this.rect.y + model.y;
        let x = startX + target.radius + target.width + this.offsetX;
        let y = startY + this.offsetY;
        const { overflowX, overflowY } = this.isTooltipContainerOverflow(x, y);
        const { width, height } = this.tooltipContainerEl.getBoundingClientRect();
        if (overflowX) {
            x =
                startX - (width + target.radius + this.offsetX) > 0
                    ? startX - (width + target.radius + this.offsetX)
                    : startX + this.offsetX;
        }
        if (overflowY) {
            y =
                startY + target.height - (height + this.offsetY) > 0
                    ? startY + target.height - (height + this.offsetY)
                    : y;
        }
        return { x, y };
    }
    setTooltipPosition(model) {
        const { x, y } = this.getPositionInRect(model);
        this.tooltipContainerEl.style.transform = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_1__.getTranslateString)(x, y);
    }
    getTooltipInfoModels() {
        return Object.values(this.tooltipInfoModels).flatMap((item) => item);
    }
    renderTooltip() {
        const model = this.getTooltipInfoModels().reduce((acc, item) => {
            const { data, x, y, radius, width, height } = item;
            acc.x = acc.x ? (acc.x + x) / 2 : x;
            acc.y = acc.y ? (acc.y + y) / 2 : y;
            if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.isNumber)(radius)) {
                acc.target.radius = radius;
            }
            if (width) {
                acc.target.width = width;
            }
            if (height) {
                acc.target.height = height;
            }
            acc.data.push(Object.assign(Object.assign({}, data), { value: Array.isArray(data.value)
                    ? data.value.map((titleValue) => (Object.assign(Object.assign({}, titleValue), { formattedValue: this.getFormattedValue(titleValue.value, data) })))
                    : data.value, formattedValue: this.getFormattedValue(data.value, data) }));
            if (!acc.category && data.category) {
                acc.category = data.category;
            }
            if (data.templateType) {
                acc.templateType = data.templateType;
            }
            return acc;
        }, { type: 'tooltip', x: 0, y: 0, data: [], target: { radius: 0, width: 0, height: 0 } });
        this.tooltipContainerEl.innerHTML = (0,_helpers_htmlSanitizer__WEBPACK_IMPORTED_MODULE_3__.sanitizeHTML)(this.templateFunc(model, {
            header: _helpers_tooltipTemplate__WEBPACK_IMPORTED_MODULE_4__.tooltipTemplates.defaultHeader(model, this.theme),
            body: (0,_helpers_tooltipTemplate__WEBPACK_IMPORTED_MODULE_4__.getBodyTemplate)(model.templateType)(model, this.theme),
        }, this.theme));
        this.setTooltipPosition(model);
    }
    initialize({ chartEl }) {
        this.type = 'tooltip';
        this.name = 'tooltip';
        this.chartEl = chartEl;
        this.tooltipContainerEl = document.createElement('div');
        this.tooltipContainerEl.classList.add('toastui-chart-tooltip-container');
        const { width, height, top, left } = this.chartEl.getBoundingClientRect();
        this.tooltipContainerEl.style.transform = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_1__.getTranslateString)(left + width / 2, top + height / 2);
        this.chartEl.appendChild(this.tooltipContainerEl);
        this.eventBus.on('seriesPointHovered', this.onSeriesPointHovered);
    }
    removeTooltip() {
        this.tooltipContainerEl.innerHTML = '';
    }
    setTooltipTransition(options) {
        var _a;
        const transition = (_a = options.tooltip) === null || _a === void 0 ? void 0 : _a.transition;
        if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.isBoolean)(transition) && transition) {
            this.tooltipContainerEl.style.transition = DEFAULT_TOOLTIP_TRANSITION;
        }
        else if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(transition)) {
            this.tooltipContainerEl.style.transition = transition;
        }
    }
    render({ layout, options, theme }) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        this.setTooltipTransition(options);
        this.rect = layout.plot;
        this.theme = theme.tooltip;
        this.templateFunc = (_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.tooltip) === null || _b === void 0 ? void 0 : _b.template, (_c !== null && _c !== void 0 ? _c : _helpers_tooltipTemplate__WEBPACK_IMPORTED_MODULE_4__.tooltipTemplates["default"]));
        this.offsetX = (_f = (_e = (_d = options) === null || _d === void 0 ? void 0 : _d.tooltip) === null || _e === void 0 ? void 0 : _e.offsetX, (_f !== null && _f !== void 0 ? _f : 10));
        this.offsetY = (_j = (_h = (_g = options) === null || _g === void 0 ? void 0 : _g.tooltip) === null || _h === void 0 ? void 0 : _h.offsetY, (_j !== null && _j !== void 0 ? _j : 0));
        this.formatter = (_l = (_k = options) === null || _k === void 0 ? void 0 : _k.tooltip) === null || _l === void 0 ? void 0 : _l.formatter;
    }
    getFormattedValue(value, tooltipDataInfo) {
        return this.formatter
            ? this.formatter(value, tooltipDataInfo)
            : (0,_helpers_tooltip__WEBPACK_IMPORTED_MODULE_5__.getValueString)(value);
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/treemapSeries.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/treemapSeries.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TreemapSeries)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_squarifier__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/squarifier */ "./node_modules/@toast-ui/chart/dist/esm/helpers/squarifier.js");
/* harmony import */ var _helpers_color__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");
/* harmony import */ var _helpers_responders__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helpers/responders */ "./node_modules/@toast-ui/chart/dist/esm/helpers/responders.js");
/* harmony import */ var _helpers_dataLabels__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/dataLabels */ "./node_modules/@toast-ui/chart/dist/esm/helpers/dataLabels.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_colorSpectrum__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/colorSpectrum */ "./node_modules/@toast-ui/chart/dist/esm/helpers/colorSpectrum.js");
/* harmony import */ var _helpers_theme__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/theme */ "./node_modules/@toast-ui/chart/dist/esm/helpers/theme.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");









class TreemapSeries extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.models = { series: [], layer: [] };
        this.activatedResponders = [];
        this.onMouseoutComponent = () => {
            this.emitMouseEvent([]);
        };
        this.selectSeries = ({ seriesIndex }) => {
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(seriesIndex)) {
                return;
            }
            const model = this.responders.find(({ indexes }) => (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.last)(indexes) === seriesIndex);
            if (!model) {
                throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.SELECT_SERIES_API_INDEX_ERROR);
            }
            const models = this.getRespondersWithTheme([model], 'select');
            this.eventBus.emit('renderSelectedSeries', { models, name: this.name });
            this.eventBus.emit('needDraw');
        };
        this.showTooltip = ({ seriesIndex }) => {
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(seriesIndex)) {
                return;
            }
            const model = this.responders.find(({ indexes }) => (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.last)(indexes) === seriesIndex);
            if (model) {
                this.emitMouseEvent([model]);
            }
        };
    }
    initialize() {
        this.type = 'series';
        this.name = 'treemap';
        this.eventBus.on('selectSeries', this.selectSeries);
        this.eventBus.on('showTooltip', this.showTooltip);
        this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
    getAllChildSeries(series, parentId) {
        const allChildSeries = [];
        series.forEach((data) => {
            if (data.parentId === parentId) {
                allChildSeries.push(data);
                if (data.hasChild) {
                    const res = this.getAllChildSeries(series, data.id);
                    allChildSeries.push(...res);
                }
            }
        });
        return allChildSeries;
    }
    render(chartState) {
        var _a, _b, _c, _d, _e;
        const { layout, treemapSeries, colorValueScale, options, theme, treemapZoomId } = chartState;
        if (!treemapSeries) {
            throw new Error(_message__WEBPACK_IMPORTED_MODULE_2__.message.noDataError(this.name));
        }
        const currentTreemapZoomId = treemapZoomId.cur;
        const series = this.getAllChildSeries(treemapSeries, currentTreemapZoomId);
        this.theme = theme.series.treemap;
        this.rect = layout.plot;
        this.selectable = this.getSelectableOption(options);
        this.models = this.renderTreemapSeries(series, options, colorValueScale, currentTreemapZoomId);
        this.zoomable = (_b = (_a = options.series) === null || _a === void 0 ? void 0 : _a.zoomable, (_b !== null && _b !== void 0 ? _b : false));
        if ((0,_helpers_dataLabels__WEBPACK_IMPORTED_MODULE_3__.getDataLabelsOptions)(options, this.name).visible) {
            const useTreemapLeaf = (_e = (_d = (_c = options.series) === null || _c === void 0 ? void 0 : _c.dataLabels) === null || _d === void 0 ? void 0 : _d.useTreemapLeaf, (_e !== null && _e !== void 0 ? _e : false));
            const dataLabelModel = this.makeDataLabel(useTreemapLeaf, currentTreemapZoomId);
            this.renderDataLabels(dataLabelModel);
        }
        this.responders = this.makeTreemapSeriesResponder(currentTreemapZoomId);
    }
    makeTreemapSeriesResponder(treemapCurrentDepthParentId) {
        const tooltipData = this.makeTooltipData();
        let { series } = this.models;
        if (this.zoomable) {
            series = series.filter(({ parentId }) => parentId === treemapCurrentDepthParentId);
        }
        return series.map((m, idx) => (Object.assign(Object.assign({}, m), { data: tooltipData[idx], thickness: _helpers_theme__WEBPACK_IMPORTED_MODULE_4__.boxDefault.HOVER_THICKNESS, style: ['shadow'] })));
    }
    makeTooltipData() {
        return this.models.series.map(({ label, data, color }) => ({
            label: label,
            color,
            value: data,
        }));
    }
    makeBoundMap(series, parentId, layout, boundMap = {}) {
        const seriesItems = series.filter((item) => item.parentId === parentId);
        boundMap = Object.assign(Object.assign({}, boundMap), (0,_helpers_squarifier__WEBPACK_IMPORTED_MODULE_5__.squarify)(Object.assign({}, layout), seriesItems));
        seriesItems.forEach((seriesItem) => {
            boundMap = this.makeBoundMap(series, seriesItem.id, boundMap[seriesItem.id], boundMap);
        });
        return boundMap;
    }
    makeDataLabel(useTreemapLeaf, treemapCurrentDepthParentId) {
        const series = useTreemapLeaf
            ? this.models.series.filter(({ hasChild }) => !hasChild)
            : this.models.series.filter(({ parentId }) => parentId === treemapCurrentDepthParentId);
        const dataLabelTheme = this.theme.dataLabels;
        return series.map((m) => (Object.assign(Object.assign({}, m), { type: 'treemapSeriesName', value: m.label, direction: 'left', plot: { x: 0, y: 0, size: 0 }, theme: Object.assign(Object.assign({}, dataLabelTheme), { color: dataLabelTheme.useSeriesColor ? m.color : dataLabelTheme.color }) })));
    }
    getColor(treemapSeries, colors) {
        const { indexes } = treemapSeries;
        const colorIdx = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.first)(indexes);
        return colors[colorIdx];
    }
    getOpacity(treemapSeries) {
        const { indexes, depth } = treemapSeries;
        const idx = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.last)(indexes);
        return indexes.length === 1 ? 0 : Number((0.1 * depth + 0.05 * idx).toFixed(2));
    }
    renderTreemapSeries(seriesData, options, colorValueScale, treemapCurrentDepthParentId) {
        var _a, _b, _c;
        let layer = [];
        const boundMap = this.makeBoundMap(seriesData, treemapCurrentDepthParentId, Object.assign(Object.assign({}, this.rect), { x: 0, y: 0 }));
        const { colors, startColor, endColor, borderWidth, borderColor } = this.theme;
        let startRGB, distances;
        const useColorValue = (_b = (_a = options.series) === null || _a === void 0 ? void 0 : _a.useColorValue, (_b !== null && _b !== void 0 ? _b : false));
        if (useColorValue && startColor && endColor) {
            startRGB = (0,_helpers_color__WEBPACK_IMPORTED_MODULE_6__.hexToRGB)(startColor);
            distances = (0,_helpers_colorSpectrum__WEBPACK_IMPORTED_MODULE_7__.makeDistances)(startRGB, (0,_helpers_color__WEBPACK_IMPORTED_MODULE_6__.hexToRGB)(endColor));
        }
        const series = Object.keys(boundMap).map((id) => {
            const treemapSeries = seriesData.find((item) => item.id === id);
            let colorRatio;
            if (useColorValue) {
                colorRatio = (0,_helpers_colorSpectrum__WEBPACK_IMPORTED_MODULE_7__.getColorRatio)(colorValueScale.limit, treemapSeries.colorValue);
            }
            return Object.assign(Object.assign(Object.assign({}, treemapSeries), boundMap[id]), { type: 'rect', colorRatio, color: useColorValue
                    ? (0,_helpers_colorSpectrum__WEBPACK_IMPORTED_MODULE_7__.getSpectrumColor)(colorRatio, distances, startRGB)
                    : this.getColor(treemapSeries, colors), opacity: useColorValue ? 0 : this.getOpacity(treemapSeries), thickness: borderWidth, borderColor: borderColor });
        });
        if (!((_c = options.series) === null || _c === void 0 ? void 0 : _c.useColorValue)) {
            layer = series.map((m) => (Object.assign(Object.assign({}, m), { color: (0,_helpers_color__WEBPACK_IMPORTED_MODULE_6__.getRGBA)('#000000', m.opacity) })));
        }
        return { series, layer };
    }
    getRespondersWithTheme(responders, type) {
        return responders.map((responder) => (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.deepMergedCopy)(responder, Object.assign(Object.assign({}, this.theme[type]), { style: ['shadow'] })));
    }
    onClick({ responders }) {
        if (responders.length) {
            if (this.zoomable) {
                const { id, hasChild } = responders[0];
                if (hasChild) {
                    this.emitMouseEvent([]);
                    this.store.dispatch('setTreemapZoomId', id);
                    this.eventBus.emit('resetSelectedSeries');
                }
                else if (this.selectable) {
                    this.eventBus.emit('renderSelectedSeries', {
                        models: this.getRespondersWithTheme(responders, 'select'),
                        name: this.name,
                    });
                }
            }
            else if (this.selectable) {
                const deepestNode = (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_8__.getDeepestNode)(responders);
                this.eventBus.emit('renderSelectedSeries', {
                    models: this.getRespondersWithTheme(deepestNode, 'select'),
                    name: this.name,
                });
            }
        }
    }
    onMousemove({ responders }) {
        const deepestNode = (0,_helpers_responders__WEBPACK_IMPORTED_MODULE_8__.getDeepestNode)(responders);
        this.activatedResponders = deepestNode;
        this.emitMouseEvent(deepestNode);
    }
    emitMouseEvent(responders) {
        this.eventBus.emit('renderHoveredSeries', {
            models: this.getRespondersWithTheme(responders, 'hover'),
            name: this.name,
        });
        this.eventBus.emit('seriesPointHovered', {
            models: responders,
            name: this.name,
        });
        this.eventBus.emit('renderSpectrumTooltip', responders);
        this.eventBus.emit('needDraw');
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/component/zeroAxis.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/component/zeroAxis.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ZeroAxis)
/* harmony export */ });
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@toast-ui/chart/dist/esm/component/component.js");
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");




class ZeroAxis extends _component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.models = [];
    }
    initialize() {
        this.type = 'zeroAxis';
        this.name = 'zeroAxis';
    }
    render({ layout, axes, series, options }) {
        this.rect = layout.plot;
        const labelAxisOnYAxis = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.isLabelAxisOnYAxis)({ series, options });
        const valueAxisName = labelAxisOnYAxis ? 'xAxis' : 'yAxis';
        const { zeroPosition } = axes[valueAxisName];
        if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.isNumber)(zeroPosition)) {
            this.models = this.renderZeroModel(zeroPosition, labelAxisOnYAxis);
        }
    }
    renderZeroModel(zeroPosition, vertical) {
        const zeroPixel = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(0);
        const position = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(zeroPosition);
        let model;
        if (vertical) {
            model = {
                type: 'line',
                x: position,
                y: zeroPixel,
                x2: position,
                y2: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(this.rect.height),
                strokeStyle: 'rgba(0, 0, 0, 0.5)',
            };
        }
        else {
            model = {
                type: 'line',
                x: zeroPixel,
                y: position,
                x2: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.crispPixel)(this.rect.width),
                y2: position,
                strokeStyle: 'rgba(0, 0, 0, 0.5)',
            };
        }
        return [model];
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/eventEmitter.js":
/*!***************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/eventEmitter.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EventEmitter)
/* harmony export */ });
class EventEmitter {
    constructor() {
        this.handlers = [];
    }
    on(type, handler) {
        if (!this.handlers[type]) {
            this.handlers[type] = [];
        }
        this.handlers[type].push(handler);
    }
    emit(type, ...args) {
        var _a;
        (_a = this.handlers[type]) === null || _a === void 0 ? void 0 : _a.forEach((handler) => handler(...args));
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/arrayUtil.js":
/*!********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/arrayUtil.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "pivot": () => (/* binding */ pivot),
/* harmony export */   "isSameArray": () => (/* binding */ isSameArray),
/* harmony export */   "pluck": () => (/* binding */ pluck)
/* harmony export */ });
function max(arr, condition, context) {
    let result;
    if (!condition) {
        result = Math.max(...arr);
    }
    else {
        [result] = arr;
        const rest = arr.slice(1);
        let maxValue = condition.call(context, result, 0);
        rest.forEach((item, index) => {
            const compareValue = condition.call(context, item, index + 1);
            if (compareValue > maxValue) {
                maxValue = compareValue;
                result = item;
            }
        });
    }
    return result;
}
/**
 * Array pivot.
 * @memberOf module:arrayUtil
 * @param {Array.<Array>} arr2d target 2d array
 * @returns {Array.<Array>} pivoted 2d array
 */
function pivot(arr2d) {
    const result = [];
    const len = max(arr2d.map((arr) => arr.length));
    arr2d.forEach((arr) => {
        for (let index = 0; index < len; index += 1) {
            if (!result[index]) {
                result[index] = [];
            }
            result[index].push(arr[index]);
        }
    });
    return result;
}
function isSameArray(arr1, arr2) {
    if (arr1.length !== arr2.length) {
        return false;
    }
    for (let i = 0; i < arr1.length; i += 1) {
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
}
function pluck(arr, property) {
    return arr.reduce((acc, cur) => {
        return [...acc, cur[property]];
    }, []);
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js":
/*!***************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAutoAdjustingInterval": () => (/* binding */ getAutoAdjustingInterval),
/* harmony export */   "isLabelAxisOnYAxis": () => (/* binding */ isLabelAxisOnYAxis),
/* harmony export */   "hasBoxTypeSeries": () => (/* binding */ hasBoxTypeSeries),
/* harmony export */   "isPointOnColumn": () => (/* binding */ isPointOnColumn),
/* harmony export */   "isSeriesUsingRadialAxes": () => (/* binding */ isSeriesUsingRadialAxes),
/* harmony export */   "getAxisName": () => (/* binding */ getAxisName),
/* harmony export */   "getSizeKey": () => (/* binding */ getSizeKey),
/* harmony export */   "getLimitOnAxis": () => (/* binding */ getLimitOnAxis),
/* harmony export */   "hasSecondaryYAxis": () => (/* binding */ hasSecondaryYAxis),
/* harmony export */   "getYAxisOption": () => (/* binding */ getYAxisOption),
/* harmony export */   "getValueAxisName": () => (/* binding */ getValueAxisName),
/* harmony export */   "getValueAxisNames": () => (/* binding */ getValueAxisNames),
/* harmony export */   "getAxisTheme": () => (/* binding */ getAxisTheme),
/* harmony export */   "hasAxesLayoutChanged": () => (/* binding */ hasAxesLayoutChanged),
/* harmony export */   "getRotatableOption": () => (/* binding */ getRotatableOption),
/* harmony export */   "getViewAxisLabels": () => (/* binding */ getViewAxisLabels),
/* harmony export */   "makeTitleOption": () => (/* binding */ makeTitleOption),
/* harmony export */   "getAxisFormatter": () => (/* binding */ getAxisFormatter),
/* harmony export */   "getLabelsAppliedFormatter": () => (/* binding */ getLabelsAppliedFormatter),
/* harmony export */   "makeRotationData": () => (/* binding */ makeRotationData),
/* harmony export */   "getMaxLabelSize": () => (/* binding */ getMaxLabelSize),
/* harmony export */   "getLabelXMargin": () => (/* binding */ getLabelXMargin),
/* harmony export */   "getInitAxisIntervalData": () => (/* binding */ getInitAxisIntervalData),
/* harmony export */   "getDefaultRadialAxisData": () => (/* binding */ getDefaultRadialAxisData),
/* harmony export */   "getRadiusInfo": () => (/* binding */ getRadiusInfo),
/* harmony export */   "isDateType": () => (/* binding */ isDateType)
/* harmony export */ });
/* harmony import */ var _component_axis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../component/axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");
/* harmony import */ var _calculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _geometric__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./geometric */ "./node_modules/@toast-ui/chart/dist/esm/helpers/geometric.js");
/* harmony import */ var _formatDate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatDate */ "./node_modules/@toast-ui/chart/dist/esm/helpers/formatDate.js");
/* harmony import */ var _sector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sector */ "./node_modules/@toast-ui/chart/dist/esm/helpers/sector.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _pieSeries__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./pieSeries */ "./node_modules/@toast-ui/chart/dist/esm/helpers/pieSeries.js");
/* harmony import */ var _store_radialAxes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store/radialAxes */ "./node_modules/@toast-ui/chart/dist/esm/store/radialAxes.js");









function makeAdjustingIntervalInfo(blockCount, axisWidth, blockSize) {
    let remainBlockCount;
    let newBlockCount = Math.floor(axisWidth / blockSize);
    let intervalInfo = null;
    const interval = newBlockCount ? Math.floor(blockCount / newBlockCount) : blockCount;
    if (interval > 1) {
        // remainBlockCount : remaining block count after filling new blocks
        // | | | | | | | | | | | |  - previous block interval
        // |     |     |     |      - new block interval
        //                   |*|*|  - remaining block
        remainBlockCount = blockCount - interval * newBlockCount;
        if (remainBlockCount >= interval) {
            newBlockCount += Math.floor(remainBlockCount / interval);
            remainBlockCount = remainBlockCount % interval;
        }
        intervalInfo = {
            blockCount: newBlockCount,
            remainBlockCount,
            interval,
        };
    }
    return intervalInfo;
}
function getAutoAdjustingInterval(count, axisWidth, categories) {
    var _a;
    const autoInterval = {
        MIN_WIDTH: 90,
        MAX_WIDTH: 121,
        STEP_SIZE: 5,
    };
    const LABEL_MARGIN = 5;
    if ((_a = categories) === null || _a === void 0 ? void 0 : _a[0]) {
        const categoryMinWidth = (0,_calculator__WEBPACK_IMPORTED_MODULE_0__.getTextWidth)(categories[0]);
        if (categoryMinWidth < axisWidth / count - LABEL_MARGIN) {
            return 1;
        }
    }
    let candidates = [];
    (0,_calculator__WEBPACK_IMPORTED_MODULE_0__.divisors)(count).forEach((interval) => {
        const intervalWidth = (interval / count) * axisWidth;
        if (intervalWidth >= autoInterval.MIN_WIDTH && intervalWidth <= autoInterval.MAX_WIDTH) {
            candidates.push({ interval, blockCount: Math.floor(count / interval), remainBlockCount: 0 });
        }
    });
    if (!candidates.length) {
        const blockSizeRange = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.range)(autoInterval.MIN_WIDTH, autoInterval.MAX_WIDTH, autoInterval.STEP_SIZE);
        candidates = blockSizeRange.reduce((acc, blockSize) => {
            const candidate = makeAdjustingIntervalInfo(count, axisWidth, blockSize);
            return candidate ? [...acc, candidate] : acc;
        }, []);
    }
    let tickInterval = 1;
    if (candidates.length) {
        const candidate = candidates.reduce((acc, cur) => (cur.blockCount > acc.blockCount ? cur : acc), { blockCount: 0, interval: 1 });
        tickInterval = candidate.interval;
    }
    return tickInterval;
}
function isLabelAxisOnYAxis({ series, options, categories, }) {
    var _a, _b;
    return (!!series.bar ||
        !!series.radialBar ||
        (!!series.gauge && Array.isArray(categories) && !categories.length) ||
        (!!series.bullet && !((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.vertical)));
}
function hasBoxTypeSeries(series) {
    return !!series.column || !!series.bar || !!series.boxPlot || !!series.bullet;
}
function isPointOnColumn(series, options) {
    var _a;
    if (hasBoxTypeSeries(series)) {
        return true;
    }
    if (series.line || series.area) {
        return Boolean((_a = options.xAxis) === null || _a === void 0 ? void 0 : _a.pointOnColumn);
    }
    return false;
}
function isSeriesUsingRadialAxes(series) {
    return !!series.radar || !!series.radialBar || !!series.gauge;
}
function getAxisNameUsingRadialAxes(labelAxisOnYAxis) {
    return {
        valueAxisName: labelAxisOnYAxis ? 'circularAxis' : 'verticalAxis',
        labelAxisName: labelAxisOnYAxis ? 'verticalAxis' : 'circularAxis',
    };
}
function getAxisName(labelAxisOnYAxis, series) {
    return isSeriesUsingRadialAxes(series)
        ? getAxisNameUsingRadialAxes(labelAxisOnYAxis)
        : {
            valueAxisName: labelAxisOnYAxis ? 'xAxis' : 'yAxis',
            labelAxisName: labelAxisOnYAxis ? 'yAxis' : 'xAxis',
        };
}
function getSizeKey(labelAxisOnYAxis) {
    return {
        valueSizeKey: labelAxisOnYAxis ? 'width' : 'height',
        labelSizeKey: labelAxisOnYAxis ? 'height' : 'width',
    };
}
function getLimitOnAxis(labels) {
    const values = labels.map((label) => Number(label));
    return {
        min: Math.min(...values),
        max: Math.max(...values),
    };
}
function hasSecondaryYAxis(options) {
    var _a;
    return Array.isArray((_a = options) === null || _a === void 0 ? void 0 : _a.yAxis) && options.yAxis.length === 2;
}
function getYAxisOption(options) {
    var _a;
    const secondaryYAxis = hasSecondaryYAxis(options);
    return {
        yAxis: secondaryYAxis ? options.yAxis[0] : (_a = options) === null || _a === void 0 ? void 0 : _a.yAxis,
        secondaryYAxis: secondaryYAxis ? options.yAxis[1] : null,
    };
}
function getValueAxisName(options, seriesName, valueAxisName) {
    var _a;
    const { secondaryYAxis } = getYAxisOption(options);
    return ((_a = secondaryYAxis) === null || _a === void 0 ? void 0 : _a.chartType) === seriesName ? 'secondaryYAxis' : valueAxisName;
}
function getValueAxisNames(options, valueAxisName) {
    if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__.includes)([_component_axis__WEBPACK_IMPORTED_MODULE_2__.AxisType.X, _component_axis__WEBPACK_IMPORTED_MODULE_2__.AxisType.CIRCULAR, _component_axis__WEBPACK_IMPORTED_MODULE_2__.AxisType.VERTICAL], valueAxisName)) {
        return [valueAxisName];
    }
    const optionsUsingYAxis = options;
    const { yAxis, secondaryYAxis } = getYAxisOption(optionsUsingYAxis);
    return secondaryYAxis
        ? [yAxis.chartType, secondaryYAxis.chartType].map((seriesName, index) => seriesName
            ? getValueAxisName(optionsUsingYAxis, seriesName, valueAxisName)
            : ['yAxis', 'secondaryYAxis'][index])
        : [valueAxisName];
}
function getAxisTheme(theme, name) {
    const { xAxis, yAxis, circularAxis } = theme;
    let axisTheme;
    if (name === _component_axis__WEBPACK_IMPORTED_MODULE_2__.AxisType.X) {
        axisTheme = xAxis;
    }
    else if (Array.isArray(yAxis)) {
        axisTheme = name === _component_axis__WEBPACK_IMPORTED_MODULE_2__.AxisType.Y ? yAxis[0] : yAxis[1];
    }
    else if (name === _store_radialAxes__WEBPACK_IMPORTED_MODULE_3__.RadialAxisType.CIRCULAR) {
        axisTheme = circularAxis;
    }
    else {
        axisTheme = yAxis;
    }
    return axisTheme;
}
function getRotationDegree(distance, labelWidth, labelHeight, axisLayout) {
    let degree = 0;
    _geometric__WEBPACK_IMPORTED_MODULE_4__.ANGLE_CANDIDATES.every((angle) => {
        const compareWidth = (0,_geometric__WEBPACK_IMPORTED_MODULE_4__.calculateRotatedWidth)(angle, labelWidth, labelHeight);
        degree = angle;
        return compareWidth > distance || compareWidth / 2 > axisLayout.x;
    });
    return distance < labelWidth || labelWidth / 2 > axisLayout.x ? degree : 0;
}
function hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, field) {
    var _a, _b;
    const prevYAxis = previousAxes[field];
    const yAxis = currentAxes[field];
    if (!prevYAxis && !yAxis) {
        return false;
    }
    return ((_a = prevYAxis) === null || _a === void 0 ? void 0 : _a.maxLabelWidth) !== ((_b = yAxis) === null || _b === void 0 ? void 0 : _b.maxLabelWidth);
}
function hasYAxisTypeMaxLabelChanged(previousAxes, currentAxes) {
    return (hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, 'yAxis') ||
        hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, 'secondaryYAxis'));
}
function hasXAxisSizeChanged(previousAxes, currentAxes) {
    const { maxHeight: prevMaxHeight } = previousAxes.xAxis;
    const { maxHeight } = currentAxes.xAxis;
    return prevMaxHeight !== maxHeight;
}
function hasAxesLayoutChanged(previousAxes, currentAxes) {
    return (hasYAxisTypeMaxLabelChanged(previousAxes, currentAxes) ||
        hasXAxisSizeChanged(previousAxes, currentAxes));
}
function getRotatableOption(options) {
    var _a, _b, _c, _d;
    return _d = (_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.xAxis) === null || _b === void 0 ? void 0 : _b.label) === null || _c === void 0 ? void 0 : _c.rotatable, (_d !== null && _d !== void 0 ? _d : true);
}
function getViewAxisLabels(axisData, axisSize) {
    var _a, _b, _c, _d;
    const { labels, pointOnColumn, labelDistance, tickDistance, labelInterval, tickInterval, tickCount, scale, } = axisData;
    let axisSizeAppliedRatio = axisSize;
    let additional = 0;
    let labelAdjustment = 0;
    if (scale) {
        const sizeRatio = (_b = (_a = scale) === null || _a === void 0 ? void 0 : _a.sizeRatio, (_b !== null && _b !== void 0 ? _b : 1));
        const positionRatio = (_d = (_c = scale) === null || _c === void 0 ? void 0 : _c.positionRatio, (_d !== null && _d !== void 0 ? _d : 0));
        axisSizeAppliedRatio = axisSize * sizeRatio;
        additional = axisSize * positionRatio;
    }
    else {
        const interval = labelInterval === tickInterval ? labelInterval : 1;
        labelAdjustment = pointOnColumn ? ((labelDistance !== null && labelDistance !== void 0 ? labelDistance : tickDistance * interval)) / 2 : 0;
    }
    const relativePositions = (0,_calculator__WEBPACK_IMPORTED_MODULE_0__.makeTickPixelPositions)(axisSizeAppliedRatio, tickCount, additional);
    return labels.reduce((acc, text, index) => {
        const offsetPos = relativePositions[index] + labelAdjustment;
        const needRender = !(index % labelInterval) && offsetPos <= axisSize;
        return needRender ? [...acc, { offsetPos, text }] : acc;
    }, []);
}
function makeTitleOption(title) {
    if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(title)) {
        return title;
    }
    const defaultOption = { text: '', offsetX: 0, offsetY: 0 };
    return (0,_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(title) ? Object.assign(Object.assign({}, defaultOption), { text: title }) : Object.assign(Object.assign({}, defaultOption), title);
}
function getAxisFormatter(options, axisName) {
    var _a, _b, _c;
    const axisOptions = Object.assign(Object.assign({}, getYAxisOption(options)), { xAxis: options.xAxis });
    return _c = (_b = (_a = axisOptions[axisName]) === null || _a === void 0 ? void 0 : _a.label) === null || _b === void 0 ? void 0 : _b.formatter, (_c !== null && _c !== void 0 ? _c : ((value) => value));
}
function getLabelsAppliedFormatter(labels, options, dateType, axisName) {
    var _a, _b;
    const dateFormatter = (0,_formatDate__WEBPACK_IMPORTED_MODULE_5__.getDateFormat)((_b = (_a = options) === null || _a === void 0 ? void 0 : _a[axisName]) === null || _b === void 0 ? void 0 : _b.date);
    const formattedLabels = dateType && dateFormatter
        ? labels.map((label) => (0,_formatDate__WEBPACK_IMPORTED_MODULE_5__.formatDate)(dateFormatter, new Date(label)))
        : labels;
    const formatter = getAxisFormatter(options, axisName);
    return formattedLabels.map((label, index) => formatter(label, { index, labels, axisName }));
}
function makeRotationData(maxLabelWidth, maxLabelHeight, distance, rotatable, axisLayout) {
    const degree = getRotationDegree(distance, maxLabelWidth, maxLabelHeight, axisLayout);
    if (!rotatable || degree === 0) {
        return {
            needRotateLabel: false,
            radian: 0,
            rotationHeight: maxLabelHeight,
        };
    }
    return {
        needRotateLabel: degree > 0,
        radian: (0,_sector__WEBPACK_IMPORTED_MODULE_6__.calculateDegreeToRadian)(degree, 0),
        rotationHeight: (0,_geometric__WEBPACK_IMPORTED_MODULE_4__.calculateRotatedHeight)(degree, maxLabelWidth, maxLabelHeight),
    };
}
function getMaxLabelSize(labels, xMargin, font = _brushes_label__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_LABEL_TEXT) {
    const maxLengthLabel = labels.reduce((acc, cur) => (acc.length > cur.length ? acc : cur), '');
    return {
        maxLabelWidth: (0,_calculator__WEBPACK_IMPORTED_MODULE_0__.getTextWidth)(maxLengthLabel, font) + xMargin,
        maxLabelHeight: (0,_calculator__WEBPACK_IMPORTED_MODULE_0__.getTextHeight)(maxLengthLabel, font),
    };
}
function getLabelXMargin(axisName, options) {
    var _a, _b, _c, _d;
    if (axisName === 'xAxis') {
        return 0;
    }
    const axisOptions = getYAxisOption(options);
    return Math.abs((_d = (_c = (_b = (_a = axisOptions) === null || _a === void 0 ? void 0 : _a[axisName]) === null || _b === void 0 ? void 0 : _b.label) === null || _c === void 0 ? void 0 : _c.margin, (_d !== null && _d !== void 0 ? _d : 0)));
}
function getInitAxisIntervalData(isLabelAxis, params) {
    var _a, _b, _c, _d, _e, _f;
    const { axis, categories, layout, isCoordinateTypeChart } = params;
    const tickInterval = (_b = (_a = axis) === null || _a === void 0 ? void 0 : _a.tick) === null || _b === void 0 ? void 0 : _b.interval;
    const labelInterval = (_d = (_c = axis) === null || _c === void 0 ? void 0 : _c.label) === null || _d === void 0 ? void 0 : _d.interval;
    const existIntervalOptions = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(tickInterval) || (0,_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(labelInterval);
    const needAdjustInterval = isLabelAxis &&
        !(0,_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)((_f = (_e = axis) === null || _e === void 0 ? void 0 : _e.scale) === null || _f === void 0 ? void 0 : _f.stepSize) &&
        !params.shift &&
        !existIntervalOptions &&
        !isCoordinateTypeChart;
    const initTickInterval = needAdjustInterval ? getInitTickInterval(categories, layout) : 1;
    const initLabelInterval = needAdjustInterval ? initTickInterval : 1;
    const axisData = {
        tickInterval: (tickInterval !== null && tickInterval !== void 0 ? tickInterval : initTickInterval),
        labelInterval: (labelInterval !== null && labelInterval !== void 0 ? labelInterval : initLabelInterval),
    };
    return axisData;
}
function getInitTickInterval(categories, layout) {
    if (!categories || !layout) {
        return 1;
    }
    const { width } = layout.xAxis;
    const count = categories.length;
    return getAutoAdjustingInterval(count, width, categories);
}
function getDefaultRadialAxisData(options, plot, maxLabelWidth = 0, maxLabelHeight = 0, isLabelOnVerticalAxis = false) {
    var _a;
    const centerX = plot.width / 2;
    if (isLabelOnVerticalAxis) {
        const { startAngle, endAngle, clockwise } = (0,_sector__WEBPACK_IMPORTED_MODULE_6__.initSectorOptions)((_a = options) === null || _a === void 0 ? void 0 : _a.series);
        const isSemiCircular = (0,_pieSeries__WEBPACK_IMPORTED_MODULE_8__.isSemiCircle)(clockwise, startAngle, endAngle);
        return {
            isSemiCircular,
            axisSize: (0,_sector__WEBPACK_IMPORTED_MODULE_6__.getDefaultRadius)(plot, isSemiCircular, maxLabelWidth, maxLabelHeight),
            centerX,
            centerY: isSemiCircular ? (0,_pieSeries__WEBPACK_IMPORTED_MODULE_8__.getSemiCircleCenterY)(plot.height, clockwise) : plot.height / 2,
            totalAngle: (0,_pieSeries__WEBPACK_IMPORTED_MODULE_8__.getTotalAngle)(clockwise, startAngle, endAngle),
            drawingStartAngle: startAngle,
            clockwise,
            startAngle,
            endAngle,
        };
    }
    return {
        isSemiCircular: false,
        axisSize: (0,_sector__WEBPACK_IMPORTED_MODULE_6__.getDefaultRadius)(plot, false, maxLabelWidth, maxLabelHeight),
        centerX,
        centerY: plot.height / 2,
        totalAngle: _sector__WEBPACK_IMPORTED_MODULE_6__.DEGREE_360,
        drawingStartAngle: _sector__WEBPACK_IMPORTED_MODULE_6__.DEGREE_0,
        clockwise: true,
        startAngle: _sector__WEBPACK_IMPORTED_MODULE_6__.DEGREE_0,
        endAngle: _sector__WEBPACK_IMPORTED_MODULE_6__.DEGREE_360,
    };
}
function getRadiusInfo(axisSize, radiusRange, count = 1) {
    var _a, _b, _c, _d;
    const innerRadius = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.calculateSizeWithPercentString)(axisSize, (_b = (_a = radiusRange) === null || _a === void 0 ? void 0 : _a.inner, (_b !== null && _b !== void 0 ? _b : 0)));
    const outerRadius = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.calculateSizeWithPercentString)(axisSize, (_d = (_c = radiusRange) === null || _c === void 0 ? void 0 : _c.outer, (_d !== null && _d !== void 0 ? _d : axisSize)));
    return {
        radiusRanges: (0,_calculator__WEBPACK_IMPORTED_MODULE_0__.makeTickPixelPositions)(outerRadius - innerRadius, count, innerRadius)
            .splice(innerRadius === 0 ? 1 : 0, count)
            .reverse(),
        innerRadius,
        outerRadius,
    };
}
function isDateType(options, axisName) {
    var _a;
    return !!((_a = options[axisName]) === null || _a === void 0 ? void 0 : _a.date);
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/boxSeries.js":
/*!********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/boxSeries.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calibrateDrawingValue": () => (/* binding */ calibrateDrawingValue),
/* harmony export */   "sumValuesBeforeIndex": () => (/* binding */ sumValuesBeforeIndex),
/* harmony export */   "outsideRange": () => (/* binding */ outsideRange),
/* harmony export */   "calibrateBoxStackDrawingValue": () => (/* binding */ calibrateBoxStackDrawingValue)
/* harmony export */ });
function limitNegative(value, min, max) {
    let result = value;
    if (result >= max) {
        return 0;
    }
    if (max < 0) {
        result = Math.min(value - max, 0);
    }
    if (value < min) {
        result -= value - min;
    }
    return result;
}
function limitPositive(value, min, max) {
    let result = value;
    if (min > 0) {
        result = Math.max(value - min, 0);
    }
    if (value > max) {
        result -= value - max;
    }
    return result;
}
function calibrateDrawingValue(value, min, max) {
    return value < 0 ? limitNegative(value, min, max) : limitPositive(value, min, max);
}
function sumValuesBeforeIndex(values, targetIndex, includeTarget = false) {
    const target = values[targetIndex];
    return values.reduce((total, value, idx) => {
        const isBefore = includeTarget ? idx <= targetIndex : idx < targetIndex;
        const isSameSign = value * target >= 0;
        return isBefore && isSameSign ? total + value : total;
    }, 0);
}
function outsideRange(values, currentIndex, min, max) {
    const value = values[currentIndex];
    const totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);
    const positive = value >= 0;
    const negative = value < 0;
    return ((positive && totalOfIndexBefore >= max) ||
        (negative && totalOfIndexBefore <= min) ||
        (currentIndex === 0 && positive && value < min) ||
        (currentIndex === 0 && negative && value > max));
}
function calibrateBoxStackDrawingValue(values, currentIndex, min, max) {
    const totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);
    const totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);
    if (outsideRange(values, currentIndex, min, max)) {
        return null;
    }
    if (currentIndex === 0) {
        return calibrateDrawingValue(values[currentIndex], min, max);
    }
    if (totalOfIndexBefore < min && totalOfValues > max) {
        return max - min;
    }
    let result = values[currentIndex];
    if (totalOfValues > max) {
        result = max - totalOfIndexBefore;
    }
    else if (totalOfValues < min) {
        result = min - totalOfIndexBefore;
    }
    else if (totalOfIndexBefore < min) {
        result = totalOfValues - min;
    }
    else if (totalOfIndexBefore > max) {
        result = totalOfValues - max;
    }
    return result;
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTextWidth": () => (/* binding */ getTextWidth),
/* harmony export */   "getTextHeight": () => (/* binding */ getTextHeight),
/* harmony export */   "getFontHeight": () => (/* binding */ getFontHeight),
/* harmony export */   "getAxisLabelAnchorPoint": () => (/* binding */ getAxisLabelAnchorPoint),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "divide": () => (/* binding */ divide),
/* harmony export */   "sum": () => (/* binding */ sum),
/* harmony export */   "divisors": () => (/* binding */ divisors),
/* harmony export */   "makeLabelsFromLimit": () => (/* binding */ makeLabelsFromLimit),
/* harmony export */   "makeTickPixelPositions": () => (/* binding */ makeTickPixelPositions),
/* harmony export */   "crispPixel": () => (/* binding */ crispPixel),
/* harmony export */   "setSplineControlPoint": () => (/* binding */ setSplineControlPoint),
/* harmony export */   "getValueRatio": () => (/* binding */ getValueRatio),
/* harmony export */   "getDistance": () => (/* binding */ getDistance),
/* harmony export */   "getMaxLengthLabelWidth": () => (/* binding */ getMaxLengthLabelWidth),
/* harmony export */   "getXPosition": () => (/* binding */ getXPosition)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _brushes_label__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../brushes/label */ "./node_modules/@toast-ui/chart/dist/esm/brushes/label.js");
/* harmony import */ var _brushes_axis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../brushes/axis */ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js");



const LINE_HEIGHT_NORMAL = 1.2;
const ctx = document.createElement('canvas').getContext('2d');
function getTextWidth(text, font = _brushes_label__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_LABEL_TEXT) {
    ctx.font = font;
    return Math.ceil(ctx.measureText(text).width);
}
/*
 * Calculate height of canvas text
 * https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics
 * */
function getTextHeight(text, font = _brushes_label__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_LABEL_TEXT) {
    ctx.font = font;
    const { actualBoundingBoxAscent, actualBoundingBoxDescent } = ctx.measureText(text);
    const validActualBoundingBox = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(actualBoundingBoxAscent) && (0,_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(actualBoundingBoxDescent);
    return validActualBoundingBox
        ? Math.ceil(Math.abs(actualBoundingBoxAscent) + Math.abs(actualBoundingBoxDescent)) + 1
        : getFontHeight(font);
}
function getFontHeight(font = _brushes_label__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_LABEL_TEXT) {
    const fontSize = font.match(/\d+(?=px)/);
    return parseInt(String(Number(fontSize) * LINE_HEIGHT_NORMAL), 10);
}
function getAxisLabelAnchorPoint(labelHeight) {
    return crispPixel(_brushes_axis__WEBPACK_IMPORTED_MODULE_2__.TICK_SIZE * 2 + labelHeight / 2);
}
function getDecimalLength(value) {
    var _a, _b;
    return _b = (_a = String(value).split('.')[1]) === null || _a === void 0 ? void 0 : _a.length, (_b !== null && _b !== void 0 ? _b : 0);
}
function findMultipleNum(...args) {
    const underPointLens = args.map((value) => getDecimalLength(value));
    const underPointLen = Math.max(...underPointLens);
    return Math.pow(10, underPointLen);
}
function add(a, b) {
    const multipleNum = findMultipleNum(a, b);
    return (a * multipleNum + b * multipleNum) / multipleNum;
}
function multiply(a, b) {
    const multipleNum = findMultipleNum(a, b);
    return (a * multipleNum * (b * multipleNum)) / (multipleNum * multipleNum);
}
function divide(a, b) {
    const multipleNum = findMultipleNum(a, b);
    return (a * multipleNum) / (b * multipleNum);
}
function sum(values) {
    const copyArr = values.slice();
    copyArr.unshift(0);
    return copyArr.reduce((base, value) => add(parseFloat(String(base)), parseFloat(String(value))));
}
function divisors(value) {
    const result = [];
    for (let a = 2, b; a * a <= value; a += 1) {
        if (value % a === 0) {
            b = value / a;
            result.push(a);
            if (b !== a) {
                result.push(b);
            }
        }
    }
    return result.sort((prev, next) => prev - next);
}
function makeLabelsFromLimit(limit, stepSize, isDateType) {
    const multipleNum = findMultipleNum(stepSize);
    const min = Math.round(limit.min * multipleNum);
    const max = Math.round(limit.max * multipleNum);
    const labels = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.range)(min, max + 1, stepSize * multipleNum);
    return labels.map((label) => {
        return String(isDateType ? new Date(label) : label / multipleNum);
    });
}
function makeTickPixelPositions(size, count, additionalPosition = 0, remainLastBlockIntervalPosition = 0) {
    let positions = [];
    if (count > 0) {
        positions = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.range)(0, count).map((index) => {
            const ratio = index === 0 ? 0 : index / (count - 1);
            return ratio * size + additionalPosition;
        });
    }
    if (remainLastBlockIntervalPosition) {
        positions.push(remainLastBlockIntervalPosition);
    }
    return positions;
}
function crispPixel(pixel, thickness = 1) {
    const halfThickness = thickness / 2;
    return thickness % 2
        ? ((0,_utils__WEBPACK_IMPORTED_MODULE_1__.isInteger)(pixel) ? pixel : Math.round(pixel - halfThickness)) + halfThickness
        : Math.round(pixel);
}
function getControlPoints(prev, cur, next) {
    // http://scaledinnovation.com/analytics/splines/aboutSplines.html
    const TENSION = 0.333;
    const { x: x0, y: y0 } = prev;
    const { x: x1, y: y1 } = cur;
    const { x: x2, y: y2 } = next;
    const d12 = getDistance(next, cur);
    const d01 = getDistance(cur, prev);
    const fa = (TENSION * d01) / (d01 + d12) || 0; // scaling factor for triangle Ta
    const fb = (TENSION * d12) / (d01 + d12) || 0; // ditto for Tb, simplifies to fb=t-fa
    return {
        prev: {
            x: x1 - fa * (x2 - x0),
            y: y1 - fa * (y2 - y0),
        },
        next: { x: x1 + fb * (x2 - x0), y: y1 + fb * (y2 - y0) },
    };
}
function setSplineControlPoint(points) {
    for (let i = 0, pointsSize = points.length, prev = points[0]; i < pointsSize; i += 1) {
        const point = points[i];
        if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(point)) {
            prev = points[i + 1];
            continue;
        }
        const next = points[Math.min(i + 1, pointsSize - 1) % pointsSize];
        if (prev && next) {
            point.controlPoint = getControlPoints(prev, point, next);
        }
        prev = point;
    }
}
function getValueRatio(value, { min, max }) {
    if (max === min) {
        return 0;
    }
    return (value - min) / (max - min);
}
function getDistance(point1, point2) {
    return Math.sqrt(Math.pow((point2.x - point1.x), 2) + Math.pow((point2.y - point1.y), 2));
}
function getMaxLengthLabelWidth(labels) {
    const maxLengthLabel = labels.reduce((acc, cur) => (acc.length > cur.length ? acc : cur), '');
    return getTextWidth(maxLengthLabel);
}
function getXPosition(axisData, offsetSize, value, dataIndex) {
    const { pointOnColumn, tickDistance, labelRange } = axisData;
    let x;
    if (labelRange) {
        const xValue = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(value) ? Number(new Date(value)) : Number(value);
        const xValueRatio = getValueRatio(xValue, labelRange);
        x = xValueRatio * offsetSize;
    }
    else {
        x = tickDistance * dataIndex + (pointOnColumn ? tickDistance / 2 : 0);
    }
    return x;
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js":
/*!****************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/color.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "colorMap": () => (/* binding */ colorMap),
/* harmony export */   "hexToRGB": () => (/* binding */ hexToRGB),
/* harmony export */   "rgbToHEX": () => (/* binding */ rgbToHEX),
/* harmony export */   "getRGBA": () => (/* binding */ getRGBA),
/* harmony export */   "getAlpha": () => (/* binding */ getAlpha),
/* harmony export */   "rgba": () => (/* binding */ rgba)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");

const hexRX = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i;
const rgbRX = /rgb\((\d{1,3}), ?(\d{1,3}), ?(\d{1,3})\)/;
const rgbaRX = /rgba\((\d{1,3}), ?(\d{1,3}), ?(\d{1,3}), ?(1|0?\.?\d+)\)/;
/**
 * Color map.
 * http://stackoverflow.com/questions/1573053/javascript-function-to-convert-color-names-to-hex-codes
 * http://www.w3schools.com/HTML/html_colornames.asp
 * @ignore
 */
const colorMap = {
    aliceblue: '#f0f8ff',
    antiquewhite: '#faebd7',
    aqua: '#00ffff',
    aquamarine: '#7fffd4',
    azure: '#f0ffff',
    beige: '#f5f5dc',
    bisque: '#ffe4c4',
    black: '#000000',
    blanchedalmond: '#ffebcd',
    blue: '#0000ff',
    blueviolet: '#8a2be2',
    brown: '#a52a2a',
    burlywood: '#deb887',
    cadetblue: '#5f9ea0',
    chartreuse: '#7fff00',
    chocolate: '#d2691e',
    coral: '#ff7f50',
    cornflowerblue: '#6495ed',
    cornsilk: '#fff8dc',
    crimson: '#dc143c',
    cyan: '#00ffff',
    darkblue: '#00008b',
    darkcyan: '#008b8b',
    darkgoldenrod: '#b8860b',
    darkgray: '#a9a9a9',
    darkgreen: '#006400',
    darkkhaki: '#bdb76b',
    darkmagenta: '#8b008b',
    darkolivegreen: '#556b2f',
    darkorange: '#ff8c00',
    darkorchid: '#9932cc',
    darkred: '#8b0000',
    darksalmon: '#e9967a',
    darkseagreen: '#8fbc8f',
    darkslateblue: '#483d8b',
    darkslategray: '#2f4f4f',
    darkturquoise: '#00ced1',
    darkviolet: '#9400d3',
    deeppink: '#ff1493',
    deepskyblue: '#00bfff',
    dimgray: '#696969',
    dodgerblue: '#1e90ff',
    firebrick: '#b22222',
    floralwhite: '#fffaf0',
    forestgreen: '#228b22',
    fuchsia: '#ff00ff',
    gainsboro: '#dcdcdc',
    ghostwhite: '#f8f8ff',
    gold: '#ffd700',
    goldenrod: '#daa520',
    gray: '#808080',
    green: '#008000',
    greenyellow: '#adff2f',
    honeydew: '#f0fff0',
    hotpink: '#ff69b4',
    indianred: '#cd5c5c',
    indigo: '#4b0082',
    ivory: '#fffff0',
    khaki: '#f0e68c',
    lavender: '#e6e6fa',
    lavenderblush: '#fff0f5',
    lawngreen: '#7cfc00',
    lemonchiffon: '#fffacd',
    lightblue: '#add8e6',
    lightcoral: '#f08080',
    lightcyan: '#e0ffff',
    lightgoldenrodyellow: '#fafad2',
    lightgrey: '#d3d3d3',
    lightgreen: '#90ee90',
    lightpink: '#ffb6c1',
    lightsalmon: '#ffa07a',
    lightseagreen: '#20b2aa',
    lightskyblue: '#87cefa',
    lightslategray: '#778899',
    lightsteelblue: '#b0c4de',
    lightyellow: '#ffffe0',
    lime: '#00ff00',
    limegreen: '#32cd32',
    linen: '#faf0e6',
    magenta: '#ff00ff',
    maroon: '#800000',
    mediumaquamarine: '#66cdaa',
    mediumblue: '#0000cd',
    mediumorchid: '#ba55d3',
    mediumpurple: '#9370d8',
    mediumseagreen: '#3cb371',
    mediumslateblue: '#7b68ee',
    mediumspringgreen: '#00fa9a',
    mediumturquoise: '#48d1cc',
    mediumvioletred: '#c71585',
    midnightblue: '#191970',
    mintcream: '#f5fffa',
    mistyrose: '#ffe4e1',
    moccasin: '#ffe4b5',
    navajowhite: '#ffdead',
    navy: '#000080',
    oldlace: '#fdf5e6',
    olive: '#808000',
    olivedrab: '#6b8e23',
    orange: '#ffa500',
    orangered: '#ff4500',
    orchid: '#da70d6',
    palegoldenrod: '#eee8aa',
    palegreen: '#98fb98',
    paleturquoise: '#afeeee',
    palevioletred: '#d87093',
    papayawhip: '#ffefd5',
    peachpuff: '#ffdab9',
    peru: '#cd853f',
    pink: '#ffc0cb',
    plum: '#dda0dd',
    powderblue: '#b0e0e6',
    purple: '#800080',
    red: '#ff0000',
    rosybrown: '#bc8f8f',
    royalblue: '#4169e1',
    saddlebrown: '#8b4513',
    salmon: '#fa8072',
    sandybrown: '#f4a460',
    seagreen: '#2e8b57',
    seashell: '#fff5ee',
    sienna: '#a0522d',
    silver: '#c0c0c0',
    skyblue: '#87ceeb',
    slateblue: '#6a5acd',
    slategray: '#708090',
    snow: '#fffafa',
    springgreen: '#00ff7f',
    steelblue: '#4682b4',
    tan: '#d2b48c',
    teal: '#008080',
    thistle: '#d8bfd8',
    tomato: '#ff6347',
    turquoise: '#40e0d0',
    violet: '#ee82ee',
    wheat: '#f5deb3',
    white: '#ffffff',
    whitesmoke: '#f5f5f5',
    yellow: '#ffff00',
    yellowgreen: '#9acd32',
};
function leadingZero(number, length) {
    if (number.length > length) {
        return number;
    }
    let res = number;
    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.range)(0, length - 1).forEach((_) => {
        res = '0' + res;
    });
    return res.slice(length * -1);
}
function isValidRGB(str) {
    return hexRX.test(str);
}
function colorNameToHex(colorName) {
    return colorMap[colorName.toLowerCase()] || colorName;
}
// @license RGB <-> HSV conversion utilities based off of http://www.cs.rit.edu/~ncs/color/t_convert.html
function hexToRGB(str) {
    const hexStr = colorNameToHex(str);
    if (!isValidRGB(hexStr)) {
        return false;
    }
    return hexStr
        .replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (m, r, g, b) => '#' + r + r + g + g + b + b)
        .substring(1)
        .match(/.{2}/g)
        .map((x) => parseInt(x, 16));
}
function rgbToHEX(r, g, b) {
    const hexPreFix = '#';
    const hexStr = hexPreFix +
        leadingZero(r.toString(16), 2) +
        leadingZero(g.toString(16), 2) +
        leadingZero(b.toString(16), 2);
    if (isValidRGB(hexStr)) {
        return hexStr;
    }
    return false;
}
function getRGBA(str, opacity) {
    const hexStr = colorNameToHex(str);
    if (isValidRGB(hexStr)) {
        const [r, g, b] = hexToRGB(hexStr);
        return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }
    if (rgbRX.test(str)) {
        const match = rgbRX.exec(str);
        return `rgba(${match[1]}, ${match[2]}, ${match[3]}, ${opacity})`;
    }
    if (rgbaRX.test(str)) {
        const match = rgbaRX.exec(str);
        return `rgba(${match[1]}, ${match[2]}, ${match[3]}, ${opacity})`;
    }
    return str;
}
function getAlpha(str) {
    if (rgbaRX.test(str)) {
        const match = rgbaRX.exec(str);
        return Number(match[4]);
    }
    return 1;
}
function rgba(color, opacity = 1) {
    const alpha = getAlpha(color) * opacity;
    return getRGBA(color, alpha);
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/colorSpectrum.js":
/*!************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/colorSpectrum.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeDistances": () => (/* binding */ makeDistances),
/* harmony export */   "getColorRatio": () => (/* binding */ getColorRatio),
/* harmony export */   "getSpectrumColor": () => (/* binding */ getSpectrumColor)
/* harmony export */ });
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");


function makeDistances(startRGB, endRGB) {
    return startRGB.map((value, index) => endRGB[index] - value);
}
function getColorRatio(limit, value) {
    if ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(value)) {
        return;
    }
    const divNumber = Math.abs(limit.max - limit.min);
    return divNumber && !(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isNull)(value) ? (value - limit.min) / divNumber : 0;
}
function getSpectrumColor(ratio, distances, startRGB) {
    const rgbColor = startRGB.map((start, index) => start + parseInt(String(distances[index] * ratio), 10));
    const color = (0,_color__WEBPACK_IMPORTED_MODULE_1__.rgbToHEX)(...rgbColor);
    return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(color) ? color : '';
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/coordinate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/coordinate.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getCoordinateYValue": () => (/* binding */ getCoordinateYValue),
/* harmony export */   "getCoordinateXValue": () => (/* binding */ getCoordinateXValue),
/* harmony export */   "isValueAfterLastCategory": () => (/* binding */ isValueAfterLastCategory),
/* harmony export */   "getCoordinateDataIndex": () => (/* binding */ getCoordinateDataIndex),
/* harmony export */   "isCoordinateSeries": () => (/* binding */ isCoordinateSeries),
/* harmony export */   "isModelExistingInRect": () => (/* binding */ isModelExistingInRect),
/* harmony export */   "isMouseInRect": () => (/* binding */ isMouseInRect)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");

function getCoordinateYValue(datum) {
    if ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(datum)) {
        return datum;
    }
    return Array.isArray(datum) ? datum[1] : datum.y;
}
function getCoordinateXValue(datum) {
    return Array.isArray(datum) ? datum[0] : datum.x;
}
function isValueAfterLastCategory(value, categories) {
    const category = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.last)(categories);
    if (!category) {
        return false;
    }
    return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(value) ? value >= Number(category) : new Date(value) >= new Date(category);
}
function getCoordinateDataIndex(datum, categories, dataIndex, startIndex) {
    if ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(datum)) {
        return dataIndex - startIndex;
    }
    const value = getCoordinateXValue(datum);
    let index = categories.findIndex((category) => category === String(value));
    if (index === -1 && isValueAfterLastCategory(value, categories)) {
        index = categories.length;
    }
    return index;
}
function isLineCoordinateSeries(series) {
    var _a;
    if (!series.line) {
        return false;
    }
    const firstData = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getFirstValidValue)((_a = series.line[0]) === null || _a === void 0 ? void 0 : _a.data);
    return firstData && (Array.isArray(firstData) || (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(firstData));
}
function isCoordinateSeries(series) {
    return isLineCoordinateSeries(series) || !!series.scatter || !!series.bubble;
}
function isModelExistingInRect(rect, point) {
    const { height, width } = rect;
    const { x, y } = point;
    return x >= 0 && x <= width && y >= 0 && y <= height;
}
function isMouseInRect(rect, mousePosition) {
    const { x, y, width, height } = rect;
    return (mousePosition.x >= x &&
        mousePosition.x <= x + width &&
        mousePosition.y >= y &&
        mousePosition.y <= y + height);
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/dataLabels.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/dataLabels.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RADIUS_PADDING": () => (/* binding */ RADIUS_PADDING),
/* harmony export */   "getDefaultDataLabelsOptions": () => (/* binding */ getDefaultDataLabelsOptions),
/* harmony export */   "makePointLabelInfo": () => (/* binding */ makePointLabelInfo),
/* harmony export */   "makeRectLabelInfo": () => (/* binding */ makeRectLabelInfo),
/* harmony export */   "makeSectorLabelPosition": () => (/* binding */ makeSectorLabelPosition),
/* harmony export */   "makeSectorBarLabelInfo": () => (/* binding */ makeSectorBarLabelInfo),
/* harmony export */   "makeSectorLabelInfo": () => (/* binding */ makeSectorLabelInfo),
/* harmony export */   "makePieSeriesNameLabelInfo": () => (/* binding */ makePieSeriesNameLabelInfo),
/* harmony export */   "getDataLabelsOptions": () => (/* binding */ getDataLabelsOptions),
/* harmony export */   "makeLineLabelInfo": () => (/* binding */ makeLineLabelInfo)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _calculator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _sector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sector */ "./node_modules/@toast-ui/chart/dist/esm/helpers/sector.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");




const RADIUS_PADDING = 30;
const CALLOUT_LENGTH = 20;
function getDefaultAnchor(type, withStack = false) {
    let anchor = 'auto';
    switch (type) {
        case 'point':
            anchor = 'center';
            break;
        case 'rect':
            anchor = !withStack ? 'auto' : 'center';
            break;
        case 'sector':
        case 'treemapSeriesName':
            anchor = 'center';
            break;
        case 'stackTotal':
            anchor = 'auto';
            break;
    }
    return anchor;
}
function getAnchor(dataLabelOptions, type, withStack = false) {
    return type !== 'stackTotal' &&
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.includes)(['center', 'start', 'end', 'auto', 'outer'], dataLabelOptions.anchor)
        ? dataLabelOptions.anchor
        : getDefaultAnchor(type, withStack);
}
function getDefaultDataLabelsOptions(dataLabelOptions, type, withStack = false) {
    var _a, _b, _c;
    const anchor = getAnchor(dataLabelOptions, type, withStack);
    const { offsetX = 0, offsetY = 0 } = dataLabelOptions;
    const formatter = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(dataLabelOptions.formatter)
        ? dataLabelOptions.formatter
        : (value) => String(value) || '';
    const options = {
        anchor,
        offsetX,
        offsetY,
        formatter,
    };
    if (withStack) {
        const stackTotal = dataLabelOptions.stackTotal;
        options.stackTotal = {
            visible: (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isBoolean)((_a = stackTotal) === null || _a === void 0 ? void 0 : _a.visible) ? stackTotal.visible : true,
            formatter: (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)((_b = stackTotal) === null || _b === void 0 ? void 0 : _b.formatter) ? stackTotal.formatter : formatter,
        };
    }
    if (type === 'sector' && ((_c = dataLabelOptions.pieSeriesName) === null || _c === void 0 ? void 0 : _c.visible)) {
        options.pieSeriesName = Object.assign({ anchor: 'center' }, dataLabelOptions.pieSeriesName);
    }
    return options;
}
function makePointLabelInfo(point, dataLabelOptions, rect) {
    const { width, height } = rect;
    const { anchor, offsetX = 0, offsetY = 0, formatter } = dataLabelOptions;
    const { name, theme } = point;
    let textBaseline = 'middle';
    if (anchor === 'end') {
        textBaseline = 'bottom';
    }
    else if (anchor === 'start') {
        textBaseline = 'top';
    }
    const xWithOffset = point.x + offsetX;
    const yWithOffset = point.y + offsetY;
    const x = xWithOffset < 0 || xWithOffset > width ? point.x : xWithOffset;
    const y = yWithOffset < 0 || yWithOffset > height ? point.y : yWithOffset;
    return {
        type: 'point',
        x,
        y,
        text: formatter(point.value, point.data),
        textAlign: 'center',
        textBaseline,
        name,
        theme,
    };
}
function isHorizontal(direction) {
    return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.includes)(['left', 'right'], direction);
}
function makeHorizontalRectPosition(rect, anchor) {
    const { x, y, width, height, direction } = rect;
    const textBaseline = 'middle';
    const posY = y + height / 2;
    let textAlign = 'center';
    let posX;
    if (direction === 'right') {
        switch (anchor) {
            case 'start':
                textAlign = 'left';
                posX = x;
                break;
            case 'end':
                textAlign = 'right';
                posX = x + width;
                break;
            case 'center':
                textAlign = 'center';
                posX = x + width / 2;
                break;
            default:
                textAlign = 'left';
                posX = x + width;
        }
    }
    else {
        switch (anchor) {
            case 'start':
                textAlign = 'right';
                posX = x + width;
                break;
            case 'end':
                textAlign = 'left';
                posX = x;
                break;
            case 'center':
                textAlign = 'center';
                posX = x + width / 2;
                break;
            default:
                textAlign = 'right';
                posX = x;
        }
    }
    return {
        x: posX,
        y: posY,
        textAlign,
        textBaseline,
    };
}
function makeVerticalRectPosition(rect, anchor) {
    const { x, y, width, height, direction } = rect;
    const textAlign = 'center';
    const posX = x + width / 2;
    let textBaseline = 'middle';
    let posY = 0;
    if (direction === 'top') {
        switch (anchor) {
            case 'end':
                textBaseline = 'top';
                posY = y;
                break;
            case 'start':
                textBaseline = 'bottom';
                posY = y + height;
                break;
            case 'center':
                textBaseline = 'middle';
                posY = y + height / 2;
                break;
            default:
                textBaseline = 'bottom';
                posY = y;
        }
    }
    else {
        switch (anchor) {
            case 'end':
                textBaseline = 'bottom';
                posY = y + height;
                break;
            case 'start':
                textBaseline = 'top';
                posY = y;
                break;
            case 'center':
                textBaseline = 'middle';
                posY = y + height / 2;
                break;
            default:
                textBaseline = 'top';
                posY = y + height;
                break;
        }
    }
    return {
        x: posX,
        y: posY,
        textAlign,
        textBaseline,
    };
}
function adjustOverflowHorizontalRect(rect, dataLabelOptions, position) {
    const { width, value, direction, plot, theme } = rect;
    const { formatter } = dataLabelOptions;
    const font = (0,_style__WEBPACK_IMPORTED_MODULE_1__.getFont)(theme);
    const text = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(value) ? value : formatter(value);
    const textWidth = (0,_calculator__WEBPACK_IMPORTED_MODULE_2__.getTextWidth)(text, font);
    let { x, textAlign } = position;
    const isOverflow = (direction === 'left' && x - textWidth < 0) || x + textWidth > plot.size;
    if (isOverflow) {
        x = rect.x + width;
        textAlign = 'right';
        if (direction === 'left' && width >= textWidth) {
            x = rect.x;
            textAlign = 'left';
        }
    }
    return {
        x,
        textAlign,
    };
}
function adjustOverflowVerticalRect(rect, dataLabelOptions, position) {
    const { height, direction, plot, theme, value } = rect;
    const font = (0,_style__WEBPACK_IMPORTED_MODULE_1__.getFont)(theme);
    const plotSize = plot.size;
    const textHeight = (0,_calculator__WEBPACK_IMPORTED_MODULE_2__.getTextHeight)(`${value}`, font); // @TODO: formatter 값해서 넘기기
    let { y, textBaseline } = position;
    const isOverflow = (!(direction === 'bottom') && y - textHeight < 0) || y + textHeight > plotSize;
    if (isOverflow) {
        y = rect.y;
        textBaseline = 'top';
        if (y + textHeight > plotSize) {
            y = rect.y;
            textBaseline = 'bottom';
        }
        if (direction === 'bottom') {
            y = rect.y + height;
            textBaseline = 'bottom';
        }
    }
    return {
        y,
        textBaseline,
    };
}
function makeHorizontalRectLabelInfo(rect, dataLabelOptions) {
    const { anchor, offsetX = 0, offsetY = 0 } = dataLabelOptions;
    const { direction, plot: { x: startOffsetX = 0, y: startOffsetY = 0 }, } = rect;
    const position = makeHorizontalRectPosition(rect, anchor);
    let { x: posX, y: posY, textAlign } = position;
    if (anchor === 'auto') {
        const adjustRect = adjustOverflowHorizontalRect(rect, dataLabelOptions, { x: posX, textAlign });
        posX = adjustRect.x;
        textAlign = adjustRect.textAlign;
    }
    posY += offsetY;
    if (direction === 'left') {
        posX = posX - offsetX;
    }
    else {
        posX = posX + offsetX;
    }
    const padding = 10;
    if (textAlign === 'right') {
        posX -= padding;
    }
    else if (textAlign === 'left') {
        posX += padding;
    }
    posX -= startOffsetX;
    posY -= startOffsetY;
    return {
        x: posX,
        y: posY,
        textAlign,
        textBaseline: position.textBaseline,
    };
}
function makeVerticalRectLabelInfo(rect, dataLabelOptions) {
    const { anchor, offsetX = 0, offsetY = 0 } = dataLabelOptions;
    const { direction, plot: { x: startOffsetX = 0, y: startOffsetY = 0 }, } = rect;
    const position = makeVerticalRectPosition(rect, anchor);
    let { x: posX, y: posY, textBaseline } = position;
    if (anchor === 'auto') {
        const adjustRect = adjustOverflowVerticalRect(rect, dataLabelOptions, position);
        posY = adjustRect.y;
        textBaseline = adjustRect.textBaseline;
    }
    posX += offsetX;
    if (direction === 'top') {
        posY = posY + offsetY;
    }
    else if (direction === 'bottom') {
        posY = posY - offsetY;
    }
    const padding = 5;
    if (textBaseline === 'bottom') {
        posY -= padding;
    }
    else if (textBaseline === 'top') {
        posY += padding;
    }
    posX -= startOffsetX;
    posY -= startOffsetY;
    return {
        x: posX,
        y: posY,
        textAlign: position.textAlign,
        textBaseline,
    };
}
function makeRectLabelInfo(rect, dataLabelOptions) {
    const { type, value, direction, name, theme } = rect;
    const horizontal = isHorizontal(direction);
    const labelPosition = horizontal
        ? makeHorizontalRectLabelInfo(rect, dataLabelOptions)
        : makeVerticalRectLabelInfo(rect, dataLabelOptions);
    const formatter = type === 'stackTotal' ? dataLabelOptions.stackTotal.formatter : dataLabelOptions.formatter;
    return Object.assign(Object.assign({ type }, labelPosition), { text: (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(value) ? value : formatter(value), name, seriesColor: rect.color, theme });
}
function makeSectorLabelPosition(model, dataLabelOptions) {
    const anchor = dataLabelOptions.anchor;
    const position = (0,_sector__WEBPACK_IMPORTED_MODULE_3__.getRadialAnchorPosition)((0,_sector__WEBPACK_IMPORTED_MODULE_3__.makeAnchorPositionParam)(anchor, Object.assign(Object.assign({}, model), { radius: Object.assign(Object.assign({}, model.radius), { outer: anchor === 'outer' ? model.radius.outer + RADIUS_PADDING : model.radius.outer }) })));
    const textAlign = (0,_sector__WEBPACK_IMPORTED_MODULE_3__.getRadialLabelAlign)(model, anchor);
    return Object.assign(Object.assign({}, position), { textAlign, textBaseline: hasSameAnchorPieDataLabel(dataLabelOptions) ? 'bottom' : 'middle' });
}
function makeSectorBarLabelPosition(model, dataLabelOptions) {
    const { anchor } = dataLabelOptions;
    const { clockwise, degree: { start, end }, radius: { inner, outer }, } = model;
    let startAngle = start;
    let endAngle = end;
    let textAlign = 'center';
    let rotationDegree = (start + end) / 2;
    if (anchor === 'start') {
        textAlign = clockwise ? 'left' : 'right';
        endAngle = startAngle;
        rotationDegree = start;
    }
    else if (anchor === 'end') {
        textAlign = clockwise ? 'right' : 'left';
        startAngle = endAngle;
        rotationDegree = end;
    }
    const { x, y } = (0,_sector__WEBPACK_IMPORTED_MODULE_3__.getRadialAnchorPosition)((0,_sector__WEBPACK_IMPORTED_MODULE_3__.makeAnchorPositionParam)(anchor, Object.assign(Object.assign({}, model), { degree: {
            start: startAngle,
            end: endAngle,
        }, radius: {
            inner: inner,
            outer: outer,
        } })));
    return {
        x,
        y,
        textAlign,
        textBaseline: 'middle',
        radian: (0,_sector__WEBPACK_IMPORTED_MODULE_3__.calculateDegreeToRadian)(rotationDegree, 0),
    };
}
function makeSectorBarLabelInfo(model, dataLabelOptions) {
    const { formatter } = dataLabelOptions;
    const labelPosition = makeSectorBarLabelPosition(model, dataLabelOptions);
    const { value, name, theme: dataLabelTheme } = model;
    const theme = Object.assign(Object.assign({}, dataLabelTheme), { color: dataLabelTheme.useSeriesColor ? model.color : dataLabelTheme.color });
    return Object.assign(Object.assign({ type: 'sector' }, labelPosition), { text: formatter(value), name,
        theme });
}
function makeSectorLabelInfo(model, dataLabelOptions) {
    const { formatter } = dataLabelOptions;
    const labelPosition = makeSectorLabelPosition(model, dataLabelOptions);
    const { value, name, theme: dataLabelTheme } = model;
    const anchor = dataLabelOptions.anchor;
    const theme = Object.assign(Object.assign({}, dataLabelTheme), { color: dataLabelTheme.useSeriesColor ? model.color : dataLabelTheme.color });
    return Object.assign(Object.assign({ type: 'sector' }, labelPosition), { text: formatter(value), name, callout: hasSectorCallout(dataLabelOptions) ? getPieDataLabelCallout(model, anchor) : null, theme });
}
function makePieSeriesNameLabelInfo(model, dataLabelOptions) {
    var _a;
    const seriesNameAnchor = (_a = dataLabelOptions.pieSeriesName) === null || _a === void 0 ? void 0 : _a.anchor;
    const hasOuterAnchor = seriesNameAnchor === 'outer';
    const position = (0,_sector__WEBPACK_IMPORTED_MODULE_3__.getRadialAnchorPosition)((0,_sector__WEBPACK_IMPORTED_MODULE_3__.makeAnchorPositionParam)(seriesNameAnchor, Object.assign(Object.assign({}, model), { radius: Object.assign(Object.assign({}, model.radius), { outer: hasOuterAnchor ? model.radius.outer + RADIUS_PADDING : model.radius.outer }) })));
    const textAlign = (0,_sector__WEBPACK_IMPORTED_MODULE_3__.getRadialLabelAlign)(model, seriesNameAnchor);
    const pieSeriesNameTheme = model.theme.pieSeriesName;
    const theme = Object.assign(Object.assign({}, pieSeriesNameTheme), { color: pieSeriesNameTheme.useSeriesColor ? model.color : pieSeriesNameTheme.color });
    return Object.assign(Object.assign({ type: 'pieSeriesName' }, position), { text: model.name, callout: hasPieSeriesNameCallout(dataLabelOptions)
            ? getPieDataLabelCallout(model, seriesNameAnchor)
            : null, textAlign, textBaseline: hasSameAnchorPieDataLabel(dataLabelOptions) ? 'top' : 'middle', theme });
}
function getDataLabelsOptions(options, name) {
    var _a, _b, _c, _d, _e;
    return ((_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b[name]) === null || _c === void 0 ? void 0 : _c.dataLabels) || ((_e = (_d = options) === null || _d === void 0 ? void 0 : _d.series) === null || _e === void 0 ? void 0 : _e.dataLabels) || {};
}
function makeLineLabelInfo(model, dataLabelOptions) {
    const { value, textAlign, textBaseline } = model;
    const { formatter } = dataLabelOptions;
    return Object.assign(Object.assign({}, model), { x: model.x, y: (model.y + model.y2) / 2, textAlign: (textAlign !== null && textAlign !== void 0 ? textAlign : 'center'), textBaseline: (textBaseline !== null && textBaseline !== void 0 ? textBaseline : 'middle'), text: (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(value) ? value : formatter(value) });
}
function hasSameAnchorPieDataLabel(dataLabelOptions) {
    var _a;
    return dataLabelOptions.anchor === ((_a = dataLabelOptions.pieSeriesName) === null || _a === void 0 ? void 0 : _a.anchor);
}
function hasSectorCallout(dataLabelOptions) {
    var _a;
    return dataLabelOptions.anchor === 'outer' || ((_a = dataLabelOptions.pieSeriesName) === null || _a === void 0 ? void 0 : _a.anchor) !== 'outer';
}
function hasPieSeriesNameCallout(dataLabelOptions) {
    var _a;
    return dataLabelOptions.anchor !== 'outer' || ((_a = dataLabelOptions.pieSeriesName) === null || _a === void 0 ? void 0 : _a.anchor) === 'outer';
}
function getPieDataLabelCallout(model, anchor) {
    if (anchor !== 'outer') {
        return null;
    }
    const { x, y } = (0,_sector__WEBPACK_IMPORTED_MODULE_3__.getRadialAnchorPosition)((0,_sector__WEBPACK_IMPORTED_MODULE_3__.makeAnchorPositionParam)('outer', Object.assign(Object.assign({}, model), { radius: Object.assign(Object.assign({}, model.radius), { outer: model.radius.outer + CALLOUT_LENGTH }) })));
    const { x: x2, y: y2 } = (0,_sector__WEBPACK_IMPORTED_MODULE_3__.getRadialAnchorPosition)((0,_sector__WEBPACK_IMPORTED_MODULE_3__.makeAnchorPositionParam)('outer', Object.assign({}, model)));
    const { callout } = model.theme;
    const theme = Object.assign(Object.assign({}, callout), { lineColor: callout.useSeriesColor ? model.color : callout.lineColor });
    return { x, y, x2, y2, theme };
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/dom.js":
/*!**************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/dom.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "findNodes": () => (/* binding */ findNodes),
/* harmony export */   "removeNode": () => (/* binding */ removeNode)
/* harmony export */ });
function findNodes(element, selector) {
    return element.querySelectorAll(selector);
}
function removeNode(node) {
    if (node.parentNode) {
        node.parentNode.removeChild(node);
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/downloader.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/downloader.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "execDownload": () => (/* binding */ execDownload),
/* harmony export */   "downloadSpreadSheet": () => (/* binding */ downloadSpreadSheet)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _coordinate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./coordinate */ "./node_modules/@toast-ui/chart/dist/esm/helpers/coordinate.js");


const DATA_URI_HEADERS = {
    xls: 'data:application/vnd.ms-excel;base64,',
    csv: 'data:text/csv;charset=utf-8,%EF%BB%BF' /* BOM for utf-8 */,
};
function getDownloadMethod() {
    let method;
    const isDownloadAttributeSupported = !(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(document.createElement('a').download);
    const isMSSaveOrOpenBlobSupported = !(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(window.Blob && window.navigator.msSaveOrOpenBlob);
    if (isMSSaveOrOpenBlobSupported) {
        method = downloadWithMSSaveOrOpenBlob;
    }
    else if (isDownloadAttributeSupported) {
        method = downloadWithAnchorElementDownloadAttribute;
    }
    return method;
}
/**
 * Base64 string to blob
 * original source ref: https://github.com/miguelmota/base64toblob/blob/master/base64toblob.js
 * Licence: MIT Licence
 */
function base64toBlob(base64String) {
    const contentType = base64String
        .substr(0, base64String.indexOf(';base64,'))
        .substr(base64String.indexOf(':') + 1);
    const sliceSize = 1024;
    const byteCharacters = atob(base64String.substr(base64String.indexOf(',') + 1));
    const byteArrays = [];
    for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
        const slice = byteCharacters.slice(offset, offset + sliceSize);
        const byteNumbers = new Array(slice.length);
        for (let i = 0; i < slice.length; i += 1) {
            byteNumbers[i] = slice.charCodeAt(i);
        }
        byteArrays.push(new window.Uint8Array(byteNumbers));
    }
    try {
        // for IE 11
        return new Blob(byteArrays, { type: contentType });
    }
    catch (e) {
        // for IE 10
        return new Blob(byteArrays.map((byteArr) => byteArr.buffer), { type: contentType });
    }
}
function isImageExtension(extension) {
    return extension === 'jpeg' || extension === 'png';
}
function downloadWithMSSaveOrOpenBlob(fileName, extension, content, contentType) {
    const blobObject = isImageExtension(extension)
        ? base64toBlob(content)
        : new Blob([content], { type: contentType });
    window.navigator.msSaveOrOpenBlob(blobObject, `${fileName}.${extension}`);
}
function downloadWithAnchorElementDownloadAttribute(fileName, extension, content) {
    if (content) {
        const anchorElement = document.createElement('a');
        anchorElement.href = content;
        anchorElement.target = '_blank';
        anchorElement.download = `${fileName}.${extension}`;
        document.body.appendChild(anchorElement);
        anchorElement.click();
        anchorElement.remove();
    }
}
function oneLineTrim(...args) {
    const normalTag = (template, ...expressions) => template.reduce((accumulator, part, i) => accumulator + expressions[i - 1] + part);
    return normalTag(...args).replace(/\n\s*/g, '');
}
function isNeedDataEncoding() {
    const isDownloadAttributeSupported = !(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(document.createElement('a').download);
    const isMSSaveOrOpenBlobSupported = !(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(window.Blob && window.navigator.msSaveOrOpenBlob);
    return !isMSSaveOrOpenBlobSupported && isDownloadAttributeSupported;
}
function getBulletLongestArrayLength(arr, field) {
    return arr.reduce((acc, cur, idx) => { var _a, _b; return (!idx || acc < ((_b = (_a = cur) === null || _a === void 0 ? void 0 : _a[field]) === null || _b === void 0 ? void 0 : _b.length) ? cur[field].length : acc); }, 0);
}
function makeBulletExportData({ series }) {
    const seriesData = series.bullet.data;
    const markerCount = getBulletLongestArrayLength(seriesData, 'markers');
    const rangeCount = getBulletLongestArrayLength(seriesData, 'ranges');
    const rangesHeaders = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.range)(0, rangeCount).map((idx) => `Range ${idx + 1}`);
    const markerHeaders = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.range)(0, markerCount).map((idx) => `Marker ${idx + 1}`);
    return seriesData.reduce((acc, { data, markers, name, ranges }) => {
        const rangeDatum = rangesHeaders.map((_, index) => {
            var _a;
            const rangeData = (_a = ranges) === null || _a === void 0 ? void 0 : _a[index];
            return rangeData ? `${rangeData[0]} ~ ${rangeData[1]}` : '';
        });
        const markerDatum = markerHeaders.map((_, index) => { var _a, _b; return _b = (_a = markers) === null || _a === void 0 ? void 0 : _a[index], (_b !== null && _b !== void 0 ? _b : ''); });
        return [...acc, [name, (data !== null && data !== void 0 ? data : ''), ...rangeDatum, ...markerDatum]];
    }, [['', 'Actual', ...rangesHeaders, ...markerHeaders]]);
}
function makeHeatmapExportData({ categories, series }) {
    const xCategories = categories.x;
    return series.heatmap.data.reduce((acc, { data, yCategory }) => [
        ...acc,
        [yCategory, ...data.map((datum) => ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.isNull)(datum) ? '' : datum))],
    ], [['', ...xCategories]]);
}
function recursiveTreemapData({ label, data, children = [] }, result) {
    if (data) {
        result.push([label, data]);
    }
    children.forEach((childrenData) => recursiveTreemapData(childrenData, result));
    return result;
}
function makeTreemapExportData(exportData) {
    const { series } = exportData;
    const result = [['Label', 'Data']];
    series.treemap.data.forEach((datum) => {
        recursiveTreemapData(datum, result);
    });
    return result;
}
function makeBubbleExportData(exportData) {
    const { series } = exportData;
    return series.bubble.data.reduce((acc, { name, data }) => [
        ...acc,
        ...data.map((datum) => (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isNull)(datum) ? [] : [name, datum.label, String(datum.x), datum.y, datum.r]),
    ], [['Name', 'Label', 'X', 'Y', 'Radius']]);
}
function makeBoxPlotExportData(exportData) {
    var _a;
    const { series } = exportData;
    const categories = (_a = exportData.categories, (_a !== null && _a !== void 0 ? _a : []));
    return series.boxPlot.data.reduce((acc, { name, data, outliers }) => {
        const values = ((data !== null && data !== void 0 ? data : [])).map((rawData, index) => {
            var _a;
            const outlierValue = (_a = ((outliers !== null && outliers !== void 0 ? outliers : [])).find((outlier) => outlier[0] === index)) === null || _a === void 0 ? void 0 : _a[1];
            const value = outlierValue ? [...rawData, outlierValue] : [...rawData];
            return value.join();
        });
        return [...acc, [name, ...values]];
    }, [['', ...categories]]);
}
function makePieExportData(exportData) {
    var _a;
    const { series } = exportData;
    const categories = (_a = exportData.categories, (_a !== null && _a !== void 0 ? _a : []));
    return series.pie.data.reduce((acc, { name, data }) => {
        const values = Array.isArray(data)
            ? ((data !== null && data !== void 0 ? data : [])).reduce((accNestedPieValue, value) => {
                var _a;
                return [...accNestedPieValue, [value.name, (_a = value.data, (_a !== null && _a !== void 0 ? _a : ''))]];
            }, [])
            : [[name, (data !== null && data !== void 0 ? data : '')]];
        return [...acc, ...values];
    }, categories.length ? [['', ...categories]] : []);
}
function makeCoordinateExportDataValues(type, categories, data) {
    return categories.map((category, index) => {
        if (type === 'area' && Array.isArray(data[index])) {
            return data[index].join();
        }
        const foundItem = data.find((value) => category === String((0,_coordinate__WEBPACK_IMPORTED_MODULE_1__.getCoordinateXValue)(value)));
        return foundItem ? (0,_coordinate__WEBPACK_IMPORTED_MODULE_1__.getCoordinateYValue)(foundItem) : '';
    });
}
function makeExportData(exportData) {
    const { series } = exportData;
    const categories = exportData.categories;
    return Object.keys(series).reduce((acc, type) => {
        const result = series[type].data.map(({ name, data }) => {
            const values = !(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)((0,_utils__WEBPACK_IMPORTED_MODULE_0__.getFirstValidValue)(data)) && (0,_utils__WEBPACK_IMPORTED_MODULE_0__.includes)(['line', 'area', 'scatter'], type)
                ? makeCoordinateExportDataValues(type, categories, data)
                : data.map((value) => (Array.isArray(value) ? value.join() : value));
            return [name, ...values];
        });
        return [...acc, ...result];
    }, series.gauge ? [] : [['', ...categories]]);
}
function get2DArrayFromRawData(exportData) {
    let result;
    const { series } = exportData;
    if (series.bullet) {
        result = makeBulletExportData(exportData);
    }
    else if (series.heatmap) {
        result = makeHeatmapExportData(exportData);
    }
    else if (series.bubble) {
        result = makeBubbleExportData(exportData);
    }
    else if (series.boxPlot) {
        result = makeBoxPlotExportData(exportData);
    }
    else if (series.pie) {
        result = makePieExportData(exportData);
    }
    else if (series.treemap) {
        result = makeTreemapExportData(exportData);
    }
    else {
        result = makeExportData(exportData);
    }
    return result;
}
function getTableElementStringForXLS(chartData2DArray) {
    let tableElementString = '<table>';
    chartData2DArray.forEach((row, rowIndex) => {
        const cellTagName = rowIndex === 0 ? 'th' : 'td';
        tableElementString += '<tr>';
        row.forEach((cell, cellIndex) => {
            const cellNumberClass = rowIndex !== 0 || cellIndex === 0 ? ' class="number"' : '';
            const cellString = `<${cellTagName}${cellNumberClass}>${cell}</${cellTagName}>`;
            tableElementString += cellString;
        });
        tableElementString += '</tr>';
    });
    tableElementString += '</table>';
    return tableElementString;
}
function makeXLSBodyWithRawData(chartData2DArray) {
    return oneLineTrim `<html xmlns:o="urn:schemas-microsoft-com:office:office"
        xmlns:x="urn:schemas-microsoft-com:office:excel"
        xmlns="http://www.w3.org/TR/REC-html40">
        <head>
            <!--[if gte mso 9]>
                <xml>
                    <x:ExcelWorkbook>
                        <x:ExcelWorksheets>
                            <x:ExcelWorksheet>
                                <x:Name>Ark1</x:Name>
                                <x:WorksheetOptions>
                                    <x:DisplayGridlines/>
                                </x:WorksheetOptions>
                            </x:ExcelWorksheet>
                        </x:ExcelWorksheets>
                        </x:ExcelWorkbook>
                </xml>
            <![endif]-->
            <meta name=ProgId content=Excel.Sheet>
            <meta charset=UTF-8>
        </head>
        <body>
            ${getTableElementStringForXLS(chartData2DArray)}
        </body>
        </html>`;
}
function makeCSVBodyWithRawData(chartData2DArray, option = {}) {
    const { lineDelimiter = '\u000a', itemDelimiter = ',' } = option;
    const lastRowIndex = chartData2DArray.length - 1;
    let csvText = '';
    chartData2DArray.forEach((row, rowIndex) => {
        const lastCellIndex = row.length - 1;
        row.forEach((cell, cellIndex) => {
            const cellContent = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(cell) ? cell : `"${cell}"`;
            csvText += cellContent;
            if (cellIndex < lastCellIndex) {
                csvText += itemDelimiter;
            }
        });
        if (rowIndex < lastRowIndex) {
            csvText += lineDelimiter;
        }
    });
    return csvText;
}
function execDownload(fileName, extension, content, contentType) {
    const downloadMethod = getDownloadMethod();
    if (!(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(content) || !downloadMethod) {
        return;
    }
    downloadMethod(fileName, extension, content, contentType);
}
function downloadSpreadSheet(fileName, extension, data) {
    const chartData2DArray = get2DArrayFromRawData(data);
    const contentType = DATA_URI_HEADERS[extension].replace(/(data:|;base64,|,%EF%BB%BF)/g, '');
    let content = '';
    if (extension === 'csv') {
        content = encodeURIComponent(makeCSVBodyWithRawData(chartData2DArray));
    }
    else {
        content = makeXLSBodyWithRawData(chartData2DArray);
    }
    if (isNeedDataEncoding()) {
        if (extension !== 'csv') {
            // base64 encoding for data URI scheme.
            content = window.btoa(unescape(encodeURIComponent(content)));
        }
        content = DATA_URI_HEADERS[extension] + content;
    }
    execDownload(fileName, extension, content, contentType);
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/formatDate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/formatDate.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_DATE_FORMAT": () => (/* binding */ DEFAULT_DATE_FORMAT),
/* harmony export */   "getDateFormat": () => (/* binding */ getDateFormat),
/* harmony export */   "formatDate": () => (/* binding */ formatDate)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
// https://github.com/nhn/tui.code-snippet/blob/master/formatDate/formatDate.js

const DEFAULT_DATE_FORMAT = 'YY-MM-DD hh:mm:ss';
function getDateFormat(date) {
    if (!date) {
        return;
    }
    return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(date) ? date.format : DEFAULT_DATE_FORMAT;
}
const tokens = /[\\]*YYYY|[\\]*YY|[\\]*MMMM|[\\]*MMM|[\\]*MM|[\\]*M|[\\]*DD|[\\]*D|[\\]*HH|[\\]*H|[\\]*mm|[\\]*m|[\\]*ss|[\\]*s|[\\]*A/gi;
const MONTH_STR = [
    'Invalid month',
    'January',
    'February',
    'March',
    'April',
    'May',
    'Jun',
    'Jul',
    'August',
    'September',
    'October',
    'November',
    'December',
];
const MONTH_DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const replaceMap = {
    M: (date) => Number(date.month),
    MM: (date) => {
        const month = date.month;
        return Number(month) < 10 ? `0${month}` : month;
    },
    MMM: (date) => MONTH_STR[Number(date.month)].substr(0, 3),
    MMMM: (date) => MONTH_STR[Number(date.month)],
    D: (date) => Number(date.date),
    d: (date) => replaceMap.D(date),
    DD: (date) => {
        const dayInMonth = date.date;
        return Number(dayInMonth) < 10 ? `0${dayInMonth}` : dayInMonth;
    },
    dd: (date) => replaceMap.DD(date),
    YY: (date) => Number(date.year) % 100,
    yy: (date) => replaceMap.YY(date),
    YYYY: (date) => {
        let prefix = '20';
        const year = date.year;
        if (year > 69 && year < 100) {
            prefix = '19';
        }
        return Number(year) < 100 ? prefix + String(year) : year;
    },
    yyyy: (date) => replaceMap.YYYY(date),
    A: (date) => date.meridiem,
    a: (date) => date.meridiem,
    hh: (date) => {
        const hour = date.hour;
        return Number(hour) < 10 ? '0' + hour : hour;
    },
    HH: (date) => replaceMap.hh(date),
    h: (date) => String(Number(date.hour)),
    H: (date) => replaceMap.h(date),
    m: (date) => String(Number(date.minute)),
    mm: (date) => {
        const minute = date.minute;
        return Number(minute) < 10 ? `0${minute}` : minute;
    },
    s: (date) => String(Number(date.second)),
    ss: (date) => {
        const second = date.second;
        return Number(second) < 10 ? `0${second}` : second;
    },
};
function isLeapYear(month, year) {
    return month === 2 && year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function isValidDate(y, m, d) {
    const year = Number(y);
    const month = Number(m);
    const date = Number(d);
    const isValidYear = (year > -1 && year < 100) || (year > 1969 && year < 2070);
    const isValidMonth = month > 0 && month < 13;
    if (!isValidYear || !isValidMonth) {
        return false;
    }
    const lastDayInMonth = isLeapYear(month, year) ? 29 : MONTH_DAYS[month];
    return date > 0 && date <= lastDayInMonth;
}
/*
 * key             | Shorthand
 * --------------- |-----------------------
 * years           | YY / YYYY / yy / yyyy
 * months(n)       | M / MM
 * months(str)     | MMM / MMMM
 * days            | D / DD / d / dd
 * hours           | H / HH / h / hh
 * minutes         | m / mm
 * seconds         | s / ss
 * meridiem(AM,PM) | A / a
 */
function formatDate(form, date, option) {
    var _a, _b, _c;
    const am = (_b = (_a = option) === null || _a === void 0 ? void 0 : _a.meridiemSet.AM, (_b !== null && _b !== void 0 ? _b : 'AM'));
    const pm = ((_c = option) === null || _c === void 0 ? void 0 : _c.meridiemSet.PM) || 'PM';
    let nDate;
    if ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.isDate)(date)) {
        nDate = {
            year: date.getFullYear(),
            month: date.getMonth() + 1,
            date: date.getDate(),
            hour: date.getHours(),
            minute: date.getMinutes(),
            second: date.getSeconds(),
        };
    }
    else {
        const { year, month, hour, minute, second } = date;
        nDate = { year, month, date: date.date, hour, minute, second };
    }
    if (!isValidDate(nDate.year, nDate.month, nDate.date)) {
        return '';
    }
    nDate.meridiem = '';
    if (/([^\\]|^)[aA]\b/.test(form)) {
        if (nDate.hour > 12) {
            // See the clock system: https://en.wikipedia.org/wiki/12-hour_clock
            nDate.hour %= 12;
        }
        if (nDate.hour === 0) {
            nDate.hour = 12;
        }
        nDate.meridiem = nDate.hour > 11 ? pm : am;
    }
    return form.replace(tokens, (key) => {
        if (key.indexOf('\\') > -1) {
            // escape character
            return key.replace(/\\/, '');
        }
        return replaceMap[key](nDate) || '';
    });
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/geometric.js":
/*!********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/geometric.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ANGLE_CANDIDATES": () => (/* binding */ ANGLE_CANDIDATES),
/* harmony export */   "calculateRotatedWidth": () => (/* binding */ calculateRotatedWidth),
/* harmony export */   "calculateRotatedHeight": () => (/* binding */ calculateRotatedHeight)
/* harmony export */ });
const RAD = Math.PI / 180;
const ANGLE_90 = 90;
const ANGLE_CANDIDATES = [0, 25, 45, 65, 85, 90];
/**
 * Calculate adjacent.
 *
 *   H : Hypotenuse
 *   A : Adjacent
 *   O : Opposite
 *   D : Degree
 *
 *        /|
 *       / |
 *    H /  | O
 *     /   |
 *    /\ D |
 *    -----
 *       A
 */
function calculateAdjacent(degree, hypotenuse) {
    return Math.cos(degree * RAD) * hypotenuse;
}
function calculateOpposite(degree, hypotenuse) {
    return Math.sin(degree * RAD) * hypotenuse;
}
function calculateRotatedWidth(degree, width, height) {
    const centerHalf = calculateAdjacent(degree, width / 2);
    const sideHalf = calculateAdjacent(ANGLE_90 - degree, height / 2);
    return (centerHalf + sideHalf) * 2;
}
function calculateRotatedHeight(degree, width, height) {
    const centerHalf = calculateOpposite(degree, width / 2);
    const sideHalf = calculateOpposite(ANGLE_90 - degree, height / 2);
    return (centerHalf + sideHalf) * 2;
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/googleAnalytics.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/googleAnalytics.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sendHostname": () => (/* binding */ sendHostname)
/* harmony export */ });
const MS_7_DAYS = 7 * 24 * 60 * 60 * 1000;
function isExpired(date) {
    const now = new Date().getTime();
    return now - date > MS_7_DAYS;
}
function imagePing(url, trackingInfo) {
    const queryString = Object.keys(trackingInfo)
        .map((id, index) => `${index ? '&' : ''}${id}=${trackingInfo[id]}`)
        .join('');
    const trackingElement = document.createElement('img');
    trackingElement.src = `${url}?${queryString}`;
    trackingElement.style.display = 'none';
    document.body.appendChild(trackingElement);
    document.body.removeChild(trackingElement);
    return trackingElement;
}
function sendHostname() {
    const hostname = location.hostname;
    const applicationKeyForStorage = `TOAST UI chart for ${hostname}: Statistics`;
    const date = window.localStorage.getItem(applicationKeyForStorage);
    if (date && !isExpired(Number(date))) {
        return;
    }
    window.localStorage.setItem(applicationKeyForStorage, String(new Date().getTime()));
    setTimeout(() => {
        if (document.readyState === 'interactive' || document.readyState === 'complete') {
            imagePing('https://www.google-analytics.com/collect', {
                v: 1,
                t: 'event',
                tid: 'UA-129983528-2',
                cid: hostname,
                dp: hostname,
                dh: 'chart',
                el: 'chart',
                ec: 'use',
            });
        }
    }, 1000);
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/htmlSanitizer.js":
/*!************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/htmlSanitizer.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sanitizeHTML": () => (/* binding */ sanitizeHTML)
/* harmony export */ });
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom */ "./node_modules/@toast-ui/chart/dist/esm/helpers/dom.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");


const HTML_ATTR_LIST_RX = new RegExp('^(abbr|align|alt|axis|bgcolor|border|cellpadding|cellspacing|class|clear|' +
    'color|cols|compact|coords|dir|face|headers|height|hreflang|hspace|' +
    'ismap|lang|language|nohref|nowrap|rel|rev|rows|rules|' +
    'scope|scrolling|shape|size|span|start|summary|tabindex|target|title|type|' +
    'valign|value|vspace|width|checked|mathvariant|encoding|id|name|' +
    'background|cite|href|longdesc|src|usemap|xlink:href|data-+|checked|style)', 'g');
const SVG_ATTR_LIST_RX = new RegExp('^(accent-height|accumulate|additive|alphabetic|arabic-form|ascent|' +
    'baseProfile|bbox|begin|by|calcMode|cap-height|class|color|color-rendering|content|' +
    'cx|cy|d|dx|dy|descent|display|dur|end|fill|fill-rule|font-family|font-size|font-stretch|' +
    'font-style|font-variant|font-weight|from|fx|fy|g1|g2|glyph-name|gradientUnits|hanging|' +
    'height|horiz-adv-x|horiz-origin-x|ideographic|k|keyPoints|keySplines|keyTimes|lang|' +
    'marker-end|marker-mid|marker-start|markerHeight|markerUnits|markerWidth|mathematical|' +
    'max|min|offset|opacity|orient|origin|overline-position|overline-thickness|panose-1|' +
    'path|pathLength|points|preserveAspectRatio|r|refX|refY|repeatCount|repeatDur|' +
    'requiredExtensions|requiredFeatures|restart|rotate|rx|ry|slope|stemh|stemv|stop-color|' +
    'stop-opacity|strikethrough-position|strikethrough-thickness|stroke|stroke-dasharray|' +
    'stroke-dashoffset|stroke-linecap|stroke-linejoin|stroke-miterlimit|stroke-opacity|' +
    'stroke-width|systemLanguage|target|text-anchor|to|transform|type|u1|u2|underline-position|' +
    'underline-thickness|unicode|unicode-range|units-per-em|values|version|viewBox|visibility|' +
    'width|widths|x|x-height|x1|x2|xlink:actuate|xlink:arcrole|xlink:role|xlink:show|xlink:title|' +
    'xlink:type|xml:base|xml:lang|xml:space|xmlns|xmlns:xlink|y|y1|y2|zoomAndPan)', 'g');
const DEFAULT_TAG_DENY_LIST = [
    'script',
    'iframe',
    'textarea',
    'form',
    'button',
    'select',
    'input',
    'meta',
    'style',
    'link',
    'title',
    'embed',
    'object',
];
const XSS_ATTR_RX = /href|src|background/gi;
const XSS_VALUE_RX = /((java|vb|live)script|x):/gi;
const ON_EVENT_RX = /^on\S+/;
function sanitizeHTML(html) {
    const root = document.createElement('div');
    if ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(html)) {
        html = html.replace(/<!--[\s\S]*?-->/g, '');
        root.innerHTML = html;
    }
    else {
        root.appendChild(html);
    }
    removeUnnecessaryTags(root);
    leaveOnlyWhitelistAttribute(root);
    return root.innerHTML;
}
function removeUnnecessaryTags(html) {
    const removedTags = (0,_dom__WEBPACK_IMPORTED_MODULE_1__.findNodes)(html, DEFAULT_TAG_DENY_LIST.join(','));
    removedTags.forEach((node) => {
        (0,_dom__WEBPACK_IMPORTED_MODULE_1__.removeNode)(node);
    });
}
function isXSSAttribute(attrName, attrValue) {
    return attrName.match(XSS_ATTR_RX) && attrValue.match(XSS_VALUE_RX);
}
function removeBlacklistAttributes(node, blacklistAttrs) {
    blacklistAttrs.forEach(({ name }) => {
        if (ON_EVENT_RX.test(name)) {
            node[name] = null;
        }
        if (node.getAttribute(name)) {
            node.removeAttribute(name);
        }
    });
}
function leaveOnlyWhitelistAttribute(html) {
    (0,_dom__WEBPACK_IMPORTED_MODULE_1__.findNodes)(html, '*').forEach((node) => {
        const { attributes } = node;
        const blacklist = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.toArray)(attributes).filter((attr) => {
            const { name, value } = attr;
            const htmlAttr = name.match(HTML_ATTR_LIST_RX);
            const svgAttr = name.match(SVG_ATTR_LIST_RX);
            const xssAttr = htmlAttr && isXSSAttribute(name, value);
            return (!htmlAttr && !svgAttr) || xssAttr;
        });
        removeBlacklistAttributes(node, blacklist);
    });
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/legend.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/legend.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getActiveSeriesMap": () => (/* binding */ getActiveSeriesMap),
/* harmony export */   "showCircleLegend": () => (/* binding */ showCircleLegend),
/* harmony export */   "showLegend": () => (/* binding */ showLegend),
/* harmony export */   "showCheckbox": () => (/* binding */ showCheckbox),
/* harmony export */   "getIconType": () => (/* binding */ getIconType),
/* harmony export */   "getLegendAlign": () => (/* binding */ getLegendAlign)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");

function getActiveSeriesMap(legend) {
    return legend.data.reduce((acc, { active, label }) => (Object.assign(Object.assign({}, acc), { [label]: active })), {});
}
function showCircleLegend(options) {
    var _a, _b, _c;
    return _c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.circleLegend) === null || _b === void 0 ? void 0 : _b.visible, (_c !== null && _c !== void 0 ? _c : true);
}
function showLegend(options, series) {
    var _a, _b, _c;
    if (series.gauge ||
        (series.treemap && !((_a = options.series) === null || _a === void 0 ? void 0 : _a.useColorValue))) {
        return false;
    }
    return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)((_b = options.legend) === null || _b === void 0 ? void 0 : _b.visible) ? true : !!((_c = options.legend) === null || _c === void 0 ? void 0 : _c.visible);
}
function showCheckbox(options) {
    var _a, _b;
    return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)((_a = options.legend) === null || _a === void 0 ? void 0 : _a.showCheckbox) ? true : !!((_b = options.legend) === null || _b === void 0 ? void 0 : _b.showCheckbox);
}
// @TODO: Need to manage with chart type constant/Enum
function useRectIcon(type) {
    return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.includes)(['bar', 'column', 'area', 'pie', 'boxPlot', 'bullet', 'radialBar'], type);
}
function useCircleIcon(type) {
    return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.includes)(['bubble', 'scatter'], type);
}
function useLineIcon(type) {
    return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.includes)(['line', 'radar'], type);
}
function getIconType(type) {
    let iconType = 'spectrum';
    if (useCircleIcon(type)) {
        iconType = 'circle';
    }
    else if (useRectIcon(type)) {
        iconType = 'rect';
    }
    else if (useLineIcon(type)) {
        iconType = 'line';
    }
    return iconType;
}
function getLegendAlign(options) {
    var _a, _b;
    return _b = (_a = options.legend) === null || _a === void 0 ? void 0 : _a.align, (_b !== null && _b !== void 0 ? _b : 'right');
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/pieSeries.js":
/*!********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/pieSeries.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasClockwiseSemiCircle": () => (/* binding */ hasClockwiseSemiCircle),
/* harmony export */   "hasCounterClockwiseSemiCircle": () => (/* binding */ hasCounterClockwiseSemiCircle),
/* harmony export */   "getRadius": () => (/* binding */ getRadius),
/* harmony export */   "getTotalAngle": () => (/* binding */ getTotalAngle),
/* harmony export */   "isSemiCircle": () => (/* binding */ isSemiCircle),
/* harmony export */   "getSemiCircleCenterY": () => (/* binding */ getSemiCircleCenterY),
/* harmony export */   "makePieTooltipData": () => (/* binding */ makePieTooltipData),
/* harmony export */   "hasNestedPieSeries": () => (/* binding */ hasNestedPieSeries),
/* harmony export */   "getNestedPieChartAliasNames": () => (/* binding */ getNestedPieChartAliasNames),
/* harmony export */   "pieTooltipLabelFormatter": () => (/* binding */ pieTooltipLabelFormatter),
/* harmony export */   "hasOuterDataLabel": () => (/* binding */ hasOuterDataLabel),
/* harmony export */   "hasOuterPieSeriesName": () => (/* binding */ hasOuterPieSeriesName)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _sector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sector */ "./node_modules/@toast-ui/chart/dist/esm/helpers/sector.js");


const semiCircleCenterYRatio = {
    COUNTER_CLOCKWISE: 0.1,
    CLOCKWISE: 1,
};
function hasClockwiseSemiCircle(clockwise, startAngle, endAngle) {
    return (clockwise &&
        ((startAngle >= _sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_NEGATIVE_90 && endAngle <= _sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_90) ||
            (startAngle >= _sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_90 && endAngle <= _sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_180)));
}
function hasCounterClockwiseSemiCircle(clockwise, startAngle, endAngle) {
    return (!clockwise &&
        ((startAngle >= _sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_NEGATIVE_180 && endAngle <= _sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_90) ||
            (startAngle <= _sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_90 && endAngle >= _sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_NEGATIVE_90)));
}
function getRadius(defaultRadius, radius) {
    return (0,_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(radius)
        ? Number(((defaultRadius * (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getPercentageValue)(radius)) / 100).toFixed(2))
        : radius;
}
function getTotalAngle(clockwise, startAngle, endAngle) {
    const diffAngle = endAngle - startAngle;
    const absDiff = Math.abs(diffAngle);
    const needSubstractAngle = (diffAngle > _sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_0 && absDiff !== _sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_360 && !clockwise) ||
        (diffAngle < _sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_0 && absDiff !== _sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_360 && clockwise);
    return needSubstractAngle ? _sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_360 - absDiff : absDiff;
}
function isSemiCircle(clockwise, startAngle, endAngle) {
    return (getTotalAngle(clockwise, startAngle, endAngle) <= _sector__WEBPACK_IMPORTED_MODULE_0__.DEGREE_180 &&
        (hasClockwiseSemiCircle(clockwise, startAngle, endAngle) ||
            hasCounterClockwiseSemiCircle(clockwise, startAngle, endAngle)));
}
function getSemiCircleCenterY(rectHeight, clockwise) {
    return clockwise
        ? rectHeight * semiCircleCenterYRatio.CLOCKWISE
        : rectHeight * semiCircleCenterYRatio.COUNTER_CLOCKWISE;
}
function makePieTooltipData(seriesRawData, category = '') {
    return seriesRawData
        .filter(({ data }) => !(0,_utils__WEBPACK_IMPORTED_MODULE_1__.isNull)(data))
        .map(({ data, name, color, rootParentName }) => ({
        label: name,
        color: color,
        value: data,
        category,
        rootParentName,
        templateType: 'pie',
    }));
}
function hasNestedPieSeries(series) {
    var _a;
    return !!(series.pie && Array.isArray((_a = series.pie[0]) === null || _a === void 0 ? void 0 : _a.data));
}
function getNestedPieChartAliasNames(series) {
    return series.pie.map(({ name }) => name);
}
function pieTooltipLabelFormatter(percentValue) {
    const percentageString = percentValue.toFixed(2);
    const percent = parseFloat(percentageString);
    const needSlice = percentageString.length > 5;
    return `${needSlice ? parseFloat(percentageString.substr(0, 4)) : String(percent)}%`;
}
function hasOuterDataLabel(options, series) {
    var _a, _b, _c;
    return !!series.pie && ((_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.dataLabels) === null || _c === void 0 ? void 0 : _c.anchor) === 'outer';
}
function hasOuterPieSeriesName(options, series) {
    var _a, _b, _c, _d;
    return (!!series.pie &&
        ((_d = (_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.dataLabels) === null || _c === void 0 ? void 0 : _c.pieSeriesName) === null || _d === void 0 ? void 0 : _d.anchor) === 'outer');
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/plot.js":
/*!***************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/plot.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isExistPlotId": () => (/* binding */ isExistPlotId)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");

function isExistPlotId(plots, data) {
    return plots.some(({ id: bandId }) => !(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(bandId) && !(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(data.id) && bandId === data.id);
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/range.js":
/*!****************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/range.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isRangeValue": () => (/* binding */ isRangeValue),
/* harmony export */   "isRangeData": () => (/* binding */ isRangeData),
/* harmony export */   "isZooming": () => (/* binding */ isZooming),
/* harmony export */   "getDataInRange": () => (/* binding */ getDataInRange)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");

function isRangeValue(value) {
    return Array.isArray(value) && value.length === 2;
}
function isRangeData(data) {
    return Array.isArray(data) && isRangeValue((0,_utils__WEBPACK_IMPORTED_MODULE_0__.getFirstValidValue)(data));
}
function isZooming(categories, zoomRange) {
    return !!(zoomRange && (zoomRange[0] !== 0 || zoomRange[1] !== categories.length - 1));
}
function getDataInRange(data, range) {
    if (!range) {
        return data;
    }
    return data.slice(range[0], range[1] + 1);
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/responders.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/responders.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isSameSeriesResponder": () => (/* binding */ isSameSeriesResponder),
/* harmony export */   "getNearestResponder": () => (/* binding */ getNearestResponder),
/* harmony export */   "makeRectResponderModel": () => (/* binding */ makeRectResponderModel),
/* harmony export */   "makeRectResponderModelForCoordinateType": () => (/* binding */ makeRectResponderModelForCoordinateType),
/* harmony export */   "makeTooltipCircleMap": () => (/* binding */ makeTooltipCircleMap),
/* harmony export */   "getDeepestNode": () => (/* binding */ getDeepestNode),
/* harmony export */   "isClickSameNameResponder": () => (/* binding */ isClickSameNameResponder),
/* harmony export */   "isClickSameCircleResponder": () => (/* binding */ isClickSameCircleResponder),
/* harmony export */   "isClickSameDataResponder": () => (/* binding */ isClickSameDataResponder),
/* harmony export */   "isClickSameLabelResponder": () => (/* binding */ isClickSameLabelResponder),
/* harmony export */   "isClickSameGroupedRectResponder": () => (/* binding */ isClickSameGroupedRectResponder),
/* harmony export */   "isClickSameBoxPlotDataResponder": () => (/* binding */ isClickSameBoxPlotDataResponder),
/* harmony export */   "makeGroupedSectorResponderModel": () => (/* binding */ makeGroupedSectorResponderModel)
/* harmony export */ });
/* harmony import */ var _calculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _sector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sector */ "./node_modules/@toast-ui/chart/dist/esm/helpers/sector.js");



// eslint-disable-next-line complexity
function isSameSeriesResponder({ models, comparisonModel, name, eventDetectType, }) {
    switch (name) {
        case 'heatmap':
            return isClickSameNameResponder(models, comparisonModel);
        case 'bullet':
            return eventDetectType === 'grouped'
                ? isClickSameGroupedRectResponder(models, comparisonModel)
                : isClickSameNameResponder(models, comparisonModel);
        case 'radar':
        case 'bubble':
        case 'scatter':
        case 'area':
        case 'line':
            return isClickSameCircleResponder(models, comparisonModel);
        case 'pie':
            return isClickSameDataResponder(models, comparisonModel);
        case 'column':
        case 'bar':
            return eventDetectType === 'grouped'
                ? isClickSameGroupedRectResponder(models, comparisonModel)
                : isClickSameDataResponder(models, comparisonModel);
        case 'boxPlot':
            return eventDetectType === 'grouped'
                ? isClickSameDataResponder(models, comparisonModel)
                : isClickSameBoxPlotDataResponder(models, comparisonModel);
        case 'treemap':
            return isClickSameLabelResponder(models, comparisonModel);
        case 'gauge':
            return isClickSameNameResponder(models, comparisonModel);
        default:
            return false;
    }
}
function getNearestResponder(responders, mousePosition, rect) {
    let minDistance = Infinity;
    let result = [];
    responders.forEach((responder) => {
        const { x, y, radius } = responder;
        const responderPoint = { x: x + rect.x, y: y + rect.y };
        const distance = (0,_calculator__WEBPACK_IMPORTED_MODULE_0__.getDistance)(responderPoint, mousePosition);
        if (minDistance > distance) {
            minDistance = distance;
            result = [responder];
        }
        else if (minDistance === distance) {
            if (result.length && result[0].radius > radius) {
                result = [responder];
            }
            else {
                result.push(responder);
            }
        }
    });
    return result;
}
function makeRectResponderModel(rect, axis, categories, vertical = true) {
    const { pointOnColumn, tickDistance, rectResponderCount } = axis;
    const { width, height } = rect;
    const halfDetectAreaIndex = pointOnColumn ? [] : [0, rectResponderCount - 1];
    const halfSize = tickDistance / 2;
    return (0,_utils__WEBPACK_IMPORTED_MODULE_1__.range)(0, rectResponderCount).map((index) => {
        const half = halfDetectAreaIndex.includes(index);
        const size = half ? halfSize : tickDistance;
        let startPos = 0;
        if (index !== 0) {
            startPos += pointOnColumn ? tickDistance * index : halfSize + tickDistance * (index - 1);
        }
        return {
            type: 'rect',
            y: vertical ? 0 : startPos,
            height: vertical ? height : size,
            x: vertical ? startPos : 0,
            width: vertical ? size : width,
            index,
            label: categories[index],
        };
    });
}
function makeRectResponderModelForCoordinateType(responderInfo, rect) {
    const { width, height } = rect;
    let startPos = 0;
    return responderInfo
        .sort((a, b) => a.x - b.x)
        .reduce((acc, model, index) => {
        const { x, label } = model;
        const next = responderInfo[index + 1];
        const endPos = next ? (next.x + x) / 2 : width;
        const rectResponderModel = {
            type: 'rect',
            x: startPos,
            y: 0,
            width: endPos - startPos,
            height,
            label,
            index,
        };
        startPos = endPos;
        return [...acc, rectResponderModel];
    }, []);
}
function makeTooltipCircleMap(seriesCircleModel, tooltipDataArr) {
    const dataMap = tooltipDataArr.reduce((acc, cur) => {
        const { index, seriesIndex } = cur;
        if (!acc[seriesIndex]) {
            acc[seriesIndex] = [];
        }
        acc[seriesIndex][index] = cur;
        return acc;
    }, []);
    return seriesCircleModel.reduce((acc, model) => {
        const { seriesIndex, index } = model;
        const data = dataMap[seriesIndex][index];
        const { category } = data;
        if (!category) {
            return acc;
        }
        if (!acc[category]) {
            acc[category] = [];
        }
        acc[category].push(Object.assign(Object.assign({}, model), { data }));
        return acc;
    }, {});
}
function getDeepestNode(responders) {
    return responders.reduce((acc, responder) => {
        if (!acc.length || responder.depth > acc[0].depth) {
            return [responder];
        }
        return acc;
    }, []);
}
function isClickSameNameResponder(responders, selectedSeries) {
    var _a;
    return (responders.length && ((_a = selectedSeries) === null || _a === void 0 ? void 0 : _a.length) && responders[0].name === selectedSeries[0].name);
}
function isClickSameCircleResponder(responders, selectedSeries) {
    var _a;
    let same = false;
    if (responders.length && ((_a = selectedSeries) === null || _a === void 0 ? void 0 : _a.length) && responders.length === selectedSeries.length) {
        same = responders.reduce((acc, cur, idx) => {
            return (acc &&
                cur.seriesIndex === selectedSeries[idx].seriesIndex &&
                cur.index === selectedSeries[idx].index);
        }, true);
    }
    return same;
}
function isClickSameDataResponder(responders, selectedSeries) {
    var _a;
    let same = false;
    if (responders.length && ((_a = selectedSeries) === null || _a === void 0 ? void 0 : _a.length) && responders.length === selectedSeries.length) {
        same = responders.reduce((acc, cur, idx) => {
            var _a, _b, _c, _d;
            return (acc &&
                ((_a = cur.data) === null || _a === void 0 ? void 0 : _a.label) === ((_b = selectedSeries[idx].data) === null || _b === void 0 ? void 0 : _b.label) &&
                ((_c = cur.data) === null || _c === void 0 ? void 0 : _c.category) === ((_d = selectedSeries[idx].data) === null || _d === void 0 ? void 0 : _d.category));
        }, true);
    }
    return same;
}
function isClickSameLabelResponder(responders, selectedSeries) {
    var _a;
    return (responders.length && ((_a = selectedSeries) === null || _a === void 0 ? void 0 : _a.length) && responders[0].label === selectedSeries[0].label);
}
function isClickSameGroupedRectResponder(responders, selectedSeries) {
    var _a;
    return (responders.length && ((_a = selectedSeries) === null || _a === void 0 ? void 0 : _a.length) && responders[0].index === selectedSeries[0].index);
}
function isClickSameBoxPlotDataResponder(responders, selectedSeries) {
    var _a, _b, _c, _d, _e;
    let same = false;
    if (responders.length && ((_a = selectedSeries) === null || _a === void 0 ? void 0 : _a.length)) {
        const { type, data } = responders[0];
        same =
            type === selectedSeries[0].type &&
                ((_b = data) === null || _b === void 0 ? void 0 : _b.label) === ((_c = selectedSeries[0].data) === null || _c === void 0 ? void 0 : _c.label) &&
                ((_d = data) === null || _d === void 0 ? void 0 : _d.category) === ((_e = selectedSeries[0].data) === null || _e === void 0 ? void 0 : _e.category);
    }
    return same;
}
function makeGroupedSectorResponderModel(radiusRanges, renderOptions, categories) {
    const { centerX, centerY, angleRange: { start, end }, clockwise, } = renderOptions;
    return (0,_sector__WEBPACK_IMPORTED_MODULE_2__.getRadiusRanges)(radiusRanges, 0).map((radius, index) => ({
        type: 'sector',
        x: centerX,
        y: centerY,
        degree: { start, end },
        radius,
        name: categories[index],
        clockwise,
        index,
    }));
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/sector.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/sector.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEGREE_180": () => (/* binding */ DEGREE_180),
/* harmony export */   "DEGREE_NEGATIVE_180": () => (/* binding */ DEGREE_NEGATIVE_180),
/* harmony export */   "DEGREE_360": () => (/* binding */ DEGREE_360),
/* harmony export */   "DEGREE_0": () => (/* binding */ DEGREE_0),
/* harmony export */   "DEGREE_NEGATIVE_90": () => (/* binding */ DEGREE_NEGATIVE_90),
/* harmony export */   "DEGREE_90": () => (/* binding */ DEGREE_90),
/* harmony export */   "makeAnchorPositionParam": () => (/* binding */ makeAnchorPositionParam),
/* harmony export */   "calculateDegreeToRadian": () => (/* binding */ calculateDegreeToRadian),
/* harmony export */   "calculateRadianToDegree": () => (/* binding */ calculateRadianToDegree),
/* harmony export */   "getRadialAnchorPosition": () => (/* binding */ getRadialAnchorPosition),
/* harmony export */   "getRadialPosition": () => (/* binding */ getRadialPosition),
/* harmony export */   "withinRadian": () => (/* binding */ withinRadian),
/* harmony export */   "initSectorOptions": () => (/* binding */ initSectorOptions),
/* harmony export */   "getDefaultRadius": () => (/* binding */ getDefaultRadius),
/* harmony export */   "getRadialLabelAlign": () => (/* binding */ getRadialLabelAlign),
/* harmony export */   "getRadiusRanges": () => (/* binding */ getRadiusRanges),
/* harmony export */   "calculateValidAngle": () => (/* binding */ calculateValidAngle)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");

const DEGREE_180 = 180;
const DEGREE_NEGATIVE_180 = -180;
const DEGREE_360 = 360;
const DEGREE_0 = 0;
const DEGREE_NEGATIVE_90 = -90;
const DEGREE_90 = 90;
const MINIMUM_RADIUS = 10;
function makeAnchorPositionParam(anchor, model) {
    return Object.assign({ anchor }, (0,_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(model, 'x', 'y', 'radius', 'degree', 'drawingStartAngle'));
}
function calculateDegreeToRadian(degree, drawingStartAngle = DEGREE_NEGATIVE_90) {
    let result = 0;
    if (degree % DEGREE_360 === 0) {
        result = (Math.PI / DEGREE_180) * drawingStartAngle;
    }
    else if (degree >= 0) {
        result = (Math.PI / DEGREE_180) * (degree + drawingStartAngle);
    }
    return result;
}
function calculateRadianToDegree(radian, drawingStartAngle = DEGREE_NEGATIVE_90) {
    return ((radian * DEGREE_180) / Math.PI - drawingStartAngle + DEGREE_360) % DEGREE_360;
}
function getRadialAnchorPosition(param) {
    const { anchor, x, y, radius: { inner, outer }, degree: { start, end }, drawingStartAngle = DEGREE_NEGATIVE_90, } = param;
    const halfDegree = start + (end - start) / 2;
    const radian = calculateDegreeToRadian(halfDegree, drawingStartAngle);
    const r = anchor === 'outer' ? outer : (outer + inner) / 2;
    return getRadialPosition(x, y, r, radian);
}
function getRadialPosition(x, y, r, radian) {
    return { x: Math.round(x + r * Math.cos(radian)), y: Math.round(y + r * Math.sin(radian)) };
}
function withinRadian(clockwise, startDegree, endDegree, currentDegree) {
    return clockwise
        ? startDegree <= currentDegree && endDegree >= currentDegree
        : startDegree >= currentDegree && endDegree <= currentDegree;
}
function initSectorOptions(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const clockwise = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.clockwise, (_b !== null && _b !== void 0 ? _b : true));
    return {
        clockwise,
        startAngle: (_e = (_d = (_c = options) === null || _c === void 0 ? void 0 : _c.angleRange) === null || _d === void 0 ? void 0 : _d.start, (_e !== null && _e !== void 0 ? _e : (clockwise ? DEGREE_0 : DEGREE_360))),
        endAngle: (_h = (_g = (_f = options) === null || _f === void 0 ? void 0 : _f.angleRange) === null || _g === void 0 ? void 0 : _g.end, (_h !== null && _h !== void 0 ? _h : (clockwise ? DEGREE_360 : DEGREE_0))),
    };
}
function getDefaultRadius({ width, height }, isSemiCircular = false, maxLabelWidth = 0, maxLabelHeight = 0) {
    let result;
    if (isSemiCircular) {
        result = Math.min(width / 2, height) - maxLabelHeight;
    }
    else if (width > height) {
        result = height / 2 - maxLabelHeight;
    }
    else {
        result = width / 2 - maxLabelWidth;
    }
    return Math.max(result, MINIMUM_RADIUS);
}
function getRadian(startAngle, endAngle, drawingStartAngle, needCalculateByHalf) {
    const degree = needCalculateByHalf ? (endAngle + startAngle) / 2 : startAngle;
    return calculateDegreeToRadian(degree, drawingStartAngle);
}
function getRadialLabelAlign(model, anchor, needCalculateByHalf = true) {
    const { totalAngle = DEGREE_360, degree: { start, end }, drawingStartAngle = DEGREE_NEGATIVE_90, } = model;
    let textAlign = 'center';
    if (anchor !== 'outer') {
        return textAlign;
    }
    const radian0 = calculateDegreeToRadian(0, drawingStartAngle);
    const halfRadian = calculateDegreeToRadian(totalAngle / 2, drawingStartAngle);
    const radian = getRadian(start, end, drawingStartAngle, needCalculateByHalf);
    if (drawingStartAngle >= DEGREE_NEGATIVE_90 && drawingStartAngle < DEGREE_90) {
        if (radian0 < radian && halfRadian > radian) {
            textAlign = 'left';
        }
        else if (halfRadian < radian) {
            textAlign = 'right';
        }
    }
    else if (radian0 < radian && halfRadian > radian) {
        textAlign = 'right';
    }
    else if (halfRadian < radian) {
        textAlign = 'left';
    }
    return textAlign;
}
function getRadiusRanges(radiusRanges, padding) {
    return radiusRanges.reduce((acc, cur, index) => {
        if (index) {
            acc.push({
                inner: cur + padding,
                outer: radiusRanges[index - 1] - padding,
            });
        }
        if (index === radiusRanges.length - 1) {
            acc.push({
                inner: padding,
                outer: cur - padding,
            });
        }
        return acc;
    }, []);
}
// Recalculate to an angle between 0 and 360 degrees.
function calculateValidAngle(angle) {
    if (angle < DEGREE_0) {
        return DEGREE_360 + (angle % DEGREE_360);
    }
    if (angle > DEGREE_360) {
        return angle % DEGREE_360;
    }
    return angle;
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/squarifier.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/squarifier.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "squarify": () => (/* binding */ squarify)
/* harmony export */ });
/* harmony import */ var _calculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _arrayUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./arrayUtil */ "./node_modules/@toast-ui/chart/dist/esm/helpers/arrayUtil.js");


function calculateScale(values, width, height) {
    return (width * height) / (0,_calculator__WEBPACK_IMPORTED_MODULE_0__.sum)(values);
}
function isVerticalStack({ height, width }) {
    return height < width;
}
function selectBaseSize(baseBound) {
    return isVerticalStack(baseBound) ? baseBound.height : baseBound.width;
}
function makeBaseData(seriesItems, baseBound) {
    const { width, height } = baseBound;
    const scale = calculateScale((0,_arrayUtil__WEBPACK_IMPORTED_MODULE_1__.pluck)(seriesItems, 'data'), width, height);
    return seriesItems
        .map((seriesItem) => ({
        id: seriesItem.id,
        weight: seriesItem.data * scale,
    }))
        .sort((a, b) => b.weight - a.weight);
}
/**
 * Calculate worst aspect ratio.
 * Referred function worst() in https://www.win.tue.nl/~vanwijk/stm.pdf
 */
function worst(total, min, max, baseSize) {
    const sumSquare = total * total;
    const sizeSquare = baseSize * baseSize;
    return Math.max((sizeSquare * max) / sumSquare, sumSquare / (sizeSquare * min));
}
function changedStackDirection(total, weights, baseSize, newWeight) {
    const minWeight = Math.min(...weights);
    const maxWeight = Math.max(...weights);
    const beforeWorst = worst(total, minWeight, maxWeight, baseSize);
    const newWorst = worst(total + newWeight, Math.min(minWeight, newWeight), Math.max(maxWeight, newWeight), baseSize);
    return newWorst >= beforeWorst;
}
function calculateFixedSize(baseSize, total, rows) {
    if (!total) {
        const weights = (0,_arrayUtil__WEBPACK_IMPORTED_MODULE_1__.pluck)(rows, 'weight');
        total = (0,_calculator__WEBPACK_IMPORTED_MODULE_0__.sum)(weights);
    }
    return total / baseSize;
}
function addBounds(startPosition, rows, fixedSize, callback) {
    rows.reduce((storedPosition, rowDatum) => {
        const dynamicSize = rowDatum.weight / fixedSize;
        callback(dynamicSize, storedPosition, rowDatum.id);
        return storedPosition + dynamicSize;
    }, startPosition);
}
function addBound(boundMap, id, rect) {
    boundMap[id] = rect;
}
function addBoundsForVerticalStack(boundMap, rows, baseBound, baseSize, total) {
    const fixedWidth = calculateFixedSize(baseSize, total, rows);
    addBounds(baseBound.y, rows, fixedWidth, (dynamicHeight, storedTop, id) => {
        addBound(boundMap, id, {
            x: baseBound.x,
            y: storedTop,
            width: fixedWidth,
            height: dynamicHeight,
        });
    });
    baseBound.x += fixedWidth;
    baseBound.width -= fixedWidth;
}
function addBoundsForHorizontalStack(boundMap, rows, baseBound, baseSize, total) {
    const fixedHeight = calculateFixedSize(baseSize, total, rows);
    addBounds(baseBound.x, rows, fixedHeight, (dynamicWidth, storedLeft, id) => {
        addBound(boundMap, id, {
            x: storedLeft,
            y: baseBound.y,
            width: dynamicWidth,
            height: fixedHeight,
        });
    });
    baseBound.y += fixedHeight;
    baseBound.height -= fixedHeight;
}
function getAddingBoundsFunction(baseBound) {
    if (isVerticalStack(baseBound)) {
        return addBoundsForVerticalStack;
    }
    return addBoundsForHorizontalStack;
}
function squarify(layout, seriesItems) {
    const baseBound = layout;
    const baseData = makeBaseData(seriesItems, baseBound);
    let row = [];
    let baseSize, addBoundsFunc;
    const boundMap = {};
    baseData.forEach((datum) => {
        const weights = (0,_arrayUtil__WEBPACK_IMPORTED_MODULE_1__.pluck)(row, 'weight');
        const totalWeight = (0,_calculator__WEBPACK_IMPORTED_MODULE_0__.sum)(weights);
        if (row.length && changedStackDirection(totalWeight, weights, baseSize, datum.weight)) {
            addBoundsFunc(boundMap, row, baseBound, baseSize, totalWeight);
            row = [];
        }
        if (!row.length) {
            baseSize = selectBaseSize(baseBound);
            addBoundsFunc = getAddingBoundsFunction(baseBound);
        }
        row.push(datum);
    });
    if (row.length) {
        addBoundsFunc(boundMap, row, baseBound, baseSize);
    }
    return boundMap;
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js":
/*!****************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/style.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeStyleObj": () => (/* binding */ makeStyleObj),
/* harmony export */   "getTranslateString": () => (/* binding */ getTranslateString),
/* harmony export */   "getTitleFontString": () => (/* binding */ getTitleFontString),
/* harmony export */   "getFontStyleString": () => (/* binding */ getFontStyleString),
/* harmony export */   "getFont": () => (/* binding */ getFont),
/* harmony export */   "setLineDash": () => (/* binding */ setLineDash),
/* harmony export */   "getBoxTypeSeriesPadding": () => (/* binding */ getBoxTypeSeriesPadding),
/* harmony export */   "fillStyle": () => (/* binding */ fillStyle),
/* harmony export */   "strokeWithOptions": () => (/* binding */ strokeWithOptions)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");


function makeStyleObj(style, styleSet) {
    return style.reduce((acc, curValue) => {
        if ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(curValue)) {
            return Object.assign(Object.assign({}, acc), styleSet[curValue]);
        }
        return Object.assign(Object.assign({}, acc), curValue);
    }, {});
}
function getTranslateString(x, y) {
    return `translate(${x}px,${y}px)`;
}
function getTitleFontString(fontTheme) {
    const { fontFamily, fontSize, fontWeight } = fontTheme;
    return `${fontWeight} ${fontSize}px ${fontFamily}`;
}
function getFontStyleString(theme) {
    const { color, fontSize, fontFamily, fontWeight } = theme;
    return `font-weight: ${fontWeight}; font-family: ${fontFamily}; font-size: ${fontSize}px; color: ${color};`;
}
function getFont(theme) {
    return getTitleFontString((0,_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(theme, 'fontFamily', 'fontWeight', 'fontSize'));
}
function setLineDash(ctx, dashSegments) {
    if (ctx.setLineDash) {
        ctx.setLineDash(dashSegments);
    }
}
function getBoxTypeSeriesPadding(tickDistance) {
    return Math.floor(tickDistance * 0.15);
}
function fillStyle(ctx, fillOption) {
    ctx.fillStyle = fillOption;
    ctx.fill();
}
function strokeWithOptions(ctx, style) {
    const { lineWidth, strokeStyle } = style;
    if (strokeStyle) {
        ctx.strokeStyle = strokeStyle;
    }
    if (lineWidth) {
        ctx.lineWidth = lineWidth;
    }
    if (ctx.lineWidth && (0,_color__WEBPACK_IMPORTED_MODULE_1__.getAlpha)(String(ctx.strokeStyle))) {
        ctx.stroke();
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/theme.js":
/*!****************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/theme.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_LINE_SERIES_WIDTH": () => (/* binding */ DEFAULT_LINE_SERIES_WIDTH),
/* harmony export */   "DEFAULT_LINE_SERIES_DOT_RADIUS": () => (/* binding */ DEFAULT_LINE_SERIES_DOT_RADIUS),
/* harmony export */   "radarDefault": () => (/* binding */ radarDefault),
/* harmony export */   "boxDefault": () => (/* binding */ boxDefault),
/* harmony export */   "DEFAULT_BULLET_RANGE_OPACITY": () => (/* binding */ DEFAULT_BULLET_RANGE_OPACITY),
/* harmony export */   "defaultSeriesTheme": () => (/* binding */ defaultSeriesTheme),
/* harmony export */   "makeAxisTitleTheme": () => (/* binding */ makeAxisTitleTheme),
/* harmony export */   "makeDefaultTheme": () => (/* binding */ makeDefaultTheme),
/* harmony export */   "getDefaultTheme": () => (/* binding */ getDefaultTheme)
/* harmony export */ });
/* harmony import */ var _pieSeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pieSeries */ "./node_modules/@toast-ui/chart/dist/esm/helpers/pieSeries.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");


const DEFAULT_LINE_SERIES_WIDTH = 2;
const DEFAULT_LINE_SERIES_DOT_RADIUS = 3;
const DEFAULT_AREA_OPACITY = 0.3;
const DEFAULT_AREA_SELECTED_SERIES_OPACITY = DEFAULT_AREA_OPACITY;
const DEFAULT_AREA_UNSELECTED_SERIES_OPACITY = 0.06;
const radarDefault = {
    LINE_WIDTH: 2,
    DOT_RADIUS: 3,
    HOVER_DOT_RADIUS: 4,
    SELECTED_SERIES_OPACITY: 0.3,
    UNSELECTED_SERIES_OPACITY: 0.05,
};
const boxDefault = {
    HOVER_THICKNESS: 4,
    BOX_HOVER: {
        shadowColor: 'rgba(0, 0, 0, 0.3)',
        shadowOffsetX: 2,
        shadowOffsetY: 2,
        shadowBlur: 6,
    },
};
const boxplotDefault = {
    OUTLIER_RADIUS: 4,
    OUTLIER_BORDER_WIDTH: 2,
    LINE_TYPE: {
        whisker: { lineWidth: 1 },
        maximum: { lineWidth: 1 },
        minimum: { lineWidth: 1 },
        median: { lineWidth: 1, color: '#ffffff' },
    },
};
const DEFAULT_BULLET_RANGE_OPACITY = [0.5, 0.3, 0.1];
const DEFAULT_PIE_LINE_WIDTH = 3;
function makeDefaultDataLabelsTheme(globalFontFamily = 'Arial') {
    return {
        fontFamily: globalFontFamily,
        fontSize: 11,
        fontWeight: 400,
        color: '#333333',
        useSeriesColor: false,
    };
}
const DEFAULT_BUBBLE_ARROW = {
    width: 8,
    height: 6,
};
const defaultSeriesTheme = {
    colors: [
        '#00a9ff',
        '#ffb840',
        '#ff5a46',
        '#00bd9f',
        '#785fff',
        '#f28b8c',
        '#989486',
        '#516f7d',
        '#28e6eb',
        '#28695f',
        '#96c85a',
        '#45ba3f',
        '#295ba0',
        '#2a4175',
        '#289399',
        '#66c8d3',
        '#617178',
        '#8a9a9a',
        '#bebebe',
        '#374b5a',
        '#64eba0',
        '#ffe155',
        '#ff9141',
        '#af4beb',
        '#ff73fa',
        '#ff55b2',
        '#2869f5',
        '#3296ff',
        '#8cc3ff',
        '#2828b9',
        '#fa8787',
        '#e13782',
        '#7d5aaa',
        '#643c91',
        '#d25f5f',
        '#fabe6e',
        '#c3a9eb',
        '#b9c8f5',
        '#73a0cd',
        '#0f5a8c',
    ],
    startColor: '#ffe98a',
    endColor: '#d74177',
    lineWidth: DEFAULT_LINE_SERIES_WIDTH,
    dashSegments: [],
    borderWidth: 0,
    borderColor: '#ffffff',
    select: {
        dot: {
            radius: DEFAULT_LINE_SERIES_DOT_RADIUS,
            borderWidth: DEFAULT_LINE_SERIES_DOT_RADIUS + 2,
        },
        areaOpacity: DEFAULT_AREA_SELECTED_SERIES_OPACITY,
        restSeries: {
            areaOpacity: DEFAULT_AREA_UNSELECTED_SERIES_OPACITY,
        },
    },
    hover: {
        dot: {
            radius: DEFAULT_LINE_SERIES_DOT_RADIUS,
            borderWidth: DEFAULT_LINE_SERIES_DOT_RADIUS + 2,
        },
    },
    dot: {
        radius: DEFAULT_LINE_SERIES_DOT_RADIUS,
    },
    areaOpacity: DEFAULT_AREA_OPACITY,
};
function makeAxisTitleTheme(globalFontFamily = 'Arial') {
    return {
        fontSize: 11,
        fontFamily: globalFontFamily,
        fontWeight: 700,
        color: '#bbbbbb',
    };
}
function makeCommonTextTheme(globalFontFamily = 'Arial') {
    return { fontSize: 11, fontFamily: globalFontFamily, fontWeight: 'normal', color: '#333333' };
}
function makeDefaultTheme(series, globalFontFamily = 'Arial') {
    var _a, _b;
    const axisTitleTheme = makeAxisTitleTheme(globalFontFamily);
    const commonTextTheme = makeCommonTextTheme(globalFontFamily);
    const hasRadarSeries = !!((_a = series) === null || _a === void 0 ? void 0 : _a.radar);
    const hasGaugeSeries = !!((_b = series) === null || _b === void 0 ? void 0 : _b.gauge);
    return {
        chart: {
            fontFamily: globalFontFamily,
            backgroundColor: '#ffffff',
        },
        noData: {
            fontSize: 18,
            fontFamily: globalFontFamily,
            fontWeight: 'normal',
            color: '#333333',
        },
        title: {
            fontSize: 18,
            fontFamily: globalFontFamily,
            fontWeight: 100,
            color: '#333333',
        },
        yAxis: {
            title: Object.assign({}, axisTitleTheme),
            label: Object.assign({}, commonTextTheme),
            width: 1,
            color: '#333333',
        },
        xAxis: {
            title: Object.assign({}, axisTitleTheme),
            label: Object.assign({}, commonTextTheme),
            width: 1,
            color: '#333333',
        },
        verticalAxis: {
            label: Object.assign(Object.assign({}, commonTextTheme), { textBubble: {
                    visible: hasRadarSeries,
                    backgroundColor: hasRadarSeries ? '#f3f3f3' : 'rgba(0, 0, 0, 0)',
                    borderRadius: 7,
                    paddingX: 7,
                    paddingY: 2,
                    borderColor: 'rgba(0, 0, 0, 0)',
                    borderWidth: 1,
                } }),
        },
        circularAxis: {
            title: Object.assign({}, axisTitleTheme),
            label: Object.assign({}, commonTextTheme),
            lineWidth: 1,
            strokeStyle: hasGaugeSeries ? 'rgba(0, 0, 0, 0.5)' : 'rgba(0, 0, 0, 0.05)',
            dotColor: 'rgba(0, 0, 0, 0.5)',
            tick: {
                lineWidth: 1,
                strokeStyle: 'rgba(0, 0, 0, 0.5)',
            },
        },
        legend: {
            label: {
                color: '#333333',
                fontSize: 11,
                fontWeight: 'normal',
                fontFamily: globalFontFamily,
            },
        },
        tooltip: {
            background: 'rgba(85, 85, 85, 0.95)',
            borderColor: 'rgba(255, 255, 255, 0)',
            borderWidth: 0,
            borderRadius: 3,
            borderStyle: 'solid',
            body: {
                fontSize: 12,
                fontFamily: `${globalFontFamily}, sans-serif`,
                fontWeight: 'normal',
                color: '#ffffff',
            },
            header: {
                fontSize: 13,
                fontFamily: `${globalFontFamily}, sans-serif`,
                fontWeight: 'bold',
                color: '#ffffff',
            },
        },
        plot: {
            lineColor: 'rgba(0, 0, 0, 0.05)',
            backgroundColor: 'rgba(255, 255, 255, 0)',
        },
        exportMenu: {
            button: Object.assign(Object.assign({}, makeBorderTheme(5, '#f4f4f4')), { backgroundColor: '#f4f4f4', xIcon: {
                    color: '#555555',
                    lineWidth: 2,
                }, dotIcon: {
                    color: '#555555',
                    width: 2,
                    height: 2,
                    gap: 2,
                } }),
            panel: Object.assign(Object.assign({}, makeBorderTheme(0, '#bab9ba')), { header: Object.assign(Object.assign({}, commonTextTheme), { backgroundColor: '#f4f4f4' }), body: Object.assign(Object.assign({}, commonTextTheme), { backgroundColor: '#ffffff' }) }),
        },
    };
}
function makeBorderTheme(borderRadius, borderColor, borderWidth = 1) {
    return { borderWidth, borderRadius, borderColor };
}
function makeDefaultTextBubbleTheme(visible = false, borderRadius = 7, paddingX = 5, paddingY = 1, backgroundColor = '#ffffff') {
    return {
        visible,
        paddingX,
        paddingY,
        borderRadius,
        backgroundColor,
        shadowColor: 'rgba(0, 0, 0, 0.3)',
        shadowOffsetY: 2,
        shadowBlur: 4,
    };
}
function getLineTypeSeriesTheme(globalFontFamily) {
    const defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
    return {
        lineWidth: defaultSeriesTheme.lineWidth,
        dashSegments: defaultSeriesTheme.dashSegments,
        select: { dot: defaultSeriesTheme.select.dot },
        hover: { dot: defaultSeriesTheme.hover.dot },
        dot: defaultSeriesTheme.dot,
        dataLabels: Object.assign(Object.assign({}, defaultDataLabelTheme), { textBubble: Object.assign(Object.assign({}, makeDefaultTextBubbleTheme()), { arrow: Object.assign({ visible: false, direction: 'bottom' }, DEFAULT_BUBBLE_ARROW) }) }),
    };
}
function getTreemapHeatmapSeriesTheme(globalFontFamily) {
    const defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
    return {
        startColor: defaultSeriesTheme.startColor,
        endColor: defaultSeriesTheme.endColor,
        borderWidth: 0,
        borderColor: '#ffffff',
        hover: {
            borderWidth: boxDefault.HOVER_THICKNESS,
            borderColor: '#ffffff',
        },
        select: {
            borderWidth: boxDefault.HOVER_THICKNESS,
            borderColor: '#ffffff',
        },
        dataLabels: Object.assign(Object.assign({}, defaultDataLabelTheme), { color: '#ffffff', textBubble: Object.assign({}, makeDefaultTextBubbleTheme(false, 1, 5, 1, 'rgba(255, 255, 255, 0.5)')) }),
    };
}
function getBarColumnSeriesTheme(globalFontFamily) {
    const defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
    return {
        areaOpacity: 1,
        hover: Object.assign(Object.assign({}, boxDefault.BOX_HOVER), { borderWidth: boxDefault.HOVER_THICKNESS, borderColor: '#ffffff', groupedRect: {
                color: '#000000',
                opacity: 0.05,
            } }),
        select: Object.assign(Object.assign({}, boxDefault.BOX_HOVER), { borderWidth: boxDefault.HOVER_THICKNESS, borderColor: '#ffffff', groupedRect: {
                color: '#000000',
                opacity: 0.2,
            }, restSeries: {
                areaOpacity: 0.2,
            }, areaOpacity: 1 }),
        connector: {
            color: 'rgba(51, 85, 139, 0.3)',
            lineWidth: 1,
            dashSegments: [],
        },
        dataLabels: Object.assign(Object.assign({}, defaultDataLabelTheme), { textBubble: Object.assign(Object.assign({}, makeDefaultTextBubbleTheme(false, 1, 4, 3)), { arrow: Object.assign({ visible: false }, DEFAULT_BUBBLE_ARROW) }), stackTotal: Object.assign(Object.assign({}, defaultDataLabelTheme), { textBubble: Object.assign(Object.assign({}, makeDefaultTextBubbleTheme(true, 1, 4, 3)), { arrow: Object.assign({ visible: true }, DEFAULT_BUBBLE_ARROW) }) }) }),
    };
}
const transparentColor = 'rgba(255, 255, 255, 0)';
const defaultThemeMakers = {
    line: (globalFontFamily) => (Object.assign({}, getLineTypeSeriesTheme(globalFontFamily))),
    area: (globalFontFamily) => {
        const lineTypeSeriesTheme = getLineTypeSeriesTheme(globalFontFamily);
        return Object.assign(Object.assign({}, lineTypeSeriesTheme), { select: Object.assign(Object.assign({}, lineTypeSeriesTheme.select), { areaOpacity: DEFAULT_AREA_SELECTED_SERIES_OPACITY, restSeries: defaultSeriesTheme.select.restSeries }), areaOpacity: DEFAULT_AREA_OPACITY });
    },
    treemap: (globalFontFamily) => getTreemapHeatmapSeriesTheme(globalFontFamily),
    heatmap: (globalFontFamily) => getTreemapHeatmapSeriesTheme(globalFontFamily),
    scatter: () => ({
        size: 12,
        borderWidth: 1.5,
        fillColor: transparentColor,
        select: {
            fillColor: 'rgba(255, 255, 255, 1)',
            borderWidth: 2.5,
            size: 12,
        },
        hover: {
            fillColor: 'rgba(255, 255, 255, 1)',
            borderWidth: 2.5,
            size: 12,
        },
    }),
    bubble: () => ({
        borderWidth: 0,
        borderColor: transparentColor,
        select: {},
        hover: {
            shadowColor: 'rgba(0, 0, 0, 0.3)',
            shadowBlur: 2,
            shadowOffsetY: 2,
            lineWidth: 2,
        },
    }),
    radar: () => ({
        areaOpacity: radarDefault.SELECTED_SERIES_OPACITY,
        hover: {
            dot: {
                radius: radarDefault.HOVER_DOT_RADIUS,
                borderWidth: radarDefault.HOVER_DOT_RADIUS + 1,
            },
        },
        select: {
            dot: {
                radius: radarDefault.HOVER_DOT_RADIUS,
                borderWidth: radarDefault.HOVER_DOT_RADIUS + 1,
            },
            restSeries: {
                areaOpacity: radarDefault.UNSELECTED_SERIES_OPACITY,
            },
            areaOpacity: radarDefault.SELECTED_SERIES_OPACITY,
        },
        dot: {
            radius: radarDefault.DOT_RADIUS,
        },
    }),
    bar: (globalFontFamily) => (Object.assign({}, getBarColumnSeriesTheme(globalFontFamily))),
    column: (globalFontFamily) => (Object.assign({}, getBarColumnSeriesTheme(globalFontFamily))),
    bullet: (globalFontFamily) => {
        const defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
        return {
            areaOpacity: 1,
            barWidthRatios: {
                rangeRatio: 1,
                bulletRatio: 0.5,
                markerRatio: 0.8,
            },
            markerLineWidth: 1,
            borderWidth: 0,
            borderColor: 'rgba(255, 255, 255, 0)',
            hover: Object.assign(Object.assign({}, boxDefault.BOX_HOVER), { borderWidth: boxDefault.HOVER_THICKNESS, borderColor: '#ffffff', groupedRect: {
                    color: '#000000',
                    opacity: 0.05,
                } }),
            select: Object.assign(Object.assign({}, boxDefault.BOX_HOVER), { borderWidth: boxDefault.HOVER_THICKNESS, borderColor: '#ffffff', groupedRect: {
                    color: '#000000',
                    opacity: 0.2,
                }, restSeries: {
                    areaOpacity: 0.2,
                }, areaOpacity: 1 }),
            dataLabels: Object.assign(Object.assign({}, defaultDataLabelTheme), { textBubble: Object.assign(Object.assign({}, makeDefaultTextBubbleTheme()), { arrow: Object.assign({ visible: false }, DEFAULT_BUBBLE_ARROW) }), marker: Object.assign(Object.assign({}, defaultDataLabelTheme), { fontSize: 9, useSeriesColor: true, textBubble: Object.assign(Object.assign({}, makeDefaultTextBubbleTheme(true)), { backgroundColor: 'rgba(255, 255, 255, 0.8)', shadowColor: 'rgba(0, 0, 0, 0.0)', shadowOffsetX: 0, shadowOffsetY: 0, shadowBlur: 0, arrow: Object.assign({ visible: false }, DEFAULT_BUBBLE_ARROW) }) }) }),
        };
    },
    boxPlot: () => ({
        areaOpacity: 1,
        barWidthRatios: {
            barRatio: 1,
            minMaxBarRatio: 0.5,
        },
        markerLineWidth: 1,
        dot: {
            color: '#ffffff',
            radius: boxplotDefault.OUTLIER_RADIUS,
            borderWidth: boxplotDefault.OUTLIER_BORDER_WIDTH,
            useSeriesColor: false,
        },
        rect: { borderWidth: 0 },
        line: Object.assign({}, boxplotDefault.LINE_TYPE),
        hover: Object.assign(Object.assign({}, boxDefault.BOX_HOVER), { rect: { borderWidth: boxDefault.HOVER_THICKNESS, borderColor: '#ffffff' }, dot: {
                radius: boxplotDefault.OUTLIER_RADIUS,
                borderWidth: 0,
                useSeriesColor: true,
            }, line: Object.assign({}, boxplotDefault.LINE_TYPE) }),
        select: Object.assign(Object.assign({}, boxDefault.BOX_HOVER), { rect: { borderWidth: boxDefault.HOVER_THICKNESS, borderColor: '#ffffff' }, dot: {
                radius: boxplotDefault.OUTLIER_RADIUS,
                borderWidth: 0,
                useSeriesColor: true,
            }, line: Object.assign({}, boxplotDefault.LINE_TYPE), restSeries: {
                areaOpacity: 0.2,
            }, areaOpacity: 1 }),
    }),
    pie: (globalFontFamily, { hasOuterAnchor = false, hasOuterAnchorPieSeriesName = false }, isNestedPieChart = false) => {
        const defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
        return {
            areaOpacity: 1,
            strokeStyle: isNestedPieChart ? '#ffffff' : 'rgba(255, 255, 255, 0)',
            lineWidth: isNestedPieChart ? 1 : 0,
            hover: {
                lineWidth: DEFAULT_PIE_LINE_WIDTH,
                strokeStyle: '#ffffff',
                shadowColor: '#cccccc',
                shadowBlur: 5,
                shadowOffsetX: 0,
                shadowOffsetY: 0,
            },
            select: {
                lineWidth: DEFAULT_PIE_LINE_WIDTH,
                strokeStyle: '#ffffff',
                shadowColor: '#cccccc',
                shadowBlur: 5,
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                restSeries: {
                    areaOpacity: 0.3,
                },
                areaOpacity: 1,
            },
            dataLabels: {
                fontFamily: globalFontFamily,
                fontSize: 16,
                fontWeight: 600,
                color: hasOuterAnchor ? '#333333' : '#ffffff',
                useSeriesColor: hasOuterAnchor,
                textBubble: Object.assign({}, makeDefaultTextBubbleTheme(false, 0)),
                callout: {
                    lineWidth: 1,
                    useSeriesColor: true,
                    lineColor: '#e9e9e9',
                },
                pieSeriesName: Object.assign(Object.assign({}, defaultDataLabelTheme), { useSeriesColor: hasOuterAnchorPieSeriesName, color: hasOuterAnchorPieSeriesName ? '#333333' : '#ffffff', textBubble: Object.assign({}, makeDefaultTextBubbleTheme(false, 0)) }),
            },
        };
    },
    radialBar: (globalFontFamily) => ({
        areaOpacity: 1,
        strokeStyle: 'rgba(255, 255, 255, 0)',
        lineWidth: 0,
        hover: {
            lineWidth: DEFAULT_PIE_LINE_WIDTH,
            strokeStyle: '#fff',
            shadowColor: '#cccccc',
            shadowBlur: 5,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            groupedSector: {
                color: '#000000',
                opacity: 0.05,
            },
        },
        select: {
            lineWidth: DEFAULT_PIE_LINE_WIDTH,
            strokeStyle: '#fff',
            shadowColor: '#cccccc',
            shadowBlur: 5,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            restSeries: {
                areaOpacity: 0.3,
            },
            areaOpacity: 1,
            groupedSector: {
                color: '#000000',
                opacity: 0.2,
            },
        },
        dataLabels: {
            fontFamily: globalFontFamily,
            fontSize: 11,
            fontWeight: 400,
            color: '#333333',
            useSeriesColor: false,
            textBubble: Object.assign({}, makeDefaultTextBubbleTheme(false, 0)),
        },
    }),
    gauge: (globalFontFamily) => ({
        areaOpacity: 1,
        hover: {
            clockHand: { baseLine: 5 },
            pin: { radius: 5, borderWidth: 5 },
            solid: {
                lineWidth: DEFAULT_PIE_LINE_WIDTH,
                strokeStyle: '#ffffff',
                shadowColor: '#cccccc',
                shadowBlur: 5,
                shadowOffsetX: 0,
                shadowOffsetY: 0,
            },
        },
        select: {
            clockHand: { baseLine: 5 },
            pin: { radius: 6, borderWidth: 4 },
            solid: {
                lineWidth: DEFAULT_PIE_LINE_WIDTH,
                strokeStyle: '#ffffff',
                shadowColor: '#cccccc',
                shadowBlur: 5,
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                restSeries: {
                    areaOpacity: 0.3,
                },
                areaOpacity: 1,
            },
            areaOpacity: 1,
            restSeries: { areaOpacity: 0.3 },
        },
        clockHand: { baseLine: 4 },
        pin: { radius: 5, borderWidth: 5 },
        solid: {
            lineWidth: 0,
            backgroundSolid: { color: 'rgba(0, 0, 0, 0.1)' },
        },
        dataLabels: {
            fontFamily: globalFontFamily,
            fontSize: 11,
            fontWeight: 400,
            color: '#333333',
            useSeriesColor: false,
            textBubble: Object.assign(Object.assign({}, makeDefaultTextBubbleTheme(true, 4, 4, 3)), { shadowColor: 'rgba(0, 0, 0, 0)', shadowOffsetY: 0, shadowBlur: 0, borderColor: '#ccc', borderWidth: 1 }),
        },
    }),
};
function getSeriesTheme(globalFontFamily, seriesName, paramForPieSeries, isNestedPieChart = false) {
    if (seriesName === 'pie') {
        return defaultThemeMakers[seriesName](globalFontFamily, paramForPieSeries, isNestedPieChart);
    }
    if ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.includes)(['bubble', 'radar', 'boxPlot'], seriesName)) {
        return defaultThemeMakers[seriesName]();
    }
    return defaultThemeMakers[seriesName](globalFontFamily);
}
function getDefaultTheme(series, pieSeriesOuterAnchors, globalFontFamily = 'Arial', isNestedPieChart = false) {
    const result = Object.keys(series).reduce((acc, seriesName) => (Object.assign(Object.assign({}, acc), { series: Object.assign(Object.assign({}, acc.series), { [seriesName]: getSeriesTheme(globalFontFamily, seriesName, pieSeriesOuterAnchors) }) })), makeDefaultTheme(series, globalFontFamily));
    if (isNestedPieChart) {
        const aliasNames = (0,_pieSeries__WEBPACK_IMPORTED_MODULE_1__.getNestedPieChartAliasNames)(series);
        result.series.pie = aliasNames.reduce((acc, cur) => (Object.assign(Object.assign({}, acc), { [cur]: getSeriesTheme(globalFontFamily, 'pie', pieSeriesOuterAnchors[cur], isNestedPieChart) })), {});
    }
    return result;
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/tooltip.js":
/*!******************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/tooltip.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getValueString": () => (/* binding */ getValueString)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./range */ "./node_modules/@toast-ui/chart/dist/esm/helpers/range.js");


function isBubblePointType(value) {
    return value.hasOwnProperty('r');
}
function getValueString(value) {
    let result = '';
    if ((0,_range__WEBPACK_IMPORTED_MODULE_0__.isRangeValue)(value)) {
        result = `${value[0]} ~ ${value[1]}`;
    }
    else if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) && !Array.isArray(value)) {
        result = `(${value.x}, ${value.y})` + (isBubblePointType(value) ? `, r: ${value.r}` : '');
    }
    else {
        result = String(value);
    }
    return result;
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/tooltipTemplate.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/tooltipTemplate.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDefaultTemplate": () => (/* binding */ getDefaultTemplate),
/* harmony export */   "getHeaderTemplate": () => (/* binding */ getHeaderTemplate),
/* harmony export */   "tooltipTemplates": () => (/* binding */ tooltipTemplates),
/* harmony export */   "getBodyTemplate": () => (/* binding */ getBodyTemplate)
/* harmony export */ });
/* harmony import */ var _pieSeries__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pieSeries */ "./node_modules/@toast-ui/chart/dist/esm/helpers/pieSeries.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./range */ "./node_modules/@toast-ui/chart/dist/esm/helpers/range.js");




function getSeriesNameTemplate(label, color) {
    return `<span class="toastui-chart-series-name">
    <i class="toastui-chart-icon" style="background: ${color}"></i>
    <span class="toastui-chart-name">${label}</span>
  </span>`;
}
function getTitleValueTemplate(title, value) {
    return `<div class="toastui-chart-tooltip-series">
    <span class="toastui-chart-series-name">${title}</span>
    <span class="toastui-chart-series-value">${value}</span>
  </div>`;
}
function getColorValueTemplate(color, value) {
    return `<div class="toastui-chart-tooltip-series">
    <i class="toastui-chart-icon" style="background: ${color}"></i>
    <span class="toastui-chart-series-value">${value}</span>
  </div>`;
}
function makeBulletDataTemplate(data, titleType) {
    return data
        .filter(({ title }) => title === titleType)
        .sort((a, b) => {
        if ((0,_range__WEBPACK_IMPORTED_MODULE_0__.isRangeValue)(a.value) && (0,_range__WEBPACK_IMPORTED_MODULE_0__.isRangeValue)(b.value)) {
            return a.value[0] - b.value[0];
        }
        if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(a.value) && (0,_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(b.value)) {
            return a.value - b.value;
        }
        return 0;
    })
        .map(({ formattedValue, color }) => getColorValueTemplate(color, formattedValue))
        .join('');
}
function getDefaultTemplate(model, { header, body }, theme) {
    const { borderColor, borderWidth, background, borderRadius, borderStyle } = theme;
    const style = `border: ${borderWidth}px ${borderStyle} ${borderColor};border-radius: ${borderRadius}px;background: ${background};`;
    return `<div class="toastui-chart-tooltip" style="${style}">${header}${body}</div>`;
}
function getHeaderTemplate({ category }, theme) {
    return category
        ? `<div class="toastui-chart-tooltip-category" style="${(0,_style__WEBPACK_IMPORTED_MODULE_2__.getFontStyleString)(theme.header)}">
        ${category}
      </div>`
        : '';
}
function getDefaultBodyTemplate({ data }, theme) {
    return `
    <div class="toastui-chart-tooltip-series-wrapper" style="${(0,_style__WEBPACK_IMPORTED_MODULE_2__.getFontStyleString)(theme.body)}">
      ${data
        .map(({ label, color, formattedValue }) => `<div class="toastui-chart-tooltip-series">
                ${getSeriesNameTemplate(label, color)}
                <span class="toastui-chart-series-value">${formattedValue}</span>
              </div>`)
        .join('')}
    </div>`;
}
function getBoxPlotTemplate({ data }, theme) {
    const groupedData = data.reduce((acc, item, index) => {
        if (!index) {
            return item;
        }
        if (acc.category === item.category && acc.label === item.label) {
            acc.value = [...acc.value, ...item.value];
        }
        return acc;
    }, {});
    return `
    <div class="toastui-chart-tooltip-series-wrapper" style="${(0,_style__WEBPACK_IMPORTED_MODULE_2__.getFontStyleString)(theme.body)}">
      ${[groupedData]
        .map(({ label, color, value: values }) => `<div class="toastui-chart-tooltip-series">
              ${getSeriesNameTemplate(label, color)}
            </div>
            <div>
          ${values
        .map(({ title, formattedValue }) => getTitleValueTemplate(title, formattedValue))
        .join('')}
            </div>`)
        .join('')}
    </div>`;
}
function getBulletTemplate({ data }, theme) {
    return data.length > 1
        ? getBulletGroupedTemplate(data, theme)
        : getBulletBasicTemplate(data, theme);
}
function getBulletBasicTemplate(data, theme) {
    return `
    <div class="toastui-chart-tooltip-series-wrapper" style="${(0,_style__WEBPACK_IMPORTED_MODULE_2__.getFontStyleString)(theme.body)}">
      ${data
        .map(({ label, color, value: values }) => `<div class="toastui-chart-tooltip-series">${getSeriesNameTemplate(label, color)}</div>
            ${values
        .map(({ title, formattedValue }) => getTitleValueTemplate(title, formattedValue))
        .join('')}`)
        .join('')}
    </div>`;
}
function getBulletGroupedTemplate(data, theme) {
    const bulletData = data.map(({ value }) => value[0]);
    const [actual, ranges, markers] = ['Actual', 'Range', 'Marker'].map((titleType) => makeBulletDataTemplate(bulletData, titleType));
    return `<div class="toastui-chart-tooltip-category" style="${(0,_style__WEBPACK_IMPORTED_MODULE_2__.getFontStyleString)(theme.header)}">
      ${data[0].label}
    </div>
    <div class="toastui-chart-tooltip-series-wrapper" style="${(0,_style__WEBPACK_IMPORTED_MODULE_2__.getFontStyleString)(theme.body)}">
      ${actual ? '<div class="toastui-chart-tooltip-title">Actual</div>' : ''} ${actual}
      ${ranges ? '<div class="toastui-chart-tooltip-title">Ranges</div>' : ''} ${ranges}
      ${markers ? '<div class="toastui-chart-tooltip-title">Markers</div>' : ''} ${markers}
    </div>`;
}
function getPieTemplate({ data }, theme) {
    return `
    <div class="toastui-chart-tooltip-series-wrapper" style="${(0,_style__WEBPACK_IMPORTED_MODULE_2__.getFontStyleString)(theme.body)}">
      ${data
        .map(({ label, color, formattedValue, percentValue }) => `<div class="toastui-chart-tooltip-series">
          ${getSeriesNameTemplate(label, color)}
          <span class="toastui-chart-series-value">${(0,_pieSeries__WEBPACK_IMPORTED_MODULE_3__.pieTooltipLabelFormatter)(percentValue)}&nbsp;&nbsp;(${formattedValue})</span>
        </div>`)
        .join('')}
    </div>`;
}
function getHeatmapTemplate({ data }, theme) {
    return `${data
        .map(({ label, color, formattedValue }) => `<div class="toastui-chart-tooltip-category" style="${(0,_style__WEBPACK_IMPORTED_MODULE_2__.getFontStyleString)(theme.header)}">
          ${label}
        </div>
        <div class="toastui-chart-tooltip-series-wrapper" style="${(0,_style__WEBPACK_IMPORTED_MODULE_2__.getFontStyleString)(theme.body)}">
          <div class="toastui-chart-tooltip-series">
            ${getSeriesNameTemplate(formattedValue, color)}
          </div>
        </div>`)
        .join('')}`;
}
const tooltipTemplates = {
    default: getDefaultTemplate,
    defaultHeader: getHeaderTemplate,
    defaultBody: getDefaultBodyTemplate,
    boxPlot: getBoxPlotTemplate,
    bullet: getBulletTemplate,
    pie: getPieTemplate,
    heatmap: getHeatmapTemplate,
};
function getBodyTemplate(type) {
    return tooltipTemplates[type || 'defaultBody'];
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isExist": () => (/* binding */ isExist),
/* harmony export */   "isDate": () => (/* binding */ isDate),
/* harmony export */   "isUndefined": () => (/* binding */ isUndefined),
/* harmony export */   "isNull": () => (/* binding */ isNull),
/* harmony export */   "isBoolean": () => (/* binding */ isBoolean),
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isInteger": () => (/* binding */ isInteger),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "forEach": () => (/* binding */ forEach),
/* harmony export */   "forEachArray": () => (/* binding */ forEachArray),
/* harmony export */   "range": () => (/* binding */ range),
/* harmony export */   "toArray": () => (/* binding */ toArray),
/* harmony export */   "includes": () => (/* binding */ includes),
/* harmony export */   "pick": () => (/* binding */ pick),
/* harmony export */   "omit": () => (/* binding */ omit),
/* harmony export */   "pickProperty": () => (/* binding */ pickProperty),
/* harmony export */   "pickPropertyWithMakeup": () => (/* binding */ pickPropertyWithMakeup),
/* harmony export */   "debounce": () => (/* binding */ debounce),
/* harmony export */   "merge": () => (/* binding */ merge),
/* harmony export */   "throttle": () => (/* binding */ throttle),
/* harmony export */   "deepMergedCopy": () => (/* binding */ deepMergedCopy),
/* harmony export */   "deepCopyArray": () => (/* binding */ deepCopyArray),
/* harmony export */   "deepCopy": () => (/* binding */ deepCopy),
/* harmony export */   "sortCategories": () => (/* binding */ sortCategories),
/* harmony export */   "sortNumber": () => (/* binding */ sortNumber),
/* harmony export */   "first": () => (/* binding */ first),
/* harmony export */   "last": () => (/* binding */ last),
/* harmony export */   "hasNegative": () => (/* binding */ hasNegative),
/* harmony export */   "sum": () => (/* binding */ sum),
/* harmony export */   "hasPositiveOnly": () => (/* binding */ hasPositiveOnly),
/* harmony export */   "hasNegativeOnly": () => (/* binding */ hasNegativeOnly),
/* harmony export */   "getFirstValidValue": () => (/* binding */ getFirstValidValue),
/* harmony export */   "getPercentageValue": () => (/* binding */ getPercentageValue),
/* harmony export */   "calculateSizeWithPercentString": () => (/* binding */ calculateSizeWithPercentString),
/* harmony export */   "getInitialSize": () => (/* binding */ getInitialSize),
/* harmony export */   "isAutoValue": () => (/* binding */ isAutoValue)
/* harmony export */ });
function isExist(value) {
    return !isUndefined(value) && !isNull(value);
}
function isDate(value) {
    return value instanceof Date;
}
function isUndefined(value) {
    return typeof value === 'undefined';
}
function isNull(value) {
    return value === null;
}
function isBoolean(value) {
    return typeof value === 'boolean';
}
function isNumber(value) {
    return typeof value === 'number';
}
function isString(value) {
    return typeof value === 'string';
}
function isInteger(value) {
    return isNumber(value) && isFinite(value) && Math.floor(value) === value;
}
function isObject(obj) {
    return typeof obj === 'object' && obj !== null;
}
function isFunction(value) {
    return typeof value === 'function';
}
function forEach(obj, cb) {
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            cb(obj[key], key);
        }
    }
}
function forEachArray(arr, iteratee, context = null) {
    for (let index = 0, len = arr.length; index < len; index += 1) {
        if (iteratee.call(context, arr[index], index, arr) === false) {
            break;
        }
    }
}
function range(start, stop, step) {
    if (isUndefined(stop)) {
        stop = start || 0;
        start = 0;
    }
    step = step || 1;
    const arr = [];
    if (stop) {
        const flag = step < 0 ? -1 : 1;
        stop *= flag;
        for (; start * flag < stop; start += step) {
            arr.push(start);
        }
    }
    return arr;
}
function toArray(arrayLike) {
    let arr = [];
    try {
        arr = Array.prototype.slice.call(arrayLike);
    }
    catch (e) {
        forEachArray(arrayLike, function (value) {
            arr.push(value);
        });
    }
    return arr;
}
function includes(arr, searchItem, searchIndex) {
    if (typeof searchIndex === 'number' && arr[searchIndex] !== searchItem) {
        return false;
    }
    for (const item of arr) {
        if (item === searchItem) {
            return true;
        }
    }
    return false;
}
function pick(obj, ...propNames) {
    const resultMap = {};
    Object.keys(obj).forEach((key) => {
        if (includes(propNames, key)) {
            resultMap[key] = obj[key];
        }
    });
    return resultMap;
}
function omit(obj, ...propNames) {
    const resultMap = {};
    Object.keys(obj).forEach((key) => {
        if (!includes(propNames, key)) {
            resultMap[key] = obj[key];
        }
    });
    return resultMap;
}
function pickProperty(target, keys) {
    const { length } = keys;
    if (length) {
        for (let i = 0; i < length; i += 1) {
            if (isUndefined(target) || isNull(target)) {
                return null;
            }
            target = target[keys[i]];
        }
    }
    return target;
}
function pickPropertyWithMakeup(target, args) {
    const { length } = args;
    if (length) {
        for (let i = 0; i < length; i += 1) {
            if (isUndefined(target[args[i]])) {
                target[args[i]] = {};
            }
            target = target[args[i]];
        }
    }
    return target;
}
function debounce(fn, delay = 0) {
    let timer;
    function debounced(...args) {
        window.clearTimeout(timer);
        timer = window.setTimeout(() => {
            fn(...args);
        }, delay);
    }
    return debounced;
}
function merge(target, ...args) {
    target = target || {};
    args.forEach((obj) => {
        if (!obj) {
            return;
        }
        forEach(obj, (item, key) => {
            if (Object.prototype.toString.call(item) === '[object Object]') {
                target[key] = merge(target[key], item);
            }
            else {
                target[key] = item;
            }
        });
    });
    return target;
}
function throttle(fn, interval = 0) {
    let base = null;
    let isLeading = true;
    const tick = function (...args) {
        fn(...args);
        base = null;
    };
    let stamp = 0;
    const debounced = debounce(tick, interval);
    function throttled(...args) {
        if (isLeading) {
            tick(...args);
            isLeading = false;
            return;
        }
        stamp = Number(new Date());
        base = base || stamp;
        debounced(args);
        if (stamp - base >= interval) {
            tick(args);
        }
    }
    function reset() {
        // eslint-disable-line require-jsdoc
        isLeading = true;
        base = null;
    }
    throttled.reset = reset;
    return throttled;
}
function deepMergedCopy(targetObj, obj) {
    const resultObj = Object.assign({}, targetObj);
    Object.keys(obj).forEach((prop) => {
        if (isObject(resultObj[prop])) {
            if (Array.isArray(obj[prop])) {
                resultObj[prop] = deepCopyArray(obj[prop]);
            }
            else if (resultObj.hasOwnProperty(prop)) {
                resultObj[prop] = deepMergedCopy(resultObj[prop], obj[prop]);
            }
            else {
                resultObj[prop] = deepCopy(obj[prop]);
            }
        }
        else {
            resultObj[prop] = obj[prop];
        }
    });
    return resultObj;
}
function deepCopyArray(items) {
    return items.map((item) => {
        if (isObject(item)) {
            return Array.isArray(item) ? deepCopyArray(item) : deepCopy(item);
        }
        return item;
    });
}
function deepCopy(obj) {
    const resultObj = {};
    const keys = Object.keys(obj);
    if (!keys.length) {
        return obj;
    }
    keys.forEach((prop) => {
        if (isObject(obj[prop])) {
            resultObj[prop] = Array.isArray(obj[prop]) ? deepCopyArray(obj[prop]) : deepCopy(obj[prop]);
        }
        else {
            resultObj[prop] = obj[prop];
        }
    });
    return resultObj;
}
function sortCategories(x, y) {
    return isInteger(x) ? Number(x) - Number(y) : new Date(x).getTime() - new Date(y).getTime();
}
function sortNumber(x, y) {
    return x - y;
}
function first(items) {
    // eslint-disable-next-line no-undefined
    return items.length ? items[0] : undefined;
}
function last(items) {
    // eslint-disable-next-line no-undefined
    return items.length ? items[items.length - 1] : undefined;
}
function hasNegative(values = []) {
    return values.some((value) => Number(value) < 0);
}
function sum(items) {
    return items.reduce((a, b) => a + b, 0);
}
function hasPositiveOnly(values) {
    return values.every((value) => Number(value) >= 0);
}
function hasNegativeOnly(values) {
    return values.every((value) => Number(value) <= 0);
}
function getFirstValidValue(values) {
    var _a;
    return (_a = values) === null || _a === void 0 ? void 0 : _a.find((value) => value !== null);
}
function getPercentageValue(text) {
    return Number(text.substr(0, text.length - 1));
}
function calculateSizeWithPercentString(size, value) {
    return isNumber(value) ? value : Number(((size * getPercentageValue(value)) / 100).toFixed(2));
}
function getInitialSize(size) {
    return isNumber(size) ? size : 0;
}
function isAutoValue(value) {
    return value === 'auto';
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/helpers/validation.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/helpers/validation.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isAvailableShowTooltipInfo": () => (/* binding */ isAvailableShowTooltipInfo),
/* harmony export */   "isAvailableSelectSeries": () => (/* binding */ isAvailableSelectSeries),
/* harmony export */   "isNoData": () => (/* binding */ isNoData)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");

function isAvailableShowTooltipInfo(info, eventDetectType, targetChartType) {
    const { index, seriesIndex, chartType } = info;
    return ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(index) &&
        (eventDetectType === 'grouped' || (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(seriesIndex)) &&
        ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(chartType) || chartType === targetChartType));
}
function isAvailableSelectSeries(info, targetChartType) {
    const { index, seriesIndex, chartType } = info;
    return ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(index) &&
        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(seriesIndex) &&
        ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(chartType) || chartType === targetChartType));
}
function isNoData(series) {
    return Object.keys(series).reduce((acc, chartType) => !series[chartType].data.length && acc, true);
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Chart),
/* harmony export */   "LineChart": () => (/* reexport safe */ _charts_lineChart__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "AreaChart": () => (/* reexport safe */ _charts_areaChart__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "BarChart": () => (/* reexport safe */ _charts_barChart__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "ColumnChart": () => (/* reexport safe */ _charts_columnChart__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "PieChart": () => (/* reexport safe */ _charts_pieChart__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "HeatmapChart": () => (/* reexport safe */ _charts_heatmapChart__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "BubbleChart": () => (/* reexport safe */ _charts_bubbleChart__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "ScatterChart": () => (/* reexport safe */ _charts_scatterChart__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "BulletChart": () => (/* reexport safe */ _charts_bulletChart__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   "RadarChart": () => (/* reexport safe */ _charts_radarChart__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "TreemapChart": () => (/* reexport safe */ _charts_treemapChart__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   "NestedPieChart": () => (/* reexport safe */ _charts_nestedPieChart__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   "LineAreaChart": () => (/* reexport safe */ _charts_lineAreaChart__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   "LineScatterChart": () => (/* reexport safe */ _charts_lineScatterChart__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   "ColumnLineChart": () => (/* reexport safe */ _charts_columnLineChart__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   "BoxPlotChart": () => (/* reexport safe */ _charts_boxPlotChart__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "RadialBarChart": () => (/* reexport safe */ _charts_radialBarChart__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   "GaugeChart": () => (/* reexport safe */ _charts_gaugeChart__WEBPACK_IMPORTED_MODULE_17__["default"])
/* harmony export */ });
/* harmony import */ var _charts_lineChart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./charts/lineChart */ "./node_modules/@toast-ui/chart/dist/esm/charts/lineChart.js");
/* harmony import */ var _charts_pieChart__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./charts/pieChart */ "./node_modules/@toast-ui/chart/dist/esm/charts/pieChart.js");
/* harmony import */ var _charts_heatmapChart__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./charts/heatmapChart */ "./node_modules/@toast-ui/chart/dist/esm/charts/heatmapChart.js");
/* harmony import */ var _charts_areaChart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./charts/areaChart */ "./node_modules/@toast-ui/chart/dist/esm/charts/areaChart.js");
/* harmony import */ var _charts_lineScatterChart__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./charts/lineScatterChart */ "./node_modules/@toast-ui/chart/dist/esm/charts/lineScatterChart.js");
/* harmony import */ var _charts_lineAreaChart__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./charts/lineAreaChart */ "./node_modules/@toast-ui/chart/dist/esm/charts/lineAreaChart.js");
/* harmony import */ var _charts_barChart__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./charts/barChart */ "./node_modules/@toast-ui/chart/dist/esm/charts/barChart.js");
/* harmony import */ var _charts_columnChart__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./charts/columnChart */ "./node_modules/@toast-ui/chart/dist/esm/charts/columnChart.js");
/* harmony import */ var _charts_columnLineChart__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./charts/columnLineChart */ "./node_modules/@toast-ui/chart/dist/esm/charts/columnLineChart.js");
/* harmony import */ var _charts_bubbleChart__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./charts/bubbleChart */ "./node_modules/@toast-ui/chart/dist/esm/charts/bubbleChart.js");
/* harmony import */ var _charts_scatterChart__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./charts/scatterChart */ "./node_modules/@toast-ui/chart/dist/esm/charts/scatterChart.js");
/* harmony import */ var _charts_bulletChart__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./charts/bulletChart */ "./node_modules/@toast-ui/chart/dist/esm/charts/bulletChart.js");
/* harmony import */ var _charts_nestedPieChart__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./charts/nestedPieChart */ "./node_modules/@toast-ui/chart/dist/esm/charts/nestedPieChart.js");
/* harmony import */ var _charts_radarChart__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./charts/radarChart */ "./node_modules/@toast-ui/chart/dist/esm/charts/radarChart.js");
/* harmony import */ var _charts_treemapChart__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./charts/treemapChart */ "./node_modules/@toast-ui/chart/dist/esm/charts/treemapChart.js");
/* harmony import */ var _charts_boxPlotChart__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./charts/boxPlotChart */ "./node_modules/@toast-ui/chart/dist/esm/charts/boxPlotChart.js");
/* harmony import */ var _charts_radialBarChart__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./charts/radialBarChart */ "./node_modules/@toast-ui/chart/dist/esm/charts/radialBarChart.js");
/* harmony import */ var _charts_gaugeChart__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./charts/gaugeChart */ "./node_modules/@toast-ui/chart/dist/esm/charts/gaugeChart.js");


















class Chart {
}
Chart.lineChart = (props) => {
    return new _charts_lineChart__WEBPACK_IMPORTED_MODULE_0__["default"](props);
};
Chart.areaChart = (props) => {
    return new _charts_areaChart__WEBPACK_IMPORTED_MODULE_1__["default"](props);
};
Chart.barChart = (props) => {
    return new _charts_barChart__WEBPACK_IMPORTED_MODULE_2__["default"](props);
};
Chart.boxPlotChart = (props) => {
    return new _charts_boxPlotChart__WEBPACK_IMPORTED_MODULE_3__["default"](props);
};
Chart.columnChart = (props) => {
    return new _charts_columnChart__WEBPACK_IMPORTED_MODULE_4__["default"](props);
};
Chart.pieChart = (props) => {
    return new _charts_pieChart__WEBPACK_IMPORTED_MODULE_5__["default"](props);
};
Chart.heatmapChart = (props) => {
    return new _charts_heatmapChart__WEBPACK_IMPORTED_MODULE_6__["default"](props);
};
Chart.bubbleChart = (props) => {
    return new _charts_bubbleChart__WEBPACK_IMPORTED_MODULE_7__["default"](props);
};
Chart.scatterChart = (props) => {
    return new _charts_scatterChart__WEBPACK_IMPORTED_MODULE_8__["default"](props);
};
Chart.bulletChart = (props) => {
    return new _charts_bulletChart__WEBPACK_IMPORTED_MODULE_9__["default"](props);
};
Chart.radarChart = (props) => {
    return new _charts_radarChart__WEBPACK_IMPORTED_MODULE_10__["default"](props);
};
Chart.treemapChart = (props) => {
    return new _charts_treemapChart__WEBPACK_IMPORTED_MODULE_11__["default"](props);
};
Chart.nestedPieChart = (props) => {
    return new _charts_nestedPieChart__WEBPACK_IMPORTED_MODULE_12__["default"](props);
};
Chart.lineAreaChart = (props) => {
    return new _charts_lineAreaChart__WEBPACK_IMPORTED_MODULE_13__["default"](props);
};
Chart.lineScatterChart = (props) => {
    return new _charts_lineScatterChart__WEBPACK_IMPORTED_MODULE_14__["default"](props);
};
Chart.columnLineChart = (props) => {
    return new _charts_columnLineChart__WEBPACK_IMPORTED_MODULE_15__["default"](props);
};
Chart.radialBarChart = (props) => {
    return new _charts_radialBarChart__WEBPACK_IMPORTED_MODULE_16__["default"](props);
};
Chart.gaugeChart = (props) => {
    return new _charts_gaugeChart__WEBPACK_IMPORTED_MODULE_17__["default"](props);
};



/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/message.js":
/*!**********************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/message.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "message": () => (/* binding */ message)
/* harmony export */ });
const message = {
    SELECT_SERIES_API_SELECTABLE_ERROR: 'It works only when the selectable option is true.',
    SELECT_SERIES_API_INDEX_ERROR: 'The index value is invalid.',
    ALREADY_OBSERVABLE_ERROR: 'Source object is observable already',
    CIRCLE_LEGEND_RENDER_ERROR: 'circleLegend is only possible when bubble series is present',
    noDataError: (chartName) => `There's no ${chartName} data!`,
    noBrushError: (brushName) => `Brush don't exist in painter: ${brushName}`,
    DASH_SEGMENTS_UNAVAILABLE_ERROR: 'DashSegments option is available from IE11 and above.',
    SERIES_INDEX_ERROR: 'The seriesIndex value is invalid',
    AUTO_LAYOUT_CONTAINER_SIZE_ERROR: 'To use auto layout, the width or height of the container must be specified as a value such as "%" or "vh", "vw".',
};


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/painter.js":
/*!**********************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/painter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Painter)
/* harmony export */ });
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");

class Painter {
    constructor(chart) {
        this.width = 0;
        this.height = 0;
        this.brushes = {};
        this.chart = chart;
    }
    showUnsupportedCanvasFeatureError() {
        if (!this.ctx.setLineDash) {
            console.warn(_message__WEBPACK_IMPORTED_MODULE_0__.message.DASH_SEGMENTS_UNAVAILABLE_ERROR);
        }
    }
    setup() {
        const { height, width } = this.chart.store.state.chart;
        if (!this.canvas) {
            const canvas = document.createElement('canvas');
            this.canvas = canvas;
            this.chart.el.appendChild(canvas);
            canvas.addEventListener('click', this.chart);
            canvas.addEventListener('mousemove', this.chart);
            canvas.addEventListener('mousedown', this.chart);
            canvas.addEventListener('mouseup', this.chart);
            canvas.addEventListener('mouseout', this.chart);
            const ctx = canvas.getContext('2d');
            if (ctx) {
                this.ctx = ctx;
            }
        }
        this.setSize(width, height);
        this.showUnsupportedCanvasFeatureError();
    }
    setSize(width, height) {
        this.canvas.style.width = `${width}px`;
        this.canvas.style.height = `${height}px`;
        let ratio = 1;
        if ('deviceXDPI' in window.screen) {
            // IE mobile or IE
            ratio =
                window.screen.deviceXDPI /
                    window.screen.logicalXDPI;
        }
        else if (window.hasOwnProperty('devicePixelRatio')) {
            ratio = window.devicePixelRatio;
        }
        this.width = width * ratio || 0;
        this.height = height * ratio || 0;
        this.scaleCanvasRatio(ratio);
    }
    scaleCanvasRatio(ratio) {
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        this.ctx.scale(ratio, ratio);
    }
    add(name, brush) {
        this.brushes[name] = brush;
    }
    addGroups(groups) {
        groups.forEach((group) => {
            Object.keys(group).forEach((key) => {
                this.add(key, group[key]);
            });
        });
    }
    paint(name, brushModel) {
        if (this.brushes[name]) {
            this.brushes[name](this.ctx, brushModel);
        }
        else {
            throw new Error(_message__WEBPACK_IMPORTED_MODULE_0__.message.noBrushError(name));
        }
    }
    paintForEach(brushModels) {
        brushModels.forEach((m) => this.paint(m.type, m));
    }
    beforeFrame() {
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.ctx.fillStyle = 'transparent';
        this.ctx.fillRect(0, 0, this.width, this.height);
    }
    beforeDraw(transX, transY) {
        this.ctx.save();
        this.ctx.translate(transX, transY);
    }
    afterDraw() {
        this.ctx.restore();
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/responderDetectors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/responderDetectors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "responderDetectors": () => (/* binding */ responderDetectors)
/* harmony export */ });
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_sector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/sector */ "./node_modules/@toast-ui/chart/dist/esm/helpers/sector.js");


function withinRotationRect({ slope, yIntercept, mouseX, mouseY, modelXPositions, compX, compY, detectionSize = 0, }) {
    const [x1, x2] = modelXPositions;
    const posY = slope * (mouseX - compX) + yIntercept;
    const withinRadius = (x1 > x2 && mouseX >= compX + x2 && mouseX <= compX + x1) ||
        (x1 < x2 && mouseX <= compX + x2 && mouseX >= compX + x1);
    const withinDetectionSize = posY - detectionSize + compY <= mouseY && mouseY <= posY + detectionSize + compY;
    return withinRadius && withinDetectionSize;
}
const responderDetectors = {
    circle: (mousePosition, model, componentRect) => {
        const { x, y } = mousePosition;
        const { x: modelX, y: modelY, radius, detectionSize } = model;
        const { x: compX, y: compY } = componentRect;
        const radiusAdjustment = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(detectionSize) ? 10 : detectionSize;
        return (Math.pow((x - (modelX + compX)), 2) + Math.pow((y - (modelY + compY)), 2) < Math.pow((radius + radiusAdjustment), 2));
    },
    rect: (mousePosition, model, componentRect = { x: 0, y: 0, width: 0, height: 0 }) => {
        const { x, y } = mousePosition;
        const { x: modelX, y: modelY, width, height } = model;
        const { x: compX, y: compY } = componentRect;
        return (x >= modelX + compX &&
            x <= modelX + compX + width &&
            y >= modelY + compY &&
            y <= modelY + compY + height);
    },
    sector: (mousePosition, model, componentRect = { x: 0, y: 0, width: 0, height: 0 }) => {
        const { x, y } = mousePosition;
        const { x: modelX, y: modelY, radius: { outer, inner }, degree: { start, end }, drawingStartAngle, clockwise, } = model;
        const { x: compX, y: compY } = componentRect;
        const xPos = x - (modelX + compX);
        const yPos = y - (modelY + compY);
        const insideOuterRadius = Math.pow(xPos, 2) + Math.pow(yPos, 2) < Math.pow(outer, 2);
        const outsideInnerRadius = Math.pow(xPos, 2) + Math.pow(yPos, 2) > Math.pow(inner, 2);
        const withinRadius = insideOuterRadius && outsideInnerRadius;
        const detectionDegree = (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_1__.calculateRadianToDegree)(Math.atan2(yPos, xPos), drawingStartAngle);
        return withinRadius && (0,_helpers_sector__WEBPACK_IMPORTED_MODULE_1__.withinRadian)(clockwise, start, end, detectionDegree);
    },
    line: (mousePosition, model, componentRect = { x: 0, y: 0, width: 0, height: 0 }) => {
        const { x, y } = mousePosition;
        const { x: compX, y: compY } = componentRect;
        const { x: modelX, y: modelY, x2, y2, detectionSize = 3 } = model;
        const numerator = y2 - modelY;
        const denominator = x2 - modelX;
        let withinLine = false;
        if (numerator === 0) {
            const minX = Math.min(modelX, x2);
            const maxX = Math.max(modelX, x2);
            withinLine =
                x - compX >= minX &&
                    x - compX <= maxX &&
                    y >= modelY + compY - detectionSize &&
                    y <= modelY + compY + detectionSize;
        }
        else if (denominator === 0) {
            const minY = Math.min(modelY, y2);
            const maxY = Math.max(modelY, y2);
            withinLine =
                y - compY >= minY &&
                    y - compY <= maxY &&
                    x >= modelX + compX - detectionSize &&
                    x <= modelX + compX + detectionSize;
        }
        else {
            const slope = numerator / denominator;
            const xPos = x - (modelX + compX);
            const yPos = y - (modelY + compY);
            withinLine = slope * xPos === yPos;
        }
        return withinLine;
    },
    boxPlot: (mousePosition, model, componentRect = { x: 0, y: 0, width: 0, height: 0 }) => {
        return ['rect', 'median', 'minimum', 'maximum', 'upperWhisker', 'lowerWhisker'].some((prop) => {
            if (!model[prop]) {
                return false;
            }
            return prop === 'rect'
                ? responderDetectors.rect(mousePosition, model[prop], componentRect)
                : responderDetectors.line(mousePosition, model[prop], componentRect);
        });
    },
    clockHand: (mousePosition, model, componentRect = { x: 0, y: 0, width: 0, height: 0 }) => {
        const { x, y } = mousePosition;
        const { x: compX, y: compY } = componentRect;
        const { x: centerX, y: centerY, x2, y2, detectionSize = 5 } = model;
        const numerator = y2 - centerY;
        const denominator = x2 - centerX;
        let withinClockHand = false;
        if (numerator === 0) {
            const minX = Math.min(centerX, x2);
            const maxX = Math.max(centerX, x2);
            withinClockHand =
                x - compX >= minX &&
                    x - compX <= maxX &&
                    y >= centerY + compY - detectionSize &&
                    y <= centerY + compY + detectionSize;
        }
        else if (denominator === 0) {
            const minY = Math.min(centerY, y2);
            const maxY = Math.max(centerY, y2);
            withinClockHand =
                y - compY >= minY &&
                    y - compY <= maxY &&
                    x >= centerX + compX - detectionSize &&
                    x <= centerX + compX + detectionSize;
        }
        else {
            const slope = numerator / denominator;
            const yIntercept = centerY - slope * centerX;
            withinClockHand = withinRotationRect({
                slope,
                yIntercept,
                mouseX: x,
                mouseY: y,
                modelXPositions: [centerX, x2],
                compX,
                compY,
                detectionSize,
            });
        }
        return withinClockHand;
    },
};


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/scale/coordinateScaleCalculator.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/scale/coordinateScaleCalculator.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getNormalizedStepCount": () => (/* binding */ getNormalizedStepCount),
/* harmony export */   "makeScaleOption": () => (/* binding */ makeScaleOption),
/* harmony export */   "calculateCoordinateScale": () => (/* binding */ calculateCoordinateScale),
/* harmony export */   "getStackScaleData": () => (/* binding */ getStackScaleData),
/* harmony export */   "calculateXAxisScaleForCoordinateLineType": () => (/* binding */ calculateXAxisScaleForCoordinateLineType)
/* harmony export */ });
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _component_axis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../component/axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");



const SNAP_VALUES = [1, 2, 5, 10];
const DEFAULT_PIXELS_PER_STEP = 88;
function adjustLimitForOverflow({ min, max }, stepSize, overflowed) {
    return {
        min: overflowed.min ? min - stepSize : min,
        max: overflowed.max ? max + stepSize : max,
    };
}
function isSeriesOverflowed(scaleData, { min, max }, scaleOption) {
    var _a, _b;
    const scaleDataLimit = scaleData.limit;
    const hasMinOption = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)((_a = scaleOption) === null || _a === void 0 ? void 0 : _a.min);
    const hasMaxOption = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)((_b = scaleOption) === null || _b === void 0 ? void 0 : _b.max);
    const isOverflowedMin = !hasMinOption && scaleDataLimit.min === min && scaleDataLimit.min !== 0;
    const isOverflowedMax = !hasMaxOption && scaleDataLimit.max === max && scaleDataLimit.max !== 0;
    if (!isOverflowedMin && !isOverflowedMax) {
        return null;
    }
    return {
        min: isOverflowedMin,
        max: isOverflowedMax,
    };
}
function getDigits(num) {
    const logNumberDividedLN10 = num === 0 ? 1 : Math.log(Math.abs(num)) / Math.LN10;
    return Math.pow(10, Math.floor(logNumberDividedLN10));
}
function getSnappedNumber(num) {
    let snapNumber = 0;
    for (let i = 0, t = SNAP_VALUES.length; i < t; i += 1) {
        snapNumber = SNAP_VALUES[i];
        const guideValue = (snapNumber + (SNAP_VALUES[i + 1] || snapNumber)) / 2;
        if (num <= guideValue) {
            break;
        }
    }
    return snapNumber;
}
function getNormalizedStep(stepSize) {
    const placeNumber = getDigits(stepSize);
    const simplifiedStepValue = stepSize / placeNumber;
    return getSnappedNumber(simplifiedStepValue) * placeNumber;
}
/**
 * Get normalized limit values
 * max = 155 and step = 10 ---> max = 160
 */
function getNormalizedLimit(limit, stepSize) {
    let { min, max } = limit;
    const minNumber = Math.min(getDigits(max), getDigits(stepSize));
    const placeNumber = minNumber > 1 ? 1 : 1 / minNumber;
    const fixedStep = stepSize * placeNumber;
    // ceil max value step digits
    max = (Math.ceil((max * placeNumber) / fixedStep) * fixedStep) / placeNumber;
    if (min > stepSize) {
        // floor min value to multiples of step
        min = (Math.floor((min * placeNumber) / fixedStep) * fixedStep) / placeNumber;
    }
    else if (min < 0) {
        min = -(Math.ceil((Math.abs(min) * placeNumber) / fixedStep) * fixedStep) / placeNumber;
    }
    else {
        min = 0;
    }
    return { min, max };
}
function getNormalizedStepCount(limitSize, stepSize) {
    const multiplier = 1 / Math.min(getDigits(limitSize), getDigits(stepSize));
    return Math.ceil((limitSize * multiplier) / (stepSize * multiplier));
}
function hasStepSize(stepSize) {
    return (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(stepSize);
}
function getNormalizedScale(scaleData, scale) {
    const stepSize = hasStepSize(scale.stepSize)
        ? scaleData.stepSize
        : getNormalizedStep(scaleData.stepSize);
    const edge = getNormalizedLimit(scaleData.limit, stepSize);
    const limitSize = Math.abs(edge.max - edge.min);
    const stepCount = getNormalizedStepCount(limitSize, stepSize);
    return {
        limit: {
            min: edge.min,
            max: edge.max,
        },
        stepSize,
        stepCount,
    };
}
function getRoughScale(scale, offsetSize, minStepSize = 1) {
    const { min, max } = scale;
    const limitSize = Math.abs(max - min);
    const valuePerPixel = limitSize / offsetSize;
    let stepCount = Math.ceil(offsetSize / DEFAULT_PIXELS_PER_STEP);
    const pixelsPerStep = offsetSize / stepCount;
    let stepSize = valuePerPixel * pixelsPerStep;
    if (hasStepSize(scale.stepSize)) {
        stepSize = scale.stepSize;
        stepCount = limitSize / stepSize;
    }
    else if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(minStepSize) && stepSize < minStepSize) {
        stepSize = minStepSize;
        stepCount = limitSize / stepSize;
    }
    return { limit: { min, max }, stepSize, stepCount };
}
function makeScaleOption(dataRange, scaleOptions) {
    var _a, _b, _c, _d, _e, _f;
    return {
        max: (_b = (_a = scaleOptions) === null || _a === void 0 ? void 0 : _a.max, (_b !== null && _b !== void 0 ? _b : dataRange.max)),
        min: (_d = (_c = scaleOptions) === null || _c === void 0 ? void 0 : _c.min, (_d !== null && _d !== void 0 ? _d : dataRange.min)),
        stepSize: (_f = (_e = scaleOptions) === null || _e === void 0 ? void 0 : _e.stepSize, (_f !== null && _f !== void 0 ? _f : 'auto')),
    };
}
function calculateCoordinateScale(options) {
    const { dataRange, scaleOption, offsetSize, minStepSize, useSpectrumLegend } = options;
    const scale = makeScaleOption(dataRange, scaleOption);
    const roughScale = getRoughScale(scale, offsetSize, minStepSize);
    const normalizedScale = getNormalizedScale(roughScale, scale);
    const overflowed = useSpectrumLegend
        ? null
        : isSeriesOverflowed(normalizedScale, scale, scaleOption);
    if (overflowed) {
        const { stepSize, limit } = normalizedScale;
        normalizedScale.limit = adjustLimitForOverflow(limit, stepSize, overflowed);
    }
    return normalizedScale;
}
function getStackScaleData(type) {
    if (type === 'minusPercentStack') {
        return { limit: { min: -100, max: 0 }, stepSize: 25, stepCount: 5 };
    }
    if (type === 'dualPercentStack') {
        return { limit: { min: -100, max: 100 }, stepSize: 25, stepCount: 9 };
    }
    if (type === 'divergingPercentStack') {
        return { limit: { min: -100, max: 100 }, stepSize: 25, stepCount: 9 };
    }
    return { limit: { min: 0, max: 100 }, stepSize: 25, stepCount: 5 };
}
function calculateXAxisScaleForCoordinateLineType(scale, options, categories) {
    const dateType = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.isDateType)(options, _component_axis__WEBPACK_IMPORTED_MODULE_2__.AxisType.X);
    const values = categories.map((value) => (dateType ? Number(new Date(value)) : Number(value)));
    const { limit, stepSize } = scale;
    const min = Math.min(...values);
    const max = Math.max(...values);
    const newLimit = Object.assign({}, limit);
    const distance = max - min;
    let positionRatio = 0;
    let sizeRatio = 1;
    if (distance) {
        if (limit.min < min) {
            newLimit.min += stepSize;
            positionRatio = (newLimit.min - min) / distance;
            sizeRatio -= positionRatio;
        }
        if (limit.max > max) {
            newLimit.max -= stepSize;
            sizeRatio -= (max - newLimit.max) / distance;
        }
    }
    const limitSize = Math.abs(newLimit.max - newLimit.min);
    const newStepCount = getNormalizedStepCount(limitSize, stepSize);
    return {
        limit: newLimit,
        stepCount: newStepCount,
        stepSize,
        positionRatio,
        sizeRatio,
    };
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/scale/datetimeScaleCalculator.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/scale/datetimeScaleCalculator.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calculateDatetimeScale": () => (/* binding */ calculateDatetimeScale)
/* harmony export */ });
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _coordinateScaleCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./coordinateScaleCalculator */ "./node_modules/@toast-ui/chart/dist/esm/scale/coordinateScaleCalculator.js");



const msMap = {
    year: 31536000000,
    month: 2678400000,
    week: 604800000,
    date: 86400000,
    hour: 3600000,
    minute: 60000,
    second: 1000,
};
function calculateDatetimeScale(options) {
    const { dataRange, rawCategoriesSize, scaleOption } = options;
    const datetimeInfo = makeDatetimeInfo(dataRange, rawCategoriesSize, scaleOption);
    const { minDate, divisionNumber, limit } = datetimeInfo;
    const scale = (0,_coordinateScaleCalculator__WEBPACK_IMPORTED_MODULE_0__.calculateCoordinateScale)(Object.assign(Object.assign({}, (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.omit)(options, 'scaleOption')), { dataRange: limit, minStepSize: 1 }));
    return restoreScaleToDatetimeType(scale, minDate, divisionNumber);
}
const msTypes = ['year', 'month', 'week', 'date', 'hour', 'minute', 'second'];
function restoreScaleToDatetimeType(scale, minDate, divisionNumber) {
    const { limit, stepSize } = scale;
    const { min, max } = limit;
    return Object.assign(Object.assign({}, scale), { stepSize: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_2__.multiply)(stepSize, divisionNumber), limit: {
            min: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_2__.multiply)((0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_2__.add)(min, minDate), divisionNumber),
            max: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_2__.multiply)((0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_2__.add)(max, minDate), divisionNumber),
        } });
}
function makeDatetimeInfo(limit, count, scaleOption) {
    var _a, _b;
    const dateType = findDateType(limit, count);
    const divisionNumber = (_b = (_a = scaleOption) === null || _a === void 0 ? void 0 : _a.stepSize, (_b !== null && _b !== void 0 ? _b : msMap[dateType]));
    const scale = (0,_coordinateScaleCalculator__WEBPACK_IMPORTED_MODULE_0__.makeScaleOption)(limit, scaleOption);
    const minDate = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_2__.divide)(Number(new Date(scale.min)), divisionNumber);
    const maxDate = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_2__.divide)(Number(new Date(scale.max)), divisionNumber);
    return { divisionNumber, minDate, limit: { min: 0, max: maxDate - minDate } };
}
function findDateType({ max, min }, count) {
    const diff = max - min;
    const lastTypeIndex = msTypes.length - 1;
    let foundType;
    if (diff) {
        msTypes.every((type, index) => {
            const millisecond = msMap[type];
            const dividedCount = Math.floor(diff / millisecond);
            let foundIndex;
            if (dividedCount) {
                foundIndex =
                    index < lastTypeIndex && dividedCount < 2 && dividedCount < count ? index + 1 : index;
                foundType = msTypes[foundIndex];
            }
            return !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isExist)(foundIndex);
        });
    }
    else {
        foundType = 'second';
    }
    return foundType;
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/axes.js":
/*!*************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/axes.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isCenterYAxis": () => (/* binding */ isCenterYAxis),
/* harmony export */   "getLabelAxisData": () => (/* binding */ getLabelAxisData),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_coordinate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/coordinate */ "./node_modules/@toast-ui/chart/dist/esm/helpers/coordinate.js");
/* harmony import */ var _component_axis__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../component/axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");






function isCenterYAxis(options) {
    var _a, _b;
    const diverging = !!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.pickProperty)(options, ['series', 'diverging']);
    const alignCenter = ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.yAxis) === null || _b === void 0 ? void 0 : _b.align) === 'center';
    return diverging && alignCenter;
}
function isDivergingBoxSeries(series, options) {
    var _a;
    return (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.hasBoxTypeSeries)(series) && !!((_a = options.series) === null || _a === void 0 ? void 0 : _a.diverging);
}
function getZeroPosition(limit, axisSize, labelAxisOnYAxis, isDivergingSeries) {
    const { min, max } = limit;
    const hasZeroValue = min <= 0 && max >= 0;
    if (!hasZeroValue || isDivergingSeries) {
        return null;
    }
    const position = ((0 - min) / (max - min)) * axisSize;
    return labelAxisOnYAxis ? position : axisSize - position;
}
function getLabelAxisData(stateProp) {
    const { axisSize, categories, series, options, theme, scale, initialAxisData, isCoordinateTypeChart, axisName, } = stateProp;
    const hasLineSeries = !!series.line;
    const pointOnColumn = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.isPointOnColumn)(series, options);
    const dateType = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.isDateType)(options, axisName);
    const labelsBeforeFormatting = isCoordinateTypeChart
        ? (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_2__.makeLabelsFromLimit)(scale.limit, scale.stepSize, dateType)
        : categories;
    const labels = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getLabelsAppliedFormatter)(labelsBeforeFormatting, options, dateType, axisName);
    let labelRange;
    if (scale && hasLineSeries) {
        const baseLabels = pointOnColumn ? labelsBeforeFormatting : categories;
        const values = baseLabels.map((value) => (dateType ? Number(new Date(value)) : Number(value)));
        labelRange = { min: Math.min(...values), max: Math.max(...values) };
    }
    const rectResponderCount = categories.length;
    const tickIntervalCount = rectResponderCount - (pointOnColumn ? 0 : 1);
    const tickDistance = tickIntervalCount ? axisSize / tickIntervalCount : axisSize;
    const labelDistance = axisSize / (labels.length - (pointOnColumn ? 0 : 1));
    let tickCount = labels.length;
    if (pointOnColumn && !isCoordinateTypeChart) {
        tickCount += 1;
    }
    const viewLabels = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getViewAxisLabels)(Object.assign({ labels,
        pointOnColumn,
        tickDistance,
        tickCount,
        scale }, initialAxisData), axisSize);
    const axisLabelMargin = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getLabelXMargin)(axisName, options);
    return Object.assign(Object.assign({ labels,
        viewLabels,
        pointOnColumn,
        labelDistance,
        tickDistance,
        tickCount,
        labelRange,
        rectResponderCount, isLabelAxis: true }, initialAxisData), (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getMaxLabelSize)(labels, axisLabelMargin, (0,_helpers_style__WEBPACK_IMPORTED_MODULE_3__.getTitleFontString)(theme.label)));
}
function getValueAxisData(stateProp) {
    var _a;
    const { scale, axisSize, series, options, centerYAxis, initialAxisData, theme, labelOnYAxis, axisName, } = stateProp;
    const { limit, stepSize } = scale;
    const size = centerYAxis ? (_a = centerYAxis) === null || _a === void 0 ? void 0 : _a.xAxisHalfSize : axisSize;
    const divergingBoxSeries = isDivergingBoxSeries(series, options);
    const formatter = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getAxisFormatter)(options, axisName);
    const zeroPosition = getZeroPosition(limit, axisSize, (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.isLabelAxisOnYAxis)({ series, options }), divergingBoxSeries);
    let valueLabels = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_2__.makeLabelsFromLimit)(limit, stepSize);
    if (!centerYAxis && divergingBoxSeries) {
        valueLabels = getDivergingValues(valueLabels);
    }
    const labels = valueLabels.map((label, index) => formatter(label, { index, labels: valueLabels, axisName }));
    const tickDistance = size / Math.max(valueLabels.length, 1);
    const tickCount = valueLabels.length;
    const pointOnColumn = false;
    const viewLabels = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getViewAxisLabels)(Object.assign({ labels: labelOnYAxis ? labels : [...labels].reverse(), pointOnColumn,
        tickDistance,
        tickCount }, initialAxisData), size);
    const axisLabelMargin = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getLabelXMargin)(axisName, options);
    const axisData = Object.assign(Object.assign({ labels,
        viewLabels,
        pointOnColumn, isLabelAxis: false, tickCount,
        tickDistance }, initialAxisData), (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getMaxLabelSize)(labels, axisLabelMargin, (0,_helpers_style__WEBPACK_IMPORTED_MODULE_3__.getTitleFontString)(theme.label)));
    if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(zeroPosition)) {
        axisData.zeroPosition = zeroPosition;
    }
    return axisData;
}
function getDivergingValues(valueLabels) {
    return (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.hasNegativeOnly)(valueLabels)
        ? valueLabels.reverse().slice(1).concat(valueLabels)
        : valueLabels.slice(1).reverse().concat(valueLabels);
}
function makeDefaultAxisData(isLabelAxis, params) {
    var _a, _b;
    const axisData = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getInitAxisIntervalData)(isLabelAxis, params);
    const title = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.makeTitleOption)((_b = (_a = params) === null || _a === void 0 ? void 0 : _a.axis) === null || _b === void 0 ? void 0 : _b.title);
    if (title) {
        axisData.title = title;
    }
    return axisData;
}
function getInitialAxisData(options, labelOnYAxis, categories, layout, isCoordinateTypeChart) {
    var _a, _b, _c;
    const { yAxis, secondaryYAxis } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getYAxisOption)(options);
    const shift = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.shift;
    return {
        xAxis: makeDefaultAxisData(!labelOnYAxis, {
            categories,
            axis: (_c = options) === null || _c === void 0 ? void 0 : _c.xAxis,
            layout,
            shift,
            isCoordinateTypeChart,
        }),
        yAxis: makeDefaultAxisData(labelOnYAxis, { axis: yAxis }),
        secondaryYAxis: secondaryYAxis
            ? makeDefaultAxisData(labelOnYAxis, { axis: secondaryYAxis })
            : null,
    };
}
function getSecondaryYAxisData({ state, labelOnYAxis, valueAxisSize, labelAxisSize, initialAxisData, isCoordinateTypeChart, }) {
    var _a, _b;
    const { scale, options, series, theme } = state;
    const categories = state.categories;
    return labelOnYAxis
        ? getLabelAxisData({
            scale: scale.secondaryYAxis,
            axisSize: labelAxisSize,
            categories: (_b = (_a = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getYAxisOption)(options).secondaryYAxis) === null || _a === void 0 ? void 0 : _a.categories, (_b !== null && _b !== void 0 ? _b : categories)),
            options,
            series,
            theme: (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getAxisTheme)(theme, _component_axis__WEBPACK_IMPORTED_MODULE_4__.AxisType.SECONDARY_Y),
            initialAxisData,
            isCoordinateTypeChart,
            axisName: _component_axis__WEBPACK_IMPORTED_MODULE_4__.AxisType.SECONDARY_Y,
        })
        : getValueAxisData({
            scale: scale.secondaryYAxis,
            axisSize: valueAxisSize,
            options,
            series,
            theme: (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getAxisTheme)(theme, _component_axis__WEBPACK_IMPORTED_MODULE_4__.AxisType.SECONDARY_Y),
            centerYAxis: null,
            initialAxisData,
            axisName: _component_axis__WEBPACK_IMPORTED_MODULE_4__.AxisType.SECONDARY_Y,
        });
}
function makeXAxisData({ axisData, axisSize, axisLayout, centerYAxis, rotatable, labelMargin = 0, }) {
    const { viewLabels, pointOnColumn, maxLabelWidth, maxLabelHeight } = axisData;
    const offsetY = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_2__.getAxisLabelAnchorPoint)(maxLabelHeight) + labelMargin;
    const size = centerYAxis ? centerYAxis.xAxisHalfSize : axisSize;
    const distance = size / (viewLabels.length - (pointOnColumn ? 0 : 1));
    const rotationData = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.makeRotationData)(maxLabelWidth, maxLabelHeight, distance, rotatable, axisLayout);
    const { needRotateLabel, rotationHeight } = rotationData;
    const maxHeight = (needRotateLabel ? rotationHeight : maxLabelHeight) + offsetY;
    return Object.assign(Object.assign(Object.assign({}, axisData), rotationData), { maxHeight,
        offsetY });
}
function getAxisInfo(labelOnYAxis, plot, series) {
    const { valueAxisName, labelAxisName } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getAxisName)(labelOnYAxis, series);
    const { valueSizeKey, labelSizeKey } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getSizeKey)(labelOnYAxis);
    const valueAxisSize = plot[valueSizeKey];
    const labelAxisSize = plot[labelSizeKey];
    return { valueAxisName, valueAxisSize, labelAxisName, labelAxisSize };
}
function getCategoriesWithTypes(categories, rawCategories) {
    var _a, _b;
    return {
        categories: (_a = categories, (_a !== null && _a !== void 0 ? _a : [])),
        rawCategories: (_b = rawCategories, (_b !== null && _b !== void 0 ? _b : [])),
    };
}
const axes = {
    name: 'axes',
    state: ({ series, options }) => {
        const { secondaryYAxis } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getYAxisOption)(options);
        const axesState = {
            xAxis: {},
            yAxis: {},
        };
        if (!!series.bar && isCenterYAxis(options)) {
            axesState.centerYAxis = {};
        }
        if (secondaryYAxis) {
            axesState.secondaryYAxis = {};
        }
        return {
            axes: axesState,
        };
    },
    action: {
        setAxesData({ state, initStoreState }) {
            var _a, _b;
            const { scale, options, series, layout, theme } = state;
            const { xAxis, yAxis, plot } = layout;
            const isCoordinateTypeChart = (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_5__.isCoordinateSeries)(initStoreState.series);
            const labelOnYAxis = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.isLabelAxisOnYAxis)({ series, options });
            const { categories } = getCategoriesWithTypes(state.categories, state.rawCategories);
            const { valueAxisName, valueAxisSize, labelAxisName, labelAxisSize } = getAxisInfo(labelOnYAxis, plot, series);
            const hasCenterYAxis = state.axes.centerYAxis;
            const initialAxisData = getInitialAxisData(options, labelOnYAxis, categories, layout, isCoordinateTypeChart);
            const valueAxisData = getValueAxisData({
                scale: scale[valueAxisName],
                axisSize: valueAxisSize,
                options,
                series,
                theme: (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getAxisTheme)(theme, valueAxisName),
                centerYAxis: hasCenterYAxis
                    ? {
                        xAxisHalfSize: (xAxis.width - yAxis.width) / 2,
                    }
                    : null,
                initialAxisData: initialAxisData[valueAxisName],
                labelOnYAxis,
                axisName: valueAxisName,
            });
            const labelAxisData = getLabelAxisData({
                scale: scale[labelAxisName],
                axisSize: labelAxisSize,
                categories,
                options,
                series,
                theme: (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getAxisTheme)(theme, labelAxisName),
                initialAxisData: initialAxisData[labelAxisName],
                isCoordinateTypeChart,
                labelOnYAxis,
                axisName: labelAxisName,
            });
            let secondaryYAxis, centerYAxis;
            if (state.axes.secondaryYAxis) {
                secondaryYAxis = getSecondaryYAxisData({
                    state,
                    labelOnYAxis,
                    valueAxisSize,
                    labelAxisSize,
                    labelAxisName,
                    valueAxisName,
                    initialAxisData: initialAxisData.secondaryYAxis,
                    isCoordinateTypeChart,
                });
            }
            if (hasCenterYAxis) {
                const xAxisHalfSize = (xAxis.width - yAxis.width) / 2;
                centerYAxis = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.deepMergedCopy)(valueAxisData, {
                    x: xAxis.x + xAxisHalfSize,
                    xAxisHalfSize,
                    secondStartX: (xAxis.width + yAxis.width) / 2,
                    yAxisLabelAnchorPoint: yAxis.width / 2,
                    yAxisHeight: yAxis.height,
                });
            }
            const axesState = {
                xAxis: makeXAxisData({
                    axisData: labelOnYAxis ? valueAxisData : labelAxisData,
                    axisSize: labelOnYAxis ? valueAxisSize : labelAxisSize,
                    axisLayout: layout.xAxis,
                    centerYAxis,
                    rotatable: (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getRotatableOption)(options),
                    labelMargin: (_b = (_a = options.xAxis) === null || _a === void 0 ? void 0 : _a.label) === null || _b === void 0 ? void 0 : _b.margin,
                }),
                yAxis: labelOnYAxis ? labelAxisData : valueAxisData,
                secondaryYAxis,
                centerYAxis,
            };
            if ((0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.hasAxesLayoutChanged)(state.axes, axesState)) {
                this.notify(state, 'layout');
            }
            state.axes = axesState;
        },
    },
    computed: {},
    observe: {
        updateAxes() {
            this.dispatch('setAxesData');
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (axes);


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/category.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/category.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeRawCategories": () => (/* binding */ makeRawCategories),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_coordinate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/coordinate */ "./node_modules/@toast-ui/chart/dist/esm/helpers/coordinate.js");
/* harmony import */ var _helpers_range__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/range */ "./node_modules/@toast-ui/chart/dist/esm/helpers/range.js");



function makeRawCategories(series, categories) {
    if (categories) {
        return categories;
    }
    const firstValues = new Set();
    Object.keys(series).forEach((key) => {
        var _a;
        if (key === 'pie' || key === 'gauge') {
            return;
        }
        (_a = series[key].data, (_a !== null && _a !== void 0 ? _a : series[key])).forEach(({ data, name, visible }) => {
            if (Array.isArray(data)) {
                data.forEach((datum) => {
                    if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNull)(datum)) {
                        const rawXValue = (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_1__.getCoordinateXValue)(datum);
                        firstValues.add((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(rawXValue) ? rawXValue : rawXValue.toString());
                    }
                });
            }
            else if ((key === 'bullet' && (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(visible)) || visible) {
                firstValues.add(name);
            }
        });
    });
    return Array.from(firstValues)
        .sort(_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.sortCategories)
        .map((category) => String(category));
}
const category = {
    name: 'category',
    state: ({ categories, series }) => ({
        categories: makeRawCategories(series, categories),
    }),
    action: {
        setCategory({ state, computed }) {
            const { viewRange } = computed;
            let categories = state.rawCategories;
            if (viewRange) {
                if (Array.isArray(categories)) {
                    categories = (0,_helpers_range__WEBPACK_IMPORTED_MODULE_2__.getDataInRange)(categories, viewRange);
                }
                else {
                    categories = Object.assign(Object.assign({}, categories), { x: (0,_helpers_range__WEBPACK_IMPORTED_MODULE_2__.getDataInRange)(categories.x, viewRange) });
                }
            }
            state.categories = categories;
            this.notify(state, 'categories');
        },
        initCategory({ initStoreState, state }) {
            const { zoomRange } = state;
            let categories = makeRawCategories(initStoreState.series);
            if (zoomRange && Array.isArray(categories)) {
                categories = (0,_helpers_range__WEBPACK_IMPORTED_MODULE_2__.getDataInRange)(categories, zoomRange);
            }
            state.categories = categories;
            this.notify(state, 'categories');
        },
        removeCategoryByName({ state }, name) {
            const index = state.categories.findIndex((seriesName) => seriesName === name);
            state.categories.splice(index, 1);
            this.notify(state, 'axes');
        },
    },
    observe: {
        updateCategory() {
            this.dispatch('setCategory');
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (category);


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/colorValueScale.js":
/*!************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/colorValueScale.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./store */ "./node_modules/@toast-ui/chart/dist/esm/store/store.js");
/* harmony import */ var _scale_coordinateScaleCalculator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../scale/coordinateScaleCalculator */ "./node_modules/@toast-ui/chart/dist/esm/scale/coordinateScaleCalculator.js");
/* harmony import */ var _dataRange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dataRange */ "./node_modules/@toast-ui/chart/dist/esm/store/dataRange.js");
/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layout */ "./node_modules/@toast-ui/chart/dist/esm/store/layout.js");
/* harmony import */ var _treemapSeriesData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./treemapSeriesData */ "./node_modules/@toast-ui/chart/dist/esm/store/treemapSeriesData.js");





const colorValueScale = {
    name: 'colorValueScale',
    state: () => ({
        treemapZoomId: {
            prev: _treemapSeriesData__WEBPACK_IMPORTED_MODULE_0__.TREEMAP_ROOT_ID,
            cur: _treemapSeriesData__WEBPACK_IMPORTED_MODULE_0__.TREEMAP_ROOT_ID,
        },
        colorValueScale: {},
    }),
    action: {
        setColorValueScale({ state }) {
            const { layout, treemapSeries, legend, heatmapSeries } = state;
            if (!legend.useSpectrumLegend) {
                return;
            }
            const series = (treemapSeries !== null && treemapSeries !== void 0 ? treemapSeries : heatmapSeries.flatMap((value) => value));
            const values = series.reduce((acc, { colorValue }) => (colorValue ? [...acc, colorValue] : acc), []);
            const dataRange = (0,_dataRange__WEBPACK_IMPORTED_MODULE_1__.getLimitSafely)([...new Set(values)]);
            const offsetSize = (0,_layout__WEBPACK_IMPORTED_MODULE_2__.isVerticalAlign)(legend.align) ? layout.plot.width / 2 : layout.plot.height;
            (0,_store__WEBPACK_IMPORTED_MODULE_3__.extend)(state.colorValueScale, (0,_scale_coordinateScaleCalculator__WEBPACK_IMPORTED_MODULE_4__.calculateCoordinateScale)({
                dataRange,
                offsetSize,
                useSpectrumLegend: true,
                scaleOption: {},
            }));
        },
        setTreemapZoomId({ state }, id) {
            state.treemapZoomId.prev = state.treemapZoomId.cur;
            state.treemapZoomId.cur = id;
        },
        zoomBack({ state }) {
            var _a, _b;
            const { treemapSeries, treemapZoomId } = state;
            const { prev } = treemapZoomId;
            const prevSeries = treemapSeries.find(({ id }) => id === prev);
            state.treemapZoomId.prev = (_b = (_a = prevSeries) === null || _a === void 0 ? void 0 : _a.parentId, (_b !== null && _b !== void 0 ? _b : _treemapSeriesData__WEBPACK_IMPORTED_MODULE_0__.TREEMAP_ROOT_ID));
            state.treemapZoomId.cur = prev;
        },
    },
    observe: {
        updateColorValueScale() {
            this.dispatch('setColorValueScale');
        },
    },
    computed: {
        isTreemapSeriesZooming: ({ treemapZoomId }) => {
            return treemapZoomId && treemapZoomId.cur !== treemapZoomId.prev;
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (colorValueScale);


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/dataRange.js":
/*!******************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/dataRange.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getLimitSafely": () => (/* binding */ getLimitSafely),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./store */ "./node_modules/@toast-ui/chart/dist/esm/store/store.js");
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _helpers_coordinate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/coordinate */ "./node_modules/@toast-ui/chart/dist/esm/helpers/coordinate.js");
/* harmony import */ var _helpers_range__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/range */ "./node_modules/@toast-ui/chart/dist/esm/helpers/range.js");
/* harmony import */ var _component_axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");






function getLimitSafely(baseValues, isXAxis = false) {
    const limit = {
        min: Math.min(...baseValues),
        max: Math.max(...baseValues),
    };
    if (baseValues.length === 1) {
        const [firstValue] = baseValues;
        if (isXAxis) {
            limit.min = firstValue;
            limit.max = firstValue;
        }
        else if (firstValue > 0) {
            limit.min = 0;
        }
        else if (firstValue === 0) {
            limit.max = 10;
        }
        else {
            limit.max = 0;
        }
    }
    else if (limit.min === 0 && limit.max === 0) {
        limit.max = 10;
    }
    else if (limit.min === limit.max) {
        limit.min -= limit.min / 10;
        limit.max += limit.max / 10;
    }
    return limit;
}
function initDataRange(accDataRangeValue, curDataRangeValue, axisName) {
    var _a, _b, _c, _d;
    const defaultDataRange = {
        min: Number.MAX_SAFE_INTEGER,
        max: Number.MIN_SAFE_INTEGER,
    };
    return {
        min: Math.min(curDataRangeValue[axisName].min, (_b = (_a = accDataRangeValue[axisName]) === null || _a === void 0 ? void 0 : _a.min, (_b !== null && _b !== void 0 ? _b : defaultDataRange.min))),
        max: Math.max(curDataRangeValue[axisName].max, (_d = (_c = accDataRangeValue[axisName]) === null || _c === void 0 ? void 0 : _c.max, (_d !== null && _d !== void 0 ? _d : defaultDataRange.max))),
    };
}
function getTotalDataRange(seriesDataRange) {
    return Object.values(seriesDataRange).reduce((acc, cur) => {
        if (cur.xAxis) {
            acc.xAxis = initDataRange(acc, cur, 'xAxis');
        }
        if (cur.yAxis) {
            acc.yAxis = initDataRange(acc, cur, 'yAxis');
        }
        if (cur.secondaryYAxis) {
            acc.secondaryYAxis = initDataRange(acc, cur, 'secondaryYAxis');
        }
        if (cur.circularAxis) {
            acc.circularAxis = initDataRange(acc, cur, 'circularAxis');
        }
        if (cur.verticalAxis) {
            acc.verticalAxis = initDataRange(acc, cur, 'verticalAxis');
        }
        return acc;
    }, {});
}
function setSeriesDataRange({ options, seriesName, values, valueAxisName, seriesDataRange, }) {
    var _a;
    let axisNames;
    if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.includes)([_component_axis__WEBPACK_IMPORTED_MODULE_1__.AxisType.X, _component_axis__WEBPACK_IMPORTED_MODULE_1__.AxisType.CIRCULAR, _component_axis__WEBPACK_IMPORTED_MODULE_1__.AxisType.VERTICAL], valueAxisName)) {
        axisNames = [valueAxisName];
    }
    else {
        const optionsUsingYAxis = options;
        const { secondaryYAxis } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_2__.getYAxisOption)(optionsUsingYAxis);
        axisNames =
            (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_2__.hasSecondaryYAxis)(optionsUsingYAxis) && ((_a = secondaryYAxis) === null || _a === void 0 ? void 0 : _a.chartType)
                ? [secondaryYAxis.chartType === seriesName ? 'secondaryYAxis' : 'yAxis']
                : (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_2__.getValueAxisNames)(optionsUsingYAxis, valueAxisName);
    }
    axisNames.forEach((axisName) => {
        seriesDataRange[seriesName][axisName] = getLimitSafely([...new Set(values)]);
    });
    return seriesDataRange;
}
function getBoxPlotValues(series, seriesName) {
    return series[seriesName].data.flatMap(({ data, outliers = [] }) => [
        ...((data !== null && data !== void 0 ? data : [])).flatMap((datum) => datum),
        ...((outliers !== null && outliers !== void 0 ? outliers : [])).flatMap((datum) => datum),
    ]);
}
function getBulletValues(series, seriesName) {
    return series[seriesName].data.flatMap(({ data, markers, ranges }) => [
        data,
        ...((markers !== null && markers !== void 0 ? markers : [])).flatMap((datum) => datum),
        ...((ranges !== null && ranges !== void 0 ? ranges : [])).flatMap((range) => range),
    ]);
}
function getCoordinateDataValues(values, categories, hasDateValue) {
    const yAxisValues = values
        .filter((value) => !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNull)(value))
        .map((value) => (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_3__.getCoordinateYValue)(value));
    const xAxisValues = categories.map((value) => hasDateValue ? Number(new Date(value)) : Number(value));
    return { xAxisValues, yAxisValues };
}
const dataRange = {
    name: 'dataRange',
    state: () => ({
        dataRange: {},
    }),
    action: {
        setDataRange({ state, initStoreState }) {
            const { series, disabledSeries, stackSeries, categories, options } = state;
            const seriesDataRange = {};
            const labelAxisOnYAxis = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_2__.isLabelAxisOnYAxis)({ series, options, categories });
            const { labelAxisName, valueAxisName } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_2__.getAxisName)(labelAxisOnYAxis, series);
            Object.keys(series).forEach((seriesName) => {
                var _a, _b;
                seriesDataRange[seriesName] = {};
                let values = series[seriesName].data.flatMap(({ data, name }) => disabledSeries.includes(name) ? [] : data);
                const firstExistValue = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.getFirstValidValue)(values);
                if ((0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_3__.isCoordinateSeries)(initStoreState.series)) {
                    const hasDateValue = !!((_a = options.xAxis) === null || _a === void 0 ? void 0 : _a.date);
                    const { yAxisValues, xAxisValues } = getCoordinateDataValues(values, categories, hasDateValue);
                    values = yAxisValues;
                    seriesDataRange[seriesName][labelAxisName] = getLimitSafely([...xAxisValues], true);
                }
                else if (!series[seriesName].data.length) {
                    values = [];
                }
                else if ((0,_helpers_range__WEBPACK_IMPORTED_MODULE_4__.isRangeValue)(firstExistValue)) {
                    values = values.reduce((arr, value) => {
                        if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNull)(value)) {
                            return arr;
                        }
                        return Array.isArray(value) ? [...arr, ...value] : [...value];
                    }, []);
                }
                else if (stackSeries && ((_b = stackSeries[seriesName]) === null || _b === void 0 ? void 0 : _b.stack)) {
                    values = stackSeries[seriesName].dataRangeValues;
                }
                else if (seriesName === 'boxPlot') {
                    values = getBoxPlotValues(series, seriesName);
                }
                else if (seriesName === 'bullet') {
                    values = getBulletValues(series, seriesName);
                }
                if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.includes)(['bar', 'column', 'radar', 'bullet'], seriesName)) {
                    values.push(0);
                }
                setSeriesDataRange({
                    options,
                    seriesName,
                    values,
                    valueAxisName,
                    seriesDataRange,
                });
            });
            const newDataRange = getTotalDataRange(seriesDataRange);
            (0,_store__WEBPACK_IMPORTED_MODULE_5__.extend)(state.dataRange, newDataRange);
        },
    },
    observe: {
        updateDataRange() {
            this.dispatch('setDataRange');
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dataRange);


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/gaugeAxes.js":
/*!******************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/gaugeAxes.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DATA_LABEL_MARGIN": () => (/* binding */ DATA_LABEL_MARGIN),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _helpers_sector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/sector */ "./node_modules/@toast-ui/chart/dist/esm/helpers/sector.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _radialAxes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./radialAxes */ "./node_modules/@toast-ui/chart/dist/esm/store/radialAxes.js");
/* harmony import */ var _helpers_plot__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/plot */ "./node_modules/@toast-ui/chart/dist/esm/helpers/plot.js");







const DEFAULT_LABEL_PADDING = 15;
const RANGE_BAR_MARGIN = 10;
const CLOCK_HAND_MARGIN = 10;
const DATA_LABEL_MARGIN = 30;
function makeSolidData(outerRadius, barWidth, solidOptions) {
    const initialSolidOptions = (solidOptions !== null && solidOptions !== void 0 ? solidOptions : false);
    const solidBarWidth = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.calculateSizeWithPercentString)(outerRadius, barWidth);
    const defaultSolidOptions = {
        visible: true,
        radiusRange: {
            inner: outerRadius - solidBarWidth,
            outer: outerRadius,
        },
        barWidth: solidBarWidth,
        clockHand: false,
    };
    if (!initialSolidOptions) {
        return Object.assign(Object.assign({}, defaultSolidOptions), { visible: false });
    }
    return (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(initialSolidOptions)
        ? Object.assign(Object.assign({}, defaultSolidOptions), initialSolidOptions) : defaultSolidOptions;
}
function getCircularAxisData({ labels, intervalData, circularAxisLabelMargin, circularAxisLabelFont, defaultAxisData, bandWidth, options, solidBarWidth, }) {
    var _a, _b, _c, _d;
    const { maxLabelWidth, maxLabelHeight } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getMaxLabelSize)(labels, circularAxisLabelMargin, circularAxisLabelFont);
    const { totalAngle, axisSize, centerX, centerY, startAngle, endAngle, drawingStartAngle, clockwise, } = defaultAxisData;
    const { tickInterval, labelInterval } = intervalData;
    const outerRadius = axisSize - bandWidth - RANGE_BAR_MARGIN;
    const solidBarWidthValue = (solidBarWidth !== null && solidBarWidth !== void 0 ? solidBarWidth : outerRadius * 0.1);
    const solidData = makeSolidData(outerRadius - circularAxisLabelMargin - maxLabelHeight - (circularAxisLabelMargin - 5), solidBarWidthValue, (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.solid);
    const centralAngle = totalAngle / (labels.length + (totalAngle < _helpers_sector__WEBPACK_IMPORTED_MODULE_2__.DEGREE_360 ? -1 : _helpers_sector__WEBPACK_IMPORTED_MODULE_2__.DEGREE_0));
    const maxClockHandSize = outerRadius -
        circularAxisLabelMargin -
        maxLabelHeight -
        CLOCK_HAND_MARGIN +
        (solidData.visible ? -solidData.barWidth - CLOCK_HAND_MARGIN : 0);
    return {
        axisSize,
        centerX,
        centerY,
        label: {
            labels,
            interval: labelInterval,
            margin: circularAxisLabelMargin,
            maxWidth: maxLabelWidth,
            maxHeight: maxLabelHeight,
        },
        radius: {
            inner: 0,
            outer: outerRadius,
        },
        angle: {
            start: startAngle,
            end: endAngle,
            total: totalAngle,
            central: centralAngle,
            drawingStart: drawingStartAngle,
        },
        band: {
            width: bandWidth,
            margin: RANGE_BAR_MARGIN,
        },
        tickInterval,
        clockwise,
        maxClockHandSize,
        title: (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.makeTitleOption)((_d = (_c = options) === null || _c === void 0 ? void 0 : _c.circularAxis) === null || _d === void 0 ? void 0 : _d.title),
        solidData,
    };
}
function makeLabels(options, rawLabels, axisName) {
    var _a, _b, _c;
    const formatter = (_c = (_b = (_a = options[axisName]) === null || _a === void 0 ? void 0 : _a.label) === null || _b === void 0 ? void 0 : _b.formatter, (_c !== null && _c !== void 0 ? _c : ((value) => value)));
    return rawLabels.map((label, index) => formatter(label, { index, labels: rawLabels, axisName }));
}
function getAxisLabels(isLabelOnVerticalAxis, options, categories, scale) {
    const valueAxisName = isLabelOnVerticalAxis
        ? _radialAxes__WEBPACK_IMPORTED_MODULE_3__.RadialAxisType.CIRCULAR
        : _radialAxes__WEBPACK_IMPORTED_MODULE_3__.RadialAxisType.VERTICAL;
    const { limit, stepSize } = scale[valueAxisName];
    const valueLabels = makeLabels(options, (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_4__.makeLabelsFromLimit)(limit, stepSize), valueAxisName);
    const categoryLabels = makeLabels(options, categories, isLabelOnVerticalAxis ? _radialAxes__WEBPACK_IMPORTED_MODULE_3__.RadialAxisType.VERTICAL : _radialAxes__WEBPACK_IMPORTED_MODULE_3__.RadialAxisType.CIRCULAR);
    return isLabelOnVerticalAxis ? valueLabels : categoryLabels;
}
function getAxisLabelMargin(options) {
    var _a, _b, _c, _d;
    return _d = (_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.circularAxis) === null || _b === void 0 ? void 0 : _b.label) === null || _c === void 0 ? void 0 : _c.margin, (_d !== null && _d !== void 0 ? _d : DEFAULT_LABEL_PADDING);
}
function hasAxesLayoutChanged(previousAxes, currentAxes) {
    var _a, _b, _c, _d;
    const prevMaxWidth = (_b = (_a = previousAxes) === null || _a === void 0 ? void 0 : _a.label) === null || _b === void 0 ? void 0 : _b.maxWidth;
    const prevMaxHeight = (_d = (_c = previousAxes) === null || _c === void 0 ? void 0 : _c.label) === null || _d === void 0 ? void 0 : _d.maxHeight;
    const curMaxWidth = currentAxes.label.maxWidth;
    const curMaxHeight = currentAxes.label.maxHeight;
    return prevMaxHeight !== curMaxHeight || prevMaxWidth !== curMaxWidth;
}
const axes = {
    name: 'gaugeAxes',
    state: () => ({
        radialAxes: {
            circularAxis: {},
        },
    }),
    action: {
        setCircularAxisData({ state }) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
            const { series, layout, scale } = state;
            const categories = state.categories;
            const { plot } = layout;
            const isLabelOnVerticalAxis = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.isLabelAxisOnYAxis)({ series, categories });
            const options = state.options;
            const theme = state.theme;
            const circularAxisLabelFont = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_5__.getTitleFontString)(theme.circularAxis.label);
            const circularAxisLabelMargin = getAxisLabelMargin(options);
            const circularAxisLabels = getAxisLabels(isLabelOnVerticalAxis, options, categories, scale);
            const { maxLabelWidth, maxLabelHeight } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getMaxLabelSize)(circularAxisLabels, circularAxisLabelMargin, circularAxisLabelFont);
            const defaultAxisData = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getDefaultRadialAxisData)(options, plot, maxLabelWidth, maxLabelHeight, isLabelOnVerticalAxis);
            const dataLabelHeight = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_4__.getFontHeight)((0,_helpers_style__WEBPACK_IMPORTED_MODULE_5__.getTitleFontString)(theme.series.gauge.dataLabels));
            const dataLabelOffsetY = (_d = (_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.dataLabels) === null || _c === void 0 ? void 0 : _c.offsetY, (_d !== null && _d !== void 0 ? _d : DATA_LABEL_MARGIN));
            if (defaultAxisData.isSemiCircular) {
                defaultAxisData.centerY =
                    defaultAxisData.centerY - (dataLabelOffsetY > 0 ? dataLabelOffsetY + dataLabelHeight : 0);
                const diffHeight = defaultAxisData.centerY - defaultAxisData.axisSize;
                defaultAxisData.axisSize += diffHeight < 0 ? diffHeight : 0;
            }
            const defualtBandWidth = ((_g = (_f = (_e = options) === null || _e === void 0 ? void 0 : _e.plot) === null || _f === void 0 ? void 0 : _f.bands) === null || _g === void 0 ? void 0 : _g.length) ? defaultAxisData.axisSize / 2 - RANGE_BAR_MARGIN
                : 0;
            const bandWidth = (_k = (_j = (_h = theme.plot) === null || _h === void 0 ? void 0 : _h.bands) === null || _j === void 0 ? void 0 : _j.barWidth, (_k !== null && _k !== void 0 ? _k : defualtBandWidth));
            const circularAxisData = getCircularAxisData({
                labels: circularAxisLabels,
                intervalData: (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getInitAxisIntervalData)(true, {
                    axis: options.circularAxis,
                    categories,
                    layout,
                }),
                defaultAxisData,
                circularAxisLabelMargin,
                circularAxisLabelFont,
                bandWidth,
                options,
                solidBarWidth: (_m = (_l = theme.series.gauge) === null || _l === void 0 ? void 0 : _l.solid) === null || _m === void 0 ? void 0 : _m.barWidth,
            });
            if (hasAxesLayoutChanged((_o = state.radialAxes) === null || _o === void 0 ? void 0 : _o.circularAxis, circularAxisData)) {
                this.notify(state, 'layout');
            }
            state.radialAxes = {
                circularAxis: circularAxisData,
            };
        },
        addGaugePlotBand({ state }, { data }) {
            var _a, _b, _c;
            const bands = (_c = (_b = (_a = state.options) === null || _a === void 0 ? void 0 : _a.plot) === null || _b === void 0 ? void 0 : _b.bands, (_c !== null && _c !== void 0 ? _c : []));
            if (!(0,_helpers_plot__WEBPACK_IMPORTED_MODULE_6__.isExistPlotId)(bands, data)) {
                this.dispatch('updateOptions', { options: { plot: { bands: [...bands, data] } } });
            }
        },
        removeGaugePlotBand({ state }, { id }) {
            var _a, _b, _c;
            const bands = (_c = (_b = (_a = state.options) === null || _a === void 0 ? void 0 : _a.plot) === null || _b === void 0 ? void 0 : _b.bands, (_c !== null && _c !== void 0 ? _c : [])).filter(({ id: bandId }) => bandId !== id);
            this.dispatch('updateOptions', { options: { plot: { bands } } });
        },
    },
    observe: {
        updateRadialAxes() {
            this.dispatch('setCircularAxisData');
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (axes);


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/heatmapAxes.js":
/*!********************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/heatmapAxes.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/axis */ "./node_modules/@toast-ui/chart/dist/esm/component/axis.js");
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");




function getHeatmapAxisData(stateProp, axisType) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const { categories, axisSize, axisLayout, options, theme } = stateProp;
    const isLabelAxis = axisType === _component_axis__WEBPACK_IMPORTED_MODULE_0__.AxisType.X;
    const axisName = isLabelAxis ? 'x' : 'y';
    const dateType = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.isDateType)(options, axisType);
    const labels = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getLabelsAppliedFormatter)(categories[axisName], options, dateType, axisType);
    const tickIntervalCount = labels.length;
    const tickDistance = tickIntervalCount ? axisSize / tickIntervalCount : axisSize;
    const labelDistance = axisSize / tickIntervalCount;
    const pointOnColumn = true;
    const tickCount = tickIntervalCount + 1;
    const tickInterval = (_c = (_b = (_a = options[axisType]) === null || _a === void 0 ? void 0 : _a.tick) === null || _b === void 0 ? void 0 : _b.interval, (_c !== null && _c !== void 0 ? _c : 1));
    const labelInterval = (_f = (_e = (_d = options[axisType]) === null || _d === void 0 ? void 0 : _d.label) === null || _e === void 0 ? void 0 : _e.interval, (_f !== null && _f !== void 0 ? _f : 1));
    const viewLabels = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getViewAxisLabels)({
        labels,
        pointOnColumn,
        tickDistance,
        tickCount,
        tickInterval,
        labelInterval,
    }, axisSize);
    const labelXMargin = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getLabelXMargin)(axisType, options);
    const { maxLabelWidth, maxLabelHeight } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getMaxLabelSize)(labels, labelXMargin, (0,_helpers_style__WEBPACK_IMPORTED_MODULE_2__.getTitleFontString)(theme.label));
    const axisData = {
        labels,
        viewLabels,
        pointOnColumn,
        isLabelAxis,
        tickCount,
        tickDistance,
        labelDistance,
        tickInterval,
        labelInterval,
        title: (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.makeTitleOption)((_g = options[axisType]) === null || _g === void 0 ? void 0 : _g.title),
        maxLabelWidth,
        maxLabelHeight,
    };
    if (axisType === _component_axis__WEBPACK_IMPORTED_MODULE_0__.AxisType.X) {
        const labelMargin = (_k = (_j = (_h = options.xAxis) === null || _h === void 0 ? void 0 : _h.label) === null || _j === void 0 ? void 0 : _j.margin, (_k !== null && _k !== void 0 ? _k : 0));
        const offsetY = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_3__.getAxisLabelAnchorPoint)(maxLabelHeight) + labelMargin;
        const distance = axisSize / viewLabels.length;
        const rotationData = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.makeRotationData)(maxLabelWidth, maxLabelHeight, distance, (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getRotatableOption)(options), axisLayout);
        const { needRotateLabel, rotationHeight } = rotationData;
        const maxHeight = (needRotateLabel ? rotationHeight : maxLabelHeight) + offsetY;
        return Object.assign(Object.assign(Object.assign({}, axisData), rotationData), { maxHeight,
            offsetY });
    }
    return axisData;
}
const axes = {
    name: 'axes',
    state: () => {
        return {
            axes: {
                xAxis: {},
                yAxis: {},
            },
        };
    },
    action: {
        setAxesData({ state }) {
            const { layout, theme } = state;
            const { width, height } = layout.plot;
            const categories = state.categories;
            const options = state.options;
            const xAxisData = getHeatmapAxisData({
                axisSize: width,
                categories,
                options,
                theme: (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getAxisTheme)(theme, _component_axis__WEBPACK_IMPORTED_MODULE_0__.AxisType.X),
                axisLayout: layout[_component_axis__WEBPACK_IMPORTED_MODULE_0__.AxisType.X],
            }, _component_axis__WEBPACK_IMPORTED_MODULE_0__.AxisType.X);
            const yAxisData = getHeatmapAxisData({
                axisSize: height,
                categories,
                options,
                theme: (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.getAxisTheme)(theme, _component_axis__WEBPACK_IMPORTED_MODULE_0__.AxisType.Y),
            }, _component_axis__WEBPACK_IMPORTED_MODULE_0__.AxisType.Y);
            const axesState = { xAxis: xAxisData, yAxis: yAxisData };
            if ((0,_helpers_axes__WEBPACK_IMPORTED_MODULE_1__.hasAxesLayoutChanged)(state.axes, axesState)) {
                this.notify(state, 'layout');
            }
            state.axes = axesState;
        },
    },
    computed: {},
    observe: {
        updateAxes() {
            this.dispatch('setAxesData');
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (axes);


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/heatmapSeriesData.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/heatmapSeriesData.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_range__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/range */ "./node_modules/@toast-ui/chart/dist/esm/helpers/range.js");

function makeHeatmapSeries(series, categories, viewRange) {
    if (!series.heatmap) {
        return [];
    }
    return series.heatmap.data.map((rowSeries, y) => {
        const { yCategory, data } = rowSeries;
        return (0,_helpers_range__WEBPACK_IMPORTED_MODULE_0__.getDataInRange)(data, viewRange).map((colorValue, x) => ({
            colorValue,
            category: {
                x: categories.x[x],
                y: yCategory,
            },
            indexes: [x, y],
        }));
    });
}
const heatmapSeriesData = {
    name: 'heatmapSeriesData',
    state: () => ({
        heatmapSeries: [],
    }),
    action: {
        setHeatmapSeriesData({ state, computed }) {
            state.heatmapSeries = makeHeatmapSeries(state.series, state.categories, computed.viewRange);
        },
    },
    observe: {
        updateTreemapSeriesData() {
            this.dispatch('setHeatmapSeriesData');
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (heatmapSeriesData);


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/layout.js":
/*!***************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/layout.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "padding": () => (/* binding */ padding),
/* harmony export */   "X_AXIS_HEIGHT": () => (/* binding */ X_AXIS_HEIGHT),
/* harmony export */   "isVerticalAlign": () => (/* binding */ isVerticalAlign),
/* harmony export */   "isUsingResetButton": () => (/* binding */ isUsingResetButton),
/* harmony export */   "isExportMenuVisible": () => (/* binding */ isExportMenuVisible),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./store */ "./node_modules/@toast-ui/chart/dist/esm/store/store.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _axes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./axes */ "./node_modules/@toast-ui/chart/dist/esm/store/axes.js");
/* harmony import */ var _component_exportMenu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/exportMenu */ "./node_modules/@toast-ui/chart/dist/esm/component/exportMenu.js");
/* harmony import */ var _brushes_axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../brushes/axis */ "./node_modules/@toast-ui/chart/dist/esm/brushes/axis.js");
/* harmony import */ var _brushes_spectrumLegend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../brushes/spectrumLegend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/spectrumLegend.js");
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");







const padding = { X: 10, Y: 15 };
const X_AXIS_HEIGHT = 20;
const Y_AXIS_MIN_WIDTH = 40;
function isVerticalAlign(align) {
    return align === 'top' || align === 'bottom';
}
function getValidRectSize(size, width, height) {
    var _a, _b, _c, _d;
    return {
        height: (_b = (_a = size) === null || _a === void 0 ? void 0 : _a.height, (_b !== null && _b !== void 0 ? _b : height)),
        width: (_d = (_c = size) === null || _c === void 0 ? void 0 : _c.width, (_d !== null && _d !== void 0 ? _d : width)),
    };
}
function getDefaultXAxisHeight(size) {
    var _a;
    return ((_a = size.xAxis) === null || _a === void 0 ? void 0 : _a.height) && !size.yAxis ? size.xAxis.height : X_AXIS_HEIGHT;
}
function getDefaultYAxisXPoint(yAxisRectParam) {
    const { yAxisTitle, isRightSide, visibleSecondaryYAxis } = yAxisRectParam;
    const yAxisWidth = getDefaultYAxisWidth(yAxisRectParam);
    return isRightSide && visibleSecondaryYAxis
        ? Math.max(yAxisTitle.x + yAxisTitle.width - yAxisWidth, 0)
        : yAxisTitle.x;
}
function getYAxisXPoint(yAxisRectParam) {
    const { chartSize, legend, circleLegend, hasCenterYAxis, maxLabelWidth } = yAxisRectParam;
    const { width } = chartSize;
    const { align } = legend;
    let yAxisWidth = getDefaultYAxisWidth(yAxisRectParam);
    let x = getDefaultYAxisXPoint(yAxisRectParam);
    if (hasCenterYAxis) {
        yAxisWidth = maxLabelWidth + (_brushes_axis__WEBPACK_IMPORTED_MODULE_0__.TICK_SIZE + padding.X) * 2;
        x = (width - legend.width - yAxisWidth + padding.X * 2) / 2;
    }
    if (legend.visible && align === 'left') {
        x = getDefaultYAxisXPoint(yAxisRectParam);
    }
    if (circleLegend.visible && align === 'left') {
        x = Math.max(circleLegend.width + padding.X, x);
    }
    return x;
}
function getYAxisYPoint({ yAxisTitle }) {
    return yAxisTitle.y + yAxisTitle.height;
}
function getDefaultYAxisWidth({ maxLabelWidth, size, isRightSide }) {
    var _a, _b, _c;
    return _c = (_b = (_a = size) === null || _a === void 0 ? void 0 : _a[isRightSide ? 'secondaryYAxis' : 'yAxis']) === null || _b === void 0 ? void 0 : _b.width, (_c !== null && _c !== void 0 ? _c : maxLabelWidth);
}
function getYAxisWidth(yAxisRectParam) {
    const { hasCenterYAxis, hasXYAxis, maxLabelWidth, visibleSecondaryYAxis = false, isRightSide = false, } = yAxisRectParam;
    let yAxisWidth = getDefaultYAxisWidth(yAxisRectParam);
    if (hasCenterYAxis && !isRightSide) {
        yAxisWidth = maxLabelWidth + (_brushes_axis__WEBPACK_IMPORTED_MODULE_0__.TICK_SIZE + padding.X) * 2;
    }
    else if (!hasXYAxis || (isRightSide && !visibleSecondaryYAxis)) {
        yAxisWidth = 0;
    }
    return yAxisWidth;
}
function getYAxisHeight({ chartSize, legend, yAxisTitle, hasXYAxis, size, xAxisTitleHeight, }) {
    var _a, _b, _c, _d;
    const { height } = chartSize;
    const { align, height: legendHeight } = legend;
    const xAxisHeight = getDefaultXAxisHeight(size);
    const y = yAxisTitle.y + yAxisTitle.height;
    let yAxisHeight = height - y - xAxisHeight - xAxisTitleHeight;
    if (!hasXYAxis) {
        yAxisHeight = height - y;
    }
    if (legend.visible) {
        const topArea = Math.max(y, legendHeight);
        if (align === 'top') {
            yAxisHeight = height - topArea - (hasXYAxis ? X_AXIS_HEIGHT + xAxisTitleHeight : 0);
        }
        else if (align === 'bottom') {
            yAxisHeight = height - y - X_AXIS_HEIGHT - xAxisTitleHeight - legendHeight;
        }
    }
    if (!((_b = (_a = size) === null || _a === void 0 ? void 0 : _a.yAxis) === null || _b === void 0 ? void 0 : _b.height) && ((_d = (_c = size) === null || _c === void 0 ? void 0 : _c.plot) === null || _d === void 0 ? void 0 : _d.height)) {
        yAxisHeight = size.plot.height;
    }
    return yAxisHeight;
}
function getYAxisRect(yAxisRectParam) {
    var _a, _b;
    const { size, isRightSide = false } = yAxisRectParam;
    const x = getYAxisXPoint(yAxisRectParam);
    const y = getYAxisYPoint(yAxisRectParam);
    const yAxisWidth = getYAxisWidth(yAxisRectParam);
    const yAxisHeight = getYAxisHeight(yAxisRectParam);
    return Object.assign({ x,
        y }, getValidRectSize(isRightSide ? (_a = size) === null || _a === void 0 ? void 0 : _a.secondaryYAxis : (_b = size) === null || _b === void 0 ? void 0 : _b.yAxis, yAxisWidth, yAxisHeight));
}
function getXAxisWidth({ chartSize, yAxis, hasCenterYAxis, legend, circleLegend, secondaryYAxis, xAxisData, }) {
    var _a;
    const { width } = chartSize;
    const { align, width: legendWidth } = legend;
    const legendVerticalAlign = isVerticalAlign(align);
    let xAxisWidth;
    if (legendVerticalAlign) {
        xAxisWidth = width - (yAxis.x + yAxis.width + padding.X);
        if (circleLegend.visible) {
            xAxisWidth -= circleLegend.width;
        }
    }
    else {
        xAxisWidth =
            width - (yAxis.width + Math.max(legendWidth, circleLegend.visible ? circleLegend.width : 0));
    }
    if (hasCenterYAxis) {
        xAxisWidth = width - (legendVerticalAlign ? 0 : legendWidth) - padding.X * 2;
    }
    if (secondaryYAxis.width) {
        xAxisWidth -= secondaryYAxis.width;
    }
    if ((_a = xAxisData) === null || _a === void 0 ? void 0 : _a.maxLabelWidth) {
        // subtract half of the maximum label length to secure margin size
        xAxisWidth -= xAxisData.maxLabelWidth * 0.5;
    }
    return xAxisWidth;
}
function getXAxisHeight(xAxisData, hasXYAxis = false) {
    var _a, _b;
    if (!hasXYAxis) {
        return 0;
    }
    return _b = (_a = xAxisData) === null || _a === void 0 ? void 0 : _a.maxHeight, (_b !== null && _b !== void 0 ? _b : X_AXIS_HEIGHT);
}
function getXAxisRect(xAxisRectParam) {
    var _a;
    const { hasXYAxis, hasCenterYAxis, yAxis, size, xAxisData } = xAxisRectParam;
    const x = hasCenterYAxis ? padding.X * 2 : yAxis.x + yAxis.width;
    const y = yAxis.y + yAxis.height;
    const xAxisWidth = getXAxisWidth(xAxisRectParam);
    const xAxisHeight = getXAxisHeight(xAxisData, hasXYAxis);
    return Object.assign({ x,
        y }, getValidRectSize((_a = size) === null || _a === void 0 ? void 0 : _a.xAxis, xAxisWidth, xAxisHeight));
}
function getLegendRect(legendRectParams) {
    const { legend, xAxis, yAxis, chartSize, title, hasXYAxis, secondaryYAxis, xAxisTitleHeight, } = legendRectParams;
    if (!legend.visible) {
        return {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
        };
    }
    const { align, width: legendWidth, height: legendHeight } = legend;
    const { width } = chartSize;
    const verticalAlign = isVerticalAlign(align);
    let x = xAxis.x + xAxis.width + secondaryYAxis.width + padding.X;
    let y = Math.max(yAxis.y, _component_exportMenu__WEBPACK_IMPORTED_MODULE_1__.BUTTON_RECT_SIZE);
    if (verticalAlign) {
        x = (width - legendWidth) / 2;
        if (align === 'top') {
            y = title.y + title.height;
        }
        else {
            y = yAxis.y + yAxis.height + (hasXYAxis ? xAxis.height + xAxisTitleHeight : padding.Y);
        }
    }
    else if (align === 'left') {
        x = padding.X;
    }
    return { width: legendWidth, height: legendHeight, x, y };
}
function getCircleLegendRect(xAxis, yAxis, align, width) {
    return {
        width,
        height: yAxis.height,
        x: align === 'left' ? padding.X : xAxis.x + xAxis.width + padding.X,
        y: yAxis.y,
    };
}
function getPlotRect(xAxis, yAxis, size) {
    return Object.assign({ x: xAxis.x, y: yAxis.y }, getValidRectSize(size, xAxis.width, yAxis.height));
}
function getTitleRect(chartSize, exportMenu, visible, titleHeight) {
    const point = { x: padding.X, y: padding.Y };
    const marginBottom = 5;
    const width = visible ? chartSize.width - exportMenu.width : 0;
    const height = visible
        ? Math.max(titleHeight + marginBottom, exportMenu.height)
        : exportMenu.height;
    return Object.assign({ width, height }, point);
}
function getTopLegendAreaHeight(useSpectrumLegend, legendHeight) {
    return useSpectrumLegend
        ? _brushes_spectrumLegend__WEBPACK_IMPORTED_MODULE_2__.SPECTRUM_LEGEND_LABEL_HEIGHT +
            _brushes_spectrumLegend__WEBPACK_IMPORTED_MODULE_2__.spectrumLegendBar.PADDING * 2 +
            _brushes_spectrumLegend__WEBPACK_IMPORTED_MODULE_2__.spectrumLegendTooltip.POINT_HEIGHT +
            _brushes_spectrumLegend__WEBPACK_IMPORTED_MODULE_2__.spectrumLegendTooltip.HEIGHT +
            padding.Y
        : legendHeight + padding.Y;
}
function getYAxisTitleRect({ chartSize, visible, title, legend: { align: legendAlign, width: legendWidth, height: legendHeight, visible: legendVisible, useSpectrumLegend, }, hasCenterYAxis, visibleSecondaryYAxis, isRightSide = false, yAxisTitleHeight, }) {
    const marginBottom = 5;
    const height = visible ? yAxisTitleHeight + marginBottom : 0;
    const verticalLegendAlign = isVerticalAlign(legendAlign);
    const width = (chartSize.width - (verticalLegendAlign ? padding.X * 2 : legendWidth)) /
        (visibleSecondaryYAxis ? 2 : 1);
    const point = {
        x: isRightSide ? title.x + width : title.x,
        y: title.y + title.height,
    };
    if (legendVisible) {
        if (legendAlign === 'left') {
            point.x += legendWidth;
        }
        else if (legendAlign === 'top') {
            point.y += getTopLegendAreaHeight(useSpectrumLegend, legendHeight);
        }
    }
    if (hasCenterYAxis) {
        point.x = (width + padding.X * 2) / 2;
    }
    return Object.assign({ height, width }, point);
}
function getXAxisTitleRect(visible, xAxis, xAxisTitleHeight) {
    const point = { x: xAxis.x, y: xAxis.y + xAxis.height };
    const height = visible ? xAxisTitleHeight : 0;
    const width = visible ? xAxis.width : 0;
    return Object.assign({ height, width }, point);
}
function getExportMenuRect(chartSize, visible) {
    const marginY = 5;
    const x = visible ? padding.X + chartSize.width - _component_exportMenu__WEBPACK_IMPORTED_MODULE_1__.BUTTON_RECT_SIZE : padding.X + chartSize.width;
    const y = padding.Y;
    const height = visible ? _component_exportMenu__WEBPACK_IMPORTED_MODULE_1__.BUTTON_RECT_SIZE + marginY : 0;
    const width = visible ? _component_exportMenu__WEBPACK_IMPORTED_MODULE_1__.BUTTON_RECT_SIZE : 0;
    return { x, y, height, width };
}
function getResetButtonRect(exportMenu, useResetButton) {
    const marginY = 5;
    const x = useResetButton ? exportMenu.x - _component_exportMenu__WEBPACK_IMPORTED_MODULE_1__.BUTTON_RECT_SIZE - padding.X : 0;
    const y = useResetButton ? exportMenu.y : 0;
    const height = useResetButton ? _component_exportMenu__WEBPACK_IMPORTED_MODULE_1__.BUTTON_RECT_SIZE + marginY : 0;
    const width = useResetButton ? _component_exportMenu__WEBPACK_IMPORTED_MODULE_1__.BUTTON_RECT_SIZE : 0;
    return { x, y, height, width };
}
function isUsingResetButton(options) {
    var _a;
    return !!((_a = options.series) === null || _a === void 0 ? void 0 : _a.zoomable);
}
function isExportMenuVisible(options) {
    var _a;
    const visible = (_a = options.exportMenu) === null || _a === void 0 ? void 0 : _a.visible;
    return (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(visible) ? true : visible;
}
function getYAxisMaxLabelWidth(maxLabelLength) {
    return maxLabelLength ? maxLabelLength + padding.X : Y_AXIS_MIN_WIDTH;
}
function pickOptionSize(option) {
    if (!option || ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(option.width) && (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(option.height))) {
        return null;
    }
    return (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.pick)(option, 'width', 'height');
}
function validOffsetValue(axis, plot, sizeKey) {
    const axisSize = axis[sizeKey];
    const plotSize = plot[sizeKey];
    if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.isNumber)(axisSize) && (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_3__.isNumber)(plotSize)) {
        return Math.max(axisSize, plotSize);
    }
}
function getOptionSize(options) {
    const xAxis = pickOptionSize(options.xAxis);
    const yAxisOptions = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_4__.getYAxisOption)(options);
    const yAxis = pickOptionSize(yAxisOptions.yAxis);
    const secondaryYAxis = pickOptionSize(yAxisOptions.secondaryYAxis);
    const plot = pickOptionSize(options.plot);
    if (plot) {
        /*
        If both the width of the x-axis and the width of the plot are entered,
        set the maximum value.
      */
        if (xAxis) {
            xAxis.width = plot.width = validOffsetValue(xAxis, plot, 'width');
        }
        /*
        If both the height of the y-axis and the height of the plot are entered,
        set the maximum value.
      */
        if (yAxis) {
            yAxis.height = plot.height = validOffsetValue(yAxis, plot, 'height');
        }
        if (secondaryYAxis) {
            secondaryYAxis.height = plot.height = validOffsetValue(secondaryYAxis, plot, 'height');
        }
    }
    return {
        xAxis,
        yAxis,
        plot,
        secondaryYAxis,
    };
}
function getAxisTitleHeight(axisTheme, offsetY = 0) {
    const fontSize = Array.isArray(axisTheme)
        ? Math.max(axisTheme[0].title.fontSize, axisTheme[1].title.fontSize)
        : axisTheme.title.fontSize;
    return fontSize + offsetY;
}
function adjustAxisSize({ width, height }, layout, legendState) {
    if (width < 0 || height < 0) {
        return;
    }
    const { title, yAxisTitle, yAxis, xAxis, xAxisTitle, legend, secondaryYAxis } = layout;
    const { align } = legendState;
    const hasVerticalLegend = isVerticalAlign(align);
    const legendHeight = hasVerticalLegend ? legend.height : 0;
    const diffHeight = xAxis.height +
        xAxisTitle.height +
        yAxis.height +
        yAxisTitle.height +
        title.height +
        legendHeight -
        height;
    if (diffHeight > 0) {
        yAxis.height -= diffHeight;
        xAxis.y -= diffHeight;
        xAxisTitle.y -= diffHeight;
        if (hasVerticalLegend) {
            legend.y -= diffHeight;
        }
    }
    secondaryYAxis.x = xAxis.x + xAxis.width;
    secondaryYAxis.height = yAxis.height;
}
function getCircularAxisTitleRect(plot, axisTheme, circularAxis) {
    var _a, _b;
    if (!circularAxis) {
        return Object.assign({}, plot);
    }
    const { x, y } = plot;
    const { centerX, centerY, axisSize, title, radius: { outer }, } = circularAxis;
    const offsetY = (_b = (_a = title) === null || _a === void 0 ? void 0 : _a.offsetY, (_b !== null && _b !== void 0 ? _b : 0));
    return {
        x: centerX + x - axisSize / 2,
        y: centerY + y - outer / 2,
        width: axisSize,
        height: axisTheme.title.fontSize + offsetY,
    };
}
function hasXYAxes(series) {
    return !(series.pie || series.radar || series.treemap || series.radialBar || series.gauge);
}
function getYAxisOptions(options, hasXYAxis) {
    return hasXYAxis
        ? (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_4__.getYAxisOption)(options)
        : {
            yAxis: null,
            secondaryYAxis: null,
        };
}
const layout = {
    name: 'layout',
    state: () => ({
        layout: {},
    }),
    action: {
        setLayout({ state }) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
            const { legend: legendState, theme, circleLegend: circleLegendState, series, options, chart, axes, radialAxes, } = state;
            const { width, height } = chart;
            const chartSize = {
                height: height - padding.Y * 2,
                width: width - padding.X * 2,
            };
            const hasCenterYAxis = series.bar ? (0,_axes__WEBPACK_IMPORTED_MODULE_5__.isCenterYAxis)(options) : false;
            const hasXYAxis = hasXYAxes(series);
            const optionSize = getOptionSize(options);
            const { yAxis: yAxisOption, secondaryYAxis: secondaryYAxisOption } = getYAxisOptions(options, hasXYAxis);
            const visibleSecondaryYAxis = !!secondaryYAxisOption;
            const titleHeight = theme.title.fontSize;
            const yAxisTitleHeight = (_d = getAxisTitleHeight(theme.yAxis, (_c = (_b = (_a = axes) === null || _a === void 0 ? void 0 : _a.yAxis) === null || _b === void 0 ? void 0 : _b.title) === null || _c === void 0 ? void 0 : _c.offsetY), (_d !== null && _d !== void 0 ? _d : 0));
            const xAxisTitleHeight = (_h = getAxisTitleHeight(theme.xAxis, (_g = (_f = (_e = axes) === null || _e === void 0 ? void 0 : _e.xAxis) === null || _f === void 0 ? void 0 : _f.title) === null || _g === void 0 ? void 0 : _g.offsetY), (_h !== null && _h !== void 0 ? _h : 0));
            // Don't change the order!
            // exportMenu -> resetButton -> title -> yAxis.title -> yAxis -> secondaryYAxisTitle -> secondaryYAxis -> xAxis -> xAxis.title -> legend -> circleLegend -> plot -> circularAxis.title
            const exportMenu = getExportMenuRect(chartSize, isExportMenuVisible(options));
            const resetButton = getResetButtonRect(exportMenu, isUsingResetButton(options));
            const btnAreaRect = exportMenu.height ? exportMenu : resetButton;
            const title = getTitleRect(chartSize, btnAreaRect, !!((_j = options.chart) === null || _j === void 0 ? void 0 : _j.title), titleHeight);
            const yAxisTitleVisible = !!((_k = yAxisOption) === null || _k === void 0 ? void 0 : _k.title) || !!((_l = secondaryYAxisOption) === null || _l === void 0 ? void 0 : _l.title);
            const yAxisTitle = getYAxisTitleRect({
                chartSize,
                visible: yAxisTitleVisible,
                title,
                legend: legendState,
                hasCenterYAxis,
                visibleSecondaryYAxis,
                yAxisTitleHeight,
            });
            const yAxis = getYAxisRect({
                chartSize,
                legend: legendState,
                circleLegend: circleLegendState,
                yAxisTitle,
                hasCenterYAxis,
                hasXYAxis,
                maxLabelWidth: getYAxisMaxLabelWidth((_m = axes) === null || _m === void 0 ? void 0 : _m.yAxis.maxLabelWidth),
                size: optionSize,
                xAxisTitleHeight,
            });
            const secondaryYAxisTitle = getYAxisTitleRect({
                chartSize,
                visible: yAxisTitleVisible,
                title,
                legend: legendState,
                hasCenterYAxis,
                isRightSide: true,
                visibleSecondaryYAxis,
                yAxisTitleHeight,
            });
            const secondaryYAxis = getYAxisRect({
                chartSize,
                legend: legendState,
                circleLegend: circleLegendState,
                yAxisTitle: secondaryYAxisTitle,
                hasCenterYAxis,
                hasXYAxis,
                maxLabelWidth: getYAxisMaxLabelWidth((_p = (_o = axes) === null || _o === void 0 ? void 0 : _o.secondaryYAxis) === null || _p === void 0 ? void 0 : _p.maxLabelWidth),
                size: optionSize,
                isRightSide: true,
                visibleSecondaryYAxis,
                xAxisTitleHeight,
            });
            const xAxis = getXAxisRect({
                chartSize,
                yAxis,
                secondaryYAxis,
                legend: legendState,
                circleLegend: circleLegendState,
                hasCenterYAxis,
                hasXYAxis,
                size: optionSize,
                xAxisData: (_q = axes) === null || _q === void 0 ? void 0 : _q.xAxis,
            });
            const xAxisTitle = getXAxisTitleRect(!!((_r = options.xAxis) === null || _r === void 0 ? void 0 : _r.title), xAxis, xAxisTitleHeight);
            const legend = getLegendRect({
                chartSize,
                xAxis,
                yAxis,
                secondaryYAxis,
                title,
                legend: legendState,
                hasXYAxis,
                xAxisTitleHeight,
            });
            adjustAxisSize(chartSize, { title, yAxisTitle, yAxis, xAxis, xAxisTitle, legend, secondaryYAxis }, legendState);
            const circleLegend = getCircleLegendRect(xAxis, yAxis, legendState.align, circleLegendState.width);
            const plot = getPlotRect(xAxis, yAxis, optionSize.plot);
            const circularAxisTitle = getCircularAxisTitleRect(plot, theme.circularAxis, (_s = radialAxes) === null || _s === void 0 ? void 0 : _s.circularAxis);
            (0,_store__WEBPACK_IMPORTED_MODULE_6__.extend)(state.layout, {
                chart: { x: 0, y: 0, width, height },
                title,
                plot,
                legend,
                circleLegend,
                xAxis,
                xAxisTitle,
                yAxis,
                yAxisTitle,
                exportMenu,
                resetButton,
                secondaryYAxisTitle,
                secondaryYAxis,
                circularAxisTitle,
            });
        },
    },
    observe: {
        updateLayoutObserve() {
            this.dispatch('setLayout');
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (layout);


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/legend.js":
/*!***************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/legend.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _brushes_legend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../brushes/legend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/legend.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layout */ "./node_modules/@toast-ui/chart/dist/esm/store/layout.js");
/* harmony import */ var _brushes_spectrumLegend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../brushes/spectrumLegend */ "./node_modules/@toast-ui/chart/dist/esm/brushes/spectrumLegend.js");
/* harmony import */ var _helpers_pieSeries__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helpers/pieSeries */ "./node_modules/@toast-ui/chart/dist/esm/helpers/pieSeries.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./store */ "./node_modules/@toast-ui/chart/dist/esm/store/store.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _helpers_theme__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/theme */ "./node_modules/@toast-ui/chart/dist/esm/helpers/theme.js");
/* harmony import */ var _helpers_validation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../helpers/validation */ "./node_modules/@toast-ui/chart/dist/esm/helpers/validation.js");
/* harmony import */ var _helpers_legend__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/legend */ "./node_modules/@toast-ui/chart/dist/esm/helpers/legend.js");











const INITIAL_LEGEND_WIDTH = 100;
const INITIAL_CIRCLE_LEGEND_WIDTH = 150;
const COMPONENT_HEIGHT_EXCEPT_Y_AXIS = 100;
const ELLIPSIS_DOT_TEXT = '...';
const WIDEST_TEXT = 'W'; // The widest text width in Arial font.
const NUMBER_OF_BOTH_SIDES = 2;
function recalculateLegendWhenHeightOverflows(params, legendHeight) {
    const { legendWidths, itemHeight } = params;
    const totalHeight = legendWidths.length * itemHeight;
    const columnCount = Math.ceil(totalHeight / legendHeight);
    const rowCount = legendWidths.length / columnCount;
    let legendWidth = 0;
    (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.range)(0, columnCount).forEach((count) => {
        legendWidth += Math.max(...legendWidths.slice(count * rowCount, (count + 1) * rowCount));
    });
    legendWidth += _brushes_legend__WEBPACK_IMPORTED_MODULE_1__.LEGEND_ITEM_MARGIN_X * (columnCount - 1);
    return { legendWidth, legendHeight: rowCount * itemHeight + _layout__WEBPACK_IMPORTED_MODULE_2__.padding.Y, columnCount, rowCount };
}
function recalculateLegendWhenWidthOverflows(params, prevLegendWidth) {
    const { legendWidths, itemHeight } = params;
    let columnCount = 0;
    let legendWidth = 0;
    const { rowCount } = legendWidths.reduce((acc, width) => {
        const widthWithMargin = _brushes_legend__WEBPACK_IMPORTED_MODULE_1__.LEGEND_ITEM_MARGIN_X + width;
        if (acc.totalWidth + width > prevLegendWidth) {
            acc.totalWidth = widthWithMargin;
            acc.rowCount += 1;
            acc.columnCount = 1;
            columnCount = Math.max(columnCount, acc.columnCount);
        }
        else {
            acc.totalWidth += widthWithMargin;
            acc.columnCount += 1;
        }
        legendWidth = Math.max(legendWidth, acc.totalWidth);
        return acc;
    }, { totalWidth: 0, rowCount: 1, columnCount: 0 });
    return { legendHeight: itemHeight * rowCount, rowCount, columnCount, legendWidth };
}
function calculateLegendSize(params) {
    if (!params.visible) {
        return { legendWidth: 0, legendHeight: 0, rowCount: 0, columnCount: 0 };
    }
    const { chart, verticalAlign, legendWidths } = params;
    const { legendWidth, isOverflow: widthOverflow } = calculateLegendWidth(params);
    const { legendHeight, isOverflow: heightOverflow } = calculateLegendHeight(params);
    const columnCount = verticalAlign ? legendWidths.length : 1;
    const rowCount = verticalAlign ? Math.ceil(legendWidth / chart.width) : legendWidths.length;
    if (widthOverflow) {
        return recalculateLegendWhenWidthOverflows(params, legendWidth / rowCount);
    }
    if (heightOverflow) {
        return recalculateLegendWhenHeightOverflows(params, legendHeight);
    }
    return { legendWidth, legendHeight, columnCount, rowCount };
}
function calculateLegendHeight(params) {
    const { verticalAlign, itemHeight, legendWidths } = params;
    const { height: chartHeight } = getDefaultLegendSize(params);
    let legendHeight;
    let isOverflow = false;
    if (verticalAlign) {
        legendHeight = chartHeight;
    }
    else {
        const totalHeight = legendWidths.length * itemHeight;
        isOverflow = chartHeight < totalHeight;
        legendHeight = isOverflow ? chartHeight : totalHeight;
    }
    return { legendHeight, isOverflow };
}
function getSpectrumLegendWidth(legendWidths, chartWidth, verticalAlign) {
    if (verticalAlign) {
        const labelAreaWidth = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.sum)(legendWidths);
        return Math.max(chartWidth / 4, labelAreaWidth);
    }
    const spectrumAreaWidth = (_brushes_spectrumLegend__WEBPACK_IMPORTED_MODULE_3__.spectrumLegendTooltip.PADDING + _brushes_spectrumLegend__WEBPACK_IMPORTED_MODULE_3__.spectrumLegendBar.PADDING + _layout__WEBPACK_IMPORTED_MODULE_2__.padding.X) * NUMBER_OF_BOTH_SIDES +
        _brushes_spectrumLegend__WEBPACK_IMPORTED_MODULE_3__.spectrumLegendTooltip.POINT_HEIGHT +
        _brushes_spectrumLegend__WEBPACK_IMPORTED_MODULE_3__.spectrumLegendBar.HEIGHT;
    return Math.max(...legendWidths) + spectrumAreaWidth;
}
function getSpectrumLegendHeight(itemHeight, chartHeight, verticalAlign) {
    return verticalAlign
        ? _brushes_spectrumLegend__WEBPACK_IMPORTED_MODULE_3__.SPECTRUM_LEGEND_LABEL_HEIGHT +
            _brushes_spectrumLegend__WEBPACK_IMPORTED_MODULE_3__.spectrumLegendBar.PADDING * NUMBER_OF_BOTH_SIDES +
            _brushes_spectrumLegend__WEBPACK_IMPORTED_MODULE_3__.spectrumLegendTooltip.POINT_HEIGHT +
            _brushes_spectrumLegend__WEBPACK_IMPORTED_MODULE_3__.spectrumLegendTooltip.HEIGHT +
            _layout__WEBPACK_IMPORTED_MODULE_2__.padding.Y
        : (chartHeight * 3) / 4;
}
function getNormalLegendWidth(params) {
    const { initialWidth, legendWidths, checkbox, verticalAlign } = params;
    let isOverflow = false;
    let legendWidth;
    if (verticalAlign) {
        const { width: chartWidth } = getDefaultLegendSize(params);
        const totalWidth = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.sum)(legendWidths) + _brushes_legend__WEBPACK_IMPORTED_MODULE_1__.LEGEND_ITEM_MARGIN_X * (legendWidths.length - 1);
        isOverflow = totalWidth > chartWidth;
        legendWidth = totalWidth;
    }
    else {
        const labelAreaWidth = Math.max(...legendWidths);
        legendWidth =
            (checkbox ? _brushes_legend__WEBPACK_IMPORTED_MODULE_1__.LEGEND_CHECKBOX_SIZE + _brushes_legend__WEBPACK_IMPORTED_MODULE_1__.LEGEND_MARGIN_X : 0) +
                _brushes_legend__WEBPACK_IMPORTED_MODULE_1__.LEGEND_ICON_SIZE +
                _brushes_legend__WEBPACK_IMPORTED_MODULE_1__.LEGEND_MARGIN_X +
                Math.max(labelAreaWidth, initialWidth);
    }
    return { legendWidth, isOverflow };
}
function calculateLegendWidth(params) {
    var _a, _b;
    const { options, visible } = params;
    const legendOptions = (_a = options) === null || _a === void 0 ? void 0 : _a.legend;
    if (!visible) {
        return { legendWidth: 0, isOverflow: false };
    }
    if ((_b = legendOptions) === null || _b === void 0 ? void 0 : _b.width) {
        return { legendWidth: legendOptions.width, isOverflow: false };
    }
    return getNormalLegendWidth(params);
}
function getDefaultLegendSize(params) {
    const { verticalAlign, chart, itemHeight, initialWidth, circleLegendVisible } = params;
    const restAreaHeight = COMPONENT_HEIGHT_EXCEPT_Y_AXIS + (circleLegendVisible ? INITIAL_CIRCLE_LEGEND_WIDTH : 0); // rest area temporary value (yAxisTitle.height + xAxis.height + circleLegend.height)
    return verticalAlign
        ? { width: chart.width - _layout__WEBPACK_IMPORTED_MODULE_2__.padding.X * NUMBER_OF_BOTH_SIDES, height: itemHeight }
        : {
            width: initialWidth,
            height: chart.height - restAreaHeight,
        };
}
function getNestedPieLegendLabelsInfo(series, legendInfo) {
    const result = [];
    const maxTextLengthWithEllipsis = getMaxTextLengthWithEllipsis(legendInfo);
    series.pie.forEach(({ data }) => {
        data.forEach(({ name, parentName, visible }) => {
            if (!parentName) {
                const { width, viewLabel } = getViewLabelInfo(legendInfo, name, maxTextLengthWithEllipsis);
                result.push({
                    label: name,
                    type: 'pie',
                    checked: (visible !== null && visible !== void 0 ? visible : true),
                    viewLabel,
                    width,
                });
            }
        });
    });
    return result;
}
function getMaxTextLengthWithEllipsis(legendInfo) {
    var _a, _b;
    const { legendOptions, font, checkboxVisible } = legendInfo;
    const width = (_b = (_a = legendOptions) === null || _a === void 0 ? void 0 : _a.item) === null || _b === void 0 ? void 0 : _b.width;
    if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(width)) {
        return;
    }
    const checkboxWidth = checkboxVisible ? _brushes_legend__WEBPACK_IMPORTED_MODULE_1__.LEGEND_CHECKBOX_SIZE + _brushes_legend__WEBPACK_IMPORTED_MODULE_1__.LEGEND_MARGIN_X : 0;
    const iconWidth = _brushes_legend__WEBPACK_IMPORTED_MODULE_1__.LEGEND_ICON_SIZE + _brushes_legend__WEBPACK_IMPORTED_MODULE_1__.LEGEND_MARGIN_X;
    const ellipsisDotWidth = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_4__.getTextWidth)(ELLIPSIS_DOT_TEXT, font);
    const widestTextWidth = (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_4__.getTextWidth)(WIDEST_TEXT, font);
    const maxTextCount = Math.floor((width - ellipsisDotWidth - checkboxWidth - iconWidth) / widestTextWidth);
    return maxTextCount > 0 ? maxTextCount : 0;
}
function getViewLabelInfo(legendInfo, label, maxTextLength) {
    var _a, _b;
    const { checkboxVisible, useSpectrumLegend, font, legendOptions } = legendInfo;
    let viewLabel = label;
    const itemWidth = (_b = (_a = legendOptions) === null || _a === void 0 ? void 0 : _a.item) === null || _b === void 0 ? void 0 : _b.width;
    const itemWidthWithFullText = getItemWidth(viewLabel, checkboxVisible, useSpectrumLegend, font);
    if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(itemWidth) && (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(maxTextLength) && itemWidth < itemWidthWithFullText) {
        viewLabel = `${label.slice(0, maxTextLength)}${ELLIPSIS_DOT_TEXT}`;
    }
    return { viewLabel, width: (itemWidth !== null && itemWidth !== void 0 ? itemWidth : itemWidthWithFullText) };
}
function getLegendLabelsInfo(series, legendInfo, categories) {
    const maxTextLengthWithEllipsis = getMaxTextLengthWithEllipsis(legendInfo);
    let colorIndex = 0;
    return Object.keys(series).flatMap((type) => {
        const labelInfo = series[type].map(({ name, colorValue, visible, colorByCategories }) => {
            const label = colorValue ? colorValue : name;
            const currentColorIndex = colorIndex;
            const { width, viewLabel } = getViewLabelInfo(legendInfo, label, maxTextLengthWithEllipsis);
            colorIndex += colorByCategories ? categories.length : 1;
            return {
                label,
                type,
                colorByCategories: !!colorByCategories,
                colorIndex: currentColorIndex,
                checked: (visible !== null && visible !== void 0 ? visible : true),
                viewLabel,
                width,
            };
        });
        colorIndex += series[type].length - 1;
        return labelInfo;
    });
}
function getItemWidth(label, checkboxVisible, useSpectrumLegend, font) {
    return ((useSpectrumLegend
        ? 0
        : (checkboxVisible ? _brushes_legend__WEBPACK_IMPORTED_MODULE_1__.LEGEND_CHECKBOX_SIZE + _brushes_legend__WEBPACK_IMPORTED_MODULE_1__.LEGEND_MARGIN_X : 0) +
            _brushes_legend__WEBPACK_IMPORTED_MODULE_1__.LEGEND_ICON_SIZE +
            _brushes_legend__WEBPACK_IMPORTED_MODULE_1__.LEGEND_MARGIN_X) + (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_4__.getTextWidth)(label, font));
}
function getLegendDataAppliedTheme(data, series) {
    const colors = Object.values(series).reduce((acc, cur) => (cur && cur.colors ? [...acc, ...cur.colors] : acc), []);
    const hasColorByCategories = data.some((legend) => legend.colorByCategories);
    return data.map((datum, idx) => {
        const { colorByCategories, colorIndex } = datum;
        const index = hasColorByCategories ? colorIndex || idx : idx;
        return Object.assign(Object.assign({}, datum), { color: colorByCategories ? '#aaa' : colors[index % colors.length] });
    });
}
function getLegendState(options, series, categories) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const useSpectrumLegend = (_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.useColorValue, (_c !== null && _c !== void 0 ? _c : !!series.heatmap));
    const useScatterChartIcon = !!((_d = series) === null || _d === void 0 ? void 0 : _d.scatter);
    const checkboxVisible = useSpectrumLegend
        ? false
        : (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_5__.showCheckbox)(options);
    const defaultTheme = (0,_helpers_theme__WEBPACK_IMPORTED_MODULE_6__.makeDefaultTheme)(series, (_g = (_f = (_e = options) === null || _e === void 0 ? void 0 : _e.theme) === null || _f === void 0 ? void 0 : _f.chart) === null || _g === void 0 ? void 0 : _g.fontFamily);
    const font = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_7__.getTitleFontString)((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.deepMergedCopy)(defaultTheme.legend.label, Object.assign({}, (_j = (_h = options.theme) === null || _h === void 0 ? void 0 : _h.legend) === null || _j === void 0 ? void 0 : _j.label)));
    const legendInfo = {
        checkboxVisible,
        font,
        useSpectrumLegend,
        legendOptions: options.legend,
    };
    const legendLabelsInfo = (0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_8__.hasNestedPieSeries)(series)
        ? getNestedPieLegendLabelsInfo(series, legendInfo)
        : getLegendLabelsInfo(series, legendInfo, categories);
    const data = legendLabelsInfo.map(({ label, type, checked, width, viewLabel, colorByCategories, colorIndex }) => ({
        label,
        active: true,
        checked,
        width,
        iconType: (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_5__.getIconType)(type),
        chartType: type,
        rowIndex: 0,
        columnIndex: 0,
        viewLabel,
        colorByCategories,
        colorIndex,
    }));
    return {
        useSpectrumLegend,
        useScatterChartIcon,
        data,
    };
}
function getNextColumnRowIndex(params) {
    const { verticalAlign, columnCount, rowCount, legendCount } = params;
    let { rowIndex, columnIndex } = params;
    if (verticalAlign) {
        const maxLen = legendCount / rowCount;
        if (maxLen - 1 > columnIndex) {
            columnIndex += 1;
        }
        else {
            rowIndex += 1;
            columnIndex = 0;
        }
    }
    else {
        const maxLen = legendCount / columnCount;
        if (maxLen - 1 > rowIndex) {
            rowIndex += 1;
        }
        else {
            columnIndex += 1;
            rowIndex = 0;
        }
    }
    return [rowIndex, columnIndex];
}
function setIndexToLegendData(legendData, rowCount, columnCount, legendCount, verticalAlign) {
    let columnIndex = 0;
    let rowIndex = 0;
    legendData.forEach((datum) => {
        datum.rowIndex = rowIndex;
        datum.columnIndex = columnIndex;
        [rowIndex, columnIndex] = getNextColumnRowIndex({
            rowCount,
            columnCount,
            verticalAlign,
            legendCount,
            rowIndex,
            columnIndex,
        });
    });
}
const legend = {
    name: 'legend',
    state: ({ options, series, categories }) => {
        return {
            legend: getLegendState(options, series, categories),
            circleLegend: {},
        };
    },
    action: {
        initLegendState({ state, initStoreState }) {
            (0,_store__WEBPACK_IMPORTED_MODULE_9__.extend)(state.legend, getLegendState(initStoreState.options, initStoreState.series, initStoreState.categories));
        },
        setLegendLayout({ state }) {
            if (state.legend.useSpectrumLegend) {
                this.dispatch('setSpectrumLegendLayout');
            }
            else {
                this.dispatch('setNormalLegendLayout');
            }
        },
        setSpectrumLegendLayout({ state }) {
            const { legend: { data: legendData }, series, options, chart, theme, } = state;
            const align = (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_5__.getLegendAlign)(options);
            const visible = (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_5__.showLegend)(options, series);
            const verticalAlign = (0,_layout__WEBPACK_IMPORTED_MODULE_2__.isVerticalAlign)(align);
            const legendWidths = legendData.map(({ width }) => width);
            const itemHeight = (0,_brushes_legend__WEBPACK_IMPORTED_MODULE_1__.getLegendItemHeight)(theme.legend.label.fontSize);
            const width = getSpectrumLegendWidth(legendWidths, chart.width, verticalAlign);
            const height = getSpectrumLegendHeight(itemHeight, chart.height, verticalAlign);
            (0,_store__WEBPACK_IMPORTED_MODULE_9__.extend)(state.legend, { visible, align, width, height });
        },
        setNormalLegendLayout({ state, initStoreState }) {
            const { legend: { data: legendData }, series, options, chart, theme, } = state;
            const align = (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_5__.getLegendAlign)(options);
            const visible = (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_5__.showLegend)(options, series);
            const checkbox = (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_5__.showCheckbox)(options);
            const initialWidth = Math.min(chart.width / 5, INITIAL_LEGEND_WIDTH);
            const verticalAlign = (0,_layout__WEBPACK_IMPORTED_MODULE_2__.isVerticalAlign)(align);
            const isNestedPieChart = (0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_8__.hasNestedPieSeries)(initStoreState.series);
            const isScatterChart = !!series.scatter;
            const isBubbleChart = !!series.bubble;
            const circleLegendVisible = isBubbleChart
                ? (0,_helpers_legend__WEBPACK_IMPORTED_MODULE_5__.showCircleLegend)(options)
                : false;
            const legendWidths = legendData.map(({ width }) => width);
            const itemHeight = (0,_brushes_legend__WEBPACK_IMPORTED_MODULE_1__.getLegendItemHeight)(theme.legend.label.fontSize);
            const { legendWidth, legendHeight, rowCount, columnCount } = calculateLegendSize({
                initialWidth,
                legendWidths,
                options,
                verticalAlign,
                visible,
                checkbox,
                chart,
                itemHeight,
                circleLegendVisible,
            });
            setIndexToLegendData(legendData, rowCount, columnCount, legendWidths.length, verticalAlign);
            (0,_store__WEBPACK_IMPORTED_MODULE_9__.extend)(state.legend, {
                visible,
                align,
                showCheckbox: checkbox,
                width: legendWidth,
                height: legendHeight,
            });
            if (isBubbleChart && circleLegendVisible) {
                this.dispatch('updateCircleLegendLayout', { legendWidth });
            }
            if (!isNestedPieChart && !(0,_helpers_validation__WEBPACK_IMPORTED_MODULE_10__.isNoData)(series)) {
                this.dispatch('updateLegendColor');
            }
            if (isScatterChart) {
                this.dispatch('updateLegendIcon');
            }
        },
        updateCircleLegendLayout({ state }, { legendWidth }) {
            const width = legendWidth === 0
                ? INITIAL_CIRCLE_LEGEND_WIDTH
                : Math.min(legendWidth, INITIAL_CIRCLE_LEGEND_WIDTH);
            const radius = Math.max((width - _brushes_legend__WEBPACK_IMPORTED_MODULE_1__.LEGEND_MARGIN_X) / 2, 0);
            (0,_store__WEBPACK_IMPORTED_MODULE_9__.extend)(state.circleLegend, { visible: true, width, radius });
        },
        setLegendActiveState({ state }, { name, active }) {
            const { data } = state.legend;
            const model = data.find(({ label }) => label === name);
            model.active = active;
            this.notify(state, 'legend');
        },
        setAllLegendActiveState({ state }, active) {
            state.legend.data.forEach((datum) => {
                datum.active = active;
            });
            this.notify(state, 'legend');
        },
        setLegendCheckedState({ state }, { name, checked }) {
            const model = state.legend.data.find(({ label }) => label === name);
            model.checked = checked;
            this.notify(state, 'legend');
        },
        updateLegendColor({ state }) {
            const { legend: legendData, series } = state;
            const data = getLegendDataAppliedTheme(legendData.data, series);
            (0,_store__WEBPACK_IMPORTED_MODULE_9__.extend)(state.legend, { data });
        },
        updateLegendIcon({ state }) {
            const { legend: legendData, series } = state;
            const data = legendData.data.reduce((acc, cur) => {
                var _a;
                if (cur.chartType === 'scatter' && ((_a = series.scatter) === null || _a === void 0 ? void 0 : _a.data)) {
                    const model = series.scatter.data.find(({ name }) => name === cur.label);
                    const iconType = model ? model.iconType : cur.iconType;
                    return [...acc, Object.assign(Object.assign({}, cur), { iconType })];
                }
                return [...acc, cur];
            }, []);
            (0,_store__WEBPACK_IMPORTED_MODULE_9__.extend)(state.legend, { data });
        },
        updateNestedPieChartLegend({ state }) {
            const { legend: legendData, nestedPieSeries } = state;
            (0,_store__WEBPACK_IMPORTED_MODULE_9__.extend)(state.legend, {
                data: getLegendDataAppliedTheme(legendData.data, nestedPieSeries),
            });
        },
    },
    observe: {
        updateLegendLayout() {
            this.dispatch('setLegendLayout');
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (legend);


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/nestedPieSeriesData.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/nestedPieSeriesData.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function findRootName(rawSeries, seriesIndex, parentName) {
    var _a, _b;
    const item = (_a = rawSeries.pie) === null || _a === void 0 ? void 0 : _a[seriesIndex].data.find(({ name }) => name === parentName);
    return ((_b = item) === null || _b === void 0 ? void 0 : _b.parentName) ? findRootName(rawSeries, seriesIndex - 1, item.parentName) : parentName;
}
const nestedPieSeriesData = {
    name: 'seriesData',
    state: () => ({
        nestedPieSeries: {},
    }),
    action: {
        setNestedPieSeriesData({ state, initStoreState }) {
            const { theme, disabledSeries } = state;
            const rawSeries = initStoreState.series;
            const newSeriesData = {};
            const colorMap = {};
            rawSeries.pie.forEach(({ name: alias, data }, seriesIndex) => {
                const { colors } = theme.series.pie[alias];
                const colorList = [];
                const originSeriesData = data.map((m, index) => {
                    var _a;
                    const { parentName, name: dataName } = m;
                    const color = parentName && seriesIndex ? colorMap[parentName] : (_a = colors) === null || _a === void 0 ? void 0 : _a[index];
                    colorList.push(color);
                    colorMap[dataName] = color;
                    const rootParentName = parentName && seriesIndex
                        ? findRootName(rawSeries, seriesIndex - 1, parentName)
                        : dataName;
                    return Object.assign(Object.assign({}, m), { data: m.data, rootParentName,
                        color });
                });
                newSeriesData[alias] = {
                    data: originSeriesData.filter(({ rootParentName }) => {
                        return !disabledSeries.includes(rootParentName);
                    }),
                    colors: colorList,
                };
            });
            state.nestedPieSeries = newSeriesData;
            this.dispatch('updateNestedPieChartLegend');
        },
    },
    observe: {
        updateNestedPieSeriesData() {
            this.dispatch('setNestedPieSeriesData');
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (nestedPieSeriesData);


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/options.js":
/*!****************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/options.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");

function getOptionsBySize(size, options) {
    var _a;
    const rules = (_a = options.responsive) === null || _a === void 0 ? void 0 : _a.rules;
    return Array.isArray(rules)
        ? rules.reduce((acc, cur) => {
            return cur.condition(size) ? (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.deepMergedCopy)(acc, cur.options) : acc;
        }, options)
        : options;
}
function getSize(usingContainerSize, containerSize, chartSize) {
    var _a, _b;
    const { width: usingContainerWidth, height: usingContainerHeight } = usingContainerSize;
    return {
        width: usingContainerWidth ? containerSize.width : (_a = chartSize) === null || _a === void 0 ? void 0 : _a.width,
        height: usingContainerHeight ? containerSize.height : (_b = chartSize) === null || _b === void 0 ? void 0 : _b.height,
    };
}
const optionsData = {
    name: 'options',
    state: ({ options }) => ({
        originalOptions: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.deepCopy)(options),
        options,
    }),
    action: {
        setOptions({ state }) {
            const { width, height } = state.chart;
            if (width < 0 || height < 0) {
                return;
            }
            state.options = getOptionsBySize({ width, height }, state.originalOptions);
        },
        initOptions({ initStoreState, state }, { options, containerSize }) {
            initStoreState.options = options;
            state.originalOptions = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.deepCopy)(options);
            const { usingContainerSize, originalOptions } = state;
            const size = getSize(usingContainerSize, containerSize, {
                width: originalOptions.chart.width,
                height: originalOptions.chart.height,
            });
            this.dispatch('setChartSize', size);
        },
        updateOptions({ state, initStoreState }, { options, containerSize }) {
            var _a, _b;
            initStoreState.options = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.deepMergedCopy)(initStoreState.options, options);
            state.originalOptions = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.deepMergedCopy)(state.originalOptions, options);
            const { usingContainerSize, originalOptions } = state;
            const size = getSize(usingContainerSize, containerSize, {
                width: (_a = originalOptions.chart) === null || _a === void 0 ? void 0 : _a.width,
                height: (_b = originalOptions.chart) === null || _b === void 0 ? void 0 : _b.height,
            });
            this.dispatch('setChartSize', size);
            this.dispatch('initThemeState');
        },
    },
    observe: {
        updateOptions() {
            this.dispatch('setOptions');
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (optionsData);


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/plot.js":
/*!*************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/plot.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./store */ "./node_modules/@toast-ui/chart/dist/esm/store/store.js");
/* harmony import */ var _helpers_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/color */ "./node_modules/@toast-ui/chart/dist/esm/helpers/color.js");
/* harmony import */ var _helpers_range__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/range */ "./node_modules/@toast-ui/chart/dist/esm/helpers/range.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_plot__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/plot */ "./node_modules/@toast-ui/chart/dist/esm/helpers/plot.js");





function getOverlappingRange(ranges) {
    const overlappingRanges = ranges.reduce((acc, { range }) => {
        const [accStart, accEnd] = acc;
        const [start, end] = range;
        return [Math.min(accStart, start), Math.max(accEnd, end)];
    }, [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);
    return {
        range: overlappingRanges,
        color: ranges[0].color,
    };
}
function getCategoryIndex(value, categories) {
    return categories.findIndex((category) => category === String(value));
}
function getValidValue(value, categories, isDateType = false) {
    if (isDateType) {
        return Number(new Date(value));
    }
    if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(value)) {
        return getCategoryIndex(value, categories);
    }
    return value;
}
function makePlotLines(categories, isDateType, plotLines = []) {
    return plotLines.map(({ value, color, opacity }) => ({
        value: getValidValue(value, categories, isDateType),
        color: (0,_helpers_color__WEBPACK_IMPORTED_MODULE_1__.rgba)(color, opacity),
    }));
}
function makePlotBands(categories, isDateType, plotBands = []) {
    return plotBands.flatMap(({ range, mergeOverlappingRanges = false, color: bgColor, opacity }) => {
        const color = (0,_helpers_color__WEBPACK_IMPORTED_MODULE_1__.rgba)(bgColor, opacity);
        const rangeArray = ((0,_helpers_range__WEBPACK_IMPORTED_MODULE_2__.isRangeValue)(range[0]) ? range : [range]);
        const ranges = rangeArray.map((rangeData) => ({
            range: rangeData.map((value) => getValidValue(value, categories, isDateType)),
            color,
        }));
        return mergeOverlappingRanges ? getOverlappingRange(ranges) : ranges;
    });
}
const plot = {
    name: 'plot',
    state: ({ options }) => {
        var _a, _b, _c;
        return ({
            plot: {
                visible: (_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.plot) === null || _b === void 0 ? void 0 : _b.visible, (_c !== null && _c !== void 0 ? _c : true)),
                lines: [],
                bands: [],
            },
        });
    },
    action: {
        setPlot({ state }) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            const { series, options } = state;
            if (!(series.area || series.line)) {
                return;
            }
            const rawCategories = state.rawCategories;
            const lineAreaOptions = options;
            const lines = makePlotLines(rawCategories, !!((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.xAxis) === null || _b === void 0 ? void 0 : _b.date), (_d = (_c = lineAreaOptions) === null || _c === void 0 ? void 0 : _c.plot) === null || _d === void 0 ? void 0 : _d.lines);
            const bands = makePlotBands(rawCategories, !!((_f = (_e = options) === null || _e === void 0 ? void 0 : _e.xAxis) === null || _f === void 0 ? void 0 : _f.date), (_h = (_g = lineAreaOptions) === null || _g === void 0 ? void 0 : _g.plot) === null || _h === void 0 ? void 0 : _h.bands);
            (0,_store__WEBPACK_IMPORTED_MODULE_3__.extend)(state.plot, { lines, bands });
        },
        addPlotLine({ state }, { data }) {
            var _a, _b, _c;
            const lines = (_c = (_b = (_a = state.options) === null || _a === void 0 ? void 0 : _a.plot) === null || _b === void 0 ? void 0 : _b.lines, (_c !== null && _c !== void 0 ? _c : []));
            if (!(0,_helpers_plot__WEBPACK_IMPORTED_MODULE_4__.isExistPlotId)(lines, data)) {
                this.dispatch('updateOptions', { options: { plot: { lines: [...lines, data] } } });
            }
        },
        addPlotBand({ state }, { data }) {
            var _a, _b, _c;
            const bands = (_c = (_b = (_a = state.options) === null || _a === void 0 ? void 0 : _a.plot) === null || _b === void 0 ? void 0 : _b.bands, (_c !== null && _c !== void 0 ? _c : []));
            if (!(0,_helpers_plot__WEBPACK_IMPORTED_MODULE_4__.isExistPlotId)(bands, data)) {
                this.dispatch('updateOptions', { options: { plot: { bands: [...bands, data] } } });
            }
        },
        removePlotLine({ state }, { id }) {
            var _a, _b, _c;
            const lines = (_c = (_b = (_a = state.options) === null || _a === void 0 ? void 0 : _a.plot) === null || _b === void 0 ? void 0 : _b.lines, (_c !== null && _c !== void 0 ? _c : [])).filter(({ id: lineId }) => lineId !== id);
            this.dispatch('updateOptions', { options: { plot: { lines } } });
        },
        removePlotBand({ state }, { id }) {
            var _a, _b, _c;
            const bands = (_c = (_b = (_a = state.options) === null || _a === void 0 ? void 0 : _a.plot) === null || _b === void 0 ? void 0 : _b.bands, (_c !== null && _c !== void 0 ? _c : [])).filter(({ id: bandId }) => bandId !== id);
            this.dispatch('updateOptions', { options: { plot: { bands } } });
        },
    },
    observe: {
        updatePlot() {
            this.dispatch('setPlot');
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plot);


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/radialAxes.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/radialAxes.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RADIAL_LABEL_PADDING": () => (/* binding */ RADIAL_LABEL_PADDING),
/* harmony export */   "RadialAxisType": () => (/* binding */ RadialAxisType),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _helpers_calculator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/calculator */ "./node_modules/@toast-ui/chart/dist/esm/helpers/calculator.js");
/* harmony import */ var _helpers_style__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/style */ "./node_modules/@toast-ui/chart/dist/esm/helpers/style.js");
/* harmony import */ var _helpers_sector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/sector */ "./node_modules/@toast-ui/chart/dist/esm/helpers/sector.js");




const Y_LABEL_PADDING = 5;
const RADIAL_LABEL_PADDING = 25;
var RadialAxisType;
(function (RadialAxisType) {
    RadialAxisType["CIRCULAR"] = "circularAxis";
    RadialAxisType["VERTICAL"] = "verticalAxis";
})(RadialAxisType || (RadialAxisType = {}));
function getYAxisLabelAlign(clockwise = true, isLabelOnVerticalAxis = false) {
    let align = 'center';
    if (isLabelOnVerticalAxis) {
        align = clockwise ? 'right' : 'left';
    }
    return align;
}
function getVerticalAxisData({ labels, pointOnColumn, intervalData, isLabelOnVerticalAxis, verticalAxisLabelMargin, verticalAxisLabelFont, defaultAxisData, radiusData, }) {
    const { clockwise, axisSize, centerX, centerY, startAngle, endAngle } = defaultAxisData;
    const { radiusRanges, innerRadius, outerRadius } = radiusData;
    const { labelInterval } = intervalData;
    /*
    return {
      labels,
      tickDistance: (outerRadius - innerRadius) / labels.length,
      ...pick(defaultAxisData, 'axisSize', 'centerX', 'centerY', 'startAngle', 'endAngle'),
      pointOnColumn,
      radiusRanges,
      innerRadius,
      outerRadius,
      labelInterval,
      labelMargin: verticalAxisLabelMargin,
      labelAlign: getYAxisLabelAlign(clockwise, isLabelOnVerticalAxis),
      ...getMaxLabelSize(labels, verticalAxisLabelMargin, verticalAxisLabelFont),
    };
    */
    const { maxLabelWidth, maxLabelHeight } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_0__.getMaxLabelSize)(labels, verticalAxisLabelMargin, verticalAxisLabelFont);
    return {
        axisSize,
        centerX,
        centerY,
        label: {
            labels,
            interval: labelInterval,
            margin: verticalAxisLabelMargin,
            maxWidth: maxLabelWidth,
            maxHeight: maxLabelHeight,
            align: getYAxisLabelAlign(clockwise, isLabelOnVerticalAxis),
        },
        radius: {
            inner: innerRadius,
            outer: outerRadius,
            ranges: radiusRanges,
        },
        angle: {
            start: startAngle,
            end: endAngle,
        },
        tickDistance: (outerRadius - innerRadius) / labels.length,
        pointOnColumn,
    };
}
function getCircularAxisData({ labels, intervalData, circularAxisLabelMargin, circularAxisLabelFont, defaultAxisData, radiusData, }) {
    const { maxLabelWidth, maxLabelHeight } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_0__.getMaxLabelSize)(labels, circularAxisLabelMargin, circularAxisLabelFont);
    const { totalAngle, clockwise, axisSize, centerX, centerY, startAngle, endAngle, drawingStartAngle, } = defaultAxisData;
    const { tickInterval, labelInterval } = intervalData;
    const { innerRadius, outerRadius } = radiusData;
    const centralAngle = totalAngle / (labels.length + (totalAngle < _helpers_sector__WEBPACK_IMPORTED_MODULE_1__.DEGREE_360 ? -1 : _helpers_sector__WEBPACK_IMPORTED_MODULE_1__.DEGREE_0));
    /*
    return {
      labels,
      ...defaultAxisData,
      centralAngle,
      tickInterval,
      labelInterval,
      labelMargin: circularAxisLabelMargin,
      maxLabelWidth,
      maxLabelHeight,
      innerRadius,
      outerRadius,
    };
    */
    return {
        axisSize,
        centerX,
        centerY,
        label: {
            labels,
            interval: labelInterval,
            margin: circularAxisLabelMargin,
            maxWidth: maxLabelWidth,
            maxHeight: maxLabelHeight,
        },
        radius: {
            inner: innerRadius,
            outer: outerRadius,
        },
        angle: {
            start: startAngle,
            end: endAngle,
            total: totalAngle,
            central: centralAngle,
            drawingStart: drawingStartAngle,
        },
        tickInterval,
        clockwise,
    };
}
function makeLabels(options, rawLabels, axisName) {
    var _a, _b, _c;
    const formatter = (_c = (_b = (_a = options[axisName]) === null || _a === void 0 ? void 0 : _a.label) === null || _b === void 0 ? void 0 : _b.formatter, (_c !== null && _c !== void 0 ? _c : ((value) => value)));
    return rawLabels.map((label, index) => formatter(label, { index, labels: rawLabels, axisName }));
}
function getAxisLabels(isLabelOnVerticalAxis, options, categories, scale) {
    const valueAxisName = isLabelOnVerticalAxis
        ? RadialAxisType.CIRCULAR
        : RadialAxisType.VERTICAL;
    const { limit, stepSize } = scale[valueAxisName];
    const valueLabels = makeLabels(options, (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_2__.makeLabelsFromLimit)(limit, stepSize), valueAxisName);
    const categoryLabels = makeLabels(options, categories, isLabelOnVerticalAxis ? RadialAxisType.VERTICAL : RadialAxisType.CIRCULAR);
    return {
        radialAxisLabels: isLabelOnVerticalAxis ? valueLabels : categoryLabels,
        yAxisLabels: isLabelOnVerticalAxis ? categoryLabels : valueLabels,
    };
}
function getAxisLabelMargin(isLabelOnVerticalAxis, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    return {
        verticalAxisLabelMargin: (_d = (_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.verticalAxis) === null || _b === void 0 ? void 0 : _b.label) === null || _c === void 0 ? void 0 : _c.margin, (_d !== null && _d !== void 0 ? _d : (isLabelOnVerticalAxis ? Y_LABEL_PADDING : 0))),
        circularAxisLabelMargin: (_h = (_g = (_f = (_e = options) === null || _e === void 0 ? void 0 : _e.circularAxis) === null || _f === void 0 ? void 0 : _f.label) === null || _g === void 0 ? void 0 : _g.margin, (_h !== null && _h !== void 0 ? _h : RADIAL_LABEL_PADDING)),
    };
}
const axes = {
    name: 'radialAxes',
    state: () => ({
        radialAxes: {},
    }),
    action: {
        setRadialAxesData({ state }) {
            var _a, _b;
            const { series, layout, scale } = state;
            const categories = state.categories;
            const { plot } = layout;
            const isLabelOnVerticalAxis = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_0__.isLabelAxisOnYAxis)({ series, categories });
            const options = state.options;
            const theme = state.theme;
            const circularAxisLabelFont = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_3__.getTitleFontString)(theme.circularAxis.label);
            const verticalAxisLabelFont = (0,_helpers_style__WEBPACK_IMPORTED_MODULE_3__.getTitleFontString)(theme.verticalAxis.label);
            const { verticalAxisLabelMargin, circularAxisLabelMargin } = getAxisLabelMargin(isLabelOnVerticalAxis, options);
            const { radialAxisLabels, yAxisLabels } = getAxisLabels(isLabelOnVerticalAxis, options, categories, scale);
            const { maxLabelWidth, maxLabelHeight } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_0__.getMaxLabelSize)(radialAxisLabels, circularAxisLabelMargin, circularAxisLabelFont);
            const defaultAxisData = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_0__.getDefaultRadialAxisData)(options, plot, maxLabelWidth, maxLabelHeight + circularAxisLabelMargin, isLabelOnVerticalAxis);
            const { axisSize } = defaultAxisData;
            const radiusData = isLabelOnVerticalAxis
                ? (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_0__.getRadiusInfo)(axisSize, (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.radiusRange, yAxisLabels.length + 1)
                : {
                    radiusRanges: (0,_helpers_calculator__WEBPACK_IMPORTED_MODULE_2__.makeTickPixelPositions)(axisSize, yAxisLabels.length),
                    innerRadius: 0,
                    outerRadius: axisSize,
                };
            const verticalAxisData = getVerticalAxisData({
                labels: yAxisLabels,
                pointOnColumn: isLabelOnVerticalAxis,
                isLabelOnVerticalAxis,
                intervalData: (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_0__.getInitAxisIntervalData)(isLabelOnVerticalAxis, {
                    axis: options.verticalAxis,
                    categories,
                    layout,
                }),
                verticalAxisLabelMargin,
                verticalAxisLabelFont,
                defaultAxisData,
                radiusData,
            });
            state.radialAxes = {
                circularAxis: getCircularAxisData({
                    labels: radialAxisLabels,
                    intervalData: (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_0__.getInitAxisIntervalData)(true, {
                        axis: options.circularAxis,
                        categories,
                        layout,
                    }),
                    defaultAxisData,
                    circularAxisLabelMargin,
                    circularAxisLabelFont,
                    radiusData,
                }),
                verticalAxis: verticalAxisData,
            };
        },
    },
    observe: {
        updateRadialAxes() {
            this.dispatch('setRadialAxesData');
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (axes);


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/reactive.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/reactive.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "observe": () => (/* binding */ observe),
/* harmony export */   "isObservable": () => (/* binding */ isObservable),
/* harmony export */   "observable": () => (/* binding */ observable),
/* harmony export */   "setValue": () => (/* binding */ setValue),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "notify": () => (/* binding */ notify),
/* harmony export */   "invisibleWork": () => (/* binding */ invisibleWork),
/* harmony export */   "notifyByPath": () => (/* binding */ notifyByPath),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "watch": () => (/* binding */ watch),
/* harmony export */   "makeObservableObjectToNormal": () => (/* binding */ makeObservableObjectToNormal)
/* harmony export */ });
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");


let currentCollectorObserver = null;
let currentRunningObserver = null;
const observerCallCue = [];
let doingInvisibleWork = false;
function observe(fn) {
    const observer = () => {
        if (currentRunningObserver === observer) {
            return;
        }
        // If there is observer running or doing invisible work
        if (doingInvisibleWork || !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNull)(currentRunningObserver)) {
            if (observerCallCue.includes(observer)) {
                observerCallCue.splice(observerCallCue.indexOf(observer), 1);
            }
            // We use observer call cue because avoid nested observer call.
            observerCallCue.push(observer);
            // or If there are no observers running. Run the observer and run the next observer in the call queue.
        }
        else if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNull)(currentRunningObserver)) {
            currentRunningObserver = observer;
            fn();
            currentRunningObserver = null;
            digestObserverCallCue();
        }
    };
    observer.deps = [];
    // first observer excution for collect dependencies
    currentCollectorObserver = observer;
    currentCollectorObserver();
    currentCollectorObserver = null;
    return () => {
        observer.deps.forEach((dep) => {
            const index = dep.findIndex((ob) => ob === observer);
            dep.splice(index, 1);
        });
        observer.deps = [];
    };
}
function digestObserverCallCue() {
    if (observerCallCue.length) {
        const nextObserver = observerCallCue.shift();
        if (nextObserver) {
            nextObserver();
        }
    }
}
function isObservable(target) {
    return typeof target === 'object' && target.__toastUIChartOb__;
}
function observable(target, source = target) {
    if (isObservable(source)) {
        throw new Error(_message__WEBPACK_IMPORTED_MODULE_1__.message.ALREADY_OBSERVABLE_ERROR);
    }
    if (!isObservable(target)) {
        Object.defineProperty(target, '__toastUIChartOb__', {
            enumerable: false,
        });
    }
    for (const key in source) {
        if (!source.hasOwnProperty(key)) {
            continue;
        }
        const obs = [];
        let value = source[key];
        const descriptor = Object.getOwnPropertyDescriptor(source, key);
        const preGetter = descriptor && descriptor.get;
        const preSetter = descriptor && descriptor.set;
        /* eslint-disable no-loop-func */
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: true,
            get: function () {
                // It's some kind a trick to get observable information from closure using getter for notify()
                if (currentCollectorObserver === observableInfo) {
                    return { target, key, value, obs };
                }
                if (!doingInvisibleWork &&
                    currentCollectorObserver &&
                    !obs.includes(currentCollectorObserver)) {
                    // if there is collector observer in running, collect current data as dependency
                    obs.push(currentCollectorObserver);
                    currentCollectorObserver.deps.push(obs);
                }
                return value;
            },
            set: function (v) {
                const prevValue = value;
                if (preSetter) {
                    preSetter.call(target, v);
                    value = preGetter ? preGetter.call(target) : target[key];
                }
                else {
                    value = v;
                }
                if (prevValue !== value) {
                    // Run observers
                    invokeObs(obs);
                }
            },
        });
        if (typeof target[key] === 'object' && !Array.isArray(target[key])) {
            observable(target[key]);
        }
        /* eslint-enable no-loop-func */
    }
    return target;
}
function setValue(target, key, source) {
    return observable(target, {
        [key]: source,
    });
}
function extend(target, source) {
    if (isObservable(source)) {
        throw new Error(_message__WEBPACK_IMPORTED_MODULE_1__.message.ALREADY_OBSERVABLE_ERROR);
    }
    return observable(target, source);
}
function notify(target, key) {
    const obInfo = observableInfo(target, key);
    if (obInfo) {
        invokeObs(obInfo.obs);
    }
}
function invisibleWork(fn) {
    doingInvisibleWork = true;
    fn();
    doingInvisibleWork = false;
    digestObserverCallCue();
}
function notifyByPath(holder, namePath) {
    const splited = namePath.split('.');
    const key = splited.splice(splited.length - 1, 1)[0];
    const target = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.pickProperty)(holder, splited);
    if (target) {
        notify(target, key);
    }
}
function invokeObs(obs) {
    obs.forEach((ob) => ob());
}
function observableInfo(target, key) {
    currentCollectorObserver = observableInfo;
    const obInfo = target[key];
    currentCollectorObserver = null;
    if (typeof obInfo === 'object' &&
        obInfo.hasOwnProperty('target') &&
        obInfo.hasOwnProperty('obs')) {
        return obInfo;
    }
    return null;
}
function computed(target, key, fn) {
    let cachedValue;
    const computedBox = {};
    Object.defineProperty(computedBox, key, {
        configurable: true,
        enumerable: true,
        get: () => cachedValue,
    });
    extend(target, computedBox);
    observe(() => {
        const prevValue = cachedValue;
        cachedValue = fn();
        if (prevValue !== cachedValue) {
            target[key] = cachedValue;
        }
    });
}
function watch(holder, path, fn) {
    const splited = path.split('.');
    const key = splited.splice(splited.length - 1, 1)[0];
    const target = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.pickProperty)(holder, splited);
    if (!target) {
        return null;
    }
    const obInfo = observableInfo(target, key);
    if (!obInfo) {
        return null;
    }
    const watcher = () => {
        fn(target[key]);
    };
    obInfo.obs.push(watcher);
    return () => {
        const index = obInfo.obs.findIndex((ob) => ob === watcher);
        if (index > -1) {
            obInfo.obs.splice(index, 1);
        }
    };
}
function makeObservableObjectToNormal(obj) {
    return JSON.parse(JSON.stringify(obj));
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/root.js":
/*!*************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/root.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");

function initialSize(containerEl, { width, height }) {
    return {
        width: width === 0 ? containerEl.offsetWidth : width,
        height: height === 0 ? containerEl.offsetHeight : height,
    };
}
const root = {
    name: 'root',
    state: ({ options }) => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return ({
            chart: Object.assign(Object.assign({}, options.chart), { width: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.getInitialSize)((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.chart) === null || _b === void 0 ? void 0 : _b.width), height: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.getInitialSize)((_d = (_c = options) === null || _c === void 0 ? void 0 : _c.chart) === null || _d === void 0 ? void 0 : _d.height) }),
            usingContainerSize: {
                width: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isAutoValue)((_f = (_e = options) === null || _e === void 0 ? void 0 : _e.chart) === null || _f === void 0 ? void 0 : _f.width),
                height: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isAutoValue)((_h = (_g = options) === null || _g === void 0 ? void 0 : _g.chart) === null || _h === void 0 ? void 0 : _h.height),
            },
            container: {},
        });
    },
    action: {
        setChartSize({ state }, size) {
            state.chart.width = size.width;
            state.chart.height = size.height;
            this.notify(state, 'chart');
        },
        initChartSize({ state }, containerEl) {
            const { width, height } = state.chart;
            if (width === 0 || height === 0) {
                if (containerEl.parentNode) {
                    this.dispatch('setChartSize', initialSize(containerEl, { width, height }));
                }
                else {
                    setTimeout(() => {
                        this.dispatch('setChartSize', initialSize(containerEl, { width, height }));
                    }, 0);
                }
            }
        },
        setUsingContainerSize({ state }, { width, height }) {
            state.usingContainerSize.width = width;
            state.usingContainerSize.height = height;
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (root);


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/scale.js":
/*!**************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/scale.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_axes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/axes */ "./node_modules/@toast-ui/chart/dist/esm/helpers/axes.js");
/* harmony import */ var _scale_coordinateScaleCalculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../scale/coordinateScaleCalculator */ "./node_modules/@toast-ui/chart/dist/esm/scale/coordinateScaleCalculator.js");
/* harmony import */ var _scale_datetimeScaleCalculator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../scale/datetimeScaleCalculator */ "./node_modules/@toast-ui/chart/dist/esm/scale/datetimeScaleCalculator.js");
/* harmony import */ var _helpers_coordinate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/coordinate */ "./node_modules/@toast-ui/chart/dist/esm/helpers/coordinate.js");
/* harmony import */ var _stackSeriesData__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stackSeriesData */ "./node_modules/@toast-ui/chart/dist/esm/store/stackSeriesData.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");






const MIN_OFFSET_SIZE = 1;
function getLabelScaleData(state, labelAxisOnYAxis, scaleOptions, labelAxisName) {
    var _a, _b;
    const { dataRange, layout, series, options } = state;
    const categories = state.categories;
    const rawCategories = state.rawCategories;
    const { labelSizeKey } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_0__.getSizeKey)(labelAxisOnYAxis);
    const dateTypeLabel = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isExist)((_a = options.xAxis) === null || _a === void 0 ? void 0 : _a.date);
    const labelOptions = {
        dataRange: dataRange[labelAxisName],
        offsetSize: Math.max(layout.plot[labelSizeKey], MIN_OFFSET_SIZE),
        scaleOption: scaleOptions[labelAxisName],
        rawCategoriesSize: rawCategories.length,
    };
    let result;
    if (dataRange[labelAxisName]) {
        result = dateTypeLabel
            ? (0,_scale_datetimeScaleCalculator__WEBPACK_IMPORTED_MODULE_2__.calculateDatetimeScale)(labelOptions)
            : (0,_scale_coordinateScaleCalculator__WEBPACK_IMPORTED_MODULE_3__.calculateCoordinateScale)(labelOptions);
    }
    if (series.line && categories && !((_b = options.xAxis) === null || _b === void 0 ? void 0 : _b.pointOnColumn)) {
        result = (0,_scale_coordinateScaleCalculator__WEBPACK_IMPORTED_MODULE_3__.calculateXAxisScaleForCoordinateLineType)(result, options, categories);
    }
    return result;
}
function getValueScaleData(state, labelAxisOnYAxis, scaleOptions, valueAxisName, isCoordinateTypeChart) {
    const { dataRange, layout, series, stackSeries } = state;
    const { valueSizeKey } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_0__.getSizeKey)(labelAxisOnYAxis);
    let result;
    if ((0,_stackSeriesData__WEBPACK_IMPORTED_MODULE_4__.hasPercentStackSeries)(stackSeries)) {
        Object.keys(series).forEach((seriesName) => {
            result = (0,_scale_coordinateScaleCalculator__WEBPACK_IMPORTED_MODULE_3__.getStackScaleData)(stackSeries[seriesName].scaleType);
        });
    }
    else if (isCoordinateTypeChart) {
        const valueOptions = {
            dataRange: dataRange[valueAxisName],
            offsetSize: Math.max(layout.plot[valueSizeKey], MIN_OFFSET_SIZE),
            scaleOption: scaleOptions[valueAxisName],
        };
        result = (0,_scale_coordinateScaleCalculator__WEBPACK_IMPORTED_MODULE_3__.calculateCoordinateScale)(valueOptions);
    }
    else {
        result = (0,_scale_coordinateScaleCalculator__WEBPACK_IMPORTED_MODULE_3__.calculateCoordinateScale)({
            dataRange: dataRange[valueAxisName],
            offsetSize: Math.max(layout.plot[valueSizeKey], MIN_OFFSET_SIZE),
            scaleOption: scaleOptions[valueAxisName],
        });
    }
    return result;
}
function getScaleOptions(options, series, valueAxisName) {
    var _a, _b, _c, _d, _e, _f;
    const scaleOptions = {};
    if ((0,_helpers_axes__WEBPACK_IMPORTED_MODULE_0__.isSeriesUsingRadialAxes)(series)) {
        scaleOptions[valueAxisName] = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a[valueAxisName]) === null || _b === void 0 ? void 0 : _b.scale;
    }
    else {
        const { yAxis, secondaryYAxis } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_0__.getYAxisOption)(options);
        scaleOptions.xAxis = (_d = (_c = options) === null || _c === void 0 ? void 0 : _c.xAxis) === null || _d === void 0 ? void 0 : _d.scale;
        scaleOptions.yAxis = (_e = yAxis) === null || _e === void 0 ? void 0 : _e.scale;
        if (secondaryYAxis) {
            scaleOptions.secondaryYAxis = (_f = secondaryYAxis) === null || _f === void 0 ? void 0 : _f.scale;
        }
    }
    return scaleOptions;
}
const scale = {
    name: 'scale',
    state: () => ({
        scale: {},
    }),
    action: {
        setScale({ state, initStoreState }) {
            const { series, options, categories } = state;
            const labelAxisOnYAxis = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_0__.isLabelAxisOnYAxis)({ series, options, categories });
            const { labelAxisName, valueAxisName } = (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_0__.getAxisName)(labelAxisOnYAxis, series);
            const scaleOptions = getScaleOptions(options, series, valueAxisName);
            const isCoordinateTypeChart = (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_5__.isCoordinateSeries)(initStoreState.series);
            const scaleData = {};
            (0,_helpers_axes__WEBPACK_IMPORTED_MODULE_0__.getValueAxisNames)(options, valueAxisName).forEach((axisName) => {
                scaleData[axisName] = getValueScaleData(state, labelAxisOnYAxis, scaleOptions, axisName, isCoordinateTypeChart);
            });
            if (isCoordinateTypeChart) {
                scaleData[labelAxisName] = getLabelScaleData(state, labelAxisOnYAxis, scaleOptions, labelAxisName);
            }
            state.scale = scaleData;
        },
    },
    observe: {
        updateScale() {
            this.dispatch('setScale');
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (scale);


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/seriesData.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/seriesData.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _category__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./category */ "./node_modules/@toast-ui/chart/dist/esm/store/category.js");
/* harmony import */ var _helpers_coordinate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/coordinate */ "./node_modules/@toast-ui/chart/dist/esm/helpers/coordinate.js");
/* harmony import */ var _helpers_range__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/range */ "./node_modules/@toast-ui/chart/dist/esm/helpers/range.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../message */ "./node_modules/@toast-ui/chart/dist/esm/message.js");
/* harmony import */ var _helpers_pieSeries__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/pieSeries */ "./node_modules/@toast-ui/chart/dist/esm/helpers/pieSeries.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./store */ "./node_modules/@toast-ui/chart/dist/esm/store/store.js");







function initRange(series, categories) {
    let rawCategoriesLength;
    if (categories) {
        rawCategoriesLength = Array.isArray(categories) ? categories.length : categories.x.length;
    }
    else {
        rawCategoriesLength = Object.keys((0,_category__WEBPACK_IMPORTED_MODULE_0__.makeRawCategories)(series, categories)).length;
    }
    return [0, rawCategoriesLength - 1];
}
function initSelectionRange(series, options, categories) {
    var _a;
    if (!(series.line || series.area || series.column) ||
        !((_a = options.series) === null || _a === void 0 ? void 0 : _a.rangeSelectable)) {
        return;
    }
    return initRange(series, categories);
}
function initZoomRange(series, options, categories) {
    var _a;
    if (!(series.line || series.area) || !((_a = options.series) === null || _a === void 0 ? void 0 : _a.zoomable)) {
        return;
    }
    return initRange(series, categories);
}
function initShiftRange(series, options, categories) {
    var _a;
    if (!(series.line || series.area || series.column || series.heatmap) ||
        !((_a = options.series) === null || _a === void 0 ? void 0 : _a.shift)) {
        return;
    }
    return initRange(series, categories);
}
function getCoordinateDataRange(data, rawCategories, zoomRange) {
    const [zoomStart, zoomEnd] = zoomRange;
    let start, end;
    (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.range)(zoomStart, zoomEnd + 1).forEach((i) => {
        const idx = data.findIndex((datum) => (0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_2__.getCoordinateXValue)(datum).toString() === rawCategories[i]);
        if (idx !== -1) {
            if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(start)) {
                start = idx;
            }
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(start)) {
                end = Math.max(idx, (end !== null && end !== void 0 ? end : 0));
            }
        }
    });
    return [start, end];
}
function getSeriesColors(colors, colorIndex, size, isColorByCategories) {
    return isColorByCategories ? colors.slice(0, size + 1) : colors[colorIndex % colors.length];
}
function getSeriesDataInRange(data, rawCategories, chartType, zoomRange) {
    if (!zoomRange) {
        return data;
    }
    let [startIdx, endIdx] = zoomRange;
    const firstValidValue = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.getFirstValidValue)(data);
    const isCoordinateChart = chartType !== 'area' && !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(firstValidValue) && !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(firstValidValue);
    if (isCoordinateChart) {
        [startIdx, endIdx] = getCoordinateDataRange(data, rawCategories, zoomRange);
    }
    else {
        startIdx = startIdx > 1 ? startIdx - 1 : startIdx;
        endIdx = endIdx < rawCategories.length - 1 ? endIdx + 1 : endIdx;
    }
    return data.slice(startIdx, endIdx + 1);
}
function isCoordinateTypeSeries(series, chartType) {
    return ((0,_helpers_coordinate__WEBPACK_IMPORTED_MODULE_2__.isCoordinateSeries)(series) &&
        ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(chartType) || chartType === 'line' || chartType === 'scatter'));
}
function isSeriesAlreadyExist(series, seriesName, data) {
    return series[seriesName].some(({ label }) => label === data.name);
}
function isTreemapSeriesAlreadyExist(series, data) {
    return series.treemap.some(({ label }) => label === data.label);
}
function isHeatmapSeriesAlreadyExist(categories, category) {
    return (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.includes)(categories.y, category);
}
function initDisabledSeries(series) {
    const nestedPieChart = (0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_3__.hasNestedPieSeries)(series);
    const disabledSeries = [];
    if (nestedPieChart) {
        series.pie.forEach(({ data }) => {
            data.forEach((datum) => {
                if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(datum.visible) && !datum.visible) {
                    disabledSeries.push(datum.name);
                }
            });
        });
    }
    else {
        Object.keys(series).forEach((type) => {
            series[type].forEach(({ name, visible }) => {
                if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(visible) && !visible) {
                    disabledSeries.push(name);
                }
            });
        });
    }
    return disabledSeries;
}
const seriesData = {
    name: 'seriesData',
    state: ({ series, categories, options }) => ({
        rawCategories: (0,_category__WEBPACK_IMPORTED_MODULE_0__.makeRawCategories)(series, categories),
        series: Object.assign({}, series),
        selectionRange: initSelectionRange(series, options, categories),
        zoomRange: initZoomRange(series, options, categories),
        shiftRange: initShiftRange(series, options, categories),
        disabledSeries: initDisabledSeries(series),
    }),
    action: {
        setSeriesData({ state, initStoreState }) {
            const rawSeries = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.deepCopy)(initStoreState.series);
            const { disabledSeries, theme, zoomRange, rawCategories } = state;
            const newSeriesData = {};
            let colorIndex = 0;
            Object.keys(rawSeries).forEach((seriesName) => {
                var _a, _b, _c;
                const { colors, iconTypes } = theme.series[seriesName];
                let originSeriesData = rawSeries[seriesName].map((series) => {
                    const isColorByCategories = !!series.colorByCategories;
                    const size = isColorByCategories ? rawCategories.length : 1;
                    const color = colors
                        ? getSeriesColors(colors, colorIndex, size, isColorByCategories)
                        : '';
                    colorIndex += size;
                    return Object.assign(Object.assign({}, series), { rawData: series.data, data: getSeriesDataInRange(series.data, rawCategories, seriesName, zoomRange), color });
                });
                if (seriesName === 'scatter') {
                    originSeriesData = originSeriesData.map((series, idx) => (Object.assign(Object.assign({}, series), { iconType: iconTypes ? iconTypes[idx] : 'circle' })));
                }
                const seriesCount = originSeriesData.length;
                const seriesGroupCount = (_c = (_b = (_a = originSeriesData[0]) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.length, (_c !== null && _c !== void 0 ? _c : 0));
                const data = originSeriesData.filter(({ name }) => !disabledSeries.includes(name));
                newSeriesData[seriesName] = {
                    seriesCount,
                    seriesGroupCount,
                    data,
                    colors,
                };
            });
            (0,_store__WEBPACK_IMPORTED_MODULE_4__.extend)(state.series, newSeriesData);
        },
        disableSeries({ state }, name) {
            state.disabledSeries.push(name);
            this.notify(state, 'disabledSeries');
            if (state.series.bullet) {
                this.dispatch('removeCategoryByName', name);
            }
        },
        enableSeries({ state }, name) {
            const index = state.disabledSeries.findIndex((disabled) => disabled === name);
            state.disabledSeries.splice(index, 1);
            this.notify(state, 'disabledSeries');
            if (state.series.bullet) {
                state.categories = state.series.bullet.data.map(({ name: seriesName }) => seriesName);
                this.notify(state, 'axes');
            }
        },
        selection({ state }, rangeCategories) {
            const rawCategories = state.rawCategories;
            state.selectionRange = rangeCategories.map((rangeCategory) => rawCategories.findIndex((category) => category === rangeCategory));
            this.notify(state, 'selectionRange');
        },
        zoom({ state }, rangeCategories) {
            const rawCategories = state.rawCategories;
            state.zoomRange = rangeCategories.map((rangeCategory) => rawCategories.findIndex((category) => category === rangeCategory));
            this.notify(state, 'zoomRange');
        },
        resetZoom({ state, initStoreState }) {
            const { series, options } = initStoreState;
            const rawCategories = state.rawCategories;
            state.zoomRange = initZoomRange(series, options, rawCategories);
            this.notify(state, 'zoomRange');
        },
        addData({ state, initStoreState }, { data, category, chartType }) {
            const { series } = initStoreState;
            const coordinateChart = isCoordinateTypeSeries(state.series, chartType);
            let { categories } = initStoreState;
            categories = series.heatmap ? categories.x : categories;
            if (category && Array.isArray(categories)) {
                const isExist = categories.some((c) => c === category);
                if (!isExist) {
                    categories.push(category);
                    if (Array.isArray(state.shiftRange)) {
                        const [start, end] = state.shiftRange;
                        state.shiftRange = [start + 1, end + 1];
                    }
                }
            }
            if (chartType) {
                series[chartType].forEach((datum, idx) => {
                    datum.data.push(data[idx]);
                });
            }
            else {
                const [seriesName] = Object.keys(initStoreState.series);
                series[seriesName].forEach((datum, idx) => {
                    datum.data.push(data[idx]);
                });
            }
            this.notify(state, 'series');
            this.notify(state, 'rawCategories');
            if (Array.isArray(state.zoomRange)) {
                this.dispatch('resetZoom');
            }
            if (coordinateChart) {
                this.dispatch('initCategory');
            }
        },
        addSeries({ state, initStoreState }, { data, chartType, category, }) {
            const { series, categories } = initStoreState;
            const coordinateChart = isCoordinateTypeSeries(state.series, chartType);
            const seriesName = chartType || Object.keys(series)[0];
            const isExist = isSeriesAlreadyExist(series, seriesName, data);
            if (!isExist) {
                series[seriesName].push(data);
                if (Array.isArray(categories) && category) {
                    categories.push(category);
                }
            }
            this.dispatch('initThemeState');
            this.dispatch('initLegendState');
            this.notify(state, 'series');
            if (coordinateChart || seriesName === 'bullet') {
                this.dispatch('initCategory');
            }
        },
        addHeatmapSeries({ state, initStoreState }, { data, category }) {
            const { series, categories } = initStoreState;
            const isExist = isHeatmapSeriesAlreadyExist(categories, category);
            if (!isExist) {
                series.heatmap.push({ data, yCategory: category });
            }
            if (!isExist && category) {
                categories.y.push(category);
                this.notify(state, 'rawCategories');
            }
            this.notify(state, 'series');
            this.dispatch('initThemeState');
            this.dispatch('initLegendState');
        },
        addTreemapSeries({ state, initStoreState }, { data }) {
            const { series } = initStoreState;
            const isExist = isTreemapSeriesAlreadyExist(series, data);
            if (!isExist) {
                series.treemap.push(data);
            }
            this.notify(state, 'series');
            this.notify(state, 'treemapSeries');
            this.dispatch('initThemeState');
            this.dispatch('initLegendState');
        },
        setData({ state, initStoreState }, { series, categories }) {
            initStoreState.series = series;
            const isNestedPieChart = (0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_3__.hasNestedPieSeries)(series);
            if (!isNestedPieChart) {
                state.rawCategories = (0,_category__WEBPACK_IMPORTED_MODULE_0__.makeRawCategories)(series, categories);
            }
            this.dispatch('initThemeState');
            this.dispatch('initLegendState');
        },
        addOutlier({ state, initStoreState }, { seriesIndex, outliers }) {
            var _a;
            const { series } = initStoreState;
            const seriesRawData = series.boxPlot[seriesIndex];
            if (!seriesRawData) {
                throw new Error(_message__WEBPACK_IMPORTED_MODULE_5__.message.SERIES_INDEX_ERROR);
            }
            seriesRawData.outliers = [...(_a = seriesRawData.outliers, (_a !== null && _a !== void 0 ? _a : [])), ...outliers];
            this.notify(state, 'series');
        },
    },
    observe: {
        updateSeriesData() {
            this.dispatch('setSeriesData');
        },
    },
    computed: {
        isLineTypeSeriesZooming: ({ zoomRange, rawCategories }) => {
            return (0,_helpers_range__WEBPACK_IMPORTED_MODULE_6__.isZooming)(rawCategories, zoomRange);
        },
        viewRange: ({ zoomRange, shiftRange }) => {
            return zoomRange || shiftRange;
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (seriesData);


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/stackSeriesData.js":
/*!************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/stackSeriesData.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isPercentStack": () => (/* binding */ isPercentStack),
/* harmony export */   "isGroupStack": () => (/* binding */ isGroupStack),
/* harmony export */   "hasPercentStackSeries": () => (/* binding */ hasPercentStackSeries),
/* harmony export */   "pickStackOption": () => (/* binding */ pickStackOption),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./store */ "./node_modules/@toast-ui/chart/dist/esm/store/store.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");


function isPercentStack(stack) {
    var _a;
    return !!(((_a = stack) === null || _a === void 0 ? void 0 : _a.type) === 'percent');
}
function isGroupStack(rawData) {
    return !Array.isArray(rawData);
}
function hasPercentStackSeries(stackSeries) {
    if (!stackSeries) {
        return false;
    }
    return Object.keys(stackSeries).some((seriesName) => isPercentStack(stackSeries[seriesName].stack));
}
function pickStackOption(options) {
    return ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.pickProperty)(options, ['series', 'stack']) ||
        (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.pickProperty)(options, ['series', 'column', 'stack']) ||
        (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.pickProperty)(options, ['series', 'area', 'stack']));
}
function makeStackData(seriesData) {
    const seriesCount = seriesData.length;
    const groupCountLengths = seriesData.map(({ rawData }) => rawData.length);
    const seriesGroupCount = Math.max(...groupCountLengths);
    const stackData = [];
    for (let i = 0; i < seriesGroupCount; i += 1) {
        const stackValues = [];
        for (let j = 0; j < seriesCount; j += 1) {
            stackValues.push(seriesData[j].rawData[i]);
        }
        stackData[i] = {
            values: stackValues,
            sum: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.sum)(stackValues),
            total: {
                positive: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.sum)(stackValues.filter((value) => value >= 0)),
                negative: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.sum)(stackValues.filter((value) => value < 0)),
            },
        };
    }
    return stackData;
}
function makeStackGroupData(seriesData) {
    const stackData = {};
    const stackGroupIds = [...new Set(seriesData.map(({ stackGroup }) => stackGroup))];
    stackGroupIds.forEach((groupId) => {
        const filtered = seriesData.filter(({ stackGroup }) => groupId === stackGroup);
        stackData[groupId] = makeStackData(filtered);
    });
    return stackData;
}
function initializeStack(stackOption) {
    if (!stackOption) {
        return;
    }
    const defaultStackOption = {
        type: 'normal',
        connector: false,
    };
    if (isStackObject(stackOption)) {
        return Object.assign(Object.assign({}, defaultStackOption), stackOption);
    }
    return defaultStackOption;
}
function isStackObject(stackOption) {
    return (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(stackOption);
}
function hasStackGrouped(seriesRawData) {
    return seriesRawData.some((rawData) => rawData.hasOwnProperty('stackGroup'));
}
function getStackDataRangeValues(stackData) {
    let values = [];
    if (Array.isArray(stackData)) {
        values = [0, ...getSumValues(stackData)];
    }
    else {
        for (const groupId in stackData) {
            if (Object.prototype.hasOwnProperty.call(stackData, groupId)) {
                values = [0, ...values, ...getSumValues(stackData[groupId])];
            }
        }
    }
    return values;
}
function getSumValues(stackData) {
    const positiveSum = stackData.map(({ total }) => total.positive);
    const negativeSum = stackData.map(({ total }) => total.negative);
    return [...negativeSum, ...positiveSum];
}
function getStackDataValues(stackData) {
    if (!isGroupStack(stackData)) {
        return stackData;
    }
    let stackDataValues = [];
    if (isGroupStack(stackData)) {
        Object.keys(stackData).forEach((groupId) => {
            stackDataValues = [...stackDataValues, ...stackData[groupId]];
        });
    }
    return stackDataValues;
}
function checkIfNegativeAndPositiveValues(stackData) {
    return {
        hasNegative: stackData.map(({ total }) => total.negative).some((total) => total < 0),
        hasPositive: stackData.map(({ total }) => total.positive).some((total) => total >= 0),
    };
}
function getScaleType(stackData, stackType, diverging) {
    const { hasPositive, hasNegative } = checkIfNegativeAndPositiveValues(stackData);
    if (stackType === 'percent') {
        if (diverging) {
            return 'divergingPercentStack';
        }
        if (hasNegative && hasPositive) {
            return 'dualPercentStack';
        }
        if (!hasNegative && hasPositive) {
            return 'percentStack';
        }
        if (hasNegative && !hasPositive) {
            return 'minusPercentStack';
        }
    }
}
function initStackSeries(series, options) {
    const stackSeries = {};
    Object.keys(series).forEach((seriesName) => {
        const chartType = seriesName;
        const stackOption = pickStackOption(options);
        if (stackOption) {
            if (!stackSeries[chartType]) {
                stackSeries[chartType] = {};
            }
            stackSeries[chartType].stack = initializeStack(stackOption);
        }
        else if (seriesName === 'radialBar') {
            stackSeries[seriesName] = { stack: true };
        }
    });
    return stackSeries;
}
const stackSeriesData = {
    name: 'stackSeriesData',
    state: ({ series, options }) => ({
        stackSeries: initStackSeries(series, options),
    }),
    action: {
        setStackSeriesData({ state }) {
            const { series, stackSeries, options } = state;
            const stackOption = pickStackOption(options);
            const newStackSeries = {};
            Object.keys(series).forEach((seriesName) => {
                var _a, _b;
                const seriesData = series[seriesName];
                const { data, seriesCount, seriesGroupCount } = seriesData;
                const isRadialBar = seriesName === 'radialBar';
                if (stackOption) {
                    if (!stackSeries[seriesName]) {
                        stackSeries[seriesName] = {};
                    }
                    stackSeries[seriesName].stack = initializeStack(stackOption);
                }
                else if (!isRadialBar) {
                    stackSeries[seriesName] = null;
                    delete stackSeries[seriesName];
                }
                const { stack } = stackSeries[seriesName] || {};
                const diverging = !!((_a = options.series) === null || _a === void 0 ? void 0 : _a.diverging);
                if (stack) {
                    const stackData = hasStackGrouped(data) ? makeStackGroupData(data) : makeStackData(data);
                    const stackType = (_b = stack.type, (_b !== null && _b !== void 0 ? _b : 'normal'));
                    const dataRangeValues = getStackDataRangeValues(stackData);
                    newStackSeries[seriesName] = {
                        data,
                        seriesCount,
                        seriesGroupCount,
                        stackData,
                        dataRangeValues,
                        scaleType: getScaleType(getStackDataValues(stackData), stackType, diverging),
                    };
                    state.stackSeries[seriesName].stackData = stackData;
                }
                (0,_store__WEBPACK_IMPORTED_MODULE_1__.extend)(state.stackSeries, newStackSeries);
            });
        },
    },
    observe: {
        updateStackSeriesData() {
            this.dispatch('setStackSeriesData');
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stackSeriesData);


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/store.js":
/*!**************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/store.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Store),
/* harmony export */   "extend": () => (/* binding */ extend)
/* harmony export */ });
/* harmony import */ var _reactive__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reactive */ "./node_modules/@toast-ui/chart/dist/esm/store/reactive.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");


class Store {
    constructor(initStoreState) {
        this.computed = {};
        this.actions = {};
        this.initStoreState = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.deepCopy)(initStoreState);
        this.setRootState({});
    }
    setRootState(state) {
        (0,_reactive__WEBPACK_IMPORTED_MODULE_1__.observable)(state);
        this.state = state;
    }
    setComputed(namePath, fn, holder = this.computed) {
        const splited = namePath.split('.');
        const key = splited.splice(splited.length - 1, 1)[0];
        const target = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.pickPropertyWithMakeup)(holder, splited);
        (0,_reactive__WEBPACK_IMPORTED_MODULE_1__.computed)(target, key, fn.bind(null, this.state, this.computed));
    }
    setWatch(namePath, fn) {
        return (0,_reactive__WEBPACK_IMPORTED_MODULE_1__.watch)(this, namePath, fn);
    }
    setAction(name, fn) {
        this.actions[name] = fn;
    }
    dispatch(name, payload, isInvisible) {
        // observe.setlayout 안에서 setLayout 액션이 실행되니까 여기서 state.layout getter가 실행되고
        // state.layout의 옵져버로 observe.setLayout이 등록된다. 여기서 무한루프
        // 즉 observe하고 안에서 특정 대상을 쓸때
        // extend(state.layout, layouts); 이런식으로 하게되면 layout의 getter실행되어
        // layout을 업데이트하려고 만든 observe를 옵저버로 등록해서 무한루프
        if (isInvisible) {
            (0,_reactive__WEBPACK_IMPORTED_MODULE_1__.invisibleWork)(() => {
                // console.log('dispatch', name, ...args);
                this.actions[name].call(this, this, payload);
                // console.log('dispatch end', name);
            });
        }
        else {
            this.actions[name].call(this, this, payload);
        }
    }
    observe(fn) {
        return (0,_reactive__WEBPACK_IMPORTED_MODULE_1__.observe)(fn.bind(this, this.state, this.computed));
    }
    observable(target) {
        return (0,_reactive__WEBPACK_IMPORTED_MODULE_1__.observable)(target);
    }
    notifyByPath(namePath) {
        (0,_reactive__WEBPACK_IMPORTED_MODULE_1__.notifyByPath)(this, namePath);
    }
    notify(target, key) {
        (0,_reactive__WEBPACK_IMPORTED_MODULE_1__.notify)(target, key);
    }
    setModule(name, param) {
        if (!param) {
            param = name;
            name = param.name;
        }
        if (param.state) {
            const moduleState = typeof param.state === 'function' ? param.state(this.initStoreState) : param.state;
            extend(this.state, moduleState);
        }
        if (param.computed) {
            (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(param.computed, (item, key) => {
                this.setComputed(key, item);
            });
        }
        if (param.watch) {
            (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(param.watch, (item, key) => {
                this.setWatch(key, item);
            });
        }
        if (param.action) {
            (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(param.action, (item, key) => {
                this.setAction(key, item);
            });
        }
        if (param.observe) {
            (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(param.observe, (item) => {
                this.observe(item);
            });
        }
    }
    setValue(target, key, source) {
        extend(target, {
            [key]: source,
        });
    }
}
function extend(target, source) {
    const newItems = {};
    for (const k in source) {
        if (!source.hasOwnProperty(k)) {
            continue;
        }
        if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(target[k])) {
            if (typeof source[k] === 'object' && !Array.isArray(source[k])) {
                extend(target[k], source[k]);
            }
            else {
                target[k] = source[k];
            }
        }
        else {
            newItems[k] = source[k];
        }
    }
    if (Object.keys(newItems).length) {
        (0,_reactive__WEBPACK_IMPORTED_MODULE_1__.extend)(target, newItems);
    }
}


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/theme.js":
/*!**************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/theme.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");
/* harmony import */ var _helpers_pieSeries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/pieSeries */ "./node_modules/@toast-ui/chart/dist/esm/helpers/pieSeries.js");
/* harmony import */ var _helpers_theme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/theme */ "./node_modules/@toast-ui/chart/dist/esm/helpers/theme.js");



function getCommonSeriesOptions(options, series, isNestedPieChart) {
    var _a, _b;
    const theme = (_a = options) === null || _a === void 0 ? void 0 : _a.theme;
    if (!((_b = theme) === null || _b === void 0 ? void 0 : _b.series)) {
        return {};
    }
    const seriesNames = isNestedPieChart ? (0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_0__.getNestedPieChartAliasNames)(series) : Object.keys(series);
    return seriesNames.reduce((acc, seriesName) => {
        delete acc[seriesName];
        return acc;
    }, Object.assign({}, theme.series));
}
function getThemeAppliedSecondaryYAxis(options) {
    var _a, _b, _c;
    const theme = Object.assign({}, options.theme);
    if (!Array.isArray(theme.yAxis)) {
        return theme;
    }
    const axisTitleTheme = (0,_helpers_theme__WEBPACK_IMPORTED_MODULE_1__.makeAxisTitleTheme)((_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.theme) === null || _b === void 0 ? void 0 : _b.chart) === null || _c === void 0 ? void 0 : _c.fontFamily);
    const yAxis = theme.yAxis.map((yAxisTheme) => (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.deepMergedCopy)({ title: Object.assign({}, axisTitleTheme) }, Object.assign({}, yAxisTheme)));
    return Object.assign(Object.assign({}, theme), { yAxis });
}
function getThemeOptionsWithSeriesName(options, series, commonSeriesOptions, isNestedPieChart) {
    var _a;
    const theme = getThemeAppliedSecondaryYAxis(options);
    if (!((_a = theme) === null || _a === void 0 ? void 0 : _a.series)) {
        return Object.assign({}, theme);
    }
    const seriesTheme = Object.assign(Object.assign({}, theme), { series: {} });
    const seriesNames = Object.keys(series);
    const isComboChart = seriesNames.length > 1;
    if (isNestedPieChart) {
        const aliasNames = (0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_0__.getNestedPieChartAliasNames)(series);
        seriesTheme.series = {
            pie: aliasNames.reduce((acc, aliasName) => {
                var _a;
                return (Object.assign(Object.assign({}, acc), { [aliasName]: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.deepMergedCopy)((_a = theme.series) === null || _a === void 0 ? void 0 : _a[aliasName], (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.omit)(commonSeriesOptions, 'colors')) }));
            }, {}),
        };
    }
    else if (isComboChart) {
        seriesTheme.series = Object.assign({}, seriesNames.reduce((acc, seriesName) => {
            var _a;
            return (Object.assign(Object.assign({}, acc), { [seriesName]: (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.deepMergedCopy)((_a = theme.series) === null || _a === void 0 ? void 0 : _a[seriesName], (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.omit)(commonSeriesOptions, 'colors')) }));
        }, {}));
    }
    else {
        seriesTheme.series = {
            [seriesNames[0]]: theme.series,
        };
    }
    return seriesTheme;
}
function setColors(theme, series, commonSeriesOptions, isNestedPieChart, categories) {
    var _a, _b;
    let index = 0;
    const commonColorsOption = [
        ...(_b = (_a = commonSeriesOptions) === null || _a === void 0 ? void 0 : _a.colors, (_b !== null && _b !== void 0 ? _b : [])),
        ..._helpers_theme__WEBPACK_IMPORTED_MODULE_1__.defaultSeriesTheme.colors,
    ];
    const themeNames = isNestedPieChart ? (0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_0__.getNestedPieChartAliasNames)(series) : Object.keys(series);
    themeNames.forEach((name, idx) => {
        var _a;
        const themeSeries = series[name] || [];
        const filteredSeries = themeSeries.filter((chartSeries) => chartSeries.colorByCategories);
        const hasColorByCategories = filteredSeries.length > 0;
        let size;
        if (isNestedPieChart) {
            size = series.pie[idx].data.length;
        }
        else if (hasColorByCategories) {
            const rejectedSeries = themeSeries.filter((chartSeries) => !chartSeries.colorByCategories);
            size = rejectedSeries.length + categories.length;
        }
        else {
            size = series[name].length;
        }
        const target = isNestedPieChart ? theme.series.pie : theme.series;
        if (!((_a = target[name]) === null || _a === void 0 ? void 0 : _a.colors)) {
            target[name] = Object.assign(Object.assign({}, target[name]), { colors: commonColorsOption.slice(index, index + size) });
            index += size;
        }
    });
}
function setPlot(theme) {
    ['vertical', 'horizontal'].reduce((acc, cur) => {
        if (!acc[cur]) {
            acc[cur] = { lineColor: acc.lineColor };
        }
        return acc;
    }, theme.plot);
}
function checkAnchorPieSeriesOption(options, series, alias) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    return {
        hasOuterAnchor: !!series.pie && ((_d = (_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b[alias]) === null || _c === void 0 ? void 0 : _c.dataLabels) === null || _d === void 0 ? void 0 : _d.anchor) === 'outer',
        hasOuterAnchorPieSeriesName: !!series.pie && ((_j = (_h = (_g = (_f = (_e = options) === null || _e === void 0 ? void 0 : _e.series) === null || _f === void 0 ? void 0 : _f[alias]) === null || _g === void 0 ? void 0 : _g.dataLabels) === null || _h === void 0 ? void 0 : _h.pieSeriesName) === null || _j === void 0 ? void 0 : _j.anchor) === 'outer',
    };
}
function getTheme(options, series, categories) {
    var _a, _b, _c;
    const isNestedPieChart = (0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_0__.hasNestedPieSeries)(series);
    const commonSeriesOptions = getCommonSeriesOptions(options, series, isNestedPieChart);
    let pieSeriesOuterAnchors = {
        hasOuterAnchor: (0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_0__.hasOuterDataLabel)(options, series),
        hasOuterAnchorPieSeriesName: (0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_0__.hasOuterPieSeriesName)(options, series),
    };
    if (isNestedPieChart) {
        const aliasNames = (0,_helpers_pieSeries__WEBPACK_IMPORTED_MODULE_0__.getNestedPieChartAliasNames)(series);
        pieSeriesOuterAnchors = aliasNames.reduce((acc, cur) => (Object.assign(Object.assign({}, acc), { [cur]: checkAnchorPieSeriesOption(options, series, cur) })), {});
    }
    const globalFontFamily = (_c = (_b = (_a = options) === null || _a === void 0 ? void 0 : _a.theme) === null || _b === void 0 ? void 0 : _b.chart) === null || _c === void 0 ? void 0 : _c.fontFamily;
    const theme = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.deepMergedCopy)((0,_helpers_theme__WEBPACK_IMPORTED_MODULE_1__.getDefaultTheme)(series, pieSeriesOuterAnchors, globalFontFamily, isNestedPieChart), getThemeOptionsWithSeriesName(options, series, commonSeriesOptions, isNestedPieChart));
    if (!series.heatmap) {
        setColors(theme, series, commonSeriesOptions, isNestedPieChart, categories);
    }
    setPlot(theme);
    return theme;
}
const theme = {
    name: 'theme',
    state: ({ options, series, categories }) => ({
        theme: getTheme(options, series, categories),
    }),
    action: {
        initThemeState({ state, initStoreState }) {
            state.theme = getTheme(state.options, initStoreState.series, initStoreState.categories);
        },
    },
    observe: {
        updateTheme() {
            this.dispatch('initThemeState');
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (theme);


/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/esm/store/treemapSeriesData.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/esm/store/treemapSeriesData.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TREEMAP_ROOT_ID": () => (/* binding */ TREEMAP_ROOT_ID),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/utils */ "./node_modules/@toast-ui/chart/dist/esm/helpers/utils.js");

const TREEMAP_ID_PREFIX = '__TOAST_UI_TREEMAP';
const TREEMAP_ROOT_ID = `${TREEMAP_ID_PREFIX}_ROOT`;
function makeTreeModel(series, indexes, depth, parentId) {
    var _a;
    const idx = (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.last)(indexes);
    const id = parentId ? `${parentId}_${idx}` : `${TREEMAP_ID_PREFIX}_${idx}`;
    const { colorValue } = series;
    const models = [
        {
            label: series.label,
            hasChild: !!series.children,
            id,
            indexes,
            parentId: parentId ? parentId : TREEMAP_ROOT_ID,
            depth,
            data: (_a = series.data, (_a !== null && _a !== void 0 ? _a : 0)),
            colorValue,
        },
    ];
    if (series.children) {
        series.children.forEach((child, childIdx) => {
            if (!(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNull)(child.data)) {
                models.push(...makeTreeModel(child, [...indexes, childIdx], depth + 1, id));
            }
        });
    }
    return models;
}
function setParentSeriesData(treemapSeries) {
    treemapSeries.forEach(({ parentId, data }) => {
        if (parentId !== TREEMAP_ROOT_ID) {
            treemapSeries.find(({ id }) => id === parentId).data += data;
        }
    });
}
function setParentColorValue(treemapSeries) {
    treemapSeries.forEach((datum) => {
        const { id, colorValue } = datum;
        if ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(colorValue)) {
            const series = treemapSeries.filter(({ parentId }) => parentId === id);
            const totalColorValue = series.reduce((acc, cur) => {
                return acc + ((0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(cur.colorValue) ? 0 : cur.colorValue);
            }, 0);
            datum.colorValue = totalColorValue / series.length;
        }
    });
}
function setRatio(treemapSeries) {
    const rootTotal = treemapSeries
        .filter(({ parentId }) => parentId === TREEMAP_ROOT_ID)
        .reduce((acc, { data }) => acc + data, 0);
    treemapSeries.forEach((series) => {
        const total = series.parentId === TREEMAP_ROOT_ID
            ? rootTotal
            : treemapSeries.find(({ id }) => id === series.parentId).data;
        series.ratio = series.data / total;
    });
}
function makeTreemapSeries(series, options) {
    var _a;
    if (!series.treemap) {
        return [];
    }
    const treemapSeries = series.treemap.data
        .filter((datum) => !(0,_helpers_utils__WEBPACK_IMPORTED_MODULE_0__.isNull)(datum.data))
        .map((datum, idx) => makeTreeModel(datum, [idx], 0))
        .flatMap((s) => s)
        .sort((a, b) => b.depth - a.depth);
    setParentSeriesData(treemapSeries);
    setRatio(treemapSeries);
    if ((_a = options.series) === null || _a === void 0 ? void 0 : _a.useColorValue) {
        setParentColorValue(treemapSeries);
    }
    return treemapSeries;
}
const treemapSeriesData = {
    name: 'treemapSeriesData',
    state: () => ({
        treemapSeries: [],
    }),
    action: {
        setTreemapSeriesData({ state }) {
            state.treemapSeries = makeTreemapSeries(state.series, state.options);
        },
    },
    observe: {
        updateTreemapSeriesData() {
            this.dispatch('setTreemapSeriesData');
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (treemapSeriesData);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/@toast-ui/chart/dist/toastui-chart.min.css":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/@toast-ui/chart/dist/toastui-chart.min.css ***!
  \*******************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/*!\n * TOAST UI Chart 4th Edition\n * @version 4.6.1 | Wed Dec 21 2022\n * @author NHN Cloud. FE Development Lab <dl_javascript@nhn.com>\n * @license MIT\n */.toastui-chart-wrapper{height:100%;position:relative;width:100%}.toastui-chart-export-menu{background:#fff;box-sizing:border-box;font-family:Arial,sans-serif;left:0;position:absolute;top:0;user-select:none}.toastui-chart-export-menu-title{box-sizing:inherit;height:34px;margin:0;padding:10px;width:140px}.toastui-chart-export-menu-btn-wrapper{height:76px;width:100%}.toastui-chart-export-menu-btn{background:transparent;border:none;color:inherit;cursor:pointer;float:left;font-family:inherit;height:50%;padding:12px 3px;width:50%}.toastui-chart-export-menu-btn:hover{font-weight:700}.toastui-chart-export-menu-btn:nth-child(3){border-bottom-left-radius:inherit}.toastui-chart-export-menu-btn:nth-child(4){border-bottom-right-radius:inherit}.toastui-chart-tooltip-container{left:0;pointer-events:none;position:absolute;top:0;user-select:none}.toastui-chart-tooltip{box-sizing:border-box;display:flex;flex-direction:column;min-width:150px}.toastui-chart-tooltip-category{border-bottom:1px solid rgba(0,0,0,.1);padding:8px 15px}.toastui-chart-tooltip-series-wrapper{display:flex;flex-direction:column;padding:13px 15px}.toastui-chart-tooltip-series{display:flex;justify-content:space-between;width:100%}.toastui-chart-series-name{align-items:center;display:flex;line-height:10px}.toastui-chart-series-name .toastui-chart-icon,.toastui-chart-tooltip-series .toastui-chart-icon{display:inline-block;height:10px;margin-right:8px;width:10px}.toastui-chart-series-name .toastui-chart-name{white-space:nowrap}.toastui-chart-series-value{margin-left:10px;white-space:nowrap}.toastui-chart-tooltip-series-wrapper .toastui-chart-tooltip-title{padding:8px 0 5px}.toastui-chart-tooltip-series-wrapper .toastui-chart-tooltip-title:first-child{padding-top:0}", "",{"version":3,"sources":["webpack://./node_modules/@toast-ui/chart/dist/toastui-chart.min.css"],"names":[],"mappings":"AAAA;;;;;EAKE,CAAC,uBAAuB,WAAW,CAAC,iBAAiB,CAAC,UAAU,CAAC,2BAA2B,eAAe,CAAC,qBAAqB,CAAC,4BAA4B,CAAC,MAAM,CAAC,iBAAiB,CAAC,KAAK,CAAC,gBAAgB,CAAC,iCAAiC,kBAAkB,CAAC,WAAW,CAAC,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,uCAAuC,WAAW,CAAC,UAAU,CAAC,+BAA+B,sBAAsB,CAAC,WAAW,CAAC,aAAa,CAAC,cAAc,CAAC,UAAU,CAAC,mBAAmB,CAAC,UAAU,CAAC,gBAAgB,CAAC,SAAS,CAAC,qCAAqC,eAAe,CAAC,4CAA4C,iCAAiC,CAAC,4CAA4C,kCAAkC,CAAC,iCAAiC,MAAM,CAAC,mBAAmB,CAAC,iBAAiB,CAAC,KAAK,CAAC,gBAAgB,CAAC,uBAAuB,qBAAqB,CAAC,YAAY,CAAC,qBAAqB,CAAC,eAAe,CAAC,gCAAgC,sCAAsC,CAAC,gBAAgB,CAAC,sCAAsC,YAAY,CAAC,qBAAqB,CAAC,iBAAiB,CAAC,8BAA8B,YAAY,CAAC,6BAA6B,CAAC,UAAU,CAAC,2BAA2B,kBAAkB,CAAC,YAAY,CAAC,gBAAgB,CAAC,iGAAiG,oBAAoB,CAAC,WAAW,CAAC,gBAAgB,CAAC,UAAU,CAAC,+CAA+C,kBAAkB,CAAC,4BAA4B,gBAAgB,CAAC,kBAAkB,CAAC,mEAAmE,iBAAiB,CAAC,+EAA+E,aAAa","sourcesContent":["/*!\n * TOAST UI Chart 4th Edition\n * @version 4.6.1 | Wed Dec 21 2022\n * @author NHN Cloud. FE Development Lab <dl_javascript@nhn.com>\n * @license MIT\n */.toastui-chart-wrapper{height:100%;position:relative;width:100%}.toastui-chart-export-menu{background:#fff;box-sizing:border-box;font-family:Arial,sans-serif;left:0;position:absolute;top:0;user-select:none}.toastui-chart-export-menu-title{box-sizing:inherit;height:34px;margin:0;padding:10px;width:140px}.toastui-chart-export-menu-btn-wrapper{height:76px;width:100%}.toastui-chart-export-menu-btn{background:transparent;border:none;color:inherit;cursor:pointer;float:left;font-family:inherit;height:50%;padding:12px 3px;width:50%}.toastui-chart-export-menu-btn:hover{font-weight:700}.toastui-chart-export-menu-btn:nth-child(3){border-bottom-left-radius:inherit}.toastui-chart-export-menu-btn:nth-child(4){border-bottom-right-radius:inherit}.toastui-chart-tooltip-container{left:0;pointer-events:none;position:absolute;top:0;user-select:none}.toastui-chart-tooltip{box-sizing:border-box;display:flex;flex-direction:column;min-width:150px}.toastui-chart-tooltip-category{border-bottom:1px solid rgba(0,0,0,.1);padding:8px 15px}.toastui-chart-tooltip-series-wrapper{display:flex;flex-direction:column;padding:13px 15px}.toastui-chart-tooltip-series{display:flex;justify-content:space-between;width:100%}.toastui-chart-series-name{align-items:center;display:flex;line-height:10px}.toastui-chart-series-name .toastui-chart-icon,.toastui-chart-tooltip-series .toastui-chart-icon{display:inline-block;height:10px;margin-right:8px;width:10px}.toastui-chart-series-name .toastui-chart-name{white-space:nowrap}.toastui-chart-series-value{margin-left:10px;white-space:nowrap}.toastui-chart-tooltip-series-wrapper .toastui-chart-tooltip-title{padding:8px 0 5px}.toastui-chart-tooltip-series-wrapper .toastui-chart-tooltip-title:first-child{padding-top:0}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/@toast-ui/chart/dist/toastui-chart.min.css":
/*!*****************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/toastui-chart.min.css ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_toastui_chart_min_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js!./toastui-chart.min.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/@toast-ui/chart/dist/toastui-chart.min.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_toastui_chart_min_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_toastui_chart_min_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _css_loader_dist_cjs_js_toastui_chart_min_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _css_loader_dist_cjs_js_toastui_chart_min_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {



var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {



var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "widgets":
/*!******************************!*\
  !*** external "HTMLWidgets" ***!
  \******************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_widgets__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!********************************!*\
  !*** ./srcjs/widgets/chart.js ***!
  \********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! widgets */ "widgets");
/* harmony import */ var widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(widgets__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _toast_ui_chart__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toast-ui/chart */ "./node_modules/@toast-ui/chart/dist/esm/index.js");
/* harmony import */ var _toast_ui_chart_dist_toastui_chart_min_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @toast-ui/chart/dist/toastui-chart.min.css */ "./node_modules/@toast-ui/chart/dist/toastui-chart.min.css");




HTMLWidgets.widget({
  name: "chart",

  type: "output",

  factory: function (el, width, height) {
    var chart;

    return {
      renderValue: function (x) {
        var type = x.config.type;
        var data = x.config.data;
        var options = x.config.options;
        if (typeof chart !== "undefined") {
          chart.destroy();
        }
        chart = _toast_ui_chart__WEBPACK_IMPORTED_MODULE_2__["default"][type]({ el, data, options });
      },

      getWidget: function () {
        return chart;
      },

      resize: function (width, height) {
        /*
        chart.updateOptions({
          chart: {width: width, height: height}
        });
        */
      },
    };
  },
});

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZDQUFLO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixFQUFFO0FBQ3BCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUyxJQUFJLFNBQVMsSUFBSSxTQUFTLElBQUksUUFBUTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUyxJQUFJLFNBQVMsSUFBSSxTQUFTLElBQUksUUFBUTtBQUN0RTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDLG1CQUFtQixjQUFjO0FBQ2pDLG1CQUFtQixjQUFjO0FBQ2pDLGtCQUFrQixnQ0FBZ0M7QUFDbEQsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxpREFBaUQsc0JBQXNCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFNBQVM7QUFDVDtBQUNBLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0RBQWtELG9DQUFvQztBQUN0RjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlEQUFpRCxvQ0FBb0Msc0NBQXNDLHNCQUFzQiw0QkFBNEIsdUNBQXVDLHNCQUFzQiw0QkFBNEIsR0FBRztBQUN6USxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQ0FBb0M7QUFDdEQsaUJBQWlCLG1DQUFtQztBQUNwRDtBQUNBLGtEQUFrRCw0QkFBNEIsMENBQTBDLG1DQUFtQyx1QkFBdUIscUNBQXFDLHlCQUF5QixHQUFHO0FBQ25QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0RBQWtELDRCQUE0Qiw4Q0FBOEMsMkVBQTJFO0FBQ3ZNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywyQkFBMkI7QUFDeEU7QUFDQTtBQUNBLGVBQWU7QUFDZiw4Q0FBOEMsMkJBQTJCO0FBQ3pFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxrREFBa0QsNEJBQTRCLDBDQUEwQyxpREFBaUQsdUJBQXVCLGdCQUFnQix5QkFBeUIsNkNBQTZDLDRCQUE0QiwwQ0FBMEMsZ0RBQWdELHVCQUF1QixlQUFlLHlCQUF5QixHQUFHLEdBQUc7QUFDamQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLDZDQUE2QywwQkFBMEIsc0NBQXNDLGlDQUFpQyxxR0FBcUcsc0NBQXNDO0FBQ3pSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxnREFBZ0Q7QUFDaEQsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDJCQUEyQjtBQUM1RTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGtEQUFrRCwyQkFBMkI7QUFDN0U7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkMsc0RBQXNELDRCQUE0QiwwQ0FBMEMsbUNBQW1DLHVCQUF1QixnQkFBZ0IseUJBQXlCLHlDQUF5Qyw0QkFBNEIsNkVBQTZFLHVDQUF1QywwSkFBMEosZ0JBQWdCLHlCQUF5QixHQUFHLEdBQUc7QUFDam1CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQixnQkFBZ0I7QUFDaEMsOEJBQThCO0FBQzlCLDZDQUE2QywyQkFBMkIsUUFBUSxpRUFBaUU7QUFDako7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3QkFBd0IsNkJBQTZCO0FBQ2xFLDhDQUE4QywyQkFBMkIsUUFBUSxpRUFBaUU7QUFDbEo7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixLQUFLO0FBQ0wsOEJBQThCLDZEQUE2RDtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiw2REFBNkQsNEJBQTRCLHFJQUFxSSx5Q0FBeUM7QUFDdlEsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEMsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QyxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUMsU0FBUztBQUNULHFCQUFxQixhQUFhO0FBQ2xDLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQSwrQkFBK0IsNkJBQTZCO0FBQzVELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0RBQWdELHVHQUF1RztBQUM3TSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxrR0FBa0csVUFBVSxzQ0FBc0MsaUJBQWlCLG1GQUFtRixHQUFHO0FBQ3pQO0FBQ0EsMkJBQTJCLHVFQUEyQjtBQUN0RCwyRkFBMkYsVUFBVSw4RkFBOEYsTUFBTTtBQUN6TTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNWlCbUM7QUFDSTtBQUN2QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsUUFBUSxvREFBWTtBQUNwQixvQkFBb0IsVUFBVSxJQUFJLFNBQVM7QUFDM0M7QUFDQSxhQUFhLGdEQUFRO0FBQ3JCLHFCQUFxQixRQUFRLElBQUksUUFBUSx5Q0FBeUMsUUFBUTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQnVEO0FBQ1Y7QUFDVjtBQUNJO0FBQ3ZDO0FBQ0E7QUFDQSx1REFBdUQsTUFBTTtBQUM3RCx1Q0FBdUMsTUFBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNO0FBQ3BELCtDQUErQyxNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELE1BQU07QUFDN0QsK0NBQStDLE1BQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBLFlBQVksb0RBQVksYUFBYSxvREFBWTtBQUNqRDtBQUNBO0FBQ0EsWUFBWSxnREFBUSxhQUFhLGdEQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDTyxxQ0FBcUMsY0FBYztBQUMxRCxZQUFZLGtFQUFrRTtBQUM5RSw2QkFBNkIsWUFBWSxLQUFLLGFBQWEsRUFBRSxhQUFhLGlCQUFpQixhQUFhLEdBQUcsY0FBYyxZQUFZO0FBQ3JJLHdEQUF3RCxNQUFNLElBQUksT0FBTyxFQUFFLEtBQUs7QUFDaEY7QUFDTyw2QkFBNkIsVUFBVTtBQUM5QztBQUNBLGdFQUFnRSwwREFBa0IsZUFBZTtBQUNqRyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQSwrREFBK0QsMERBQWtCLGFBQWE7QUFDOUYsUUFBUTtBQUNSLGdCQUFnQiw4QkFBOEI7QUFDOUMsa0JBQWtCO0FBQ2xCLDJEQUEyRCxlQUFlO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0EsK0RBQStELDBEQUFrQixhQUFhO0FBQzlGLFFBQVE7QUFDUixnQkFBZ0IsNkJBQTZCO0FBQzdDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsWUFBWTtBQUNaLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCwwREFBa0IsYUFBYTtBQUM5RixRQUFRO0FBQ1IsZ0JBQWdCLDZCQUE2QixrREFBa0Qsb0NBQW9DO0FBQ25JLGNBQWM7QUFDZCxnQkFBZ0IsdUJBQXVCO0FBQ3ZDLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0EsaUVBQWlFLDBEQUFrQixlQUFlO0FBQ2xHLFFBQVE7QUFDUjtBQUNBLCtEQUErRCwwREFBa0IsYUFBYTtBQUM5RixRQUFRLHVFQUF1RSxFQUFFO0FBQ2pGLFFBQVEsdUVBQXVFLEVBQUU7QUFDakYsUUFBUSx5RUFBeUUsRUFBRTtBQUNuRjtBQUNBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQSwrREFBK0QsMERBQWtCLGFBQWE7QUFDOUYsUUFBUTtBQUNSLGdCQUFnQiw0Q0FBNEM7QUFDNUQsWUFBWTtBQUNaLHFEQUFxRCxvRUFBd0IsZUFBZSxNQUFNLE1BQU0sR0FBRyxlQUFlO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE1BQU07QUFDcEMsY0FBYztBQUNkLGdCQUFnQiw4QkFBOEIsMkRBQTJELDBEQUFrQixlQUFlO0FBQzFJLFlBQVk7QUFDWjtBQUNBLG1FQUFtRSwwREFBa0IsYUFBYTtBQUNsRztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEpPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCwwQ0FBMEMsYUFBYTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1AsWUFBWSxTQUFTO0FBQ3JCO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxTQUFTO0FBQ3JCO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7Ozs7Ozs7Ozs7O0FDTmlCO0FBQ21CO0FBQ2dCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQUssU0FBUyxtQkFBbUI7QUFDakQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0gsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL1tuYW1lXS93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9hbmltYXRvci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2JydXNoZXMvYXhpcy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2JydXNoZXMvYmFzaWMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9icnVzaGVzL2JveFBsb3QuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9icnVzaGVzL2NpcmNsZUxlZ2VuZC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2JydXNoZXMvZGF0YUxhYmVsLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vYnJ1c2hlcy9leHBvcnRNZW51LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vYnJ1c2hlcy9nYXVnZS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2JydXNoZXMvbGFiZWwuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9icnVzaGVzL2xlZ2VuZC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2JydXNoZXMvbGluZVNlcmllcy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2JydXNoZXMvcG9seWdvbi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2JydXNoZXMvcmVzZXRCdXR0b24uanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9icnVzaGVzL3NjYXR0ZXJTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9icnVzaGVzL3NlY3Rvci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2JydXNoZXMvc3BlY3RydW1MZWdlbmQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9jaGFydHMvYXJlYUNoYXJ0LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vY2hhcnRzL2JhckNoYXJ0LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vY2hhcnRzL2JveFBsb3RDaGFydC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NoYXJ0cy9idWJibGVDaGFydC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NoYXJ0cy9idWxsZXRDaGFydC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NoYXJ0cy9jaGFydC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NoYXJ0cy9jb2x1bW5DaGFydC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NoYXJ0cy9jb2x1bW5MaW5lQ2hhcnQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9jaGFydHMvZ2F1Z2VDaGFydC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NoYXJ0cy9oZWF0bWFwQ2hhcnQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9jaGFydHMvbGluZUFyZWFDaGFydC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NoYXJ0cy9saW5lQ2hhcnQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9jaGFydHMvbGluZVNjYXR0ZXJDaGFydC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NoYXJ0cy9uZXN0ZWRQaWVDaGFydC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NoYXJ0cy9waWVDaGFydC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NoYXJ0cy9yYWRhckNoYXJ0LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vY2hhcnRzL3JhZGlhbEJhckNoYXJ0LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vY2hhcnRzL3NjYXR0ZXJDaGFydC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NoYXJ0cy90cmVlbWFwQ2hhcnQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9jb21wb25lbnQvYXJlYVNlcmllcy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NvbXBvbmVudC9heGlzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vY29tcG9uZW50L2F4aXNUaXRsZS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NvbXBvbmVudC9heGlzVXNpbmdDZW50ZXJZLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vY29tcG9uZW50L2JhY2tCdXR0b24uanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9jb21wb25lbnQvYmFja2dyb3VuZC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NvbXBvbmVudC9ib3hQbG90U2VyaWVzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vY29tcG9uZW50L2JveFNlcmllcy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NvbXBvbmVudC9ib3hTdGFja1Nlcmllcy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NvbXBvbmVudC9idWJibGVTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9jb21wb25lbnQvYnVsbGV0U2VyaWVzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vY29tcG9uZW50L2NpcmNsZUxlZ2VuZC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NvbXBvbmVudC9jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9jb21wb25lbnQvY29tcG9uZW50TWFuYWdlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NvbXBvbmVudC9kYXRhTGFiZWxzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vY29tcG9uZW50L2V4cG9ydE1lbnUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9jb21wb25lbnQvZ2F1Z2VTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9jb21wb25lbnQvaGVhdG1hcFNlcmllcy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NvbXBvbmVudC9ob3ZlcmVkU2VyaWVzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vY29tcG9uZW50L2xlZ2VuZC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NvbXBvbmVudC9saW5lU2VyaWVzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vY29tcG9uZW50L25vRGF0YVRleHQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9jb21wb25lbnQvcGllU2VyaWVzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vY29tcG9uZW50L3Bsb3QuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9jb21wb25lbnQvcmFkYXJTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9jb21wb25lbnQvcmFkaWFsQXhpcy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NvbXBvbmVudC9yYWRpYWxCYXJTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9jb21wb25lbnQvcmFkaWFsUGxvdC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NvbXBvbmVudC9yYW5nZVNlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NvbXBvbmVudC9yZXNldEJ1dHRvbi5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NvbXBvbmVudC9zY2F0dGVyU2VyaWVzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vY29tcG9uZW50L3NlbGVjdGVkU2VyaWVzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vY29tcG9uZW50L3NwZWN0cnVtTGVnZW5kLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vY29tcG9uZW50L3RpdGxlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vY29tcG9uZW50L3Rvb2x0aXAuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9jb21wb25lbnQvdHJlZW1hcFNlcmllcy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2NvbXBvbmVudC96ZXJvQXhpcy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2V2ZW50RW1pdHRlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2hlbHBlcnMvYXJyYXlVdGlsLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vaGVscGVycy9heGVzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vaGVscGVycy9ib3hTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9oZWxwZXJzL2NhbGN1bGF0b3IuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9oZWxwZXJzL2NvbG9yLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vaGVscGVycy9jb2xvclNwZWN0cnVtLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vaGVscGVycy9jb29yZGluYXRlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vaGVscGVycy9kYXRhTGFiZWxzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vaGVscGVycy9kb20uanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9oZWxwZXJzL2Rvd25sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9oZWxwZXJzL2Zvcm1hdERhdGUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9oZWxwZXJzL2dlb21ldHJpYy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2hlbHBlcnMvZ29vZ2xlQW5hbHl0aWNzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vaGVscGVycy9odG1sU2FuaXRpemVyLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vaGVscGVycy9sZWdlbmQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9oZWxwZXJzL3BpZVNlcmllcy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2hlbHBlcnMvcGxvdC5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2hlbHBlcnMvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9oZWxwZXJzL3Jlc3BvbmRlcnMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9oZWxwZXJzL3NlY3Rvci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2hlbHBlcnMvc3F1YXJpZmllci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL2hlbHBlcnMvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9oZWxwZXJzL3RoZW1lLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vaGVscGVycy90b29sdGlwLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vaGVscGVycy90b29sdGlwVGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9oZWxwZXJzL3V0aWxzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vaGVscGVycy92YWxpZGF0aW9uLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9tZXNzYWdlLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vcGFpbnRlci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL3Jlc3BvbmRlckRldGVjdG9ycy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL3NjYWxlL2Nvb3JkaW5hdGVTY2FsZUNhbGN1bGF0b3IuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9zY2FsZS9kYXRldGltZVNjYWxlQ2FsY3VsYXRvci5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL3N0b3JlL2F4ZXMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9zdG9yZS9jYXRlZ29yeS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL3N0b3JlL2NvbG9yVmFsdWVTY2FsZS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL3N0b3JlL2RhdGFSYW5nZS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL3N0b3JlL2dhdWdlQXhlcy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL3N0b3JlL2hlYXRtYXBBeGVzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vc3RvcmUvaGVhdG1hcFNlcmllc0RhdGEuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9zdG9yZS9sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9zdG9yZS9sZWdlbmQuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9zdG9yZS9uZXN0ZWRQaWVTZXJpZXNEYXRhLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vc3RvcmUvb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL3N0b3JlL3Bsb3QuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9zdG9yZS9yYWRpYWxBeGVzLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vc3RvcmUvcmVhY3RpdmUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9zdG9yZS9yb290LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vc3RvcmUvc2NhbGUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9zdG9yZS9zZXJpZXNEYXRhLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vc3RvcmUvc3RhY2tTZXJpZXNEYXRhLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC9lc20vc3RvcmUvc3RvcmUuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9jaGFydC9kaXN0L2VzbS9zdG9yZS90aGVtZS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvZXNtL3N0b3JlL3RyZWVtYXBTZXJpZXNEYXRhLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC90b2FzdHVpLWNoYXJ0Lm1pbi5jc3MiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvdG9hc3R1aS1jaGFydC5taW4uY3NzPzEzZjAiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzIiwid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vZXh0ZXJuYWwgdW1kIFwiSFRNTFdpZGdldHNcIiIsIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vW25hbWVdL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL1tuYW1lXS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vW25hbWVdL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vW25hbWVdL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjanMvd2lkZ2V0cy9jaGFydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJIVE1MV2lkZ2V0c1wiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJIVE1MV2lkZ2V0c1wiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJjaGFydFwiXSA9IGZhY3RvcnkocmVxdWlyZShcIkhUTUxXaWRnZXRzXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJjaGFydFwiXSA9IGZhY3Rvcnkocm9vdFtcIkhUTUxXaWRnZXRzXCJdKTtcbn0pKHNlbGYsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfd2lkZ2V0c19fKSB7XG5yZXR1cm4gIiwiaW1wb3J0IHsgaXNOdWxsIH0gZnJvbSBcIi4vaGVscGVycy91dGlsc1wiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFuaW1zID0gW107XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnSURMRSc7XG4gICAgICAgIHRoaXMucmVxdWVzdElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5maXJzdFJlbmRlcmluZyA9IHRydWU7XG4gICAgfVxuICAgIGFkZCh7IGNoYXJ0LCBkdXJhdGlvbiwgcmVxdWVzdGVyLCBvbkNvbXBsZXRlZCA9ICgpID0+IHsgfSwgb25GcmFtZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZmlyc3RSZW5kZXJpbmcpIHtcbiAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZShkZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmlyc3RSZW5kZXJpbmcpIHtcbiAgICAgICAgICAgIGNoYXJ0LmluaXRVcGRhdGUoZGVsdGEpO1xuICAgICAgICAgICAgaWYgKGRlbHRhID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdFJlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgfSkge1xuICAgICAgICBpZiAodGhpcy5hbmltcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0lETEUnKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGNoYXJ0LFxuICAgICAgICAgICAgICAgIHJlcXVlc3RlcixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICBvbkZyYW1lLFxuICAgICAgICAgICAgICAgIG9uQ29tcGxldGVkLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY29tcGxldGVkOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmFuaW1zLmZvckVhY2goKGFuaW0pID0+IHtcbiAgICAgICAgICAgIGFuaW0uY3VycmVudCA9IDE7XG4gICAgICAgICAgICBhbmltLm9uRnJhbWUoYW5pbS5jdXJyZW50KTtcbiAgICAgICAgICAgIGFuaW0uY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYW5pbXMgPSBbXTtcbiAgICAgICAgdGhpcy5jYW5jZWxBbmltRnJhbWUoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdJRExFJztcbiAgICAgICAgdGhpcy5yZXF1ZXN0SWQgPSBudWxsO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYW5pbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ1JVTk5JTkcnO1xuICAgICAgICAgICAgdGhpcy5ydW5GcmFtZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJ1bkZyYW1lKCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHRpbWVzdGFtcCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ydW5Bbmltcyh0aW1lc3RhbXApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcnVuQW5pbXModGltZXN0YW1wKSB7XG4gICAgICAgIHRoaXMubmV4dCh0aW1lc3RhbXApO1xuICAgICAgICBpZiAodGhpcy5hbmltcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucnVuRnJhbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnSURMRSc7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dCh0aW1lc3RhbXApIHtcbiAgICAgICAgdGhpcy5hbmltcy5mb3JFYWNoKChhbmltKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNOdWxsKGFuaW0uc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgYW5pbS5zdGFydCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhbmltLmNoYXJ0LCAnX19fYW5pbUlkX19fJywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYW5pbS5jdXJyZW50ID0gYW5pbS5kdXJhdGlvbiA/IE1hdGgubWluKCh0aW1lc3RhbXAgLSBhbmltLnN0YXJ0KSAvIGFuaW0uZHVyYXRpb24sIDEpIDogMTtcbiAgICAgICAgICAgIGFuaW0ub25GcmFtZShhbmltLmN1cnJlbnQpO1xuICAgICAgICAgICAgYW5pbS5jb21wbGV0ZWQgPSBhbmltLmN1cnJlbnQgPT09IDE7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFuaW1zLmZvckVhY2goKGFuaW0pID0+IHtcbiAgICAgICAgICAgIGlmIChhbmltLmNoYXJ0Ll9fX2FuaW1JZF9fXyA9PT0gdGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgYW5pbS5jaGFydC5kcmF3KCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGFuaW0uY2hhcnQuX19fYW5pbUlkX19fO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFuaW0uY29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxBbmltRnJhbWUoKTtcbiAgICAgICAgICAgICAgICBhbmltLm9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgICAgICAgYW5pbS5jaGFydC5ldmVudEJ1cy5lbWl0KCdhbmltYXRpb25Db21wbGV0ZWQnLCBhbmltLnJlcXVlc3Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFuaW1zID0gdGhpcy5hbmltcy5maWx0ZXIoKGFuaW0pID0+ICFhbmltLmNvbXBsZXRlZCk7XG4gICAgfVxuICAgIGNhbmNlbEFuaW1GcmFtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdElkKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXF1ZXN0SWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgbGluZSB9IGZyb20gXCIuL2Jhc2ljXCI7XG5leHBvcnQgY29uc3QgVElDS19TSVpFID0gNTtcbmV4cG9ydCBmdW5jdGlvbiB0aWNrKGN0eCwgdGlja01vZGVsKSB7XG4gICAgY29uc3QgeyB4LCB5LCBpc1lBeGlzLCB0aWNrU2l6ZSA9IFRJQ0tfU0laRSwgc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCB9ID0gdGlja01vZGVsO1xuICAgIGNvbnN0IGxpbmVNb2RlbCA9IHtcbiAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB4MjogeCxcbiAgICAgICAgeTI6IHksXG4gICAgICAgIHN0cm9rZVN0eWxlLFxuICAgICAgICBsaW5lV2lkdGgsXG4gICAgfTtcbiAgICBpZiAoaXNZQXhpcykge1xuICAgICAgICBsaW5lTW9kZWwueDIgKz0gdGlja1NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsaW5lTW9kZWwueTIgKz0gdGlja1NpemU7XG4gICAgfVxuICAgIGxpbmUoY3R4LCBsaW5lTW9kZWwpO1xufVxuIiwiaW1wb3J0IHsgbWFrZVN0eWxlT2JqLCBzZXRMaW5lRGFzaCwgZmlsbFN0eWxlLCBzdHJva2VXaXRoT3B0aW9ucyB9IGZyb20gXCIuLi9oZWxwZXJzL3N0eWxlXCI7XG5pbXBvcnQgeyBjYWxjdWxhdGVEZWdyZWVUb1JhZGlhbiB9IGZyb20gXCIuLi9oZWxwZXJzL3NlY3RvclwiO1xuY29uc3QgY2lyY2xlU3R5bGUgPSB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgICBzdHJva2VTdHlsZTogJyNmZmZmZmYnLFxuICAgICAgICBsaW5lV2lkdGg6IDIsXG4gICAgfSxcbiAgICBwbG90OiB7XG4gICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgc3Ryb2tlU3R5bGU6ICdyZ2JhKDAsIDAsIDAsIDAuMDUpJyxcbiAgICB9LFxufTtcbmNvbnN0IHJlY3RTdHlsZSA9IHtcbiAgICBzaGFkb3c6IHtcbiAgICAgICAgc2hhZG93Q29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMyknLFxuICAgICAgICBzaGFkb3dPZmZzZXRYOiAyLFxuICAgICAgICBzaGFkb3dPZmZzZXRZOiAyLFxuICAgICAgICBzaGFkb3dCbHVyOiA2LFxuICAgIH0sXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGNsaXBSZWN0QXJlYShjdHgsIGNsaXBSZWN0QXJlYU1vZGVsKSB7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSBjbGlwUmVjdEFyZWFNb2RlbDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgY3R4LmNsaXAoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXRoUmVjdChjdHgsIHBhdGhSZWN0TW9kZWwpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyA9IDAsIHN0cm9rZTogc3Ryb2tlU3R5bGUgPSAnYmxhY2snLCBmaWxsID0gJycsIGxpbmVXaWR0aCA9IDEsIH0gPSBwYXRoUmVjdE1vZGVsO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB5KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cyk7XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICBjdHgubGluZVRvKHggKyByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgIGN0eC5saW5lVG8oeCwgeSArIHJhZGl1cyk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGlmIChmaWxsKSB7XG4gICAgICAgIGZpbGxTdHlsZShjdHgsIGZpbGwpO1xuICAgIH1cbiAgICBzdHJva2VXaXRoT3B0aW9ucyhjdHgsIHsgbGluZVdpZHRoLCBzdHJva2VTdHlsZSB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGUoY3R4LCBjaXJjbGVNb2RlbCkge1xuICAgIGNvbnN0IHsgeCwgeSwgc3R5bGUsIHJhZGl1cywgY29sb3IsIGFuZ2xlID0geyBzdGFydDogMCwgZW5kOiBNYXRoLlBJICogMiB9LCBib3JkZXJXaWR0aDogbGluZVdpZHRoLCBib3JkZXJDb2xvcjogc3Ryb2tlU3R5bGUsIH0gPSBjaXJjbGVNb2RlbDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlT2JqID0gbWFrZVN0eWxlT2JqKHN0eWxlLCBjaXJjbGVTdHlsZSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHN0eWxlT2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGN0eFtrZXldID0gc3R5bGVPYmpba2V5XTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCBhbmdsZS5zdGFydCwgYW5nbGUuZW5kLCB0cnVlKTtcbiAgICBzdHJva2VXaXRoT3B0aW9ucyhjdHgsIHsgbGluZVdpZHRoLCBzdHJva2VTdHlsZSB9KTtcbiAgICBmaWxsU3R5bGUoY3R4LCBjb2xvcik7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxpbmUoY3R4LCBsaW5lTW9kZWwpIHtcbiAgICBjb25zdCB7IHgsIHksIHgyLCB5Miwgc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCwgZGFzaFNlZ21lbnRzIH0gPSBsaW5lTW9kZWw7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGlmIChkYXNoU2VnbWVudHMpIHtcbiAgICAgICAgc2V0TGluZURhc2goY3R4LCBkYXNoU2VnbWVudHMpO1xuICAgIH1cbiAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICBzdHJva2VXaXRoT3B0aW9ucyhjdHgsIHsgc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCB9KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVjdChjdHgsIG1vZGVsKSB7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdHlsZSwgdGhpY2tuZXNzID0gMCwgY29sb3IsIGJvcmRlckNvbG9yID0gJyNmZmZmZmYnIH0gPSBtb2RlbDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlT2JqID0gbWFrZVN0eWxlT2JqKHN0eWxlLCByZWN0U3R5bGUpO1xuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZU9iaikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjdHhba2V5XSA9IHN0eWxlT2JqW2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpY2tuZXNzKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KHggLSB0aGlja25lc3MsIHkgLSB0aGlja25lc3MsIHdpZHRoICsgdGhpY2tuZXNzICogMiwgaGVpZ2h0ICsgdGhpY2tuZXNzICogMik7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDApJzsgLy8gcmVzZXQgc2hhZG93IGNvbG9yXG4gICAgfVxuICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIGZpbGxTdHlsZShjdHgsIGNvbG9yKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcmMoY3R4LCBhcmNNb2RlbCkge1xuICAgIGNvbnN0IHsgeCwgeSwgYW5nbGU6IHsgc3RhcnQsIGVuZCB9LCBib3JkZXJXaWR0aDogbGluZVdpZHRoLCBib3JkZXJDb2xvcjogc3Ryb2tlU3R5bGUsIGRyYXdpbmdTdGFydEFuZ2xlLCByYWRpdXMsIGNsb2Nrd2lzZSA9IHRydWUsIH0gPSBhcmNNb2RlbDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY29uc3Qgc3RhcnRSYWRpYW4gPSBjYWxjdWxhdGVEZWdyZWVUb1JhZGlhbihzdGFydCwgZHJhd2luZ1N0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IGVuZFJhZGlhbiA9IGNhbGN1bGF0ZURlZ3JlZVRvUmFkaWFuKGVuZCwgZHJhd2luZ1N0YXJ0QW5nbGUpO1xuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCBzdGFydFJhZGlhbiwgZW5kUmFkaWFuLCAhY2xvY2t3aXNlKTtcbiAgICBzdHJva2VXaXRoT3B0aW9ucyhjdHgsIHsgbGluZVdpZHRoLCBzdHJva2VTdHlsZSB9KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG59XG4iLCJpbXBvcnQgeyBsaW5lLCByZWN0IH0gZnJvbSBcIi4vYmFzaWNcIjtcbmV4cG9ydCBmdW5jdGlvbiBib3hQbG90KGN0eCwgbW9kZWwpIHtcbiAgICBjb25zdCB7IHJlY3Q6IHJlY3RNb2RlbCwgdXBwZXJXaGlza2VyLCBsb3dlcldoaXNrZXIsIG1lZGlhbiwgbWluaW11bSwgbWF4aW11bSB9ID0gbW9kZWw7XG4gICAgaWYgKG1pbmltdW0pIHtcbiAgICAgICAgbGluZShjdHgsIE9iamVjdC5hc3NpZ24oeyB0eXBlOiAnbGluZScgfSwgbWluaW11bSkpO1xuICAgIH1cbiAgICBpZiAobG93ZXJXaGlza2VyKSB7XG4gICAgICAgIGxpbmUoY3R4LCBPYmplY3QuYXNzaWduKHsgdHlwZTogJ2xpbmUnIH0sIGxvd2VyV2hpc2tlcikpO1xuICAgIH1cbiAgICBpZiAocmVjdE1vZGVsKSB7XG4gICAgICAgIHJlY3QoY3R4LCBPYmplY3QuYXNzaWduKHsgdHlwZTogJ3JlY3QnIH0sIHJlY3RNb2RlbCkpO1xuICAgIH1cbiAgICBpZiAodXBwZXJXaGlza2VyKSB7XG4gICAgICAgIGxpbmUoY3R4LCBPYmplY3QuYXNzaWduKHsgdHlwZTogJ2xpbmUnIH0sIHVwcGVyV2hpc2tlcikpO1xuICAgIH1cbiAgICBpZiAobWF4aW11bSkge1xuICAgICAgICBsaW5lKGN0eCwgT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdsaW5lJyB9LCBtYXhpbXVtKSk7XG4gICAgfVxuICAgIGlmIChtZWRpYW4pIHtcbiAgICAgICAgbGluZShjdHgsIE9iamVjdC5hc3NpZ24oeyB0eXBlOiAnbGluZScgfSwgbWVkaWFuKSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgY2lyY2xlIH0gZnJvbSBcIi4vYmFzaWNcIjtcbmltcG9ydCB7IGxhYmVsIH0gZnJvbSBcIi4vbGFiZWxcIjtcbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGVMZWdlbmQoY3R4LCBjaXJjbGVMZWdlbmRNb2RlbCkge1xuICAgIGNvbnN0IHsgeCwgeSwgcmFkaXVzLCB2YWx1ZSB9ID0gY2lyY2xlTGVnZW5kTW9kZWw7XG4gICAgY29uc3QgcmF0aW9BcnJheSA9IFsxLCAwLjUsIDAuMjVdO1xuICAgIHJhdGlvQXJyYXkuZm9yRWFjaCgocmF0aW8sIGlkeCkgPT4ge1xuICAgICAgICBjb25zdCBjaXJjbGVSYWRpdXMgPSByYXRpbyAqIHJhZGl1cztcbiAgICAgICAgY29uc3QgY2lyY2xlWSA9IHkgKyAoaWR4ID8gKDEgLSByYXRpbykgKiByYWRpdXMgOiAwKTtcbiAgICAgICAgY2lyY2xlKGN0eCwge1xuICAgICAgICAgICAgdHlwZTogJ2NpcmNsZScsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeTogY2lyY2xlWSxcbiAgICAgICAgICAgIHJhZGl1czogY2lyY2xlUmFkaXVzLFxuICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgIHNlcmllc0luZGV4OiAwLFxuICAgICAgICAgICAgc3R5bGU6IFsnZGVmYXVsdCcsIHsgc3Ryb2tlU3R5bGU6ICcjODg4JywgbGluZVdpZHRoOiAxIH1dLFxuICAgICAgICB9KTtcbiAgICAgICAgbGFiZWwoY3R4LCB7XG4gICAgICAgICAgICB0eXBlOiAnbGFiZWwnLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHk6IGNpcmNsZVkgLSBjaXJjbGVSYWRpdXMsXG4gICAgICAgICAgICB0ZXh0OiBTdHJpbmcodmFsdWUgKiByYXRpbyksXG4gICAgICAgICAgICBzdHlsZTogWydkZWZhdWx0JywgeyB0ZXh0QWxpZ246ICdjZW50ZXInLCB0ZXh0QmFzZWxpbmU6ICdib3R0b20nIH1dLFxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbiIsImltcG9ydCB7IGxhYmVsLCBidWJibGVMYWJlbCB9IGZyb20gXCIuL2xhYmVsXCI7XG5pbXBvcnQgeyBnZXRUZXh0SGVpZ2h0LCBnZXRUZXh0V2lkdGggfSBmcm9tIFwiLi4vaGVscGVycy9jYWxjdWxhdG9yXCI7XG5pbXBvcnQgeyBsaW5lIH0gZnJvbSBcIi4vYmFzaWNcIjtcbmltcG9ydCB7IGdldEZvbnQgfSBmcm9tIFwiLi4vaGVscGVycy9zdHlsZVwiO1xuaW1wb3J0IHsgcGljaywgaW5jbHVkZXMgfSBmcm9tIFwiLi4vaGVscGVycy91dGlsc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGFMYWJlbChjdHgsIG1vZGVsKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgeCwgeSwgdGV4dCwgdGV4dEFsaWduLCB0ZXh0QmFzZWxpbmUsIG9wYWNpdHksIGNhbGxvdXQsIHRoZW1lLCByYWRpYW4gfSA9IG1vZGVsO1xuICAgIGNvbnN0IHsgY29sb3IsIHRleHRCdWJibGUgfSA9IHRoZW1lO1xuICAgIGNvbnN0IGZvbnQgPSBnZXRGb250KHRoZW1lKTtcbiAgICBjb25zdCB0ZXh0U3R5bGUgPSB7IHRleHRBbGlnbiwgdGV4dEJhc2VsaW5lLCBmb250LCBmaWxsU3R5bGU6IGNvbG9yIH07XG4gICAgY29uc3QgdGV4dFN0cm9rZVN0eWxlID0gZ2V0VGV4dFN0cm9rZVN0eWxlKHRoZW1lKTtcbiAgICBpZiAoY2FsbG91dCkge1xuICAgICAgICBjb25zdCB7IHRoZW1lOiB7IGxpbmVXaWR0aCwgbGluZUNvbG9yIH0sIH0gPSBjYWxsb3V0O1xuICAgICAgICBsaW5lKGN0eCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdHlwZTogJ2xpbmUnIH0sIHBpY2soY2FsbG91dCwgJ3gnLCAneScsICd4MicsICd5MicpKSwgeyBzdHJva2VTdHlsZTogbGluZUNvbG9yLCBsaW5lV2lkdGggfSkpO1xuICAgIH1cbiAgICBpZiAoKF9hID0gdGV4dEJ1YmJsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZpc2libGUpIHtcbiAgICAgICAgZHJhd0J1YmJsZUxhYmVsKGN0eCwgbW9kZWwpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxhYmVsKGN0eCwge1xuICAgICAgICB0eXBlOiAnbGFiZWwnLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB0ZXh0LFxuICAgICAgICBzdHlsZTogW3RleHRTdHlsZV0sXG4gICAgICAgIHN0cm9rZTogW3RleHRTdHJva2VTdHlsZV0sXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIHJhZGlhbixcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkcmF3QnViYmxlTGFiZWwoY3R4LCBtb2RlbCkge1xuICAgIGNvbnN0IHsgdGV4dCwgdGhlbWUsIHJhZGlhbiA9IDAgfSA9IG1vZGVsO1xuICAgIGNvbnN0IHsgY29sb3IsIHRleHRTdHJva2VDb2xvciB9ID0gdGhlbWU7XG4gICAgY29uc3QgZm9udCA9IGdldEZvbnQodGhlbWUpO1xuICAgIGNvbnN0IGJ1YmJsZVJlY3QgPSBnZXRCdWJibGVSZWN0KG1vZGVsKTtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IGJ1YmJsZVJlY3Q7XG4gICAgYnViYmxlTGFiZWwoY3R4LCB7XG4gICAgICAgIHR5cGU6ICdidWJibGVMYWJlbCcsXG4gICAgICAgIHJhZGlhbixcbiAgICAgICAgcm90YXRpb25Qb3NpdGlvbjogeyB4OiBtb2RlbC54LCB5OiBtb2RlbC55IH0sXG4gICAgICAgIGJ1YmJsZTogYnViYmxlUmVjdCxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHg6IHggKyB3aWR0aCAvIDIsXG4gICAgICAgICAgICB5OiB5ICsgaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICBzdHlsZTogW3sgZm9udCwgZmlsbFN0eWxlOiBjb2xvciwgdGV4dEFsaWduOiAnY2VudGVyJywgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyB9XSxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlOiB0ZXh0U3Ryb2tlQ29sb3IsXG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QnViYmxlQXJyb3dQb2ludHMoZGlyZWN0aW9uLCB7IHgsIHkgfSwgYXJyb3dQb2ludFRoZW1lKSB7XG4gICAgY29uc3Qgd2lkdGggPSBhcnJvd1BvaW50VGhlbWUud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gYXJyb3dQb2ludFRoZW1lLmhlaWdodDtcbiAgICBsZXQgcG9pbnRzID0gW107XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgcG9pbnRzID0gW1xuICAgICAgICAgICAgeyB4OiB4IC0gd2lkdGggLyAyLCB5OiB5ICsgaGVpZ2h0IH0sXG4gICAgICAgICAgICB7IHgsIHkgfSxcbiAgICAgICAgICAgIHsgeDogeCArIHdpZHRoIC8gMiwgeTogeSArIGhlaWdodCB9LFxuICAgICAgICBdO1xuICAgIH1cbiAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgIHBvaW50cyA9IFtcbiAgICAgICAgICAgIHsgeDogeCArIHdpZHRoIC8gMiwgeTogeSAtIGhlaWdodCB9LFxuICAgICAgICAgICAgeyB4LCB5IH0sXG4gICAgICAgICAgICB7IHg6IHggLSB3aWR0aCAvIDIsIHk6IHkgLSBoZWlnaHQgfSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgIHBvaW50cyA9IFtcbiAgICAgICAgICAgIHsgeDogeCAtIGhlaWdodCwgeTogeSAtIHdpZHRoIC8gMiB9LFxuICAgICAgICAgICAgeyB4LCB5IH0sXG4gICAgICAgICAgICB7IHg6IHggLSBoZWlnaHQsIHk6IHkgKyB3aWR0aCAvIDIgfSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgcG9pbnRzID0gW1xuICAgICAgICAgICAgeyB4OiB4ICsgaGVpZ2h0LCB5OiB5ICsgd2lkdGggLyAyIH0sXG4gICAgICAgICAgICB7IHgsIHkgfSxcbiAgICAgICAgICAgIHsgeDogeCArIGhlaWdodCwgeTogeSAtIHdpZHRoIC8gMiB9LFxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xufVxuZnVuY3Rpb24gZ2V0QnViYmxlUmVjdChtb2RlbCkge1xuICAgIGNvbnN0IHsgdGV4dCwgdGhlbWUsIHRleHRBbGlnbiwgdGV4dEJhc2VsaW5lIH0gPSBtb2RlbDtcbiAgICBjb25zdCBmb250ID0gZ2V0Rm9udCh0aGVtZSk7XG4gICAgY29uc3QgeyBhcnJvdywgcGFkZGluZ1gsIHBhZGRpbmdZLCBib3JkZXJSYWRpdXMsIGJvcmRlckNvbG9yLCBib3JkZXJXaWR0aCwgYmFja2dyb3VuZENvbG9yLCBzaGFkb3dCbHVyLCBzaGFkb3dPZmZzZXRYLCBzaGFkb3dPZmZzZXRZLCBzaGFkb3dDb2xvciwgfSA9IHRoZW1lLnRleHRCdWJibGU7XG4gICAgY29uc3QgbGFiZWxXaWR0aCA9IGdldFRleHRXaWR0aCh0ZXh0LCBmb250KTtcbiAgICBjb25zdCB3aWR0aCA9IGxhYmVsV2lkdGggKyBwYWRkaW5nWCAqIDI7XG4gICAgY29uc3QgaGVpZ2h0ID0gZ2V0VGV4dEhlaWdodCh0ZXh0LCBmb250KSArIHBhZGRpbmdZICogMjtcbiAgICBsZXQgeyB4LCB5IH0gPSBtb2RlbDtcbiAgICBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICB4IC09IHdpZHRoIC8gMjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5jbHVkZXMoWydyaWdodCcsICdlbmQnXSwgdGV4dEFsaWduKSkge1xuICAgICAgICB4IC09IHdpZHRoO1xuICAgIH1cbiAgICBpZiAodGV4dEJhc2VsaW5lID09PSAnbWlkZGxlJykge1xuICAgICAgICB5IC09IGhlaWdodCAvIDI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRleHRCYXNlbGluZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgeSAtPSBoZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IHJlY3QgPSB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlY3QpLCB7IHJhZGl1czogYm9yZGVyUmFkaXVzLCBsaW5lV2lkdGg6IGJvcmRlcldpZHRoLCBmaWxsOiBiYWNrZ3JvdW5kQ29sb3IsIHN0cm9rZVN0eWxlOiBib3JkZXJDb2xvciwgc3R5bGU6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzaGFkb3dCbHVyLFxuICAgICAgICAgICAgICAgIHNoYWRvd09mZnNldFgsXG4gICAgICAgICAgICAgICAgc2hhZG93T2Zmc2V0WSxcbiAgICAgICAgICAgICAgICBzaGFkb3dDb2xvcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0gfSksIGdldEFycm93SW5mbyhyZWN0LCB0ZXh0QWxpZ24sIHRleHRCYXNlbGluZSwgYXJyb3cpKTtcbn1cbmZ1bmN0aW9uIGdldEFycm93SW5mbyhyZWN0LCB0ZXh0QWxpZ24sIHRleHRCYXNlbGluZSwgdGhlbWUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghKChfYSA9IHRoZW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmlzaWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGFycm93SGVpZ2h0ID0gdGhlbWUuaGVpZ2h0O1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcmVjdDtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSAoX2IgPSB0aGVtZS5kaXJlY3Rpb24sIChfYiAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBnZXRBcnJvd0RpcmVjdGlvbih0ZXh0QWxpZ24sIHRleHRCYXNlbGluZSkpKTtcbiAgICBsZXQgeyB4OiBib3hYLCB5OiBib3hZIH0gPSByZWN0O1xuICAgIGxldCB7IHg6IHBvaW50WCwgeTogcG9pbnRZIH0gPSByZWN0O1xuICAgIGlmIChkaXJlY3Rpb24gPT09ICd0b3AnKSB7XG4gICAgICAgIGJveFkgKz0gYXJyb3dIZWlnaHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgYm94WSAtPSBhcnJvd0hlaWdodDtcbiAgICAgICAgcG9pbnRZICs9IGhlaWdodDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgIGJveFggLT0gYXJyb3dIZWlnaHQ7XG4gICAgICAgIHBvaW50WCArPSB3aWR0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgYm94WCArPSBhcnJvd0hlaWdodDtcbiAgICB9XG4gICAgaWYgKHRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcG9pbnRYID0gcmVjdC54ICsgd2lkdGggLyAyO1xuICAgIH1cbiAgICBlbHNlIGlmICh0ZXh0QmFzZWxpbmUgPT09ICdtaWRkbGUnKSB7XG4gICAgICAgIHBvaW50WSA9IHJlY3QueSArIGhlaWdodCAvIDI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgcG9pbnRzOiBnZXRCdWJibGVBcnJvd1BvaW50cyhkaXJlY3Rpb24sIHsgeDogcG9pbnRYLCB5OiBwb2ludFkgfSwgdGhlbWUpLFxuICAgICAgICB4OiBib3hYLFxuICAgICAgICB5OiBib3hZLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRBcnJvd0RpcmVjdGlvbih0ZXh0QWxpZ24sIHRleHRCYXNlbGluZSkge1xuICAgIGxldCBkaXJlY3Rpb24gPSAndG9wJztcbiAgICBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJyAmJiB0ZXh0QmFzZWxpbmUgPT09ICd0b3AnKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9ICd0b3AnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInICYmIHRleHRCYXNlbGluZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gJ2JvdHRvbSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRleHRCYXNlbGluZSA9PT0gJ21pZGRsZScgJiYgdGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRleHRCYXNlbGluZSA9PT0gJ21pZGRsZScgJiYgdGV4dEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgIH1cbiAgICByZXR1cm4gZGlyZWN0aW9uO1xufVxuZnVuY3Rpb24gZ2V0VGV4dFN0cm9rZVN0eWxlKHRoZW1lKSB7XG4gICAgY29uc3QgeyB0ZXh0U3Ryb2tlQ29sb3IgfSA9IHRoZW1lO1xuICAgIGNvbnN0IHRleHRTdHJva2VTdHlsZSA9IHBpY2sodGhlbWUsICdsaW5lV2lkdGgnLCAnc2hhZG93Q29sb3InLCAnc2hhZG93Qmx1cicpO1xuICAgIGlmICh0ZXh0U3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgdGV4dFN0cm9rZVN0eWxlLnN0cm9rZVN0eWxlID0gdGV4dFN0cm9rZUNvbG9yO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dFN0cm9rZVN0eWxlO1xufVxuIiwiaW1wb3J0IHsgbGluZSwgcmVjdCwgcGF0aFJlY3QgfSBmcm9tIFwiLi9iYXNpY1wiO1xuaW1wb3J0IHsgQlVUVE9OX1JFQ1RfU0laRSB9IGZyb20gXCIuLi9jb21wb25lbnQvZXhwb3J0TWVudVwiO1xuZnVuY3Rpb24gZHJhd1hJY29uKGN0eCwgaWNvbiwgcmVjdFNpemUpIHtcbiAgICBjb25zdCB7IHg6IHN0YXJ0WCwgeTogc3RhcnRZLCB0aGVtZTogeyBjb2xvcjogc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCB9LCB9ID0gaWNvbjtcbiAgICBjb25zdCBvZmZzZXQgPSByZWN0U2l6ZSAvIDM7XG4gICAgY29uc3QgeCA9IHN0YXJ0WCArIG9mZnNldDtcbiAgICBjb25zdCB5ID0gc3RhcnRZICsgb2Zmc2V0O1xuICAgIGNvbnN0IHgyID0gc3RhcnRYICsgb2Zmc2V0ICogMjtcbiAgICBjb25zdCB5MiA9IHN0YXJ0WSArIG9mZnNldCAqIDI7XG4gICAgY29uc3QgcG9pbnRzID0gW1xuICAgICAgICB7IHgsIHksIHgyLCB5MiB9LFxuICAgICAgICB7IHgsIHk6IHkyLCB4MiwgeTI6IHkgfSxcbiAgICBdO1xuICAgIHBvaW50cy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgIGxpbmUoY3R4LCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB0eXBlOiAnbGluZScgfSwgcCksIHsgc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCB9KSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBkcmF3TW9yZUljb24oY3R4LCBpY29uLCByZWN0U2l6ZSkge1xuICAgIGNvbnN0IHsgeCwgeSwgdGhlbWU6IHsgY29sb3IsIHdpZHRoLCBoZWlnaHQsIGdhcCB9LCB9ID0gaWNvbjtcbiAgICBjb25zdCBwYWRkaW5nWCA9IChyZWN0U2l6ZSAtIHdpZHRoKSAvIDI7XG4gICAgY29uc3QgcGFkZGluZ1kgPSAocmVjdFNpemUgLSAoaGVpZ2h0ICogMyArIGdhcCAqIDIpKSAvIDI7XG4gICAgY29uc3QgY2VudGVyWCA9IHggKyBwYWRkaW5nWDtcbiAgICBjb25zdCBwb2ludHMgPSBbXG4gICAgICAgIHsgeDogY2VudGVyWCwgeTogeSArIHBhZGRpbmdZIH0sXG4gICAgICAgIHsgeDogY2VudGVyWCwgeTogeSArIHBhZGRpbmdZICsgaGVpZ2h0ICsgZ2FwIH0sXG4gICAgICAgIHsgeDogY2VudGVyWCwgeTogeSArIHBhZGRpbmdZICsgKGhlaWdodCArIGdhcCkgKiAyIH0sXG4gICAgXTtcbiAgICBwb2ludHMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICByZWN0KGN0eCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdHlwZTogJ3JlY3QnIH0sIHApLCB7IGNvbG9yLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleHBvcnRNZW51QnV0dG9uKGN0eCwgZXhwb3J0TWVudUJ1dHRvbk1vZGVsKSB7XG4gICAgY29uc3QgeyBvcGVuZWQsIHg6IHhQb3MsIHk6IHlQb3MsIHRoZW1lIH0gPSBleHBvcnRNZW51QnV0dG9uTW9kZWw7XG4gICAgY29uc3QgeyBib3JkZXJDb2xvciwgYmFja2dyb3VuZENvbG9yLCBib3JkZXJXaWR0aCwgYm9yZGVyUmFkaXVzLCB4SWNvbiwgZG90SWNvbiwgfSA9IHRoZW1lO1xuICAgIGNvbnN0IHggPSB4UG9zICsgYm9yZGVyV2lkdGg7XG4gICAgY29uc3QgeSA9IHlQb3MgKyBib3JkZXJXaWR0aDtcbiAgICBjb25zdCByZWN0U2l6ZSA9IEJVVFRPTl9SRUNUX1NJWkUgLSAyICogYm9yZGVyV2lkdGg7XG4gICAgcGF0aFJlY3QoY3R4LCB7XG4gICAgICAgIHR5cGU6ICdwYXRoUmVjdCcsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGZpbGw6IGJhY2tncm91bmRDb2xvcixcbiAgICAgICAgc3Ryb2tlOiBib3JkZXJDb2xvcixcbiAgICAgICAgd2lkdGg6IHJlY3RTaXplLFxuICAgICAgICBoZWlnaHQ6IHJlY3RTaXplLFxuICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgbGluZVdpZHRoOiBib3JkZXJXaWR0aCxcbiAgICB9KTtcbiAgICBpZiAob3BlbmVkKSB7XG4gICAgICAgIGRyYXdYSWNvbihjdHgsIHsgeCwgeSwgdGhlbWU6IHhJY29uIH0sIHJlY3RTaXplKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRyYXdNb3JlSWNvbihjdHgsIHsgeCwgeSwgdGhlbWU6IGRvdEljb24gfSwgcmVjdFNpemUpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGNhbGN1bGF0ZURlZ3JlZVRvUmFkaWFuLCBnZXRSYWRpYWxQb3NpdGlvbiwgY2FsY3VsYXRlVmFsaWRBbmdsZSwgREVHUkVFXzkwLCB9IGZyb20gXCIuLi9oZWxwZXJzL3NlY3RvclwiO1xuaW1wb3J0IHsgY2lyY2xlIH0gZnJvbSBcIi4vYmFzaWNcIjtcbmltcG9ydCB7IHBvbHlnb24gfSBmcm9tIFwiLi9wb2x5Z29uXCI7XG5mdW5jdGlvbiBnZXRDbG9ja0hhbmRQb2ludHMobW9kZWwpIHtcbiAgICBjb25zdCB7IHgsIHksIHgyLCB5MiwgZGVncmVlLCBiYXNlTGluZSB9ID0gbW9kZWw7XG4gICAgY29uc3QgaGFsZkJhc2VMaW5lID0gYmFzZUxpbmUgLyAyO1xuICAgIGxldCBzdGFydFBvaW50LCBlbmRQb2ludDtcbiAgICBpZiAoeCA9PT0geDIpIHtcbiAgICAgICAgc3RhcnRQb2ludCA9IHsgeDogeCAtIGhhbGZCYXNlTGluZSwgeSB9O1xuICAgICAgICBlbmRQb2ludCA9IHsgeDogeCArIGhhbGZCYXNlTGluZSwgeSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh5ID09PSB5Mikge1xuICAgICAgICBzdGFydFBvaW50ID0geyB4LCB5OiB5IC0gaGFsZkJhc2VMaW5lIH07XG4gICAgICAgIGVuZFBvaW50ID0geyB4LCB5OiB5ICsgaGFsZkJhc2VMaW5lIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdGFydFBvaW50ID0gZ2V0UmFkaWFsUG9zaXRpb24oeCwgeSwgaGFsZkJhc2VMaW5lLCBjYWxjdWxhdGVEZWdyZWVUb1JhZGlhbihjYWxjdWxhdGVWYWxpZEFuZ2xlKGRlZ3JlZSArIERFR1JFRV85MCkpKTtcbiAgICAgICAgZW5kUG9pbnQgPSBnZXRSYWRpYWxQb3NpdGlvbih4LCB5LCBoYWxmQmFzZUxpbmUsIGNhbGN1bGF0ZURlZ3JlZVRvUmFkaWFuKGNhbGN1bGF0ZVZhbGlkQW5nbGUoZGVncmVlIC0gREVHUkVFXzkwKSkpO1xuICAgIH1cbiAgICByZXR1cm4gW3N0YXJ0UG9pbnQsIHsgeDogeDIsIHk6IHkyIH0sIGVuZFBvaW50XTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbG9ja0hhbmQoY3R4LCBtb2RlbCkge1xuICAgIGNvbnN0IHsgY29sb3IsIHgsIHksIHBpbjogeyBjb2xvcjogcGluQ29sb3IsIHJhZGl1cywgc3R5bGUgfSwgfSA9IG1vZGVsO1xuICAgIGNpcmNsZShjdHgsIHtcbiAgICAgICAgdHlwZTogJ2NpcmNsZScsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHJhZGl1cyxcbiAgICAgICAgY29sb3I6IHBpbkNvbG9yLFxuICAgICAgICBzdHlsZSxcbiAgICB9KTtcbiAgICBwb2x5Z29uKGN0eCwge1xuICAgICAgICB0eXBlOiAncG9seWdvbicsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgIGZpbGxDb2xvcjogY29sb3IsXG4gICAgICAgIHBvaW50czogZ2V0Q2xvY2tIYW5kUG9pbnRzKG1vZGVsKSxcbiAgICB9KTtcbn1cbiIsImltcG9ydCB7IG1ha2VTdHlsZU9iaiwgZmlsbFN0eWxlLCBzdHJva2VXaXRoT3B0aW9ucyB9IGZyb20gXCIuLi9oZWxwZXJzL3N0eWxlXCI7XG5pbXBvcnQgeyBpc051bWJlciB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyByZ2JhIH0gZnJvbSBcIi4uL2hlbHBlcnMvY29sb3JcIjtcbmV4cG9ydCBjb25zdCBERUZBVUxUX0xBQkVMX1RFWFQgPSAnbm9ybWFsIDExcHggQXJpYWwnO1xuZXhwb3J0IGNvbnN0IGxhYmVsU3R5bGUgPSB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgICBmb250OiBERUZBVUxUX0xBQkVMX1RFWFQsXG4gICAgICAgIGZpbGxTdHlsZTogJyMzMzMzMzMnLFxuICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICB9LFxuICAgIHRpdGxlOiB7XG4gICAgICAgIHRleHRCYXNlbGluZTogJ3RvcCcsXG4gICAgfSxcbiAgICBheGlzVGl0bGU6IHtcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAndG9wJyxcbiAgICB9LFxuICAgIHJlY3RMYWJlbDoge1xuICAgICAgICBmb250OiBERUZBVUxUX0xBQkVMX1RFWFQsXG4gICAgICAgIGZpbGxTdHlsZTogJ3JnYmEoMCwgMCwgMCwgMC4zKScsXG4gICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgfSxcbn07XG5leHBvcnQgY29uc3Qgc3Ryb2tlTGFiZWxTdHlsZSA9IHtcbiAgICBub25lOiB7XG4gICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgc3Ryb2tlU3R5bGU6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDApJyxcbiAgICB9LFxuICAgIHN0cm9rZToge1xuICAgICAgICBsaW5lV2lkdGg6IDQsXG4gICAgICAgIHN0cm9rZVN0eWxlOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpJyxcbiAgICB9LFxufTtcbmV4cG9ydCBmdW5jdGlvbiBsYWJlbChjdHgsIGxhYmVsTW9kZWwpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgIGNvbnN0IHsgeCwgeSwgdGV4dCwgc3R5bGUsIHN0cm9rZSwgb3BhY2l0eSwgcmFkaWFuLCByb3RhdGlvblBvc2l0aW9uIH0gPSBsYWJlbE1vZGVsO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgICBjb25zdCBzdHlsZU9iaiA9IG1ha2VTdHlsZU9iaihzdHlsZSwgbGFiZWxTdHlsZSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHN0eWxlT2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGN0eFtrZXldID1cbiAgICAgICAgICAgICAgICBrZXkgPT09ICdmaWxsU3R5bGUnICYmIGlzTnVtYmVyKG9wYWNpdHkpID8gcmdiYShzdHlsZU9ialtrZXldLCBvcGFjaXR5KSA6IHN0eWxlT2JqW2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGlmIChyYWRpYW4pIHtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgoX2IgPSAoX2EgPSByb3RhdGlvblBvc2l0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EueCwgKF9iICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHgpKSwgKF9kID0gKF9jID0gcm90YXRpb25Qb3NpdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnksIChfZCAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB5KSkpO1xuICAgICAgICBjdHgucm90YXRlKHJhZGlhbik7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLShfZiA9IChfZSA9IHJvdGF0aW9uUG9zaXRpb24pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS54LCAoX2YgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogeCkpLCAtKF9oID0gKF9nID0gcm90YXRpb25Qb3NpdGlvbikgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnksIChfaCAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiB5KSkpO1xuICAgIH1cbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgIGNvbnN0IHN0cm9rZVN0eWxlT2JqID0gbWFrZVN0eWxlT2JqKHN0cm9rZSwgc3Ryb2tlTGFiZWxTdHlsZSk7XG4gICAgICAgIGNvbnN0IHN0cm9rZVN0eWxlS2V5cyA9IE9iamVjdC5rZXlzKHN0cm9rZVN0eWxlT2JqKTtcbiAgICAgICAgc3Ryb2tlU3R5bGVLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY3R4W2tleV0gPVxuICAgICAgICAgICAgICAgIGtleSA9PT0gJ3N0cm9rZVN0eWxlJyAmJiBpc051bWJlcihvcGFjaXR5KVxuICAgICAgICAgICAgICAgICAgICA/IHJnYmEoc3Ryb2tlU3R5bGVPYmpba2V5XSwgb3BhY2l0eSlcbiAgICAgICAgICAgICAgICAgICAgOiBzdHJva2VTdHlsZU9ialtrZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN0cm9rZVN0eWxlS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KHRleHQsIHgsIHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGN0eC5maWxsVGV4dCh0ZXh0LCB4LCB5KTtcbiAgICBjdHgucmVzdG9yZSgpO1xufVxuY29uc3QgdGV4dEJ1YmJsZVN0eWxlID0ge1xuICAgIHNoYWRvdzoge1xuICAgICAgICBzaGFkb3dDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4zKScsXG4gICAgICAgIHNoYWRvd09mZnNldFk6IDIsXG4gICAgICAgIHNoYWRvd0JsdXI6IDQsXG4gICAgfSxcbn07XG5leHBvcnQgZnVuY3Rpb24gYnViYmxlTGFiZWwoY3R4LCBtb2RlbCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCB7IHJhZGlhbiA9IDAsIHJvdGF0aW9uUG9zaXRpb24sIGJ1YmJsZTogeyB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMgPSAwLCBsaW5lV2lkdGggPSAxLCBkaXJlY3Rpb24sIHBvaW50cyA9IFtdLCBmaWxsID0gJyNmZmYnLCBzdHJva2VTdHlsZSA9ICdyZ2JhKDAsIDAsIDAsIDApJywgc3R5bGU6IGJ1YmJsZVN0eWxlID0gbnVsbCwgfSwgfSA9IG1vZGVsO1xuICAgIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xuICAgICAgICBkcmF3QnViYmxlKGN0eCwge1xuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICByYWRpdXMsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHN0eWxlOiBidWJibGVTdHlsZSxcbiAgICAgICAgICAgIGZpbGwsXG4gICAgICAgICAgICBzdHJva2VTdHlsZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aCxcbiAgICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICAgIHBvaW50cyxcbiAgICAgICAgICAgIHJhZGlhbixcbiAgICAgICAgICAgIHJvdGF0aW9uUG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiAoX2IgPSAoX2EgPSByb3RhdGlvblBvc2l0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EueCwgKF9iICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHgpKSxcbiAgICAgICAgICAgICAgICB5OiAoX2QgPSAoX2MgPSByb3RhdGlvblBvc2l0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MueSwgKF9kICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHkpKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobW9kZWwubGFiZWwudGV4dCkge1xuICAgICAgICBjb25zdCB7IHg6IGxhYmVsWCwgeTogbGFiZWxZLCB0ZXh0LCBzdHJva2VTdHlsZTogbGFiZWxTdHJva2VDb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDApJywgc3R5bGUsIH0gPSBtb2RlbC5sYWJlbDtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwgMCwgMCwgMCknO1xuICAgICAgICBsYWJlbChjdHgsIHtcbiAgICAgICAgICAgIHR5cGU6ICdsYWJlbCcsXG4gICAgICAgICAgICB4OiBsYWJlbFgsXG4gICAgICAgICAgICB5OiBsYWJlbFksXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICBzdHJva2U6IFt7IHN0cm9rZVN0eWxlOiBsYWJlbFN0cm9rZUNvbG9yIH1dLFxuICAgICAgICAgICAgcmFkaWFuLFxuICAgICAgICAgICAgcm90YXRpb25Qb3NpdGlvbixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZHJhd0J1YmJsZUFycm93KGN0eCwgcG9pbnRzKSB7XG4gICAgaWYgKCFwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuICAgIGN0eC5saW5lVG8ocG9pbnRzWzFdLngsIHBvaW50c1sxXS55KTtcbiAgICBjdHgubGluZVRvKHBvaW50c1syXS54LCBwb2ludHNbMl0ueSk7XG59XG5mdW5jdGlvbiBkcmF3QnViYmxlKGN0eCwgbW9kZWwpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQsIHN0eWxlLCByYWRpdXMgPSAwLCBzdHJva2VTdHlsZSwgZmlsbCwgbGluZVdpZHRoID0gMSwgcG9pbnRzID0gW10sIGRpcmVjdGlvbiA9ICcnLCByYWRpYW4sIHJvdGF0aW9uUG9zaXRpb24sIH0gPSBtb2RlbDtcbiAgICBjb25zdCByaWdodCA9IHggKyB3aWR0aDtcbiAgICBjb25zdCBib3R0b20gPSB5ICsgaGVpZ2h0O1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGlmIChyYWRpYW4gJiYgcm90YXRpb25Qb3NpdGlvbikge1xuICAgICAgICBjdHgudHJhbnNsYXRlKHJvdGF0aW9uUG9zaXRpb24ueCwgcm90YXRpb25Qb3NpdGlvbi55KTtcbiAgICAgICAgY3R4LnJvdGF0ZShyYWRpYW4pO1xuICAgICAgICBjdHgudHJhbnNsYXRlKC1yb3RhdGlvblBvc2l0aW9uLngsIC1yb3RhdGlvblBvc2l0aW9uLnkpO1xuICAgIH1cbiAgICBjdHgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuICAgIGlmIChkaXJlY3Rpb24gPT09ICd0b3AnKSB7XG4gICAgICAgIGRyYXdCdWJibGVBcnJvdyhjdHgsIHBvaW50cyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8ocmlnaHQgLSByYWRpdXMsIHkpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHJpZ2h0LCB5LCByaWdodCwgeSArIHJhZGl1cyk7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBkcmF3QnViYmxlQXJyb3coY3R4LCBwb2ludHMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHJpZ2h0LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhyaWdodCwgYm90dG9tLCByaWdodCAtIHJhZGl1cywgYm90dG9tKTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICBkcmF3QnViYmxlQXJyb3coY3R4LCBwb2ludHMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyByYWRpdXMsIGJvdHRvbSk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgYm90dG9tLCB4LCBib3R0b20gLSByYWRpdXMpO1xuICAgIGlmIChkaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICBkcmF3QnViYmxlQXJyb3coY3R4LCBwb2ludHMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByYWRpdXMsIHkpO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgICBjb25zdCBzdHlsZU9iaiA9IG1ha2VTdHlsZU9iaihzdHlsZSwgdGV4dEJ1YmJsZVN0eWxlKTtcbiAgICAgICAgT2JqZWN0LmtleXMoc3R5bGVPYmopLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY3R4W2tleV0gPSBzdHlsZU9ialtrZXldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGZpbGwpIHtcbiAgICAgICAgZmlsbFN0eWxlKGN0eCwgZmlsbCk7XG4gICAgfVxuICAgIGlmIChzdHJva2VTdHlsZSkge1xuICAgICAgICBzdHJva2VXaXRoT3B0aW9ucyhjdHgsIHsgc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCB9KTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbn1cbiIsImltcG9ydCB7IGxpbmUsIGNpcmNsZSwgcmVjdCB9IGZyb20gXCIuL2Jhc2ljXCI7XG5pbXBvcnQgeyBsYWJlbCB9IGZyb20gXCIuL2xhYmVsXCI7XG5pbXBvcnQgeyBnZXRSR0JBIH0gZnJvbSBcIi4uL2hlbHBlcnMvY29sb3JcIjtcbmltcG9ydCB7IHNjYXR0ZXJTZXJpZXMgfSBmcm9tIFwiLi9zY2F0dGVyU2VyaWVzXCI7XG5pbXBvcnQgeyBnZXRUaXRsZUZvbnRTdHJpbmcgfSBmcm9tIFwiLi4vaGVscGVycy9zdHlsZVwiO1xuaW1wb3J0IHsgZ2V0VGV4dEhlaWdodCB9IGZyb20gXCIuLi9oZWxwZXJzL2NhbGN1bGF0b3JcIjtcbmltcG9ydCB7IHBhZGRpbmcgfSBmcm9tIFwiLi4vc3RvcmUvbGF5b3V0XCI7XG5leHBvcnQgY29uc3QgTEVHRU5EX0lURU1fTUFSR0lOX1ggPSA0MDtcbmV4cG9ydCBjb25zdCBMRUdFTkRfTUFSR0lOX1ggPSA1O1xuZXhwb3J0IGNvbnN0IExFR0VORF9DSEVDS0JPWF9TSVpFID0gMTI7XG5leHBvcnQgY29uc3QgTEVHRU5EX0lDT05fU0laRSA9IDEyO1xuY29uc3QgSUNPTl9CT1JERVJfV0lEVEggPSAxLjU7XG5jb25zdCBJTkFDVElWRV9PUEFDSVRZID0gMC4zO1xuY29uc3QgUkVDVF9TSVpFID0gMTA7XG5jb25zdCBMSU5FX0lDT05fUEFERElORyA9IDI7XG5jb25zdCBDSVJDTEVfSUNPTl9SQURJVVMgPSA2O1xuZXhwb3J0IGZ1bmN0aW9uIGdldExlZ2VuZEl0ZW1IZWlnaHQoZm9udFNpemUpIHtcbiAgICByZXR1cm4gZm9udFNpemUgKyBwYWRkaW5nLlk7XG59XG5mdW5jdGlvbiBkcmF3TGluZUljb24oY3R4LCB4LCB5LCBjb2xvcikge1xuICAgIGNvbnN0IHhDdXJ2ZU9mZnNldCA9IFsyLCAyLCA2LCA2LCAxMCwgMTBdO1xuICAgIGNvbnN0IHlDdXJ2ZU9mZnNldCA9IFs4LCAwLCAwLCA4LCA4LCAwXTtcbiAgICB4Q3VydmVPZmZzZXQuZm9yRWFjaCgoeE9mZnNldCwgaWR4KSA9PiB7XG4gICAgICAgIGlmIChpZHggPT09IDUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsaW5lKGN0eCwge1xuICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgeDogeCArIHhPZmZzZXQsXG4gICAgICAgICAgICB5OiB5ICsgeUN1cnZlT2Zmc2V0W2lkeF0sXG4gICAgICAgICAgICB4MjogeCArIHhDdXJ2ZU9mZnNldFtpZHggKyAxXSxcbiAgICAgICAgICAgIHkyOiB5ICsgeUN1cnZlT2Zmc2V0W2lkeCArIDFdLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAyLFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IGNvbG9yLFxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGRyYXdDaGVja0ljb24oY3R4LCB4LCB5LCBhY3RpdmUpIHtcbiAgICBjb25zdCBjb2xvciA9ICcjNTU1NTU1JztcbiAgICBjb25zdCBzdHJva2VTdHlsZSA9IGFjdGl2ZSA/IGNvbG9yIDogZ2V0UkdCQShjb2xvciwgSU5BQ1RJVkVfT1BBQ0lUWSk7XG4gICAgbGluZShjdHgsIHtcbiAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICB4OiB4ICsgMixcbiAgICAgICAgeTogeSArIDUsXG4gICAgICAgIHgyOiB4ICsgNSxcbiAgICAgICAgeTI6IHkgKyA4LFxuICAgICAgICBzdHJva2VTdHlsZSxcbiAgICAgICAgbGluZVdpZHRoOiAyLFxuICAgIH0pO1xuICAgIGxpbmUoY3R4LCB7XG4gICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgeDogeCArIDUsXG4gICAgICAgIHk6IHkgKyA5LFxuICAgICAgICB4MjogeCArIDEwLFxuICAgICAgICB5MjogeSArIDMsXG4gICAgICAgIHN0cm9rZVN0eWxlLFxuICAgICAgICBsaW5lV2lkdGg6IDIsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBkcmF3Q2hlY2tib3goY3R4LCB4LCB5LCByZW5kZXJPcHRpb25zKSB7XG4gICAgY29uc3QgeyBhY3RpdmUsIGNoZWNrZWQgfSA9IHJlbmRlck9wdGlvbnM7XG4gICAgY29uc3QgYm9yZGVyQ29sb3IgPSBhY3RpdmUgPyAnI2JiYicgOiBnZXRSR0JBKCcjYmJiYmJiJywgSU5BQ1RJVkVfT1BBQ0lUWSk7XG4gICAgcmVjdChjdHgsIHtcbiAgICAgICAgdHlwZTogJ3JlY3QnLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB3aWR0aDogTEVHRU5EX0NIRUNLQk9YX1NJWkUsXG4gICAgICAgIGhlaWdodDogTEVHRU5EX0NIRUNLQk9YX1NJWkUsXG4gICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgIGJvcmRlckNvbG9yLFxuICAgICAgICB0aGlja25lc3M6IDEsXG4gICAgfSk7XG4gICAgaWYgKGNoZWNrZWQpIHtcbiAgICAgICAgZHJhd0NoZWNrSWNvbihjdHgsIHgsIHksIGFjdGl2ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZHJhd0ljb24oY3R4LCB4LCB5LCByZW5kZXJPcHRpb25zKSB7XG4gICAgY29uc3QgeyBpY29uVHlwZSwgYWN0aXZlLCBjb2xvciwgc2hvd0NoZWNrYm94IH0gPSByZW5kZXJPcHRpb25zO1xuICAgIGNvbnN0IGljb25YID0geCArIChzaG93Q2hlY2tib3ggPyBMRUdFTkRfQ0hFQ0tCT1hfU0laRSArIExFR0VORF9NQVJHSU5fWCA6IDApO1xuICAgIGNvbnN0IGljb25Db2xvciA9IGFjdGl2ZSA/IGNvbG9yIDogZ2V0UkdCQShjb2xvciwgSU5BQ1RJVkVfT1BBQ0lUWSk7XG4gICAgaWYgKGljb25UeXBlID09PSAncmVjdCcpIHtcbiAgICAgICAgcmVjdChjdHgsIHtcbiAgICAgICAgICAgIHR5cGU6ICdyZWN0JyxcbiAgICAgICAgICAgIHg6IGljb25YLFxuICAgICAgICAgICAgeTogeSArIChMRUdFTkRfQ0hFQ0tCT1hfU0laRSAtIFJFQ1RfU0laRSkgLyAyLFxuICAgICAgICAgICAgd2lkdGg6IFJFQ1RfU0laRSxcbiAgICAgICAgICAgIGhlaWdodDogUkVDVF9TSVpFLFxuICAgICAgICAgICAgY29sb3I6IGljb25Db2xvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGljb25UeXBlID09PSAnbGluZScpIHtcbiAgICAgICAgZHJhd0xpbmVJY29uKGN0eCwgaWNvblgsIHkgKyBMSU5FX0lDT05fUEFERElORywgaWNvbkNvbG9yKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaWNvblR5cGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgIGNpcmNsZShjdHgsIHtcbiAgICAgICAgICAgIHR5cGU6ICdjaXJjbGUnLFxuICAgICAgICAgICAgeDogaWNvblggKyBDSVJDTEVfSUNPTl9SQURJVVMsXG4gICAgICAgICAgICB5OiB5ICsgQ0lSQ0xFX0lDT05fUkFESVVTLFxuICAgICAgICAgICAgcmFkaXVzOiBDSVJDTEVfSUNPTl9SQURJVVMsXG4gICAgICAgICAgICBjb2xvcjogaWNvbkNvbG9yLFxuICAgICAgICAgICAgc3R5bGU6IFsnZGVmYXVsdCddLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBkcmF3U2NhdHRlckljb24oY3R4LCB4LCB5LCByZW5kZXJPcHRpb25zKSB7XG4gICAgY29uc3QgeyBpY29uVHlwZSwgYWN0aXZlLCBjb2xvciwgc2hvd0NoZWNrYm94IH0gPSByZW5kZXJPcHRpb25zO1xuICAgIGNvbnN0IGljb25YID0geCArIChzaG93Q2hlY2tib3ggPyBMRUdFTkRfQ0hFQ0tCT1hfU0laRSArIExFR0VORF9NQVJHSU5fWCA6IDApO1xuICAgIGNvbnN0IGljb25Db2xvciA9IGFjdGl2ZSA/IGNvbG9yIDogZ2V0UkdCQShjb2xvciwgSU5BQ1RJVkVfT1BBQ0lUWSk7XG4gICAgc2NhdHRlclNlcmllcyhjdHgsIHtcbiAgICAgICAgdHlwZTogJ3NjYXR0ZXJTZXJpZXMnLFxuICAgICAgICBpY29uVHlwZTogaWNvblR5cGUsXG4gICAgICAgIHg6IGljb25YICsgQ0lSQ0xFX0lDT05fUkFESVVTLFxuICAgICAgICB5OiB5ICsgQ0lSQ0xFX0lDT05fUkFESVVTLFxuICAgICAgICBib3JkZXJDb2xvcjogaWNvbkNvbG9yLFxuICAgICAgICBzaXplOiBDSVJDTEVfSUNPTl9SQURJVVMgKiAyLFxuICAgICAgICBmaWxsQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDApJyxcbiAgICAgICAgYm9yZGVyV2lkdGg6IElDT05fQk9SREVSX1dJRFRILFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZHJhd0xhYmVsKGN0eCwgeCwgeSwgdGV4dCwgcmVuZGVyT3B0aW9ucykge1xuICAgIGNvbnN0IHsgYWN0aXZlLCBzaG93Q2hlY2tib3gsIGZvbnQsIGZvbnRDb2xvciB9ID0gcmVuZGVyT3B0aW9ucztcbiAgICBjb25zdCBmaWxsU3R5bGUgPSBhY3RpdmUgPyBmb250Q29sb3IgOiBnZXRSR0JBKGZvbnRDb2xvciwgSU5BQ1RJVkVfT1BBQ0lUWSk7XG4gICAgbGFiZWwoY3R4LCB7XG4gICAgICAgIHR5cGU6ICdsYWJlbCcsXG4gICAgICAgIHg6IHggK1xuICAgICAgICAgICAgTEVHRU5EX0lDT05fU0laRSArXG4gICAgICAgICAgICBMRUdFTkRfTUFSR0lOX1ggK1xuICAgICAgICAgICAgKHNob3dDaGVja2JveCA/IExFR0VORF9DSEVDS0JPWF9TSVpFICsgTEVHRU5EX01BUkdJTl9YIDogMCksXG4gICAgICAgIHksXG4gICAgICAgIHRleHQsXG4gICAgICAgIHN0eWxlOiBbJ2RlZmF1bHQnLCB7IGZvbnQsIHRleHRCYXNlbGluZTogJ3RvcCcsIGZpbGxTdHlsZSB9XSxcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsZWdlbmQoY3R4LCBtb2RlbCkge1xuICAgIGNvbnN0IHsgZGF0YSwgc2hvd0NoZWNrYm94LCBhbGlnbiwgZm9udFNpemUsIGZvbnRGYW1pbHksIGZvbnRXZWlnaHQgfSA9IG1vZGVsO1xuICAgIGNvbnN0IGZvbnQgPSBnZXRUaXRsZUZvbnRTdHJpbmcoeyBmb250U2l6ZSwgZm9udEZhbWlseSwgZm9udFdlaWdodCB9KTtcbiAgICBjb25zdCBmb250Q29sb3IgPSBtb2RlbC5jb2xvcjtcbiAgICBkYXRhLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSwgY2hlY2tlZCwgYWN0aXZlLCBjb2xvciwgaWNvblR5cGUsIHVzZVNjYXR0ZXJDaGFydEljb24sIHZpZXdMYWJlbDogbGVnZW5kTGFiZWwsIH0gPSBkYXR1bTtcbiAgICAgICAgY29uc3QgaWNvblkgPSB5IC0gMSArIChnZXRUZXh0SGVpZ2h0KGxlZ2VuZExhYmVsLCBmb250KSAtIDExKSAvIDQ7XG4gICAgICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpY29uVHlwZSxcbiAgICAgICAgICAgIGNoZWNrZWQsXG4gICAgICAgICAgICBhY3RpdmUsXG4gICAgICAgICAgICBjb2xvcixcbiAgICAgICAgICAgIHNob3dDaGVja2JveCxcbiAgICAgICAgICAgIGFsaWduLFxuICAgICAgICAgICAgZm9udCxcbiAgICAgICAgICAgIGZvbnRDb2xvcixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNob3dDaGVja2JveCkge1xuICAgICAgICAgICAgZHJhd0NoZWNrYm94KGN0eCwgeCwgaWNvblksIHJlbmRlck9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VTY2F0dGVyQ2hhcnRJY29uICYmIGljb25UeXBlICE9PSAnbGluZScpIHtcbiAgICAgICAgICAgIGRyYXdTY2F0dGVySWNvbihjdHgsIHgsIGljb25ZLCByZW5kZXJPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRyYXdJY29uKGN0eCwgeCwgaWNvblksIHJlbmRlck9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGRyYXdMYWJlbChjdHgsIHgsIHksIGxlZ2VuZExhYmVsLCByZW5kZXJPcHRpb25zKTtcbiAgICB9KTtcbn1cbiIsImltcG9ydCB7IHNldExpbmVEYXNoLCBmaWxsU3R5bGUsIHN0cm9rZVdpdGhPcHRpb25zIH0gZnJvbSBcIi4uL2hlbHBlcnMvc3R5bGVcIjtcbmltcG9ydCB7IGlzTnVsbCB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5leHBvcnQgZnVuY3Rpb24gbGluZVBvaW50cyhjdHgsIHBvaW50c01vZGVsKSB7XG4gICAgY29uc3QgeyBjb2xvcjogc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCwgcG9pbnRzLCBkYXNoU2VnbWVudHMgPSBbXSB9ID0gcG9pbnRzTW9kZWw7XG4gICAgY3R4LmxpbmVDYXAgPSAncm91bmQnO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAoZGFzaFNlZ21lbnRzKSB7XG4gICAgICAgIHNldExpbmVEYXNoKGN0eCwgZGFzaFNlZ21lbnRzKTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0ID0gZmFsc2U7XG4gICAgcG9pbnRzLmZvckVhY2goKHBvaW50LCBpZHgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKGlzTnVsbChwb2ludCkpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9pbnQuY29udHJvbFBvaW50ICYmICgoX2IgPSAoX2EgPSBwb2ludHNbaWR4IC0gMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250cm9sUG9pbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uZXh0KSkge1xuICAgICAgICAgICAgY29uc3QgeyB4OiBwcmV2WCwgeTogcHJldlkgfSA9IHBvaW50c1tpZHggLSAxXS5jb250cm9sUG9pbnQubmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHsgY29udHJvbFBvaW50LCB4LCB5IH0gPSBwb2ludDtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHByZXZYLCBwcmV2WSwgY29udHJvbFBvaW50LnByZXYueCwgY29udHJvbFBvaW50LnByZXYueSwgeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgc3Ryb2tlV2l0aE9wdGlvbnMoY3R4LCB7IGxpbmVXaWR0aCwgc3Ryb2tlU3R5bGUgfSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIHNldExpbmVEYXNoKGN0eCwgW10pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFyZWFQb2ludHMoY3R4LCBhcmVhUG9pbnRzTW9kZWwpIHtcbiAgICBjb25zdCB7IGZpbGxDb2xvciB9ID0gYXJlYVBvaW50c01vZGVsO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBsaW5lUG9pbnRzKGN0eCwgYXJlYVBvaW50c01vZGVsKTtcbiAgICBmaWxsU3R5bGUoY3R4LCBmaWxsQ29sb3IpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbn1cbiIsImltcG9ydCB7IHNldExpbmVEYXNoLCBmaWxsU3R5bGUsIHN0cm9rZVdpdGhPcHRpb25zIH0gZnJvbSBcIi4uL2hlbHBlcnMvc3R5bGVcIjtcbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uKGN0eCwgcG9seWdvbk1vZGVsKSB7XG4gICAgY29uc3QgeyBjb2xvcjogc3Ryb2tlU3R5bGUsIHBvaW50cywgbGluZVdpZHRoLCBmaWxsQ29sb3IsIGRhc2hTZWdtZW50cyA9IFtdIH0gPSBwb2x5Z29uTW9kZWw7XG4gICAgaWYgKCFwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGlmIChkYXNoU2VnbWVudHMpIHtcbiAgICAgICAgc2V0TGluZURhc2goY3R4LCBkYXNoU2VnbWVudHMpO1xuICAgIH1cbiAgICBwb2ludHMuZm9yRWFjaCgoeyB4LCB5IH0sIGlkeCkgPT4ge1xuICAgICAgICBpZiAoaWR4ID09PSAwKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgfSk7XG4gICAgY3R4LmxpbmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuICAgIGlmIChmaWxsQ29sb3IpIHtcbiAgICAgICAgZmlsbFN0eWxlKGN0eCwgZmlsbENvbG9yKTtcbiAgICB9XG4gICAgc3Ryb2tlV2l0aE9wdGlvbnMoY3R4LCB7IGxpbmVXaWR0aCwgc3Ryb2tlU3R5bGUgfSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xufVxuIiwiaW1wb3J0IHsgQlVUVE9OX1JFQ1RfU0laRSB9IGZyb20gXCIuLi9jb21wb25lbnQvZXhwb3J0TWVudVwiO1xuaW1wb3J0IHsgY2lyY2xlLCBsaW5lLCBwYXRoUmVjdCB9IGZyb20gXCIuL2Jhc2ljXCI7XG5pbXBvcnQgeyBhcmVhUG9pbnRzIH0gZnJvbSBcIi4vbGluZVNlcmllc1wiO1xuY29uc3QgQVJST1dfSEVJR0hUID0gMztcbmNvbnN0IEFSUk9XX1dJRFRIID0gNjtcbmZ1bmN0aW9uIGRyYXdSZXNldEljb24oY3R4LCBwb2ludCkge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQ7XG4gICAgY29uc3QgY2VudGVyWCA9IHggKyBCVVRUT05fUkVDVF9TSVpFIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0geSArIEJVVFRPTl9SRUNUX1NJWkUgLyAyO1xuICAgIGNvbnN0IHRpY2tTaXplID0gQlVUVE9OX1JFQ1RfU0laRSAvIDEwO1xuICAgIGNvbnN0IGNvbG9yID0gJyM1NDU0NTQnO1xuICAgIGNpcmNsZShjdHgsIHtcbiAgICAgICAgdHlwZTogJ2NpcmNsZScsXG4gICAgICAgIHg6IGNlbnRlclgsXG4gICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgIHJhZGl1czogdGlja1NpemUgKiAyLFxuICAgICAgICBhbmdsZTogeyBzdGFydDogMCwgZW5kOiBNYXRoLlBJIC8gMiB9LFxuICAgICAgICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgc3R5bGU6IFt7IGxpbmVXaWR0aDogMiwgc3Ryb2tlU3R5bGU6IGNvbG9yIH1dLFxuICAgIH0pO1xuICAgIGNvbnN0IHBvaW50U3RhcnRYID0gY2VudGVyWCArIHRpY2tTaXplICogMjtcbiAgICBjb25zdCBwb2ludFN0YXJ0WSA9IGNlbnRlclk7XG4gICAgY29uc3QgcG9pbnRzID0gW1xuICAgICAgICB7IHg6IHBvaW50U3RhcnRYIC0gQVJST1dfV0lEVEggLyAyLCB5OiBwb2ludFN0YXJ0WSB9LFxuICAgICAgICB7IHg6IHBvaW50U3RhcnRYICsgQVJST1dfV0lEVEggLyAyLCB5OiBwb2ludFN0YXJ0WSB9LFxuICAgICAgICB7IHg6IHBvaW50U3RhcnRYLCB5OiBwb2ludFN0YXJ0WSArIEFSUk9XX0hFSUdIVCB9LFxuICAgIF07XG4gICAgYXJlYVBvaW50cyhjdHgsIHtcbiAgICAgICAgdHlwZTogJ2FyZWFQb2ludHMnLFxuICAgICAgICBwb2ludHMsXG4gICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIGZpbGxDb2xvcjogY29sb3IsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBkcmF3QmFja0ljb24oY3R4LCBwb2ludCkge1xuICAgIGNvbnN0IGJhcldpZHRoID0gNDtcbiAgICBjb25zdCByYWRpdXMgPSBCVVRUT05fUkVDVF9TSVpFIC8gNztcbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50O1xuICAgIGNvbnN0IGNlbnRlclggPSB4ICsgQlVUVE9OX1JFQ1RfU0laRSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IHkgKyBCVVRUT05fUkVDVF9TSVpFIC8gMjtcbiAgICBjb25zdCBjb2xvciA9ICcjNTQ1NDU0JztcbiAgICBsaW5lKGN0eCwge1xuICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgIGxpbmVXaWR0aDogMixcbiAgICAgICAgeDogY2VudGVyWCAtIGJhcldpZHRoIC8gMixcbiAgICAgICAgeTogY2VudGVyWSArIHJhZGl1cyxcbiAgICAgICAgeDI6IGNlbnRlclggKyBiYXJXaWR0aCAvIDIsXG4gICAgICAgIHkyOiBjZW50ZXJZICsgcmFkaXVzLFxuICAgICAgICBzdHJva2VTdHlsZTogY29sb3IsXG4gICAgfSk7XG4gICAgbGluZShjdHgsIHtcbiAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICBsaW5lV2lkdGg6IDIsXG4gICAgICAgIHg6IGNlbnRlclggLSBiYXJXaWR0aCAvIDIsXG4gICAgICAgIHk6IGNlbnRlclkgLSByYWRpdXMsXG4gICAgICAgIHgyOiBjZW50ZXJYICsgYmFyV2lkdGggLyAyLFxuICAgICAgICB5MjogY2VudGVyWSAtIHJhZGl1cyxcbiAgICAgICAgc3Ryb2tlU3R5bGU6IGNvbG9yLFxuICAgIH0pO1xuICAgIGNpcmNsZShjdHgsIHtcbiAgICAgICAgdHlwZTogJ2NpcmNsZScsXG4gICAgICAgIHg6IGNlbnRlclggKyBiYXJXaWR0aCAvIDIsXG4gICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgIHJhZGl1cyxcbiAgICAgICAgYW5nbGU6IHsgc3RhcnQ6IE1hdGguUEkgLyAyLCBlbmQ6IChNYXRoLlBJICogMykgLyAyIH0sXG4gICAgICAgIGNvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBzdHlsZTogW3sgbGluZVdpZHRoOiAyLCBzdHJva2VTdHlsZTogY29sb3IgfV0sXG4gICAgfSk7XG4gICAgY29uc3QgcG9pbnRTdGFydFggPSBjZW50ZXJYIC0gYmFyV2lkdGggLyAyO1xuICAgIGNvbnN0IHBvaW50U3RhcnRZID0gY2VudGVyWSAtIHJhZGl1cztcbiAgICBjb25zdCBwb2ludHMgPSBbXG4gICAgICAgIHsgeDogcG9pbnRTdGFydFggLSBBUlJPV19IRUlHSFQsIHk6IHBvaW50U3RhcnRZIH0sXG4gICAgICAgIHsgeDogcG9pbnRTdGFydFgsIHk6IHBvaW50U3RhcnRZIC0gQVJST1dfV0lEVEggLyAyIH0sXG4gICAgICAgIHsgeDogcG9pbnRTdGFydFgsIHk6IHBvaW50U3RhcnRZICsgQVJST1dfV0lEVEggLyAyIH0sXG4gICAgXTtcbiAgICBhcmVhUG9pbnRzKGN0eCwge1xuICAgICAgICB0eXBlOiAnYXJlYVBvaW50cycsXG4gICAgICAgIHBvaW50cyxcbiAgICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgZmlsbENvbG9yOiBjb2xvcixcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBiYWNrQnV0dG9uKGN0eCwgYmFja0J1dHRvbk1vZGVsKSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBiYWNrQnV0dG9uTW9kZWw7XG4gICAgcGF0aFJlY3QoY3R4LCB7XG4gICAgICAgIHR5cGU6ICdwYXRoUmVjdCcsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGZpbGw6ICcjZjRmNGY0JyxcbiAgICAgICAgc3Ryb2tlOiAnI2Y0ZjRmNCcsXG4gICAgICAgIHdpZHRoOiBCVVRUT05fUkVDVF9TSVpFLFxuICAgICAgICBoZWlnaHQ6IEJVVFRPTl9SRUNUX1NJWkUsXG4gICAgICAgIHJhZGl1czogNSxcbiAgICB9KTtcbiAgICBkcmF3QmFja0ljb24oY3R4LCB7IHgsIHkgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVzZXRCdXR0b24oY3R4LCByZXNldEJ1dHRvbk1vZGVsKSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSByZXNldEJ1dHRvbk1vZGVsO1xuICAgIHBhdGhSZWN0KGN0eCwge1xuICAgICAgICB0eXBlOiAncGF0aFJlY3QnLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBmaWxsOiAnI2Y0ZjRmNCcsXG4gICAgICAgIHN0cm9rZTogJyNmNGY0ZjQnLFxuICAgICAgICB3aWR0aDogQlVUVE9OX1JFQ1RfU0laRSxcbiAgICAgICAgaGVpZ2h0OiBCVVRUT05fUkVDVF9TSVpFLFxuICAgICAgICByYWRpdXM6IDUsXG4gICAgfSk7XG4gICAgZHJhd1Jlc2V0SWNvbihjdHgsIHsgeCwgeSB9KTtcbn1cbiIsImltcG9ydCB7IGNpcmNsZSwgcGF0aFJlY3QgfSBmcm9tIFwiLi9iYXNpY1wiO1xuaW1wb3J0IHsgcG9seWdvbiB9IGZyb20gXCIuL3BvbHlnb25cIjtcbmltcG9ydCB7IGZpbGxTdHlsZSB9IGZyb20gXCIuLi9oZWxwZXJzL3N0eWxlXCI7XG5mdW5jdGlvbiByZWd1bGFyUG9seWdvbihjdHgsIG1vZGVsKSB7XG4gICAgY29uc3QgeyBudW1iZXJPZlNpZGVzLCBzaXplLCB4LCB5LCBib3JkZXJDb2xvciwgYm9yZGVyV2lkdGgsIGZpbGxDb2xvciB9ID0gbW9kZWw7XG4gICAgY29uc3QgcyA9IHNpemUgLyAyO1xuICAgIGNvbnN0IHNoaWZ0ID0gbnVtYmVyT2ZTaWRlcyAlIDIgPyAoTWF0aC5QSSAvIDE4MC4wKSAqICgxMCArIChudW1iZXJPZlNpZGVzIC0gMykgLyAyKSAqIG51bWJlck9mU2lkZXMgOiAwO1xuICAgIGNvbnN0IHN0ZXAgPSAoMiAqIE1hdGguUEkpIC8gbnVtYmVyT2ZTaWRlcztcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbnVtYmVyT2ZTaWRlczsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGN1clN0ZXAgPSBpICogc3RlcCArIHNoaWZ0O1xuICAgICAgICBjdHgubGluZVRvKHggKyBzICogTWF0aC5jb3MoY3VyU3RlcCksIHkgKyBzICogTWF0aC5zaW4oY3VyU3RlcCkpO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgZmlsbFN0eWxlKGN0eCwgZmlsbENvbG9yKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xufVxuLy8gaHR0cHM6Ly9wcm9ncmFtbWluZ3Rob21hcy53b3JkcHJlc3MuY29tLzIwMTIvMDUvMTYvZHJhd2luZy1zdGFycy13aXRoLWh0bWw1LWNhbnZhcy9cbmZ1bmN0aW9uIHN0YXIoY3R4LCBtb2RlbCkge1xuICAgIGNvbnN0IHsgeCwgeSwgYm9yZGVyQ29sb3IsIGJvcmRlcldpZHRoLCBzaXplLCBmaWxsQ29sb3IgfSA9IG1vZGVsO1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICBjdHguZmlsbFN0eWxlID0gZmlsbENvbG9yO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgY3R4Lm1vdmVUbygwLCAtc2l6ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpICs9IDEpIHtcbiAgICAgICAgY3R4LnJvdGF0ZShNYXRoLlBJIC8gNSk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgLXNpemUgLyAyKTtcbiAgICAgICAgY3R4LnJvdGF0ZShNYXRoLlBJIC8gNSk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgLXNpemUpO1xuICAgIH1cbiAgICBjdHguZmlsbCgpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbn1cbmZ1bmN0aW9uIGNyb3NzKGN0eCwgbW9kZWwpIHtcbiAgICBjb25zdCB7IHgsIHksIGJvcmRlckNvbG9yLCBib3JkZXJXaWR0aCwgc2l6ZSwgZmlsbENvbG9yIH0gPSBtb2RlbDtcbiAgICBjb25zdCBxdWFydGVyID0gc2l6ZSAvIDQ7XG4gICAgY29uc3QgaGFsZiA9IHNpemUgLyAyO1xuICAgIGNvbnN0IHhQb2ludHNPZmZzZXQgPSBbXG4gICAgICAgIC1oYWxmLFxuICAgICAgICAtaGFsZixcbiAgICAgICAgLXF1YXJ0ZXIsXG4gICAgICAgIC1xdWFydGVyLFxuICAgICAgICBxdWFydGVyLFxuICAgICAgICBxdWFydGVyLFxuICAgICAgICBoYWxmLFxuICAgICAgICBoYWxmLFxuICAgICAgICBxdWFydGVyLFxuICAgICAgICBxdWFydGVyLFxuICAgICAgICAtcXVhcnRlcixcbiAgICAgICAgLXF1YXJ0ZXIsXG4gICAgXTtcbiAgICBjb25zdCB5UG9pbnRzT2Zmc2V0ID0gW107XG4gICAgZm9yIChsZXQgaWR4ID0gMCwgbGVuID0geFBvaW50c09mZnNldC5sZW5ndGg7IGlkeCA8IGxlbjsgaWR4ICs9IDEpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRJZHggPSA5O1xuICAgICAgICB5UG9pbnRzT2Zmc2V0LnB1c2goeFBvaW50c09mZnNldFsoc3RhcnRJZHggKyBpZHgpICUgbGVuXSk7XG4gICAgfVxuICAgIHBvbHlnb24oY3R4LCB7XG4gICAgICAgIHR5cGU6ICdwb2x5Z29uJyxcbiAgICAgICAgbGluZVdpZHRoOiBib3JkZXJXaWR0aCxcbiAgICAgICAgY29sb3I6IGJvcmRlckNvbG9yLFxuICAgICAgICBwb2ludHM6IHhQb2ludHNPZmZzZXQubWFwKCh2YWwsIGlkeCkgPT4gKHsgeDogeCArIHZhbCwgeTogeSArIHlQb2ludHNPZmZzZXRbaWR4XSB9KSksXG4gICAgICAgIGZpbGxDb2xvcixcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldE51bWJlck9mU2lkZXNCeUljb25UeXBlKGljb25UeXBlKSB7XG4gICAgc3dpdGNoIChpY29uVHlwZSkge1xuICAgICAgICBjYXNlICd0cmlhbmdsZSc6XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgY2FzZSAnZGlhbW9uZCc6XG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgY2FzZSAncGVudGFnb24nOlxuICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgIGNhc2UgJ2hleGFnb24nOlxuICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHNjYXR0ZXJTZXJpZXMoY3R4LCBtb2RlbCkge1xuICAgIGNvbnN0IHsgeCwgeSwgYm9yZGVyQ29sb3IsIGJvcmRlcldpZHRoLCBmaWxsQ29sb3IsIGljb25UeXBlLCBzaXplIH0gPSBtb2RlbDtcbiAgICBjb25zdCBjb21tb25Nb2RlbCA9IHsgeCwgeSwgZmlsbENvbG9yLCBib3JkZXJDb2xvciwgYm9yZGVyV2lkdGgsIHNpemUgfTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgc3dpdGNoIChpY29uVHlwZSkge1xuICAgICAgICBjYXNlICdyZWN0JzpcbiAgICAgICAgICAgIHBhdGhSZWN0KGN0eCwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdwYXRoUmVjdCcsXG4gICAgICAgICAgICAgICAgeDogeCAtIHNpemUgLyAyLFxuICAgICAgICAgICAgICAgIHk6IHkgLSBzaXplIC8gMixcbiAgICAgICAgICAgICAgICB3aWR0aDogc2l6ZSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNpemUsXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IGJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgIGZpbGw6IGZpbGxDb2xvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RyaWFuZ2xlJzpcbiAgICAgICAgY2FzZSAncGVudGFnb24nOlxuICAgICAgICBjYXNlICdkaWFtb25kJzpcbiAgICAgICAgY2FzZSAnaGV4YWdvbic6XG4gICAgICAgICAgICByZWd1bGFyUG9seWdvbihjdHgsIE9iamVjdC5hc3NpZ24oeyB0eXBlOiAncmVndWxhclBvbHlnb24nLCBudW1iZXJPZlNpZGVzOiBnZXROdW1iZXJPZlNpZGVzQnlJY29uVHlwZShpY29uVHlwZSkgfSwgY29tbW9uTW9kZWwpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdGFyJzpcbiAgICAgICAgICAgIHN0YXIoY3R4LCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB0eXBlOiAnc3RhcicgfSwgY29tbW9uTW9kZWwpLCB7IHNpemU6IHNpemUgLyAyIH0pKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjcm9zcyc6XG4gICAgICAgICAgICBjcm9zcyhjdHgsIE9iamVjdC5hc3NpZ24oeyB0eXBlOiAnY3Jvc3MnIH0sIGNvbW1vbk1vZGVsKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNpcmNsZShjdHgsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY2lyY2xlJyxcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgcmFkaXVzOiBzaXplIC8gMixcbiAgICAgICAgICAgICAgICBzdHlsZTogW3sgc3Ryb2tlU3R5bGU6IGJvcmRlckNvbG9yLCBsaW5lV2lkdGg6IGJvcmRlcldpZHRoIH1dLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBmaWxsQ29sb3IsXG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbn1cbiIsImltcG9ydCB7IG1ha2VTdHlsZU9iaiwgZmlsbFN0eWxlIH0gZnJvbSBcIi4uL2hlbHBlcnMvc3R5bGVcIjtcbmltcG9ydCB7IGNhbGN1bGF0ZURlZ3JlZVRvUmFkaWFuLCBnZXRSYWRpYWxQb3NpdGlvbiwgREVHUkVFXzM2MCB9IGZyb20gXCIuLi9oZWxwZXJzL3NlY3RvclwiO1xuZXhwb3J0IGZ1bmN0aW9uIHNlY3RvcihjdHgsIHNlY3Rvck1vZGVsKSB7XG4gICAgY29uc3QgeyBkZWdyZWU6IHsgc3RhcnQsIGVuZCB9LCBjb2xvciwgc3R5bGUsIGxpbmVXaWR0aCwgfSA9IHNlY3Rvck1vZGVsO1xuICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNDaXJjbGUgPSBNYXRoLmFicyhzdGFydCAtIGVuZCkgPT09IERFR1JFRV8zNjA7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgICBjb25zdCBzdHlsZU9iaiA9IG1ha2VTdHlsZU9iaihzdHlsZSwge30pO1xuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZU9iaikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjdHhba2V5XSA9IHN0eWxlT2JqW2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNDaXJjbGUpIHtcbiAgICAgICAgZHJhd0NpcmNsZShjdHgsIHNlY3Rvck1vZGVsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRyYXdTZWN0b3IoY3R4LCBzZWN0b3JNb2RlbCk7XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBmaWxsU3R5bGUoY3R4LCBjb2xvcik7XG4gICAgaWYgKGxpbmVXaWR0aCkge1xuICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZHJhd1NlY3RvcihjdHgsIHNlY3Rvck1vZGVsKSB7XG4gICAgY29uc3QgeyB4LCB5LCByYWRpdXM6IHsgaW5uZXIsIG91dGVyIH0sIGRlZ3JlZTogeyBzdGFydCwgZW5kIH0sIGNsb2Nrd2lzZSwgZHJhd2luZ1N0YXJ0QW5nbGUsIH0gPSBzZWN0b3JNb2RlbDtcbiAgICBpZiAoaW5uZXIgPCAwIHx8IG91dGVyIDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0UmFkaWFuID0gY2FsY3VsYXRlRGVncmVlVG9SYWRpYW4oc3RhcnQsIGRyYXdpbmdTdGFydEFuZ2xlKTtcbiAgICBjb25zdCBlbmRSYWRpYW4gPSBjYWxjdWxhdGVEZWdyZWVUb1JhZGlhbihlbmQsIGRyYXdpbmdTdGFydEFuZ2xlKTtcbiAgICBpZiAoIWlubmVyKSB7XG4gICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgfVxuICAgIGN0eC5hcmMoeCwgeSwgb3V0ZXIsIHN0YXJ0UmFkaWFuLCBlbmRSYWRpYW4sICFjbG9ja3dpc2UpO1xuICAgIGlmIChpbm5lcikge1xuICAgICAgICBjdHguYXJjKHgsIHksIGlubmVyLCBlbmRSYWRpYW4sIHN0YXJ0UmFkaWFuLCBjbG9ja3dpc2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRyYXdDaXJjbGUoY3R4LCBzZWN0b3JNb2RlbCkge1xuICAgIGNvbnN0IHsgeCwgeSwgcmFkaXVzOiB7IGlubmVyLCBvdXRlciB9LCBjbG9ja3dpc2UsIH0gPSBzZWN0b3JNb2RlbDtcbiAgICBjdHguYXJjKHgsIHksIG91dGVyLCAwLCAyICogTWF0aC5QSSwgIWNsb2Nrd2lzZSk7XG4gICAgaWYgKGlubmVyKSB7XG4gICAgICAgIGNvbnN0IHsgeDogaW5uZXJTdGFydFBvc1gsIHk6IGlubmVyU3RhcnRQb3NZIH0gPSBnZXRSYWRpYWxQb3NpdGlvbih4LCB5LCBpbm5lciwgMCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0WCA9IGlubmVyID8gaW5uZXJTdGFydFBvc1ggOiB4O1xuICAgICAgICBjb25zdCBzdGFydFkgPSBpbm5lciA/IGlubmVyU3RhcnRQb3NZIDogeTtcbiAgICAgICAgY3R4Lm1vdmVUbyhzdGFydFgsIHN0YXJ0WSk7XG4gICAgICAgIGN0eC5hcmMoeCwgeSwgaW5uZXIsIDAsIDIgKiBNYXRoLlBJLCBjbG9ja3dpc2UpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IHBhZGRpbmcgfSBmcm9tIFwiLi4vc3RvcmUvbGF5b3V0XCI7XG5pbXBvcnQgeyBnZXRUZXh0V2lkdGgsIGdldE1heExlbmd0aExhYmVsV2lkdGggfSBmcm9tIFwiLi4vaGVscGVycy9jYWxjdWxhdG9yXCI7XG5pbXBvcnQgeyBsYWJlbCwgYnViYmxlTGFiZWwgfSBmcm9tIFwiLi9sYWJlbFwiO1xuaW1wb3J0IHsgZ2V0QnViYmxlQXJyb3dQb2ludHMgfSBmcm9tIFwiLi9kYXRhTGFiZWxcIjtcbmV4cG9ydCBjb25zdCBTUEVDVFJVTV9MRUdFTkRfTEFCRUxfSEVJR0hUID0gMTI7XG5leHBvcnQgY29uc3Qgc3BlY3RydW1MZWdlbmRCYXIgPSB7XG4gICAgSEVJR0hUOiA2LFxuICAgIFBBRERJTkc6IDUsXG59O1xuZXhwb3J0IGNvbnN0IHNwZWN0cnVtTGVnZW5kVG9vbHRpcCA9IHtcbiAgICBIRUlHSFQ6IDI4LFxuICAgIFBPSU5UX1dJRFRIOiA4LFxuICAgIFBPSU5UX0hFSUdIVDogNixcbiAgICBQQURESU5HOiA2LFxufTtcbmZ1bmN0aW9uIGdldEJhclN0YXJ0UG9pbnQobW9kZWwpIHtcbiAgICBjb25zdCB7IGFsaWduLCB4OiBtb2RlbFgsIHk6IG1vZGVsWSwgbGFiZWxzLCB3aWR0aCB9ID0gbW9kZWw7XG4gICAgY29uc3QgeyBQQURESU5HIH0gPSBzcGVjdHJ1bUxlZ2VuZEJhcjtcbiAgICBsZXQgeCwgeTtcbiAgICBpZiAoYWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgIHggPSBtb2RlbFg7XG4gICAgICAgIHkgPSBtb2RlbFkgKyBTUEVDVFJVTV9MRUdFTkRfTEFCRUxfSEVJR0hUICsgUEFERElORztcbiAgICB9XG4gICAgZWxzZSBpZiAoYWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICAgIHggPSBtb2RlbFg7XG4gICAgICAgIHkgPSBtb2RlbFkgKyBzcGVjdHJ1bUxlZ2VuZFRvb2x0aXAuSEVJR0hUO1xuICAgIH1cbiAgICBlbHNlIGlmIChhbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHggPSBtb2RlbFggKyBnZXRNYXhMZW5ndGhMYWJlbFdpZHRoKGxhYmVscykgKyBQQURESU5HO1xuICAgICAgICB5ID0gbW9kZWxZICsgU1BFQ1RSVU1fTEVHRU5EX0xBQkVMX0hFSUdIVCAvIDI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB4ID1cbiAgICAgICAgICAgIG1vZGVsWCArXG4gICAgICAgICAgICAgICAgd2lkdGggLVxuICAgICAgICAgICAgICAgIChnZXRNYXhMZW5ndGhMYWJlbFdpZHRoKGxhYmVscykgKyBwYWRkaW5nLlggKyBQQURESU5HICogMiArIHNwZWN0cnVtTGVnZW5kQmFyLkhFSUdIVCk7XG4gICAgICAgIHkgPSBtb2RlbFkgKyBTUEVDVFJVTV9MRUdFTkRfTEFCRUxfSEVJR0hUIC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIHsgeCwgeSB9O1xufVxuZnVuY3Rpb24gZ2V0TGFiZWxzU3RhcnRQb2ludChtb2RlbCkge1xuICAgIGNvbnN0IHsgYWxpZ24sIHg6IG1vZGVsWCwgeTogbW9kZWxZLCBsYWJlbHMsIHdpZHRoIH0gPSBtb2RlbDtcbiAgICBsZXQgeCwgeTtcbiAgICBpZiAoYWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgIHggPSBtb2RlbFg7XG4gICAgICAgIHkgPSBtb2RlbFk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgICB4ID0gbW9kZWxYO1xuICAgICAgICB5ID1cbiAgICAgICAgICAgIG1vZGVsWSArIHNwZWN0cnVtTGVnZW5kVG9vbHRpcC5IRUlHSFQgKyBzcGVjdHJ1bUxlZ2VuZEJhci5IRUlHSFQgKyBzcGVjdHJ1bUxlZ2VuZEJhci5QQURESU5HO1xuICAgIH1cbiAgICBlbHNlIGlmIChhbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHggPSBtb2RlbFggKyBnZXRNYXhMZW5ndGhMYWJlbFdpZHRoKGxhYmVscyk7XG4gICAgICAgIHkgPSBtb2RlbFk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB4ID0gbW9kZWxYICsgd2lkdGggLSBnZXRNYXhMZW5ndGhMYWJlbFdpZHRoKGxhYmVscykgLSBwYWRkaW5nLlg7XG4gICAgICAgIHkgPSBtb2RlbFk7XG4gICAgfVxuICAgIHJldHVybiB7IHgsIHkgfTtcbn1cbmZ1bmN0aW9uIGdldEJhclNpemUod2lkdGgsIGhlaWdodCwgdmVydGljYWxBbGlnbikge1xuICAgIGNvbnN0IHsgSEVJR0hUIH0gPSBzcGVjdHJ1bUxlZ2VuZEJhcjtcbiAgICBjb25zdCBiYXJXaWR0aCA9IHZlcnRpY2FsQWxpZ24gPyB3aWR0aCA6IEhFSUdIVDtcbiAgICBjb25zdCBiYXJIZWlnaHQgPSB2ZXJ0aWNhbEFsaWduID8gSEVJR0hUIDogaGVpZ2h0IC0gU1BFQ1RSVU1fTEVHRU5EX0xBQkVMX0hFSUdIVDtcbiAgICByZXR1cm4geyBiYXJXaWR0aCwgYmFySGVpZ2h0IH07XG59XG5mdW5jdGlvbiBkcmF3TGFiZWxzKGN0eCwgbW9kZWwpIHtcbiAgICBjb25zdCB7IGxhYmVscywgYWxpZ24sIHgsIHksIHdpZHRoLCBoZWlnaHQsIHZlcnRpY2FsQWxpZ24gfSA9IG1vZGVsO1xuICAgIGNvbnN0IHsgYmFyV2lkdGgsIGJhckhlaWdodCB9ID0gZ2V0QmFyU2l6ZSh3aWR0aCwgaGVpZ2h0LCB2ZXJ0aWNhbEFsaWduKTtcbiAgICBjb25zdCBsYWJlbFNpemUgPSBsYWJlbHMubGVuZ3RoIC0gMTtcbiAgICBjb25zdCB0ZXh0QmFzZVN0eWxlTWFwID0ge1xuICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgICB0ZXh0QWxpZ246ICdyaWdodCcsXG4gICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnLFxuICAgICAgICB9LFxuICAgICAgICByaWdodDoge1xuICAgICAgICAgICAgdGV4dEFsaWduOiAnbGVmdCcsXG4gICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnLFxuICAgICAgICB9LFxuICAgICAgICB0b3A6IHtcbiAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnLFxuICAgICAgICB9LFxuICAgICAgICBib3R0b206IHtcbiAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgbGFiZWxzLmZvckVhY2goKHRleHQsIGlkeCkgPT4ge1xuICAgICAgICBjb25zdCBzdGFydFggPSB2ZXJ0aWNhbEFsaWduID8geCArIChiYXJXaWR0aCAvIGxhYmVsU2l6ZSkgKiBpZHggOiB4O1xuICAgICAgICBjb25zdCBzdGFydFkgPSB2ZXJ0aWNhbEFsaWduID8geSA6IHkgKyAoYmFySGVpZ2h0IC8gbGFiZWxTaXplKSAqIGlkeDtcbiAgICAgICAgbGFiZWwoY3R4LCB7XG4gICAgICAgICAgICB0eXBlOiAnbGFiZWwnLFxuICAgICAgICAgICAgeDogc3RhcnRYLFxuICAgICAgICAgICAgeTogc3RhcnRZLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIHN0eWxlOiBbJ2RlZmF1bHQnLCB0ZXh0QmFzZVN0eWxlTWFwW2FsaWduXV0sXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZHJhd0JhcihjdHgsIG1vZGVsKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBzdGFydENvbG9yLCBlbmRDb2xvciwgeCwgeSwgdmVydGljYWxBbGlnbiB9ID0gbW9kZWw7XG4gICAgY29uc3QgeyBiYXJXaWR0aCwgYmFySGVpZ2h0IH0gPSBnZXRCYXJTaXplKHdpZHRoLCBoZWlnaHQsIHZlcnRpY2FsQWxpZ24pO1xuICAgIGNvbnN0IGdyYWRpZW50ID0gdmVydGljYWxBbGlnblxuICAgICAgICA/IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4LCB5LCB4ICsgYmFyV2lkdGgsIHkpXG4gICAgICAgIDogY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHgsIHkgKyBiYXJIZWlnaHQpO1xuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBzdGFydENvbG9yKTtcbiAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgZW5kQ29sb3IpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICBjdHguZmlsbFJlY3QoeCwgeSwgYmFyV2lkdGgsIGJhckhlaWdodCk7XG59XG5mdW5jdGlvbiBnZXRUb29sdGlwQXJyb3dQb2ludChtb2RlbCkge1xuICAgIGNvbnN0IHsgYWxpZ24sIGNvbG9yUmF0aW8sIHdpZHRoLCBoZWlnaHQsIHgsIHksIGxhYmVscywgdmVydGljYWxBbGlnbiB9ID0gbW9kZWw7XG4gICAgY29uc3QgeyBiYXJXaWR0aCwgYmFySGVpZ2h0IH0gPSBnZXRCYXJTaXplKHdpZHRoLCBoZWlnaHQsIHZlcnRpY2FsQWxpZ24pO1xuICAgIGNvbnN0IHsgUEFERElORywgSEVJR0hUIH0gPSBzcGVjdHJ1bUxlZ2VuZEJhcjtcbiAgICBpZiAoYWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4ICsgYmFyV2lkdGggKiBjb2xvclJhdGlvLFxuICAgICAgICAgICAgeTogeSArIFNQRUNUUlVNX0xFR0VORF9MQUJFTF9IRUlHSFQgKyBIRUlHSFQgKyBQQURESU5HICogMixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCArIGJhcldpZHRoICogY29sb3JSYXRpbyxcbiAgICAgICAgICAgIHk6IHkgKyBTUEVDVFJVTV9MRUdFTkRfTEFCRUxfSEVJR0hUICsgUEFERElORyAqIDIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChhbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4ICsgZ2V0TWF4TGVuZ3RoTGFiZWxXaWR0aChsYWJlbHMpICsgSEVJR0hUICsgUEFERElORyAqIDIsXG4gICAgICAgICAgICB5OiB5ICsgYmFySGVpZ2h0ICogY29sb3JSYXRpbyArIFBBRERJTkcsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCArIHdpZHRoIC0gKGdldE1heExlbmd0aExhYmVsV2lkdGgobGFiZWxzKSArIHBhZGRpbmcuWCArIFBBRERJTkcgKiAzICsgSEVJR0hUKSxcbiAgICAgICAgICAgIHk6IHkgKyBiYXJIZWlnaHQgKiBjb2xvclJhdGlvICsgUEFERElORyxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc3BlY3RydW1MZWdlbmQoY3R4LCBtb2RlbCkge1xuICAgIGNvbnN0IGxhYmVsc1N0YXJ0UG9pbnQgPSBnZXRMYWJlbHNTdGFydFBvaW50KG1vZGVsKTtcbiAgICBjb25zdCBiYXJTdGFydFBvaW50ID0gZ2V0QmFyU3RhcnRQb2ludChtb2RlbCk7XG4gICAgZHJhd0xhYmVscyhjdHgsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbW9kZWwpLCBsYWJlbHNTdGFydFBvaW50KSk7XG4gICAgZHJhd0JhcihjdHgsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbW9kZWwpLCBiYXJTdGFydFBvaW50KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3BlY3RydW1Ub29sdGlwKGN0eCwgbW9kZWwpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldFRvb2x0aXBBcnJvd1BvaW50KG1vZGVsKTtcbiAgICBjb25zdCB7IFBBRERJTkcsIFBPSU5UX0hFSUdIVCwgUE9JTlRfV0lEVEggfSA9IHNwZWN0cnVtTGVnZW5kVG9vbHRpcDtcbiAgICBjb25zdCB7IGFsaWduLCB0ZXh0LCBjb2xvciB9ID0gbW9kZWw7XG4gICAgY29uc3QgbGFiZWxXaWR0aCA9IGdldFRleHRXaWR0aCh0ZXh0KTtcbiAgICBjb25zdCB3aWR0aCA9IGxhYmVsV2lkdGggKyBQQURESU5HICogMjtcbiAgICBjb25zdCBoZWlnaHQgPSBTUEVDVFJVTV9MRUdFTkRfTEFCRUxfSEVJR0hUICsgUEFERElORyAqIDI7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gYWxpZ247XG4gICAgbGV0IGJveFN0YXJ0WCA9IHg7XG4gICAgbGV0IGJveFN0YXJ0WSA9IHk7XG4gICAgaWYgKGFsaWduID09PSAndG9wJykge1xuICAgICAgICBib3hTdGFydFkgKz0gUE9JTlRfSEVJR0hUO1xuICAgIH1cbiAgICBlbHNlIGlmIChhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBib3hTdGFydFggLT0gd2lkdGggLyAyICsgUE9JTlRfSEVJR0hUO1xuICAgICAgICBib3hTdGFydFkgLT0gaGVpZ2h0IC8gMjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICBib3hTdGFydFggKz0gd2lkdGggLyAyICsgUE9JTlRfSEVJR0hUO1xuICAgICAgICBib3hTdGFydFkgLT0gaGVpZ2h0IC8gMjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICAgIGJveFN0YXJ0WSAtPSBoZWlnaHQgKyBQT0lOVF9IRUlHSFQ7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50cyA9IGdldEJ1YmJsZUFycm93UG9pbnRzKGFsaWduLCB7IHgsIHkgfSwgeyB2aXNpYmxlOiB0cnVlLCB3aWR0aDogUE9JTlRfV0lEVEgsIGhlaWdodDogUE9JTlRfSEVJR0hUIH0pO1xuICAgIGJ1YmJsZUxhYmVsKGN0eCwge1xuICAgICAgICB0eXBlOiAnYnViYmxlTGFiZWwnLFxuICAgICAgICBidWJibGU6IHtcbiAgICAgICAgICAgIHg6IGJveFN0YXJ0WCAtIHdpZHRoIC8gMixcbiAgICAgICAgICAgIHk6IGJveFN0YXJ0WSxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICAgICAgZmlsbDogY29sb3IsXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgeDogYm94U3RhcnRYLFxuICAgICAgICAgICAgeTogYm94U3RhcnRZICsgaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIHN0eWxlOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmb250OiAnbm9ybWFsIDExcHggQXJpYWwnLFxuICAgICAgICAgICAgICAgICAgICBmaWxsU3R5bGU6ICcjMzMzMzMzJyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbiIsImltcG9ydCBDaGFydCBmcm9tIFwiLi9jaGFydFwiO1xuaW1wb3J0IGRhdGFSYW5nZSBmcm9tIFwiLi4vc3RvcmUvZGF0YVJhbmdlXCI7XG5pbXBvcnQgc2NhbGUgZnJvbSBcIi4uL3N0b3JlL3NjYWxlXCI7XG5pbXBvcnQgYXhlcyBmcm9tIFwiLi4vc3RvcmUvYXhlc1wiO1xuaW1wb3J0IHBsb3QgZnJvbSBcIi4uL3N0b3JlL3Bsb3RcIjtcbmltcG9ydCBzdGFja1Nlcmllc0RhdGEgZnJvbSBcIi4uL3N0b3JlL3N0YWNrU2VyaWVzRGF0YVwiO1xuaW1wb3J0IEhvdmVyZWRTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9ob3ZlcmVkU2VyaWVzXCI7XG5pbXBvcnQgVG9vbHRpcCBmcm9tIFwiLi4vY29tcG9uZW50L3Rvb2x0aXBcIjtcbmltcG9ydCBQbG90IGZyb20gXCIuLi9jb21wb25lbnQvcGxvdFwiO1xuaW1wb3J0IEFyZWFTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9hcmVhU2VyaWVzXCI7XG5pbXBvcnQgQXhpcyBmcm9tIFwiLi4vY29tcG9uZW50L2F4aXNcIjtcbmltcG9ydCBEYXRhTGFiZWxzIGZyb20gXCIuLi9jb21wb25lbnQvZGF0YUxhYmVsc1wiO1xuaW1wb3J0IFRpdGxlIGZyb20gXCIuLi9jb21wb25lbnQvdGl0bGVcIjtcbmltcG9ydCBBeGlzVGl0bGUgZnJvbSBcIi4uL2NvbXBvbmVudC9heGlzVGl0bGVcIjtcbmltcG9ydCBFeHBvcnRNZW51IGZyb20gXCIuLi9jb21wb25lbnQvZXhwb3J0TWVudVwiO1xuaW1wb3J0IFJlc2V0QnV0dG9uIGZyb20gXCIuLi9jb21wb25lbnQvcmVzZXRCdXR0b25cIjtcbmltcG9ydCBMZWdlbmQgZnJvbSBcIi4uL2NvbXBvbmVudC9sZWdlbmRcIjtcbmltcG9ydCBSYW5nZVNlbGVjdGlvbiBmcm9tIFwiLi4vY29tcG9uZW50L3JhbmdlU2VsZWN0aW9uXCI7XG5pbXBvcnQgU2VsZWN0ZWRTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9zZWxlY3RlZFNlcmllc1wiO1xuaW1wb3J0IEJhY2tncm91bmQgZnJvbSBcIi4uL2NvbXBvbmVudC9iYWNrZ3JvdW5kXCI7XG5pbXBvcnQgTm9EYXRhVGV4dCBmcm9tIFwiLi4vY29tcG9uZW50L25vRGF0YVRleHRcIjtcbmltcG9ydCAqIGFzIGxpbmVTZXJpZXNCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9saW5lU2VyaWVzXCI7XG5pbXBvcnQgKiBhcyBiYXNpY0JydXNoIGZyb20gXCIuLi9icnVzaGVzL2Jhc2ljXCI7XG5pbXBvcnQgKiBhcyBheGlzQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvYXhpc1wiO1xuaW1wb3J0ICogYXMgbGVnZW5kQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvbGVnZW5kXCI7XG5pbXBvcnQgKiBhcyBsYWJlbEJydXNoIGZyb20gXCIuLi9icnVzaGVzL2xhYmVsXCI7XG5pbXBvcnQgKiBhcyBleHBvcnRNZW51QnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvZXhwb3J0TWVudVwiO1xuaW1wb3J0ICogYXMgZGF0YUxhYmVsQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvZGF0YUxhYmVsXCI7XG5pbXBvcnQgKiBhcyByZXNldEJ1dHRvbkJydXNoIGZyb20gXCIuLi9icnVzaGVzL3Jlc2V0QnV0dG9uXCI7XG4vKipcbiAqIEBjbGFzc1xuICogQGNsYXNzZGVzYyBBcmVhIENoYXJ0XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gcHJvcHMuZWwgLSBUaGUgdGFyZ2V0IGVsZW1lbnQgdG8gY3JlYXRlIGNoYXJ0LlxuICogICBAcGFyYW0ge09iamVjdH0gcHJvcHMuZGF0YSAtIERhdGEgZm9yIG1ha2luZyBBcmVhIENoYXJ0LlxuICogICAgIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gcHJvcHMuZGF0YS5jYXRlZ29yaWVzIC0gQ2F0ZWdvcmllcy5cbiAqICAgICBAcGFyYW0ge0FycmF5PE9iamVjdD59IHByb3BzLmRhdGEuc2VyaWVzIC0gU2VyaWVzIGRhdGEuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gcHJvcHMuZGF0YS5zZXJpZXMubmFtZSAtIFNlcmllcyBuYW1lLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxudW1iZXJ8QXJyYXk8bnVtYmVyPj59IHByb3BzLmRhdGEuc2VyaWVzLmRhdGEgLSBTZXJpZXMgZGF0YS5cbiAqICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zXSAtIE9wdGlvbnMgZm9yIG1ha2luZyBBcmVhIENoYXJ0LlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaGFydF1cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGVdIC0gQ2hhcnQgdGl0bGUgdGV4dCBvciBvcHRpb25zLlxuICogICAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUudGV4dF0gLSBDaGFydCB0aXRsZSB0ZXh0LlxuICogICAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUub2Zmc2V0WF0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSBob3Jpem9udGFsbHkuXG4gKiAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS5vZmZzZXRZXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIHZlcnRpY2FsbHkuXG4gKiAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS5hbGlnbl0gLSBDaGFydCB0ZXh0IGFsaWduLiAnbGVmdCcsICdyaWdodCcsICdjZW50ZXInIGlzIGF2YWlsYWJsZS5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbl0gLSBXaGV0aGVyIHRvIHVzZSBhbmltYXRpb24gYW5kIGR1cmF0aW9uIHdoZW4gcmVuZGVyaW5nIHRoZSBpbml0aWFsIGNoYXJ0LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC53aWR0aF0gLSBDaGFydCB3aWR0aC4gJ2F1dG8nIG9yIGlmIG5vdCB3cml0ZSwgdGhlIHdpZHRoIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLiAnYXV0bycgb3IgaWYgbm90IGNyZWF0ZWQsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQuaGVpZ2h0XSAtIENoYXJ0IGhlaWdodC4gJ2F1dG8nIG9yIGlmIG5vdCB3cml0ZSwgdGhlIHdpZHRoIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLiAnYXV0bycgb3IgaWYgbm90IGNyZWF0ZWQsIHRoZSBoZWlnaHQgb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnNlcmllc11cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLnNlbGVjdGFibGU9ZmFsc2VdIC0gV2hldGhlciB0byBtYWtlIHNlbGVjdGFibGUgc2VyaWVzIG9yIG5vdC5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLnNob3dEb3Q9ZmFsc2VdIC0gV2hldGhlciB0byBzaG93IGRvdCBvciBub3QuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5zcGxpbmU9ZmFsc2VdIC0gV2hldGhlciB0byBtYWtlIHNwbGluZSBjaGFydCBvciBub3QuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy56b29tYWJsZT1mYWxzZV0gLSBXaGV0aGVyIHRvIHVzZSB6b29tIGZlYXR1cmUgb3Igbm90LlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5zZXJpZXMucmFuZ2VTZWxlY3RhYmxlPWZhbHNlXSAtIFdoZXRoZXIgdG8gdXNlIHJhbmdlIHNlbGVjdGlvbiBmZWF0dXJlIG9yIG5vdC5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5zZXJpZXMuZXZlbnREZXRlY3RUeXBlXSAtIEV2ZW50IGRldGVjdCB0eXBlLiAnbmVhcicsICduZWFyZXN0JywgJ2dyb3VwZWQnLCAncG9pbnQnIGlzIGF2YWlsYWJsZS5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLnNoaWZ0PWZhbHNlXSAtIFdoZXRoZXIgdG8gdXNlIHNoaWZ0IHdoZW4gYWRkRGF0YSBvciBub3QuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLmRhdGFMYWJlbHNdIC0gU2V0IHRoZSB2aXNpYmlsaXR5LCBsb2NhdGlvbiwgYW5kIGZvcm1hdHRpbmcgb2YgZGF0YUxhYmVsLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8RGF0YUxhYmVscyBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufE9iamVjdH0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLnN0YWNrXSAtIE9wdGlvbiB0byBkZWNpZGUgd2hldGhlciB0byB1c2Ugc3RhY2sgY2hhcnQgYW5kIHR5cGUgb2Ygc3RhY2sgY2hhcnQuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxBcmVhIENoYXJ0IGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzXVxuICogICAgICAgQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy50aXRsZV0gLSBBeGlzIHRpdGxlLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy54QXhpcy5wb2ludE9uQ29sdW1uPWZhbHNlXSAtIFdoZXRoZXIgdG8gbW92ZSB0aGUgc3RhcnQgb2YgdGhlIGNoYXJ0IHRvIHRoZSBjZW50ZXIgb2YgdGhlIGNvbHVtbi5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMueEF4aXMucm90YXRlTGFiZWw9dHJ1ZV0gLSBXaGV0aGVyIHRvIGFsbG93IGF4aXMgbGFiZWwgcm90YXRpb24uXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy5kYXRlXSAtIFdoZXRoZXIgdGhlIHggYXhpcyBsYWJlbCBpcyBvZiBkYXRlIHR5cGUuIEZvcm1hdCBvcHRpb24gdXNlZCBmb3IgZGF0ZSB0eXBlLiBXaGV0aGVyIHRoZSB4IGF4aXMgbGFiZWwgaXMgb2YgZGF0ZSB0eXBlLiBJZiB1c2UgZGF0ZSB0eXBlLCBmb3JtYXQgb3B0aW9uIHVzZWQgZm9yIGRhdGUgdHlwZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy50aWNrXSAtIE9wdGlvbiB0byBhZGp1c3QgdGljayBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy5sYWJlbF0gLSBPcHRpb24gdG8gYWRqdXN0IGxhYmVsIGludGVydmFsLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLnNjYWxlXSAtIE9wdGlvbiB0byBhZGp1c3QgYXhpcyBtaW5pbXVtLCBtYXhpbXVtLCBzdGVwIHNpemUuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMueEF4aXMud2lkdGhdIC0gV2lkdGggb2YgeEF4aXMuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMueEF4aXMuaGVpZ2h0XSAtIEhlaWdodCBvZiB4QXhpcy5cbiAqICAgICBAcGFyYW0ge09iamVjdHxBcnJheTxPYmplY3Q+fSBbcHJvcHMub3B0aW9ucy55QXhpc10gLSBJZiB0aGlzIG9wdGlvbiBpcyBhbiBhcnJheSB0eXBlLCB1c2UgdGhlIHNlY29uZGFyeSB5IGF4aXMuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLnlBeGlzLnRpdGxlXSAtIEF4aXMgdGl0bGUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueUF4aXMudGlja10gLSBPcHRpb24gdG8gYWRqdXN0IHRpY2sgaW50ZXJ2YWwuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueUF4aXMubGFiZWxdIC0gT3B0aW9uIHRvIGFkanVzdCBsYWJlbCBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpcy5zY2FsZV0gLSBPcHRpb24gdG8gYWRqdXN0IGF4aXMgbWluaW11bSwgbWF4aW11bSwgc3RlcCBzaXplLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnlBeGlzLndpZHRoXSAtIFdpZHRoIG9mIHlBeGlzLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnlBeGlzLmhlaWdodF0gLSBIZWlnaHQgb2YgeUF4aXMuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnBsb3RdXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMucGxvdC53aWR0aF0gLSBXaWR0aCBvZiBwbG90LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnBsb3QuaGVpZ2h0XSAtIEhlaWdodCBvZiBwbG90LlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5wbG90LnZpc2libGVdIC0gV2hldGhlciB0byBzaG93IHBsb3QgbGluZS5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gW3Byb3BzLm9wdGlvbnMucGxvdC5saW5lc10gLSBQbG90IGxpbmVzIGluZm9ybWF0aW9uLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8UGxvdCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBbcHJvcHMub3B0aW9ucy5wbG90LmJhbmRzXSAtIFBsb3QgYmFuZHMgaW5mb3JtYXRpb24uIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxQbG90IGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZF1cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5sZWdlbmQuYWxpZ25dIC0gTGVnZW5kIGFsaWduLiAndG9wJywgJ2JvdHRvbScsICdyaWdodCcsICdsZWZ0JyBpcyBhdmFpbGFibGUuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMubGVnZW5kLnNob3dDaGVja2JveF0gLSBXaGV0aGVyIHRvIHNob3cgY2hlY2tib3guXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC52aXNpYmxlXSAtIFdoZXRoZXIgdG8gc2hvdyBsZWdlbmQuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMubGVnZW5kLndpZHRoXSAtIFdpZHRoIG9mIGxlZ2VuZC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sZWdlbmQuaXRlbV0gLSBgd2lkdGhgIGFuZCBgb3ZlcmZsb3dgIG9wdGlvbnMgb2YgdGhlIGxlZ2VuZCBpdGVtLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8TGVnZW5kIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnVdXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnUudmlzaWJsZV0gLSBXaGV0aGVyIHRvIHNob3cgZXhwb3J0IG1lbnUuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuZXhwb3J0TWVudS5maWxlbmFtZV0gLSBGaWxlIG5hbWUgYXBwbGllZCB3aGVuIGRvd25sb2FkaW5nLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50b29sdGlwXVxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAub2Zmc2V0WF0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSBob3Jpem9udGFsbHkuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC5vZmZzZXRZXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIHZlcnRpY2FsbHkuXG4gKiAgICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcHMub3B0aW9ucy50b29sdGlwLmZvcm1hdHRlcl0gLSBGdW5jdGlvbiB0byBmb3JtYXQgZGF0YSB2YWx1ZS5cbiAqICAgICAgIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAudGVtcGxhdGVdIC0gRnVuY3Rpb24gdG8gY3JlYXRlIGN1c3RvbSB0ZW1wbGF0ZS4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFRvb2x0aXAgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZV0gLSBSdWxlcyBmb3IgY2hhbmdpbmcgY2hhcnQgb3B0aW9ucy4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFJlc3BvbnNpdmUgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLnJlc3BvbnNpdmUuYW5pbWF0aW9uXSAtIEFuaW1hdGlvbiBkdXJhdGlvbiB3aGVuIHRoZSBjaGFydCBpcyBtb2RpZmllZC5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZS5ydWxlc10gLSBSdWxlcyBmb3IgdGhlIENoYXJ0IHRvIFJlc3BvbmQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxhbmddIC0gT3B0aW9ucyBmb3IgY2hhbmdpbmcgdGhlIHRleHQgZGlzcGxheWVkIG9uIHRoZSBjaGFydCBvciBpMThuIGxhbmd1YWdlcy5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sYW5nLm5vRGF0YV0gLSBObyBEYXRhIExheWVyIFRleHQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lXSAtIENoYXJ0IHRoZW1lIG9wdGlvbnMuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxBcmVhIENoYXJ0IGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUuY2hhcnRdIC0gQ2hhcnQgZm9udCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5ub0RhdGFdIC0gTm8gRGF0YSBMYXllciBUZXh0IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnNlcmllc10gLSBTZXJpZXMgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUudGl0bGVdIC0gVGl0bGUgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUueEF4aXNdIC0gWCBBeGlzIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R8QXJyYXk8T2JqZWN0Pn0gW3Byb3BzLm9wdGlvbnMudGhlbWUueUF4aXNdIC0gWSBBeGlzIHRoZW1lLiBJbiB0aGUgY2FzZSBvZiBhbiBhcnJhbmdlbWVudCwgdGhlIGZpcnN0IGlzIHRoZSBtYWluIGF4aXMgYW5kIHRoZSBzZWNvbmQgaXMgdGhlIHRoZW1lIGZvciB0aGUgc2Vjb25kYXJ5IGF4aXMuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUubGVnZW5kXSAtIExlZ2VuZCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS50b29sdGlwXSAtIFRvb2x0aXAgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUucGxvdF0gLSBQbG90IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmV4cG9ydE1lbnVdIC0gRXhwb3J0TWVudSB0aGVtZS5cbiAqIEBleHRlbmRzIENoYXJ0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFyZWFDaGFydCBleHRlbmRzIENoYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBlbDogcHJvcHMuZWwsXG4gICAgICAgICAgICBvcHRpb25zOiBwcm9wcy5vcHRpb25zLFxuICAgICAgICAgICAgc2VyaWVzOiB7XG4gICAgICAgICAgICAgICAgYXJlYTogcHJvcHMuZGF0YS5zZXJpZXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2F0ZWdvcmllczogcHJvcHMuZGF0YS5jYXRlZ29yaWVzLFxuICAgICAgICAgICAgbW9kdWxlczogW3N0YWNrU2VyaWVzRGF0YSwgZGF0YVJhbmdlLCBzY2FsZSwgYXhlcywgcGxvdF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQmFja2dyb3VuZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoVGl0bGUpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFBsb3QpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKExlZ2VuZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXJlYVNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpcywgeyBuYW1lOiAneEF4aXMnIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEF4aXMsIHsgbmFtZTogJ3lBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzLCB7IG5hbWU6ICdzZWNvbmRhcnlZQXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoRGF0YUxhYmVscyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpc1RpdGxlLCB7IG5hbWU6ICd4QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpc1RpdGxlLCB7IG5hbWU6ICd5QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpc1RpdGxlLCB7IG5hbWU6ICdzZWNvbmRhcnlZQXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoRXhwb3J0TWVudSwgeyBjaGFydEVsOiB0aGlzLmVsIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEhvdmVyZWRTZXJpZXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFNlbGVjdGVkU2VyaWVzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChUb29sdGlwLCB7IGNoYXJ0RWw6IHRoaXMuZWwgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoUmVzZXRCdXR0b24pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFJhbmdlU2VsZWN0aW9uKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChOb0RhdGFUZXh0KTtcbiAgICAgICAgdGhpcy5wYWludGVyLmFkZEdyb3VwcyhbXG4gICAgICAgICAgICBiYXNpY0JydXNoLFxuICAgICAgICAgICAgYXhpc0JydXNoLFxuICAgICAgICAgICAgbGluZVNlcmllc0JydXNoLFxuICAgICAgICAgICAgbGVnZW5kQnJ1c2gsXG4gICAgICAgICAgICBsYWJlbEJydXNoLFxuICAgICAgICAgICAgZXhwb3J0TWVudUJydXNoLFxuICAgICAgICAgICAgZGF0YUxhYmVsQnJ1c2gsXG4gICAgICAgICAgICByZXNldEJ1dHRvbkJydXNoLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSAtIEFycmF5IG9mIGRhdGEgdG8gYmUgYWRkZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhdGVnb3J5IC0gQ2F0ZWdvcnkgdG8gYmUgYWRkZWQuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuYWRkRGF0YShbMTAsIDIwXSwgJzYnKTtcbiAgICAgKi9cbiAgICBhZGREYXRhKGRhdGEsIGNhdGVnb3J5KSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25Db250cm9sRmxhZy51cGRhdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2FkZERhdGEnLCB7IGRhdGEsIGNhdGVnb3J5IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSBkYXRhLm5hbWUgLSBTZXJpZXMgbmFtZS5cbiAgICAgKiAgIEBwYXJhbSB7QXJyYXk8bnVtYmVyfEFycmF5PG51bWJlcj4+fSBkYXRhLmRhdGEgLSBBcnJheSBvZiBkYXRhIHRvIGJlIGFkZGVkLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmFkZFNlcmllcyh7XG4gICAgICogICBuYW1lOiAnbmV3U2VyaWVzJyxcbiAgICAgKiAgIGRhdGE6IFsxMCwgMTAwLCA1MCwgNDAsIDcwLCA1NSwgMzMsIDcwLCA5MCwgMTEwXSxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBhZGRTZXJpZXMoZGF0YSkge1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2FkZFNlcmllcycsIHsgZGF0YSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgY2hhcnQgZGF0YSB0byBuZXcgZGF0YS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIERhdGEgdG8gYmUgc2V0XG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2V0RGF0YSh7XG4gICAgICogICBjYXRlZ29yaWVzOiBbJzEnLCAnMicsICczJ10sXG4gICAgICogICBzZXJpZXM6IFtcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgIG5hbWU6ICduZXcgc2VyaWVzJyxcbiAgICAgKiAgICAgICBkYXRhOiBbMSwgMiwgM10sXG4gICAgICogICAgIH0sXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICBuYW1lOiAnbmV3IHNlcmllczInLFxuICAgICAqICAgICAgIGRhdGE6IFs0LCA1LCA2XSxcbiAgICAgKiAgICAgfVxuICAgICAqICAgXVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHNldERhdGEoZGF0YSkge1xuICAgICAgICBjb25zdCB7IGNhdGVnb3JpZXMsIHNlcmllcyB9ID0gZGF0YTtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdzZXREYXRhJywgeyBzZXJpZXM6IHsgYXJlYTogc2VyaWVzIH0sIGNhdGVnb3JpZXMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBwbG90IGxpbmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBQbG90IGluZm8uXG4gICAgICogICBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRhdGEudmFsdWUgLSBUaGUgdmFsdWUgd2hlcmUgdGhlIHBsb3QgbGluZSB3aWxsIGJlIGRyYXduLlxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9IGRhdGEuY29sb3IgLSBQbG90IGxpbmUgY29sb3IuXG4gICAgICogICBAcGFyYW0ge3N0cmluZ30gW2RhdGEuaWRdIC0gUGxvdCBpZC4gVGhlIHZhbHVlIG9uIHdoaWNoIHRoZSByZW1vdmVQbG90TGluZSBpcyBiYXNlZC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5hZGRQbG90TGluZSh7XG4gICAgICogICB2YWx1ZTogMixcbiAgICAgKiAgIGNvbG9yOiAnIzAwZmYyMicsXG4gICAgICogICBpZDogJ3Bsb3QtMScsXG4gICAgICogfSk7XG4gICAgICovXG4gICAgYWRkUGxvdExpbmUoZGF0YSkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdhZGRQbG90TGluZScsIHsgZGF0YSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHBsb3QgbGluZSB3aXRoIGlkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIElkIG9mIHRoZSBwbG90IGxpbmUgdG8gYmUgcmVtb3ZlZC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5yZW1vdmVQbG90TGluZSgncGxvdC0xJyk7XG4gICAgICovXG4gICAgcmVtb3ZlUGxvdExpbmUoaWQpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgncmVtb3ZlUGxvdExpbmUnLCB7IGlkIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgcGxvdCBiYW5kLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gUGxvdCBpbmZvLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfG51bWJlcj59IGRhdGEucmFuZ2UgLSBUaGUgcmFuZ2UgdG8gYmUgZHJhd24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGEuY29sb3IgLSBQbG90IGJhbmQgY29sb3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtkYXRhLmlkXSAtIFBsb3QgaWQuIFRoZSB2YWx1ZSBvbiB3aGljaCB0aGUgcmVtb3ZlUGxvdEJhbmQgaXMgYmFzZWQuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuYWRkUGxvdEJhbmQoe1xuICAgICAqICAgdmFsdWU6IFsyLCA0XSxcbiAgICAgKiAgIGNvbG9yOiAnIzAwZmYyMicsXG4gICAgICogICBpZDogJ3Bsb3QtMScsXG4gICAgICogfSk7XG4gICAgICovXG4gICAgYWRkUGxvdEJhbmQoZGF0YSkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdhZGRQbG90QmFuZCcsIHsgZGF0YSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHBsb3QgYmFuZCB3aXRoIGlkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIGlkIG9mIHRoZSBwbG90IGJhbmQgdG8gYmUgcmVtb3ZlZC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5yZW1vdmVQbG90QmFuZCgncGxvdC0xJyk7XG4gICAgICovXG4gICAgcmVtb3ZlUGxvdEJhbmQoaWQpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgncmVtb3ZlUGxvdEJhbmQnLCB7IGlkIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlIHNlcmllcyBkYXRhIGxhYmVsLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmhpZGVTZXJpZXNEYXRhTGFiZWwoKTtcbiAgICAgKi9cbiAgICBoaWRlU2VyaWVzRGF0YUxhYmVsKCkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCd1cGRhdGVPcHRpb25zJywge1xuICAgICAgICAgICAgb3B0aW9uczogeyBzZXJpZXM6IHsgZGF0YUxhYmVsczogeyB2aXNpYmxlOiBmYWxzZSB9IH0gfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgc2VyaWVzIGRhdGEgbGFiZWwuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2hvd1Nlcmllc0RhdGFMYWJlbCgpO1xuICAgICAqL1xuICAgIHNob3dTZXJpZXNEYXRhTGFiZWwoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3VwZGF0ZU9wdGlvbnMnLCB7XG4gICAgICAgICAgICBvcHRpb25zOiB7IHNlcmllczogeyBkYXRhTGFiZWxzOiB7IHZpc2libGU6IHRydWUgfSB9IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBjaGFydCBvcHRpb25zIHRvIG5ldyBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ2hhcnQgb3B0aW9ucy5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zZXRPcHRpb25zKHtcbiAgICAgKiAgIGNoYXJ0OiB7XG4gICAgICogICAgIHdpZHRoOiA1MDAsXG4gICAgICogICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAqICAgICB0aXRsZTogJ0VuZXJneSBVc2FnZScsXG4gICAgICogICB9LFxuICAgICAqICAgeEF4aXM6IHtcbiAgICAgKiAgICAgdGl0bGU6ICdNb250aCcsXG4gICAgICogICAgIGRhdGU6IHsgZm9ybWF0OiAneXkvTU0nIH0sXG4gICAgICogICB9LFxuICAgICAqICAgeUF4aXM6IHtcbiAgICAgKiAgICAgdGl0bGU6ICdFbmVyZ3kgKGtXaCknLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHNlcmllczoge1xuICAgICAqICAgICBzZWxlY3RhYmxlOiB0cnVlLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHRvb2x0aXA6IHtcbiAgICAgKiAgICAgZm9ybWF0dGVyOiAodmFsdWUpID0+IGAke3ZhbHVlfWtXaGAsXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hPcHRpb25zRXZlbnQoJ2luaXRPcHRpb25zJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBjaGFydCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ2hhcnQgb3B0aW9ucy5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC51cGRhdGVPcHRpb25zKHtcbiAgICAgKiAgIGNoYXJ0OiB7XG4gICAgICogICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAqICAgICB0aXRsZTogJ0VuZXJneSBVc2FnZScsXG4gICAgICogICB9LFxuICAgICAqICAgdG9vbHRpcDoge1xuICAgICAqICAgICBmb3JtYXR0ZXI6ICh2YWx1ZSkgPT4gYCR7dmFsdWV9a1doYCxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICovXG4gICAgdXBkYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE9wdGlvbnNFdmVudCgndXBkYXRlT3B0aW9ucycsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlcmllc0luZm8gLSBJbmZvcm1hdGlvbiBvZiB0aGUgc2VyaWVzIGZvciB0aGUgdG9vbHRpcCB0byBiZSBkaXNwbGF5ZWQuXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gc2VyaWVzSW5mby5pbmRleCAtIEluZGV4IG9mIGRhdGEgd2l0aGluIHNlcmllcy4gSWYgJ3Nlcmllcy5ldmVudERldGVjdFR5cGUnIGlzIFwiZ3JvdXBlZFwiLCBvbmx5IHNlcmllc0luZGV4IGlzIG5lZWRlZC5cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBbc2VyaWVzSW5mby5zZXJpZXNJbmRleF0gLSBJbmRleCBvZiBzZXJpZXMuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2hvd1Rvb2x0aXAoe2luZGV4OiAxLCBzZXJpZXNJbmRleDogMn0pO1xuICAgICAqL1xuICAgIHNob3dUb29sdGlwKHNlcmllc0luZm8pIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzaG93VG9vbHRpcCcsIE9iamVjdC5hc3NpZ24oe30sIHNlcmllc0luZm8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZSB0b29sdGlwLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmhpZGVUb29sdGlwKCk7XG4gICAgICovXG4gICAgaGlkZVRvb2x0aXAoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnaGlkZVRvb2x0aXAnKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ2hhcnQgZnJvbSBcIi4vY2hhcnRcIjtcbmltcG9ydCBkYXRhUmFuZ2UgZnJvbSBcIi4uL3N0b3JlL2RhdGFSYW5nZVwiO1xuaW1wb3J0IHN0YWNrU2VyaWVzRGF0YSBmcm9tIFwiLi4vc3RvcmUvc3RhY2tTZXJpZXNEYXRhXCI7XG5pbXBvcnQgc2NhbGUgZnJvbSBcIi4uL3N0b3JlL3NjYWxlXCI7XG5pbXBvcnQgYXhlcyBmcm9tIFwiLi4vc3RvcmUvYXhlc1wiO1xuaW1wb3J0IHBsb3QgZnJvbSBcIi4uL3N0b3JlL3Bsb3RcIjtcbmltcG9ydCBBeGlzIGZyb20gXCIuLi9jb21wb25lbnQvYXhpc1wiO1xuaW1wb3J0IEJveFNlcmllcyBmcm9tIFwiLi4vY29tcG9uZW50L2JveFNlcmllc1wiO1xuaW1wb3J0IEJveFN0YWNrU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvYm94U3RhY2tTZXJpZXNcIjtcbmltcG9ydCBQbG90IGZyb20gXCIuLi9jb21wb25lbnQvcGxvdFwiO1xuaW1wb3J0IFRvb2x0aXAgZnJvbSBcIi4uL2NvbXBvbmVudC90b29sdGlwXCI7XG5pbXBvcnQgTGVnZW5kIGZyb20gXCIuLi9jb21wb25lbnQvbGVnZW5kXCI7XG5pbXBvcnQgRGF0YUxhYmVscyBmcm9tIFwiLi4vY29tcG9uZW50L2RhdGFMYWJlbHNcIjtcbmltcG9ydCBBeGlzVGl0bGUgZnJvbSBcIi4uL2NvbXBvbmVudC9heGlzVGl0bGVcIjtcbmltcG9ydCBUaXRsZSBmcm9tIFwiLi4vY29tcG9uZW50L3RpdGxlXCI7XG5pbXBvcnQgRXhwb3J0TWVudSBmcm9tIFwiLi4vY29tcG9uZW50L2V4cG9ydE1lbnVcIjtcbmltcG9ydCBaZXJvQXhpcyBmcm9tIFwiLi4vY29tcG9uZW50L3plcm9BeGlzXCI7XG5pbXBvcnQgQXhpc1VzaW5nQ2VudGVyWSBmcm9tIFwiLi4vY29tcG9uZW50L2F4aXNVc2luZ0NlbnRlcllcIjtcbmltcG9ydCBIb3ZlcmVkU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvaG92ZXJlZFNlcmllc1wiO1xuaW1wb3J0IFNlbGVjdGVkU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvc2VsZWN0ZWRTZXJpZXNcIjtcbmltcG9ydCBCYWNrZ3JvdW5kIGZyb20gXCIuLi9jb21wb25lbnQvYmFja2dyb3VuZFwiO1xuaW1wb3J0IE5vRGF0YVRleHQgZnJvbSBcIi4uL2NvbXBvbmVudC9ub0RhdGFUZXh0XCI7XG5pbXBvcnQgKiBhcyBiYXNpY0JydXNoIGZyb20gXCIuLi9icnVzaGVzL2Jhc2ljXCI7XG5pbXBvcnQgKiBhcyBheGlzQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvYXhpc1wiO1xuaW1wb3J0ICogYXMgbGVnZW5kQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvbGVnZW5kXCI7XG5pbXBvcnQgKiBhcyBsYWJlbEJydXNoIGZyb20gXCIuLi9icnVzaGVzL2xhYmVsXCI7XG5pbXBvcnQgKiBhcyBkYXRhTGFiZWxCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9kYXRhTGFiZWxcIjtcbmltcG9ydCAqIGFzIGV4cG9ydE1lbnVCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9leHBvcnRNZW51XCI7XG4vKipcbiAqIEBjbGFzc1xuICogQGNsYXNzZGVzYyBCYXIgQ2hhcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogICBAcGFyYW0ge0hUTUxFbGVtZW50fSBwcm9wcy5lbCAtIFRoZSB0YXJnZXQgZWxlbWVudCB0byBjcmVhdGUgY2hhcnQuXG4gKiAgIEBwYXJhbSB7T2JqZWN0fSBwcm9wcy5kYXRhIC0gRGF0YSBmb3IgbWFraW5nIEJhciBDaGFydC5cbiAqICAgICBAcGFyYW0ge0FycmF5PHN0cmluZz59IHByb3BzLmRhdGEuY2F0ZWdvcmllcyAtIENhdGVnb3JpZXMuXG4gKiAgICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwcm9wcy5kYXRhLnNlcmllcyAtIFNlcmllcyBkYXRhLlxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IHByb3BzLmRhdGEuc2VyaWVzLm5hbWUgLSBTZXJpZXMgbmFtZS5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy5kYXRhLnNlcmllcy5jb2xvckJ5Q2F0ZWdvcmllcyAtIFBhaW50IFJlY3Qgd2l0aCBjb2xvciBiYXNlZCBvbiBjYXRlZ29yaWVzLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxudW1iZXJ8QXJyYXk8bnVtYmVyPj59IHByb3BzLmRhdGEuc2VyaWVzLmRhdGEgLSBTZXJpZXMgZGF0YS5cbiAqICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zXSAtIE9wdGlvbnMgZm9yIG1ha2luZyBCYXIgQ2hhcnQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNoYXJ0XVxuICogICAgICAgQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZV0gLSBDaGFydCB0aXRsZSB0ZXh0IG9yIG9wdGlvbnMuXG4gKiAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS50ZXh0XSAtIENoYXJ0IHRpdGxlIHRleHQuXG4gKiAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS5vZmZzZXRYXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIGhvcml6b250YWxseS5cbiAqICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLm9mZnNldFldIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgdmVydGljYWxseS5cbiAqICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLmFsaWduXSAtIENoYXJ0IHRleHQgYWxpZ24uICdsZWZ0JywgJ3JpZ2h0JywgJ2NlbnRlcicgaXMgYXZhaWxhYmxlLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufE9iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2hhcnQuYW5pbWF0aW9uXSAtIFdoZXRoZXIgdG8gdXNlIGFuaW1hdGlvbiBhbmQgZHVyYXRpb24gd2hlbiByZW5kZXJpbmcgdGhlIGluaXRpYWwgY2hhcnQuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LndpZHRoXSAtIENoYXJ0IHdpZHRoLiAnYXV0bycgb3IgaWYgbm90IHdyaXRlLCB0aGUgd2lkdGggb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuICdhdXRvJyBvciBpZiBub3QgY3JlYXRlZCwgdGhlIHdpZHRoIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC5oZWlnaHRdIC0gQ2hhcnQgaGVpZ2h0LiAnYXV0bycgb3IgaWYgbm90IHdyaXRlLCB0aGUgd2lkdGggb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuICdhdXRvJyBvciBpZiBub3QgY3JlYXRlZCwgdGhlIGhlaWdodCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzXVxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5zZXJpZXMuc2VsZWN0YWJsZT1mYWxzZV0gLSBXaGV0aGVyIHRvIG1ha2Ugc2VsZWN0YWJsZSBzZXJpZXMgb3Igbm90LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnNlcmllcy5iYXJXaWR0aF0gLSBCYXIgd2lkdGguXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5kaXZlcmdpbmddIC0gV2hldGhlciB0byB1c2UgZGl2ZXJnaW5nIGNoYXJ0IG9yIG5vdC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5zZXJpZXMuc3RhY2tdIC0gT3B0aW9uIHRvIHVzZSB0aGUgc3RhY2sgY2hhcnQgb3IsIGlmIHNvLCB3aGF0IHR5cGUgb2Ygc3RhY2sgdG8gdXNlLlxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLnNlcmllcy5ldmVudERldGVjdFR5cGVdIC0gRXZlbnQgZGV0ZWN0IHR5cGUuICdncm91cGVkJywgJ3BvaW50JyBpcyBhdmFpbGFibGUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLmRhdGFMYWJlbHNdIC0gU2V0IHRoZSB2aXNpYmlsaXR5LCBsb2NhdGlvbiwgYW5kIGZvcm1hdHRpbmcgb2YgZGF0YUxhYmVsLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8RGF0YUxhYmVscyBndWlkZX0gb24gZ2l0aHViLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpc11cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXMudGl0bGVdIC0gQXhpcyB0aXRsZS5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMueEF4aXMucm90YXRlTGFiZWw9dHJ1ZV0gLSBXaGV0aGVyIHRvIGFsbG93IGF4aXMgbGFiZWwgcm90YXRpb24uXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy5kYXRlXSAtIFdoZXRoZXIgdGhlIHggYXhpcyBsYWJlbCBpcyBvZiBkYXRlIHR5cGUuIEZvcm1hdCBvcHRpb24gdXNlZCBmb3IgZGF0ZSB0eXBlLiBXaGV0aGVyIHRoZSB4IGF4aXMgbGFiZWwgaXMgb2YgZGF0ZSB0eXBlLiBJZiB1c2UgZGF0ZSB0eXBlLCBmb3JtYXQgb3B0aW9uIHVzZWQgZm9yIGRhdGUgdHlwZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy50aWNrXSAtIE9wdGlvbiB0byBhZGp1c3QgdGljayBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy5sYWJlbF0gLSBPcHRpb24gdG8gYWRqdXN0IGxhYmVsIGludGVydmFsLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLnNjYWxlXSAtIE9wdGlvbiB0byBhZGp1c3QgYXhpcyBtaW5pbXVtLCBtYXhpbXVtLCBzdGVwIHNpemUuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMueEF4aXMud2lkdGhdIC0gV2lkdGggb2YgeEF4aXMuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMueEF4aXMuaGVpZ2h0XSAtIEhlaWdodCBvZiB4QXhpcy5cbiAqICAgICBAcGFyYW0ge09iamVjdHxBcnJheTxPYmplY3Q+fSBbcHJvcHMub3B0aW9ucy55QXhpc10gLSBJZiB0aGlzIG9wdGlvbiBpcyBhbiBhcnJheSB0eXBlLCB1c2UgdGhlIHNlY29uZGFyeSB5IGF4aXMuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLnlBeGlzLnRpdGxlXSAtIEF4aXMgdGl0bGUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueUF4aXMudGlja10gLSBPcHRpb24gdG8gYWRqdXN0IHRpY2sgaW50ZXJ2YWwuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueUF4aXMubGFiZWxdIC0gT3B0aW9uIHRvIGFkanVzdCBsYWJlbCBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpcy5zY2FsZV0gLSBPcHRpb24gdG8gYWRqdXN0IGF4aXMgbWluaW11bSwgbWF4aW11bSwgc3RlcCBzaXplLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnlBeGlzLndpZHRoXSAtIFdpZHRoIG9mIHlBeGlzLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnlBeGlzLmhlaWdodF0gLSBIZWlnaHQgb2YgeUF4aXMuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnBsb3RdXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMucGxvdC53aWR0aF0gLSBXaWR0aCBvZiBwbG90LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnBsb3QuaGVpZ2h0XSAtIEhlaWdodCBvZiBwbG90LlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5wbG90LnZpc2libGVdIC0gV2hldGhlciB0byBzaG93IHBsb3QgbGluZS5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGVnZW5kXVxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC5hbGlnbl0gLSBMZWdlbmQgYWxpZ24uICd0b3AnLCAnYm90dG9tJywgJ3JpZ2h0JywgJ2xlZnQnIGlzIGF2YWlsYWJsZS5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5sZWdlbmQuc2hvd0NoZWNrYm94XSAtIFdoZXRoZXIgdG8gc2hvdyBjaGVja2JveC5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMubGVnZW5kLnZpc2libGVdIC0gV2hldGhlciB0byBzaG93IGxlZ2VuZC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5sZWdlbmQud2lkdGhdIC0gV2lkdGggb2YgbGVnZW5kLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC5pdGVtXSAtIGB3aWR0aGAgYW5kIGBvdmVyZmxvd2Agb3B0aW9ucyBvZiB0aGUgbGVnZW5kIGl0ZW0uIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxMZWdlbmQgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuZXhwb3J0TWVudV1cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuZXhwb3J0TWVudS52aXNpYmxlXSAtIFdoZXRoZXIgdG8gc2hvdyBleHBvcnQgbWVudS5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5leHBvcnRNZW51LmZpbGVuYW1lXSAtIEZpbGUgbmFtZSBhcHBsaWVkIHdoZW4gZG93bmxvYWRpbmcuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRvb2x0aXBdXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC5vZmZzZXRYXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIGhvcml6b250YWxseS5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy50b29sdGlwLm9mZnNldFldIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgdmVydGljYWxseS5cbiAqICAgICAgIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAuZm9ybWF0dGVyXSAtIEZ1bmN0aW9uIHRvIGZvcm1hdCBkYXRhIHZhbHVlLlxuICogICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC50ZW1wbGF0ZV0gLSBGdW5jdGlvbiB0byBjcmVhdGUgY3VzdG9tIHRlbXBsYXRlLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8VG9vbHRpcCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5yZXNwb25zaXZlXSAtIFJ1bGVzIGZvciBjaGFuZ2luZyBjaGFydCBvcHRpb25zLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8UmVzcG9uc2l2ZSBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufE9iamVjdH0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZS5hbmltYXRpb25dIC0gQW5pbWF0aW9uIGR1cmF0aW9uIHdoZW4gdGhlIGNoYXJ0IGlzIG1vZGlmaWVkLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBbcHJvcHMub3B0aW9ucy5yZXNwb25zaXZlLnJ1bGVzXSAtIFJ1bGVzIGZvciB0aGUgQ2hhcnQgdG8gUmVzcG9uZC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGFuZ10gLSBPcHRpb25zIGZvciBjaGFuZ2luZyB0aGUgdGV4dCBkaXNwbGF5ZWQgb24gdGhlIGNoYXJ0IG9yIGkxOG4gbGFuZ3VhZ2VzLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxhbmcubm9EYXRhXSAtIE5vIERhdGEgTGF5ZXIgVGV4dC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWVdIC0gQ2hhcnQgdGhlbWUgb3B0aW9ucy4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fEJhciBDaGFydCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmNoYXJ0XSAtIENoYXJ0IGZvbnQgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUubm9EYXRhXSAtIE5vIERhdGEgTGF5ZXIgVGV4dCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5zZXJpZXNdIC0gU2VyaWVzIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnRpdGxlXSAtIFRpdGxlIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnhBeGlzXSAtIFggQXhpcyB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fEFycmF5PE9iamVjdD59IFtwcm9wcy5vcHRpb25zLnRoZW1lLnlBeGlzXSAtIFkgQXhpcyB0aGVtZS4gSW4gdGhlIGNhc2Ugb2YgYW4gYXJyYW5nZW1lbnQsIHRoZSBmaXJzdCBpcyB0aGUgbWFpbiBheGlzIGFuZCB0aGUgc2Vjb25kIGlzIHRoZSB0aGVtZSBmb3IgdGhlIHNlY29uZGFyeSBheGlzLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmxlZ2VuZF0gLSBMZWdlbmQgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUudG9vbHRpcF0gLSBUb29sdGlwIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnBsb3RdIC0gUGxvdCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5leHBvcnRNZW51XSAtIEV4cG9ydE1lbnUgdGhlbWUuXG4gKiBAZXh0ZW5kcyBDaGFydFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXJDaGFydCBleHRlbmRzIENoYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcih7IGVsLCBvcHRpb25zLCBkYXRhIH0pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgc2VyaWVzOiB7XG4gICAgICAgICAgICAgICAgYmFyOiBkYXRhLnNlcmllcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYXRlZ29yaWVzOiBkYXRhLmNhdGVnb3JpZXMsXG4gICAgICAgICAgICBtb2R1bGVzOiBbc3RhY2tTZXJpZXNEYXRhLCBkYXRhUmFuZ2UsIHNjYWxlLCBheGVzLCBwbG90XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICAgICAgICBjb25zdCBzdGFja0NoYXJ0ID0gISEoKF9hID0gdGhpcy5zdG9yZS5pbml0U3RvcmVTdGF0ZS5vcHRpb25zLnNlcmllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YWNrKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChCYWNrZ3JvdW5kKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChUaXRsZSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoUGxvdCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoTGVnZW5kKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChCb3hTZXJpZXMsIHsgbmFtZTogJ2JhcicsIHN0YWNrQ2hhcnQgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQm94U3RhY2tTZXJpZXMsIHsgbmFtZTogJ2JhcicsIHN0YWNrQ2hhcnQgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoWmVyb0F4aXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEF4aXMsIHsgbmFtZTogJ3lBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzLCB7IG5hbWU6ICd4QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpcywgeyBuYW1lOiAnc2Vjb25kYXJ5WUF4aXMnIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEF4aXNVc2luZ0NlbnRlclksIHsgbmFtZTogJ3lBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzVXNpbmdDZW50ZXJZLCB7IG5hbWU6ICd4QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpc1RpdGxlLCB7IG5hbWU6ICdzZWNvbmRhcnlZQXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpc1RpdGxlLCB7IG5hbWU6ICd4QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpc1RpdGxlLCB7IG5hbWU6ICd5QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoRXhwb3J0TWVudSwgeyBjaGFydEVsOiB0aGlzLmVsIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEhvdmVyZWRTZXJpZXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFNlbGVjdGVkU2VyaWVzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChEYXRhTGFiZWxzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChUb29sdGlwLCB7IGNoYXJ0RWw6IHRoaXMuZWwgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoTm9EYXRhVGV4dCk7XG4gICAgICAgIHRoaXMucGFpbnRlci5hZGRHcm91cHMoW1xuICAgICAgICAgICAgYmFzaWNCcnVzaCxcbiAgICAgICAgICAgIGF4aXNCcnVzaCxcbiAgICAgICAgICAgIGxlZ2VuZEJydXNoLFxuICAgICAgICAgICAgbGFiZWxCcnVzaCxcbiAgICAgICAgICAgIGV4cG9ydE1lbnVCcnVzaCxcbiAgICAgICAgICAgIGRhdGFMYWJlbEJydXNoLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSAtIEFycmF5IG9mIGRhdGEgdG8gYmUgYWRkZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhdGVnb3J5IC0gQ2F0ZWdvcnkgdG8gYmUgYWRkZWQuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuYWRkRGF0YShbMTAsIDIwXSwgJzYnKTtcbiAgICAgKi9cbiAgICBhZGREYXRhKGRhdGEsIGNhdGVnb3J5KSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQ29udHJvbEZsYWcudXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2FkZERhdGEnLCB7IGRhdGEsIGNhdGVnb3J5IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSBkYXRhLm5hbWUgLSBTZXJpZXMgbmFtZS5cbiAgICAgKiAgIEBwYXJhbSB7QXJyYXk8bnVtYmVyfEFycmF5PG51bWJlcj4+fSBkYXRhLmRhdGEgLSBBcnJheSBvZiBkYXRhIHRvIGJlIGFkZGVkLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmFkZFNlcmllcyh7XG4gICAgICogICBuYW1lOiAnbmV3U2VyaWVzJyxcbiAgICAgKiAgIGRhdGE6IFsxMCwgMTAwLCA1MCwgNDAsIDcwLCA1NSwgMzMsIDcwLCA5MCwgMTEwXSxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBhZGRTZXJpZXMoZGF0YSkge1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2FkZFNlcmllcycsIHsgZGF0YSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgY2hhcnQgZGF0YSB0byBuZXcgZGF0YS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIERhdGEgdG8gYmUgc2V0LlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNldERhdGEoe1xuICAgICAqICAgY2F0ZWdvcmllczogWycxJywgJzInLCAnMyddLFxuICAgICAqICAgc2VyaWVzOiBbXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICBuYW1lOiAnbmV3IHNlcmllcycsXG4gICAgICogICAgICAgZGF0YTogWzEsIDIsIDNdLFxuICAgICAqICAgICB9LFxuICAgICAqICAgICB7XG4gICAgICogICAgICAgbmFtZTogJ25ldyBzZXJpZXMyJyxcbiAgICAgKiAgICAgICBkYXRhOiBbNCwgNSwgNl0sXG4gICAgICogICAgIH1cbiAgICAgKiAgIF1cbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXREYXRhKGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBjYXRlZ29yaWVzLCBzZXJpZXMgfSA9IGRhdGE7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgnc2V0RGF0YScsIHsgc2VyaWVzOiB7IGJhcjogc2VyaWVzIH0sIGNhdGVnb3JpZXMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGUgc2VyaWVzIGRhdGEgbGFiZWwuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuaGlkZVNlcmllc0RhdGFMYWJlbCgpO1xuICAgICAqL1xuICAgIGhpZGVTZXJpZXNEYXRhTGFiZWwoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3VwZGF0ZU9wdGlvbnMnLCB7XG4gICAgICAgICAgICBvcHRpb25zOiB7IHNlcmllczogeyBkYXRhTGFiZWxzOiB7IHZpc2libGU6IGZhbHNlIH0gfSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyBzZXJpZXMgZGF0YSBsYWJlbC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zaG93U2VyaWVzRGF0YUxhYmVsKCk7XG4gICAgICovXG4gICAgc2hvd1Nlcmllc0RhdGFMYWJlbCgpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgndXBkYXRlT3B0aW9ucycsIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHsgc2VyaWVzOiB7IGRhdGFMYWJlbHM6IHsgdmlzaWJsZTogdHJ1ZSB9IH0gfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGNoYXJ0IG9wdGlvbnMgdG8gbmV3IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDaGFydCBvcHRpb25zLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNldE9wdGlvbnMoe1xuICAgICAqICAgY2hhcnQ6IHtcbiAgICAgKiAgICAgd2lkdGg6IDUwMCxcbiAgICAgKiAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICogICAgIHRpdGxlOiAnRW5lcmd5IFVzYWdlJyxcbiAgICAgKiAgIH0sXG4gICAgICogICB4QXhpczoge1xuICAgICAqICAgICB0aXRsZTogJ01vbnRoJyxcbiAgICAgKiAgICAgZGF0ZTogeyBmb3JtYXQ6ICd5eS9NTScgfSxcbiAgICAgKiAgIH0sXG4gICAgICogICB5QXhpczoge1xuICAgICAqICAgICB0aXRsZTogJ0VuZXJneSAoa1doKScsXG4gICAgICogICB9LFxuICAgICAqICAgc2VyaWVzOiB7XG4gICAgICogICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICogICB9LFxuICAgICAqICAgdG9vbHRpcDoge1xuICAgICAqICAgICBmb3JtYXR0ZXI6ICh2YWx1ZSkgPT4gYCR7dmFsdWV9a1doYCxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICovXG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE9wdGlvbnNFdmVudCgnaW5pdE9wdGlvbnMnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNoYXJ0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDaGFydCBvcHRpb25zLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnVwZGF0ZU9wdGlvbnMoe1xuICAgICAqICAgY2hhcnQ6IHtcbiAgICAgKiAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICogICAgIHRpdGxlOiAnRW5lcmd5IFVzYWdlJyxcbiAgICAgKiAgIH0sXG4gICAgICogICB0b29sdGlwOiB7XG4gICAgICogICAgIGZvcm1hdHRlcjogKHZhbHVlKSA9PiBgJHt2YWx1ZX1rV2hgLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB1cGRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoT3B0aW9uc0V2ZW50KCd1cGRhdGVPcHRpb25zJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VyaWVzSW5mbyAtIEluZm9ybWF0aW9uIG9mIHRoZSBzZXJpZXMgZm9yIHRoZSB0b29sdGlwIHRvIGJlIGRpc3BsYXllZC5cbiAgICAgKiAgIEBwYXJhbSB7bnVtYmVyfSBzZXJpZXNJbmZvLmluZGV4IC0gSW5kZXggb2YgZGF0YSB3aXRoaW4gc2VyaWVzLiBJZiAnc2VyaWVzLmV2ZW50RGV0ZWN0VHlwZScgaXMgXCJncm91cGVkXCIsIG9ubHkgc2VyaWVzSW5kZXggaXMgbmVlZGVkLlxuICAgICAqICAgQHBhcmFtIHtudW1iZXJ9IFtzZXJpZXNJbmZvLnNlcmllc0luZGV4XSAtIEluZGV4IG9mIHNlcmllc1xuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNob3dUb29sdGlwKHtpbmRleDogMSwgc2VyaWVzSW5kZXg6IDJ9KTtcbiAgICAgKi9cbiAgICBzaG93VG9vbHRpcChzZXJpZXNJbmZvKSB7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnc2hvd1Rvb2x0aXAnLCBPYmplY3QuYXNzaWduKHt9LCBzZXJpZXNJbmZvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGUgdG9vbHRpcC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5oaWRlVG9vbHRpcCgpO1xuICAgICAqL1xuICAgIGhpZGVUb29sdGlwKCkge1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ2hpZGVUb29sdGlwJyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IENoYXJ0IGZyb20gXCIuL2NoYXJ0XCI7XG5pbXBvcnQgZGF0YVJhbmdlIGZyb20gXCIuLi9zdG9yZS9kYXRhUmFuZ2VcIjtcbmltcG9ydCBzY2FsZSBmcm9tIFwiLi4vc3RvcmUvc2NhbGVcIjtcbmltcG9ydCBheGVzIGZyb20gXCIuLi9zdG9yZS9heGVzXCI7XG5pbXBvcnQgcGxvdCBmcm9tIFwiLi4vc3RvcmUvcGxvdFwiO1xuaW1wb3J0IEF4aXMgZnJvbSBcIi4uL2NvbXBvbmVudC9heGlzXCI7XG5pbXBvcnQgQm94UGxvdFNlcmllcyBmcm9tIFwiLi4vY29tcG9uZW50L2JveFBsb3RTZXJpZXNcIjtcbmltcG9ydCBQbG90IGZyb20gXCIuLi9jb21wb25lbnQvcGxvdFwiO1xuaW1wb3J0IFRvb2x0aXAgZnJvbSBcIi4uL2NvbXBvbmVudC90b29sdGlwXCI7XG5pbXBvcnQgTGVnZW5kIGZyb20gXCIuLi9jb21wb25lbnQvbGVnZW5kXCI7XG5pbXBvcnQgQXhpc1RpdGxlIGZyb20gXCIuLi9jb21wb25lbnQvYXhpc1RpdGxlXCI7XG5pbXBvcnQgVGl0bGUgZnJvbSBcIi4uL2NvbXBvbmVudC90aXRsZVwiO1xuaW1wb3J0IEV4cG9ydE1lbnUgZnJvbSBcIi4uL2NvbXBvbmVudC9leHBvcnRNZW51XCI7XG5pbXBvcnQgSG92ZXJlZFNlcmllcyBmcm9tIFwiLi4vY29tcG9uZW50L2hvdmVyZWRTZXJpZXNcIjtcbmltcG9ydCBTZWxlY3RlZFNlcmllcyBmcm9tIFwiLi4vY29tcG9uZW50L3NlbGVjdGVkU2VyaWVzXCI7XG5pbXBvcnQgQmFja2dyb3VuZCBmcm9tIFwiLi4vY29tcG9uZW50L2JhY2tncm91bmRcIjtcbmltcG9ydCBOb0RhdGFUZXh0IGZyb20gXCIuLi9jb21wb25lbnQvbm9EYXRhVGV4dFwiO1xuaW1wb3J0ICogYXMgYmFzaWNCcnVzaGVzIGZyb20gXCIuLi9icnVzaGVzL2Jhc2ljXCI7XG5pbXBvcnQgKiBhcyBheGlzQnJ1c2hlcyBmcm9tIFwiLi4vYnJ1c2hlcy9heGlzXCI7XG5pbXBvcnQgKiBhcyBsZWdlbmRCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9sZWdlbmRcIjtcbmltcG9ydCAqIGFzIGxhYmVsQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvbGFiZWxcIjtcbmltcG9ydCAqIGFzIGV4cG9ydE1lbnVCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9leHBvcnRNZW51XCI7XG5pbXBvcnQgKiBhcyBCb3hQbG90QnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvYm94UGxvdFwiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBjbGFzc2Rlc2MgQm94UGxvdCBDaGFydFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHByb3BzLmVsIC0gVGhlIHRhcmdldCBlbGVtZW50IHRvIGNyZWF0ZSBjaGFydC5cbiAqICAgQHBhcmFtIHtPYmplY3R9IHByb3BzLmRhdGEgLSBEYXRhIGZvciBtYWtpbmcgQm94UGxvdCBDaGFydC5cbiAqICAgICBAcGFyYW0ge0FycmF5PHN0cmluZz59IHByb3BzLmRhdGEuY2F0ZWdvcmllcyAtIENhdGVnb3JpZXMuXG4gKiAgICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwcm9wcy5kYXRhLnNlcmllcyAtIFNlcmllcyBkYXRhLlxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IHByb3BzLmRhdGEuc2VyaWVzLm5hbWUgLSBTZXJpZXMgbmFtZS5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHByb3BzLmRhdGEuc2VyaWVzLmRhdGEgLSBTZXJpZXMgZGF0YS5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHByb3BzLmRhdGEuc2VyaWVzLm91dGxpZXJzIC0gU2VyaWVzIG91dGxpZXJzIGRhdGEuXG4gKiAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9uc10gLSBPcHRpb25zIGZvciBtYWtpbmcgQm94UGxvdCBDaGFydC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2hhcnRdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlXSAtIENoYXJ0IHRpdGxlIHRleHQgb3Igb3B0aW9ucy5cbiAqICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLnRleHRdIC0gQ2hhcnQgdGl0bGUgdGV4dC5cbiAqICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLm9mZnNldFhdIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgaG9yaXpvbnRhbGx5LlxuICogICAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUub2Zmc2V0WV0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSB2ZXJ0aWNhbGx5LlxuICogICAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUuYWxpZ25dIC0gQ2hhcnQgdGV4dCBhbGlnbi4gJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJyBpcyBhdmFpbGFibGUuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaGFydC5hbmltYXRpb25dIC0gV2hldGhlciB0byB1c2UgYW5pbWF0aW9uIGFuZCBkdXJhdGlvbiB3aGVuIHJlbmRlcmluZyB0aGUgaW5pdGlhbCBjaGFydC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQud2lkdGhdIC0gQ2hhcnQgd2lkdGguICdhdXRvJyBvciBpZiBub3Qgd3JpdGUsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC4gJ2F1dG8nIG9yIGlmIG5vdCBjcmVhdGVkLCB0aGUgd2lkdGggb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LmhlaWdodF0gLSBDaGFydCBoZWlnaHQuICdhdXRvJyBvciBpZiBub3Qgd3JpdGUsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC4gJ2F1dG8nIG9yIGlmIG5vdCBjcmVhdGVkLCB0aGUgaGVpZ2h0IG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5zZXJpZXNdXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5zZWxlY3RhYmxlPWZhbHNlXSAtIFdoZXRoZXIgdG8gbWFrZSBzZWxlY3RhYmxlIHNlcmllcyBvciBub3QuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLmV2ZW50RGV0ZWN0VHlwZV0gLSBFdmVudCBkZXRlY3QgdHlwZS4gJ2dyb3VwZWQnLCAncG9pbnQnIGlzIGF2YWlsYWJsZS5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXNdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLnRpdGxlXSAtIEF4aXMgdGl0bGUuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnhBeGlzLnJvdGF0ZUxhYmVsPXRydWVdIC0gV2hldGhlciB0byBhbGxvdyBheGlzIGxhYmVsIHJvdGF0aW9uLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufE9iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXMuZGF0ZV0gLSBXaGV0aGVyIHRoZSB4IGF4aXMgbGFiZWwgaXMgb2YgZGF0ZSB0eXBlLiBGb3JtYXQgb3B0aW9uIHVzZWQgZm9yIGRhdGUgdHlwZS4gV2hldGhlciB0aGUgeCBheGlzIGxhYmVsIGlzIG9mIGRhdGUgdHlwZS4gSWYgdXNlIGRhdGUgdHlwZSwgZm9ybWF0IG9wdGlvbiB1c2VkIGZvciBkYXRlIHR5cGUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXMudGlja10gLSBPcHRpb24gdG8gYWRqdXN0IHRpY2sgaW50ZXJ2YWwuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXMubGFiZWxdIC0gT3B0aW9uIHRvIGFkanVzdCBsYWJlbCBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy5zY2FsZV0gLSBPcHRpb24gdG8gYWRqdXN0IGF4aXMgbWluaW11bSwgbWF4aW11bSwgc3RlcCBzaXplLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnhBeGlzLndpZHRoXSAtIFdpZHRoIG9mIHhBeGlzLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnhBeGlzLmhlaWdodF0gLSBIZWlnaHQgb2YgeEF4aXMuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnlBeGlzXVxuICogICAgICAgQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpcy50aXRsZV0gLSBBeGlzIHRpdGxlLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnlBeGlzLnRpY2tdIC0gT3B0aW9uIHRvIGFkanVzdCB0aWNrIGludGVydmFsLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnlBeGlzLmxhYmVsXSAtIE9wdGlvbiB0byBhZGp1c3QgbGFiZWwgaW50ZXJ2YWwuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueUF4aXMuc2NhbGVdIC0gT3B0aW9uIHRvIGFkanVzdCBheGlzIG1pbmltdW0sIG1heGltdW0sIHN0ZXAgc2l6ZS5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy55QXhpcy53aWR0aF0gLSBXaWR0aCBvZiB5QXhpcy5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy55QXhpcy5oZWlnaHRdIC0gSGVpZ2h0IG9mIHlBeGlzLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5wbG90XVxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnBsb3Qud2lkdGhdIC0gV2lkdGggb2YgcGxvdC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5wbG90LmhlaWdodF0gLSBIZWlnaHQgb2YgcGxvdC5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMucGxvdC52aXNpYmxlXSAtIFdoZXRoZXIgdG8gc2hvdyBwbG90IGxpbmUuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZF1cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5sZWdlbmQuYWxpZ25dIC0gTGVnZW5kIGFsaWduLiAndG9wJywgJ2JvdHRvbScsICdyaWdodCcsICdsZWZ0JyBpcyBhdmFpbGFibGUuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMubGVnZW5kLnNob3dDaGVja2JveF0gLSBXaGV0aGVyIHRvIHNob3cgY2hlY2tib3guXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC52aXNpYmxlXSAtIFdoZXRoZXIgdG8gc2hvdyBsZWdlbmQuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMubGVnZW5kLndpZHRoXSAtIFdpZHRoIG9mIGxlZ2VuZC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sZWdlbmQuaXRlbV0gLSBgd2lkdGhgIGFuZCBgb3ZlcmZsb3dgIG9wdGlvbnMgb2YgdGhlIGxlZ2VuZCBpdGVtLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8TGVnZW5kIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnVdXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnUudmlzaWJsZV0gLSBXaGV0aGVyIHRvIHNob3cgZXhwb3J0IG1lbnUuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuZXhwb3J0TWVudS5maWxlbmFtZV0gLSBGaWxlIG5hbWUgYXBwbGllZCB3aGVuIGRvd25sb2FkaW5nLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50b29sdGlwXVxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAub2Zmc2V0WF0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSBob3Jpem9udGFsbHkuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC5vZmZzZXRZXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIHZlcnRpY2FsbHkuXG4gKiAgICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcHMub3B0aW9ucy50b29sdGlwLmZvcm1hdHRlcl0gLSBGdW5jdGlvbiB0byBmb3JtYXQgZGF0YSB2YWx1ZS5cbiAqICAgICAgIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAudGVtcGxhdGVdIC0gRnVuY3Rpb24gdG8gY3JlYXRlIGN1c3RvbSB0ZW1wbGF0ZS4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFRvb2x0aXAgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZV0gLSBSdWxlcyBmb3IgY2hhbmdpbmcgY2hhcnQgb3B0aW9ucy4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFJlc3BvbnNpdmUgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLnJlc3BvbnNpdmUuYW5pbWF0aW9uXSAtIEFuaW1hdGlvbiBkdXJhdGlvbiB3aGVuIHRoZSBjaGFydCBpcyBtb2RpZmllZC5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZS5ydWxlc10gLSBSdWxlcyBmb3IgdGhlIENoYXJ0IHRvIFJlc3BvbmQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxhbmddIC0gT3B0aW9ucyBmb3IgY2hhbmdpbmcgdGhlIHRleHQgZGlzcGxheWVkIG9uIHRoZSBjaGFydCBvciBpMThuIGxhbmd1YWdlcy5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sYW5nLm5vRGF0YV0gLSBObyBEYXRhIExheWVyIFRleHQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lXSAtIENoYXJ0IHRoZW1lIG9wdGlvbnMuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxCb3hQbG90IENoYXJ0IGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUuY2hhcnRdIC0gQ2hhcnQgZm9udCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5ub0RhdGFdIC0gTm8gRGF0YSBMYXllciBUZXh0IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnNlcmllc10gLSBTZXJpZXMgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUudGl0bGVdIC0gVGl0bGUgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUueEF4aXNdIC0gWCBBeGlzIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnlBeGlzXSAtIFkgQXhpcyB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5sZWdlbmRdIC0gTGVnZW5kIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnRvb2x0aXBdIC0gVG9vbHRpcCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5wbG90XSAtIFBsb3QgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUuZXhwb3J0TWVudV0gLSBFeHBvcnRNZW51IHRoZW1lLlxuICogQGV4dGVuZHMgQ2hhcnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm94UGxvdENoYXJ0IGV4dGVuZHMgQ2hhcnQge1xuICAgIGNvbnN0cnVjdG9yKHsgZWwsIG9wdGlvbnMsIGRhdGE6IHsgc2VyaWVzLCBjYXRlZ29yaWVzIH0gfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBlbCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBzZXJpZXM6IHtcbiAgICAgICAgICAgICAgICBib3hQbG90OiBzZXJpZXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2F0ZWdvcmllcyxcbiAgICAgICAgICAgIG1vZHVsZXM6IFtkYXRhUmFuZ2UsIHNjYWxlLCBheGVzLCBwbG90XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChCYWNrZ3JvdW5kKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChUaXRsZSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoUGxvdCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoTGVnZW5kKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChCb3hQbG90U2VyaWVzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzLCB7IG5hbWU6ICd5QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpcywgeyBuYW1lOiAneEF4aXMnIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEF4aXNUaXRsZSwgeyBuYW1lOiAneEF4aXMnIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEF4aXNUaXRsZSwgeyBuYW1lOiAneUF4aXMnIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEV4cG9ydE1lbnUsIHsgY2hhcnRFbDogdGhpcy5lbCB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChIb3ZlcmVkU2VyaWVzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChTZWxlY3RlZFNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoVG9vbHRpcCwgeyBjaGFydEVsOiB0aGlzLmVsIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKE5vRGF0YVRleHQpO1xuICAgICAgICB0aGlzLnBhaW50ZXIuYWRkR3JvdXBzKFtcbiAgICAgICAgICAgIGJhc2ljQnJ1c2hlcyxcbiAgICAgICAgICAgIGF4aXNCcnVzaGVzLFxuICAgICAgICAgICAgQm94UGxvdEJydXNoLFxuICAgICAgICAgICAgbGVnZW5kQnJ1c2gsXG4gICAgICAgICAgICBsYWJlbEJydXNoLFxuICAgICAgICAgICAgZXhwb3J0TWVudUJydXNoLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheTw8QXJyYXk8bnVtYmVyPj59IGRhdGEgLSBBcnJheSBvZiBkYXRhIHRvIGJlIGFkZGVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYXRlZ29yeSAtIENhdGVnb3J5IHRvIGJlIGFkZGVkLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmFkZERhdGEoXG4gICAgICAgIFtcbiAgICAgICAgICAgWzMwMDAsIDQwMDAsIDQ3MTQsIDYwMDAsIDcwMDBdLFxuICAgICAgICAgICBbMzAwMCwgNTc1MCwgNzU3MSwgODI1MCwgOTAwMF0sXG4gICAgICAgIF0sXG4gICAgICAgICduZXdDYXRlZ29yeSdcbiAgICAgICk7XG4gICAgICovXG4gICAgYWRkRGF0YShkYXRhLCBjYXRlZ29yeSkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkNvbnRyb2xGbGFnLnVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdhZGREYXRhJywgeyBkYXRhLCBjYXRlZ29yeSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYWRkIG91dGxpZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNlcmllc0luZGV4IC0gSW5kZXggb2Ygc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvdXRsaWVycyAtIEFycmF5IG9mIG91dGxpZXIuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuYWRkT3V0bGllcigxLCBbWzEsIDEwMDAwXSwgWzMsIDEyMDAwXV0pO1xuICAgICAqL1xuICAgIGFkZE91dGxpZXIoc2VyaWVzSW5kZXgsIG91dGxpZXJzKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQ29udHJvbEZsYWcudXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2FkZE91dGxpZXInLCB7IHNlcmllc0luZGV4LCBvdXRsaWVycyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHNlcmllcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIERhdGEgdG8gYmUgYWRkZWQuXG4gICAgICogICBAcGFyYW0ge3N0cmluZ30gZGF0YS5uYW1lIC0gU2VyaWVzIG5hbWUuXG4gICAgICogICBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBkYXRhLmRhdGEgLSBBcnJheSBvZiBkYXRhIHRvIGJlIGFkZGVkLlxuICAgICAqICAgQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZGF0YS5vdXRsaWVycyAtIFNlcmllcyBvdXRsaWVycyBkYXRhLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmFkZFNlcmllcyh7XG4gICAgICogICBuYW1lOiAnbmV3U2VyaWVzJyxcbiAgICAgKiAgIGRhdGE6IFtcbiAgICAgKiAgICAgWzEwLCAxMDAsIDUwLCA0MCwgNzAsIDU1LCAzMywgNzAsIDkwLCAxMTBdLFxuICAgICAqICAgXSxcbiAgICAgKiAgIG91dGxpZXJzOiBbXG4gICAgICogICAgIFswLCAxNDAwMF0sXG4gICAgICogICAgIFsyLCAxMDAwMF0sXG4gICAgICogICBdXG4gICAgICogfSk7XG4gICAgICovXG4gICAgYWRkU2VyaWVzKGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdhZGRTZXJpZXMnLCB7IGRhdGEgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGNoYXJ0IGRhdGEgdG8gbmV3IGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBEYXRhIHRvIGJlIHNldC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zZXREYXRhKHtcbiAgICAgKiAgIGNhdGVnb3JpZXM6IFsnMScsICcyJywgJzMnXSxcbiAgICAgKiAgIHNlcmllczogW1xuICAgICAqICAgICB7XG4gICAgICogICAgICAgbmFtZTogJ25ld1NlcmllcycsXG4gICAgICogICAgICAgZGF0YTogW1xuICAgICAqICAgICAgICAgWzEwLCAxMDAsIDUwLCA0MCwgNzAsIDU1LCAzMywgNzAsIDkwLCAxMTBdLFxuICAgICAqICAgICAgIF0sXG4gICAgICogICAgICAgb3V0bGllcnM6IFtcbiAgICAgKiAgICAgICAgIFswLCAxNDAwMF0sXG4gICAgICogICAgICAgICBbMiwgMTAwMDBdLFxuICAgICAqICAgICAgIF1cbiAgICAgKiAgICAgfVxuICAgICAqICAgXVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHNldERhdGEoZGF0YSkge1xuICAgICAgICBjb25zdCB7IGNhdGVnb3JpZXMsIHNlcmllcyB9ID0gZGF0YTtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdzZXREYXRhJywgeyBzZXJpZXM6IHsgYm94UGxvdDogc2VyaWVzIH0sIGNhdGVnb3JpZXMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGNoYXJ0IG9wdGlvbnMgdG8gbmV3IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDaGFydCBvcHRpb25zLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNldE9wdGlvbnMoe1xuICAgICAqICAgY2hhcnQ6IHtcbiAgICAgKiAgICAgd2lkdGg6IDUwMCxcbiAgICAgKiAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICogICAgIHRpdGxlOiAnRW5lcmd5IFVzYWdlJyxcbiAgICAgKiAgIH0sXG4gICAgICogICB4QXhpczoge1xuICAgICAqICAgICB0aXRsZTogJ01vbnRoJyxcbiAgICAgKiAgICAgZGF0ZTogeyBmb3JtYXQ6ICd5eS9NTScgfSxcbiAgICAgKiAgIH0sXG4gICAgICogICB5QXhpczoge1xuICAgICAqICAgICB0aXRsZTogJ0VuZXJneSAoa1doKScsXG4gICAgICogICB9LFxuICAgICAqICAgc2VyaWVzOiB7XG4gICAgICogICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICogICB9LFxuICAgICAqICAgdG9vbHRpcDoge1xuICAgICAqICAgICBmb3JtYXR0ZXI6ICh2YWx1ZSkgPT4gYCR7dmFsdWV9a1doYCxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICovXG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE9wdGlvbnNFdmVudCgnaW5pdE9wdGlvbnMnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNoYXJ0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDaGFydCBvcHRpb25zLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnVwZGF0ZU9wdGlvbnMoe1xuICAgICAqICAgY2hhcnQ6IHtcbiAgICAgKiAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICogICAgIHRpdGxlOiAnRW5lcmd5IFVzYWdlJyxcbiAgICAgKiAgIH0sXG4gICAgICogICB0b29sdGlwOiB7XG4gICAgICogICAgIGZvcm1hdHRlcjogKHZhbHVlKSA9PiBgJHt2YWx1ZX1rV2hgLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB1cGRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoT3B0aW9uc0V2ZW50KCd1cGRhdGVPcHRpb25zJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VyaWVzSW5mbyAtIEluZm9ybWF0aW9uIG9mIHRoZSBzZXJpZXMgZm9yIHRoZSB0b29sdGlwIHRvIGJlIGRpc3BsYXllZC5cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBzZXJpZXNJbmZvLnNlcmllc0luZGV4IC0gSW5kZXggb2Ygc2VyaWVzLlxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHNlcmllc0luZm8uaW5kZXggLSBJbmRleCBvZiBkYXRhIHdpdGhpbiBzZXJpZXMuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2hvd1Rvb2x0aXAoe2luZGV4OiAxLCBzZXJpZXNJbmRleDogMn0pO1xuICAgICAqL1xuICAgIHNob3dUb29sdGlwKHNlcmllc0luZm8pIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzaG93VG9vbHRpcCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VyaWVzSW5mbyksIHsgc3RhdGU6IHRoaXMuc3RvcmUuc3RhdGUgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlIHRvb2x0aXAuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuaGlkZVRvb2x0aXAoKTtcbiAgICAgKi9cbiAgICBoaWRlVG9vbHRpcCgpIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdoaWRlVG9vbHRpcCcpO1xuICAgIH1cbn1cbiIsImltcG9ydCBDaGFydCBmcm9tIFwiLi9jaGFydFwiO1xuaW1wb3J0IHNjYWxlIGZyb20gXCIuLi9zdG9yZS9zY2FsZVwiO1xuaW1wb3J0IGF4ZXMgZnJvbSBcIi4uL3N0b3JlL2F4ZXNcIjtcbmltcG9ydCBkYXRhUmFuZ2UgZnJvbSBcIi4uL3N0b3JlL2RhdGFSYW5nZVwiO1xuaW1wb3J0IHBsb3QgZnJvbSBcIi4uL3N0b3JlL3Bsb3RcIjtcbmltcG9ydCBUb29sdGlwIGZyb20gXCIuLi9jb21wb25lbnQvdG9vbHRpcFwiO1xuaW1wb3J0IFBsb3QgZnJvbSBcIi4uL2NvbXBvbmVudC9wbG90XCI7XG5pbXBvcnQgQnViYmxlU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvYnViYmxlU2VyaWVzXCI7XG5pbXBvcnQgQXhpcyBmcm9tIFwiLi4vY29tcG9uZW50L2F4aXNcIjtcbmltcG9ydCBDaXJjbGVMZWdlbmQgZnJvbSBcIi4uL2NvbXBvbmVudC9jaXJjbGVMZWdlbmRcIjtcbmltcG9ydCBMZWdlbmQgZnJvbSBcIi4uL2NvbXBvbmVudC9sZWdlbmRcIjtcbmltcG9ydCBUaXRsZSBmcm9tIFwiLi4vY29tcG9uZW50L3RpdGxlXCI7XG5pbXBvcnQgQXhpc1RpdGxlIGZyb20gXCIuLi9jb21wb25lbnQvYXhpc1RpdGxlXCI7XG5pbXBvcnQgRXhwb3J0TWVudSBmcm9tIFwiLi4vY29tcG9uZW50L2V4cG9ydE1lbnVcIjtcbmltcG9ydCBIb3ZlcmVkU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvaG92ZXJlZFNlcmllc1wiO1xuaW1wb3J0IFNlbGVjdGVkU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvc2VsZWN0ZWRTZXJpZXNcIjtcbmltcG9ydCBCYWNrZ3JvdW5kIGZyb20gXCIuLi9jb21wb25lbnQvYmFja2dyb3VuZFwiO1xuaW1wb3J0IE5vRGF0YVRleHQgZnJvbSBcIi4uL2NvbXBvbmVudC9ub0RhdGFUZXh0XCI7XG5pbXBvcnQgKiBhcyBiYXNpY0JydXNoIGZyb20gXCIuLi9icnVzaGVzL2Jhc2ljXCI7XG5pbXBvcnQgKiBhcyBheGlzQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvYXhpc1wiO1xuaW1wb3J0ICogYXMgY2lyY2xlTGVnZW5kQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvY2lyY2xlTGVnZW5kXCI7XG5pbXBvcnQgKiBhcyBsZWdlbmRCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9sZWdlbmRcIjtcbmltcG9ydCAqIGFzIGxhYmVsQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvbGFiZWxcIjtcbmltcG9ydCAqIGFzIGV4cG9ydE1lbnVCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9leHBvcnRNZW51XCI7XG4vKipcbiAqIEBjbGFzc1xuICogQGNsYXNzZGVzYyBCdWJibGUgQ2hhcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogICBAcGFyYW0ge0hUTUxFbGVtZW50fSBwcm9wcy5lbCAtIFRoZSB0YXJnZXQgZWxlbWVudCB0byBjcmVhdGUgY2hhcnQuXG4gKiAgIEBwYXJhbSB7T2JqZWN0fSBwcm9wcy5kYXRhIC0gRGF0YSBmb3IgbWFraW5nIEJ1YmJsZSBDaGFydC5cbiAqICAgICBAcGFyYW0ge0FycmF5PHN0cmluZz59IHByb3BzLmRhdGEuY2F0ZWdvcmllcyAtIENhdGVnb3JpZXMuXG4gKiAgICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwcm9wcy5kYXRhLnNlcmllcyAtIFNlcmllcyBkYXRhLlxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IHByb3BzLmRhdGEuc2VyaWVzLm5hbWUgLSBTZXJpZXMgbmFtZS5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcHJvcHMuZGF0YS5zZXJpZXMuZGF0YSAtIFNlcmllcyBkYXRhLiBDb29yZGluYXRlcyB4LCB5IHZhbHVlcywgcmFkaXVzIHIsIGFuZCBsYWJlbCB2YWx1ZXMgYXJlIHJlcXVpcmVkLlxuICogICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnNdIC0gT3B0aW9ucyBmb3IgbWFraW5nIEJ1YmJsZSBDaGFydC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2hhcnRdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlXSAtIENoYXJ0IHRpdGxlIHRleHQgb3Igb3B0aW9ucy5cbiAqICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLnRleHRdIC0gQ2hhcnQgdGl0bGUgdGV4dC5cbiAqICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLm9mZnNldFhdIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgaG9yaXpvbnRhbGx5LlxuICogICAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUub2Zmc2V0WV0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSB2ZXJ0aWNhbGx5LlxuICogICAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUuYWxpZ25dIC0gQ2hhcnQgdGV4dCBhbGlnbi4gJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJyBpcyBhdmFpbGFibGUuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaGFydC5hbmltYXRpb25dIC0gV2hldGhlciB0byB1c2UgYW5pbWF0aW9uIGFuZCBkdXJhdGlvbiB3aGVuIHJlbmRlcmluZyB0aGUgaW5pdGlhbCBjaGFydC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQud2lkdGhdIC0gQ2hhcnQgd2lkdGguICdhdXRvJyBvciBpZiBub3Qgd3JpdGUsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC4gJ2F1dG8nIG9yIGlmIG5vdCBjcmVhdGVkLCB0aGUgd2lkdGggb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LmhlaWdodF0gLSBDaGFydCBoZWlnaHQuICdhdXRvJyBvciBpZiBub3Qgd3JpdGUsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC4gJ2F1dG8nIG9yIGlmIG5vdCBjcmVhdGVkLCB0aGUgaGVpZ2h0IG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5zZXJpZXNdXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5zZWxlY3RhYmxlPWZhbHNlXSAtIFdoZXRoZXIgdG8gbWFrZSBzZWxlY3RhYmxlIHNlcmllcyBvciBub3QuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzXVxuICogICAgICAgQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy50aXRsZV0gLSBBeGlzIHRpdGxlLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy54QXhpcy5yb3RhdGVMYWJlbD10cnVlXSAtIFdoZXRoZXIgdG8gYWxsb3cgYXhpcyBsYWJlbCByb3RhdGlvbi5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLmRhdGVdIC0gV2hldGhlciB0aGUgeCBheGlzIGxhYmVsIGlzIG9mIGRhdGUgdHlwZS4gRm9ybWF0IG9wdGlvbiB1c2VkIGZvciBkYXRlIHR5cGUuIFdoZXRoZXIgdGhlIHggYXhpcyBsYWJlbCBpcyBvZiBkYXRlIHR5cGUuIElmIHVzZSBkYXRlIHR5cGUsIGZvcm1hdCBvcHRpb24gdXNlZCBmb3IgZGF0ZSB0eXBlLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLnRpY2tdIC0gT3B0aW9uIHRvIGFkanVzdCB0aWNrIGludGVydmFsLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLmxhYmVsXSAtIE9wdGlvbiB0byBhZGp1c3QgbGFiZWwgaW50ZXJ2YWwuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXMuc2NhbGVdIC0gT3B0aW9uIHRvIGFkanVzdCBheGlzIG1pbmltdW0sIG1heGltdW0sIHN0ZXAgc2l6ZS5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy54QXhpcy53aWR0aF0gLSBXaWR0aCBvZiB4QXhpcy5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy54QXhpcy5oZWlnaHRdIC0gSGVpZ2h0IG9mIHhBeGlzLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpc11cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW3Byb3BzLm9wdGlvbnMueUF4aXMudGl0bGVdIC0gQXhpcyB0aXRsZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpcy50aWNrXSAtIE9wdGlvbiB0byBhZGp1c3QgdGljayBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpcy5sYWJlbF0gLSBPcHRpb24gdG8gYWRqdXN0IGxhYmVsIGludGVydmFsLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnlBeGlzLnNjYWxlXSAtIE9wdGlvbiB0byBhZGp1c3QgYXhpcyBtaW5pbXVtLCBtYXhpbXVtLCBzdGVwIHNpemUuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMueUF4aXMud2lkdGhdIC0gV2lkdGggb2YgeUF4aXMuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMueUF4aXMuaGVpZ2h0XSAtIEhlaWdodCBvZiB5QXhpcy5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMucGxvdF1cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5wbG90LndpZHRoXSAtIFdpZHRoIG9mIHBsb3QuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMucGxvdC5oZWlnaHRdIC0gSGVpZ2h0IG9mIHBsb3QuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnBsb3QudmlzaWJsZV0gLSBXaGV0aGVyIHRvIHNob3cgcGxvdCBsaW5lLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sZWdlbmRdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMubGVnZW5kLmFsaWduXSAtIExlZ2VuZCBhbGlnbi4gJ3RvcCcsICdib3R0b20nLCAncmlnaHQnLCAnbGVmdCcgaXMgYXZhaWxhYmxlLlxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC5zaG93Q2hlY2tib3hdIC0gV2hldGhlciB0byBzaG93IGNoZWNrYm94LlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5sZWdlbmQudmlzaWJsZV0gLSBXaGV0aGVyIHRvIHNob3cgbGVnZW5kLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC53aWR0aF0gLSBXaWR0aCBvZiBsZWdlbmQuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGVnZW5kLml0ZW1dIC0gYHdpZHRoYCBhbmQgYG92ZXJmbG93YCBvcHRpb25zIG9mIHRoZSBsZWdlbmQgaXRlbS4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fExlZ2VuZCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaXJjbGVMZWdlbmRdXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLmNpcmNsZUxlZ2VuZC52aXNpYmxlXSAtIFdoZXRoZXIgdG8gc2hvdyBjaXJjbGUgbGVnZW5kLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5leHBvcnRNZW51XVxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5leHBvcnRNZW51LnZpc2libGVdIC0gV2hldGhlciB0byBzaG93IGV4cG9ydCBtZW51LlxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnUuZmlsZW5hbWVdIC0gRmlsZSBuYW1lIGFwcGxpZWQgd2hlbiBkb3dubG9hZGluZy5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcF1cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy50b29sdGlwLm9mZnNldFhdIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgaG9yaXpvbnRhbGx5LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAub2Zmc2V0WV0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSB2ZXJ0aWNhbGx5LlxuICogICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC5mb3JtYXR0ZXJdIC0gRnVuY3Rpb24gdG8gZm9ybWF0IGRhdGEgdmFsdWUuXG4gKiAgICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcHMub3B0aW9ucy50b29sdGlwLnRlbXBsYXRlXSAtIEZ1bmN0aW9uIHRvIGNyZWF0ZSBjdXN0b20gdGVtcGxhdGUuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxUb29sdGlwIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnJlc3BvbnNpdmVdIC0gUnVsZXMgZm9yIGNoYW5naW5nIGNoYXJ0IG9wdGlvbnMuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxSZXNwb25zaXZlIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5yZXNwb25zaXZlLmFuaW1hdGlvbl0gLSBBbmltYXRpb24gZHVyYXRpb24gd2hlbiB0aGUgY2hhcnQgaXMgbW9kaWZpZWQuXG4gKiAgICAgICBAcGFyYW0ge0FycmF5PE9iamVjdD59IFtwcm9wcy5vcHRpb25zLnJlc3BvbnNpdmUucnVsZXNdIC0gUnVsZXMgZm9yIHRoZSBDaGFydCB0byBSZXNwb25kLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sYW5nXSAtIE9wdGlvbnMgZm9yIGNoYW5naW5nIHRoZSB0ZXh0IGRpc3BsYXllZCBvbiB0aGUgY2hhcnQgb3IgaTE4biBsYW5ndWFnZXMuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGFuZy5ub0RhdGFdIC0gTm8gRGF0YSBMYXllciBUZXh0LlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZV0gLSBDaGFydCB0aGVtZSBvcHRpb25zLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8QnViYmxlIENoYXJ0IGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUuY2hhcnRdIC0gQ2hhcnQgZm9udCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5ub0RhdGFdIC0gTm8gRGF0YSBMYXllciBUZXh0IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnNlcmllc10gLSBTZXJpZXMgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUudGl0bGVdIC0gVGl0bGUgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUueEF4aXNdIC0gWCBBeGlzIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnlBeGlzXSAtIFkgQXhpcyB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5sZWdlbmRdIC0gTGVnZW5kIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnRvb2x0aXBdIC0gVG9vbHRpcCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5wbG90XSAtIFBsb3QgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUuZXhwb3J0TWVudV0gLSBFeHBvcnRNZW51IHRoZW1lLlxuICogQGV4dGVuZHMgQ2hhcnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnViYmxlQ2hhcnQgZXh0ZW5kcyBDaGFydCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgZWw6IHByb3BzLmVsLFxuICAgICAgICAgICAgb3B0aW9uczogcHJvcHMub3B0aW9ucyxcbiAgICAgICAgICAgIHNlcmllczoge1xuICAgICAgICAgICAgICAgIGJ1YmJsZTogcHJvcHMuZGF0YS5zZXJpZXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW9kdWxlczogW2RhdGFSYW5nZSwgc2NhbGUsIGF4ZXMsIHBsb3RdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEJhY2tncm91bmQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFRpdGxlKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChQbG90KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChMZWdlbmQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEJ1YmJsZVNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpcywgeyBuYW1lOiAneEF4aXMnIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEF4aXMsIHsgbmFtZTogJ3lBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzVGl0bGUsIHsgbmFtZTogJ3hBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzVGl0bGUsIHsgbmFtZTogJ3lBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChFeHBvcnRNZW51LCB7IGNoYXJ0RWw6IHRoaXMuZWwgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoSG92ZXJlZFNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoU2VsZWN0ZWRTZXJpZXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFRvb2x0aXAsIHsgY2hhcnRFbDogdGhpcy5lbCB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChDaXJjbGVMZWdlbmQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKE5vRGF0YVRleHQpO1xuICAgICAgICB0aGlzLnBhaW50ZXIuYWRkR3JvdXBzKFtcbiAgICAgICAgICAgIGJhc2ljQnJ1c2gsXG4gICAgICAgICAgICBheGlzQnJ1c2gsXG4gICAgICAgICAgICBjaXJjbGVMZWdlbmRCcnVzaCxcbiAgICAgICAgICAgIGxlZ2VuZEJydXNoLFxuICAgICAgICAgICAgbGFiZWxCcnVzaCxcbiAgICAgICAgICAgIGV4cG9ydE1lbnVCcnVzaCxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZGF0YSAtIEFycmF5IG9mIGRhdGEgdG8gYmUgYWRkZWQuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuYWRkRGF0YShbXG4gICAgICogICB7eDogMTAsIHk6IDIwLCByOiAxMCwgbGFiZWw6ICdsYWJlbDEnfSxcbiAgICAgKiAgIHt4OiAzMCwgeTogNDAsIHI6IDEwLCBsYWJlbDogJ2xhYmVsMid9LFxuICAgICAqIF0pO1xuICAgICAqL1xuICAgIGFkZERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkNvbnRyb2xGbGFnLnVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdhZGREYXRhJywgeyBkYXRhIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSBkYXRhLm5hbWUgLSBTZXJpZXMgbmFtZS5cbiAgICAgKiAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZGF0YS5kYXRhIC0gQXJyYXkgb2YgZGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5hZGRTZXJpZXMoe1xuICAgICAqICAgbmFtZTogJ25ld1NlcmllcycsXG4gICAgICogICBkYXRhOiBbXG4gICAgICogICAgIHt4OiAxMCwgeTogMjAsIHI6IDEwLCBsYWJlbDogJ2xhYmVsMSd9LFxuICAgICAqICAgICB7eDogMzAsIHk6IDQwLCByOiAxMCwgbGFiZWw6ICdsYWJlbDInfSxcbiAgICAgKiAgIF0sXG4gICAgICogfSk7XG4gICAgICovXG4gICAgYWRkU2VyaWVzKGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdhZGRTZXJpZXMnLCB7IGRhdGEgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGNoYXJ0IGRhdGEgdG8gbmV3IGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBEYXRhIHRvIGJlIHNldC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zZXREYXRhKHtcbiAgICAgKiAgIHNlcmllczogW1xuICAgICAqICAgICB7XG4gICAgICogICAgICAgbmFtZTogJ25hbWUnXG4gICAgICogICAgICAgZGF0YTogW1xuICAgICAqICAgICAgICAge3g6IDEwLCB5OiAyMCwgcjogMTAsIGxhYmVsOiAnbGFiZWwxJ30sXG4gICAgICogICAgICAgICB7eDogMzAsIHk6IDQwLCByOiAxMCwgbGFiZWw6ICdsYWJlbDInfSxcbiAgICAgKiAgICAgICBdXG4gICAgICogICAgIH1cbiAgICAgKiAgIF1cbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXREYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdzZXREYXRhJywgeyBzZXJpZXM6IHsgYnViYmxlOiBkYXRhLnNlcmllcyB9IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBjaGFydCBvcHRpb25zIHRvIG5ldyBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ2hhcnQgb3B0aW9ucy5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zZXRPcHRpb25zKHtcbiAgICAgKiAgIGNoYXJ0OiB7XG4gICAgICogICAgIHdpZHRoOiA1MDAsXG4gICAgICogICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAqICAgICB0aXRsZTogJ0VuZXJneSBVc2FnZScsXG4gICAgICogICB9LFxuICAgICAqICAgeEF4aXM6IHtcbiAgICAgKiAgICAgdGl0bGU6ICdNb250aCcsXG4gICAgICogICAgIGRhdGU6IHsgZm9ybWF0OiAneXkvTU0nIH0sXG4gICAgICogICB9LFxuICAgICAqICAgeUF4aXM6IHtcbiAgICAgKiAgICAgdGl0bGU6ICdFbmVyZ3kgKGtXaCknLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHNlcmllczoge1xuICAgICAqICAgICBzZWxlY3RhYmxlOiB0cnVlLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHRvb2x0aXA6IHtcbiAgICAgKiAgICAgZm9ybWF0dGVyOiAodmFsdWUpID0+IGAke3ZhbHVlfWtXaGAsXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hPcHRpb25zRXZlbnQoJ2luaXRPcHRpb25zJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBjaGFydCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ2hhcnQgb3B0aW9ucy5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC51cGRhdGVPcHRpb25zKHtcbiAgICAgKiAgIGNoYXJ0OiB7XG4gICAgICogICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAqICAgICB0aXRsZTogJ0VuZXJneSBVc2FnZScsXG4gICAgICogICB9LFxuICAgICAqICAgdG9vbHRpcDoge1xuICAgICAqICAgICBmb3JtYXR0ZXI6ICh2YWx1ZSkgPT4gYCR7dmFsdWV9a1doYCxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICovXG4gICAgdXBkYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE9wdGlvbnNFdmVudCgndXBkYXRlT3B0aW9ucycsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlcmllc0luZm8gLSBJbmZvcm1hdGlvbiBvZiB0aGUgc2VyaWVzIGZvciB0aGUgdG9vbHRpcCB0byBiZSBkaXNwbGF5ZWQuXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gc2VyaWVzSW5mby5zZXJpZXNJbmRleCAtIEluZGV4IG9mIHNlcmllcy5cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBzZXJpZXNJbmZvLmluZGV4IC0gSW5kZXggb2YgZGF0YSB3aXRoaW4gc2VyaWVzLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNob3dUb29sdGlwKHtpbmRleDogMSwgc2VyaWVzSW5kZXg6IDJ9KTtcbiAgICAgKi9cbiAgICBzaG93VG9vbHRpcChzZXJpZXNJbmZvKSB7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnc2hvd1Rvb2x0aXAnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlcmllc0luZm8pLCB7IHN0YXRlOiB0aGlzLnN0b3JlLnN0YXRlIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZSB0b29sdGlwLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmhpZGVUb29sdGlwKCk7XG4gICAgICovXG4gICAgaGlkZVRvb2x0aXAoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnaGlkZVRvb2x0aXAnKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ2hhcnQgZnJvbSBcIi4vY2hhcnRcIjtcbmltcG9ydCBkYXRhUmFuZ2UgZnJvbSBcIi4uL3N0b3JlL2RhdGFSYW5nZVwiO1xuaW1wb3J0IHNjYWxlIGZyb20gXCIuLi9zdG9yZS9zY2FsZVwiO1xuaW1wb3J0IGF4ZXMgZnJvbSBcIi4uL3N0b3JlL2F4ZXNcIjtcbmltcG9ydCBwbG90IGZyb20gXCIuLi9zdG9yZS9wbG90XCI7XG5pbXBvcnQgQXhpcyBmcm9tIFwiLi4vY29tcG9uZW50L2F4aXNcIjtcbmltcG9ydCBCdWxsZXRTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9idWxsZXRTZXJpZXNcIjtcbmltcG9ydCBQbG90IGZyb20gXCIuLi9jb21wb25lbnQvcGxvdFwiO1xuaW1wb3J0IFRvb2x0aXAgZnJvbSBcIi4uL2NvbXBvbmVudC90b29sdGlwXCI7XG5pbXBvcnQgTGVnZW5kIGZyb20gXCIuLi9jb21wb25lbnQvbGVnZW5kXCI7XG5pbXBvcnQgQXhpc1RpdGxlIGZyb20gXCIuLi9jb21wb25lbnQvYXhpc1RpdGxlXCI7XG5pbXBvcnQgVGl0bGUgZnJvbSBcIi4uL2NvbXBvbmVudC90aXRsZVwiO1xuaW1wb3J0IEV4cG9ydE1lbnUgZnJvbSBcIi4uL2NvbXBvbmVudC9leHBvcnRNZW51XCI7XG5pbXBvcnQgU2VsZWN0ZWRTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9zZWxlY3RlZFNlcmllc1wiO1xuaW1wb3J0IEhvdmVyZWRTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9ob3ZlcmVkU2VyaWVzXCI7XG5pbXBvcnQgRGF0YUxhYmVscyBmcm9tIFwiLi4vY29tcG9uZW50L2RhdGFMYWJlbHNcIjtcbmltcG9ydCBCYWNrZ3JvdW5kIGZyb20gXCIuLi9jb21wb25lbnQvYmFja2dyb3VuZFwiO1xuaW1wb3J0IE5vRGF0YVRleHQgZnJvbSBcIi4uL2NvbXBvbmVudC9ub0RhdGFUZXh0XCI7XG5pbXBvcnQgKiBhcyBiYXNpY0JydXNoZXMgZnJvbSBcIi4uL2JydXNoZXMvYmFzaWNcIjtcbmltcG9ydCAqIGFzIGF4aXNCcnVzaGVzIGZyb20gXCIuLi9icnVzaGVzL2F4aXNcIjtcbmltcG9ydCAqIGFzIGxlZ2VuZEJydXNoIGZyb20gXCIuLi9icnVzaGVzL2xlZ2VuZFwiO1xuaW1wb3J0ICogYXMgbGFiZWxCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9sYWJlbFwiO1xuaW1wb3J0ICogYXMgZGF0YUxhYmVsQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvZGF0YUxhYmVsXCI7XG5pbXBvcnQgKiBhcyBleHBvcnRNZW51QnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvZXhwb3J0TWVudVwiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBjbGFzc2Rlc2MgQnVsbGV0IENoYXJ0XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gcHJvcHMuZWwgLSBUaGUgdGFyZ2V0IGVsZW1lbnQgdG8gY3JlYXRlIGNoYXJ0LlxuICogICBAcGFyYW0ge09iamVjdH0gcHJvcHMuZGF0YSAtIERhdGEgZm9yIG1ha2luZyBCdWxsZXQgQ2hhcnQuXG4gKiAgICAgQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBwcm9wcy5kYXRhLmNhdGVnb3JpZXMgLSBDYXRlZ29yaWVzLlxuICogICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcHJvcHMuZGF0YS5zZXJpZXMgLSBTZXJpZXMgZGF0YS5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy5kYXRhLnNlcmllcy5uYW1lIC0gU2VyaWVzIG5hbWUuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gcHJvcHMuZGF0YS5zZXJpZXMuZGF0YSAtIFNlcmllcyBkYXRhLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxudW1iZXI+fSBwcm9wcy5kYXRhLnNlcmllcy5tYXJrZXJzIC0gU2VyaWVzIG1hcmtlcnMuIEl0IHNwZWNpZmllcyB0aGUgbWFya2VyIGZvciBjb21wYXJpbmcuXG4gKiAgICAgICBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBwcm9wcy5kYXRhLnNlcmllcy5yYW5nZXMgLSBTZXJpZXMgcmFuZ2VzLiBJdCBzcGVjaWZpZXMgdGhlIHJhbmdlIG9mIHZhbHVlcyB0aGF0IGNhbiBiZSBjb21wYXJlZC5cbiAqICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zXSAtIE9wdGlvbnMgZm9yIG1ha2luZyBCdWxsZXQgQ2hhcnQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNoYXJ0XVxuICogICAgICAgQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZV0gLSBDaGFydCB0aXRsZSB0ZXh0IG9yIG9wdGlvbnMuXG4gKiAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS50ZXh0XSAtIENoYXJ0IHRpdGxlIHRleHQuXG4gKiAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS5vZmZzZXRYXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIGhvcml6b250YWxseS5cbiAqICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLm9mZnNldFldIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgdmVydGljYWxseS5cbiAqICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLmFsaWduXSAtIENoYXJ0IHRleHQgYWxpZ24uICdsZWZ0JywgJ3JpZ2h0JywgJ2NlbnRlcicgaXMgYXZhaWxhYmxlLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufE9iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2hhcnQuYW5pbWF0aW9uXSAtIFdoZXRoZXIgdG8gdXNlIGFuaW1hdGlvbiBhbmQgZHVyYXRpb24gd2hlbiByZW5kZXJpbmcgdGhlIGluaXRpYWwgY2hhcnQuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LndpZHRoXSAtIENoYXJ0IHdpZHRoLiAnYXV0bycgb3IgaWYgbm90IHdyaXRlLCB0aGUgd2lkdGggb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuICdhdXRvJyBvciBpZiBub3QgY3JlYXRlZCwgdGhlIHdpZHRoIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC5oZWlnaHRdIC0gQ2hhcnQgaGVpZ2h0LiAnYXV0bycgb3IgaWYgbm90IHdyaXRlLCB0aGUgd2lkdGggb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuICdhdXRvJyBvciBpZiBub3QgY3JlYXRlZCwgdGhlIGhlaWdodCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzXVxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5zZXJpZXMuc2VsZWN0YWJsZT1mYWxzZV0gLSBXaGV0aGVyIHRvIG1ha2Ugc2VsZWN0YWJsZSBzZXJpZXMgb3Igbm90LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnNlcmllcy52ZXJ0aWNhbF0gLSBXaGV0aGVyIHRvIHVzZSB2ZXJ0aWNhbCBidWxsZXQgc2VyaWVzIG9yIG5vdC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5zZXJpZXMuZGF0YUxhYmVsc10gLSBTZXQgdGhlIHZpc2liaWxpdHksIGxvY2F0aW9uLCBhbmQgZm9ybWF0dGluZyBvZiBkYXRhTGFiZWwuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxEYXRhTGFiZWxzIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzXVxuICogICAgICAgQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy50aXRsZV0gLSBBeGlzIHRpdGxlLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy54QXhpcy5yb3RhdGVMYWJlbD10cnVlXSAtIFdoZXRoZXIgdG8gYWxsb3cgYXhpcyBsYWJlbCByb3RhdGlvbi5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLmRhdGVdIC0gV2hldGhlciB0aGUgeCBheGlzIGxhYmVsIGlzIG9mIGRhdGUgdHlwZS4gRm9ybWF0IG9wdGlvbiB1c2VkIGZvciBkYXRlIHR5cGUuIFdoZXRoZXIgdGhlIHggYXhpcyBsYWJlbCBpcyBvZiBkYXRlIHR5cGUuIElmIHVzZSBkYXRlIHR5cGUsIGZvcm1hdCBvcHRpb24gdXNlZCBmb3IgZGF0ZSB0eXBlLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLnRpY2tdIC0gT3B0aW9uIHRvIGFkanVzdCB0aWNrIGludGVydmFsLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLmxhYmVsXSAtIE9wdGlvbiB0byBhZGp1c3QgbGFiZWwgaW50ZXJ2YWwuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXMuc2NhbGVdIC0gT3B0aW9uIHRvIGFkanVzdCBheGlzIG1pbmltdW0sIG1heGltdW0sIHN0ZXAgc2l6ZS5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy54QXhpcy53aWR0aF0gLSBXaWR0aCBvZiB4QXhpcy5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy54QXhpcy5oZWlnaHRdIC0gSGVpZ2h0IG9mIHhBeGlzLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpc11cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW3Byb3BzLm9wdGlvbnMueUF4aXMudGl0bGVdIC0gQXhpcyB0aXRsZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpcy50aWNrXSAtIE9wdGlvbiB0byBhZGp1c3QgdGljayBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpcy5sYWJlbF0gLSBPcHRpb24gdG8gYWRqdXN0IGxhYmVsIGludGVydmFsLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnlBeGlzLnNjYWxlXSAtIE9wdGlvbiB0byBhZGp1c3QgYXhpcyBtaW5pbXVtLCBtYXhpbXVtLCBzdGVwIHNpemUuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMueUF4aXMud2lkdGhdIC0gV2lkdGggb2YgeUF4aXMuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMueUF4aXMuaGVpZ2h0XSAtIEhlaWdodCBvZiB5QXhpcy5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMucGxvdF1cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5wbG90LndpZHRoXSAtIFdpZHRoIG9mIHBsb3QuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMucGxvdC5oZWlnaHRdIC0gSGVpZ2h0IG9mIHBsb3QuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnBsb3QudmlzaWJsZV0gLSBXaGV0aGVyIHRvIHNob3cgcGxvdCBsaW5lLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sZWdlbmRdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMubGVnZW5kLmFsaWduXSAtIExlZ2VuZCBhbGlnbi4gJ3RvcCcsICdib3R0b20nLCAncmlnaHQnLCAnbGVmdCcgaXMgYXZhaWxhYmxlLlxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC5zaG93Q2hlY2tib3hdIC0gV2hldGhlciB0byBzaG93IGNoZWNrYm94LlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5sZWdlbmQudmlzaWJsZV0gLSBXaGV0aGVyIHRvIHNob3cgbGVnZW5kLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC53aWR0aF0gLSBXaWR0aCBvZiBsZWdlbmQuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGVnZW5kLml0ZW1dIC0gYHdpZHRoYCBhbmQgYG92ZXJmbG93YCBvcHRpb25zIG9mIHRoZSBsZWdlbmQgaXRlbS4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fExlZ2VuZCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5leHBvcnRNZW51XVxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5leHBvcnRNZW51LnZpc2libGVdIC0gV2hldGhlciB0byBzaG93IGV4cG9ydCBtZW51LlxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnUuZmlsZW5hbWVdIC0gRmlsZSBuYW1lIGFwcGxpZWQgd2hlbiBkb3dubG9hZGluZy5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcF1cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy50b29sdGlwLm9mZnNldFhdIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgaG9yaXpvbnRhbGx5LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAub2Zmc2V0WV0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSB2ZXJ0aWNhbGx5LlxuICogICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC5mb3JtYXR0ZXJdIC0gRnVuY3Rpb24gdG8gZm9ybWF0IGRhdGEgdmFsdWUuXG4gKiAgICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcHMub3B0aW9ucy50b29sdGlwLnRlbXBsYXRlXSAtIEZ1bmN0aW9uIHRvIGNyZWF0ZSBjdXN0b20gdGVtcGxhdGUuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxUb29sdGlwIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnJlc3BvbnNpdmVdIC0gUnVsZXMgZm9yIGNoYW5naW5nIGNoYXJ0IG9wdGlvbnMuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxSZXNwb25zaXZlIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5yZXNwb25zaXZlLmFuaW1hdGlvbl0gLSBBbmltYXRpb24gZHVyYXRpb24gd2hlbiB0aGUgY2hhcnQgaXMgbW9kaWZpZWQuXG4gKiAgICAgICBAcGFyYW0ge0FycmF5PE9iamVjdD59IFtwcm9wcy5vcHRpb25zLnJlc3BvbnNpdmUucnVsZXNdIC0gUnVsZXMgZm9yIHRoZSBDaGFydCB0byBSZXNwb25kLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sYW5nXSAtIE9wdGlvbnMgZm9yIGNoYW5naW5nIHRoZSB0ZXh0IGRpc3BsYXllZCBvbiB0aGUgY2hhcnQgb3IgaTE4biBsYW5ndWFnZXMuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGFuZy5ub0RhdGFdIC0gTm8gRGF0YSBMYXllciBUZXh0LlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZV0gLSBDaGFydCB0aGVtZSBvcHRpb25zLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8QnVsbGV0cyBDaGFydCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmNoYXJ0XSAtIENoYXJ0IGZvbnQgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUubm9EYXRhXSAtIE5vIERhdGEgTGF5ZXIgVGV4dCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5zZXJpZXNdIC0gU2VyaWVzIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnRpdGxlXSAtIFRpdGxlIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnhBeGlzXSAtIFggQXhpcyB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS55QXhpc10gLSBZIEF4aXMgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUubGVnZW5kXSAtIExlZ2VuZCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS50b29sdGlwXSAtIFRvb2x0aXAgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUucGxvdF0gLSBQbG90IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmV4cG9ydE1lbnVdIC0gRXhwb3J0TWVudSB0aGVtZS5cbiAqIEBleHRlbmRzIENoYXJ0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1bGxldENoYXJ0IGV4dGVuZHMgQ2hhcnQge1xuICAgIGNvbnN0cnVjdG9yKHsgZWwsIG9wdGlvbnMsIGRhdGE6IHsgc2VyaWVzIH0gfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBlbCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBzZXJpZXM6IHtcbiAgICAgICAgICAgICAgICBidWxsZXQ6IHNlcmllcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb2R1bGVzOiBbZGF0YVJhbmdlLCBzY2FsZSwgYXhlcywgcGxvdF0sXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGlkZSB0b29sdGlwLlxuICAgICAgICAgKiBAYXBpXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNoYXJ0LmhpZGVUb29sdGlwKCk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhpZGVUb29sdGlwID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdoaWRlVG9vbHRpcCcpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQmFja2dyb3VuZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoVGl0bGUpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFBsb3QpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKExlZ2VuZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQnVsbGV0U2VyaWVzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzLCB7IG5hbWU6ICd5QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpcywgeyBuYW1lOiAneEF4aXMnIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEF4aXNUaXRsZSwgeyBuYW1lOiAneEF4aXMnIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEF4aXNUaXRsZSwgeyBuYW1lOiAneUF4aXMnIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEV4cG9ydE1lbnUsIHsgY2hhcnRFbDogdGhpcy5lbCB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChIb3ZlcmVkU2VyaWVzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChTZWxlY3RlZFNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoRGF0YUxhYmVscyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoVG9vbHRpcCwgeyBjaGFydEVsOiB0aGlzLmVsIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKE5vRGF0YVRleHQpO1xuICAgICAgICB0aGlzLnBhaW50ZXIuYWRkR3JvdXBzKFtcbiAgICAgICAgICAgIGJhc2ljQnJ1c2hlcyxcbiAgICAgICAgICAgIGF4aXNCcnVzaGVzLFxuICAgICAgICAgICAgbGVnZW5kQnJ1c2gsXG4gICAgICAgICAgICBsYWJlbEJydXNoLFxuICAgICAgICAgICAgZXhwb3J0TWVudUJydXNoLFxuICAgICAgICAgICAgZGF0YUxhYmVsQnJ1c2gsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBiZSBhZGRlZFxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9IGRhdGEubmFtZSAtIFNlcmllcyBuYW1lXG4gICAgICogICBAcGFyYW0ge0FycmF5PDxBcnJheTxudW1iZXI+Pn0gZGF0YS5kYXRhIC0gQXJyYXkgb2YgZGF0YSB0byBiZSBhZGRlZFxuICAgICAqICAgQHBhcmFtIHtBcnJheTxudW1iZXI+fSBkYXRhLm1hcmtlcnMgLSBTZXJpZXMgbWFya2Vycy4gSXQgc3BlY2lmaWVzIHRoZSBtYXJrZXIgZm9yIGNvbXBhcmluZy5cbiAgICAgKiAgIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGRhdGEucmFuZ2VzIC0gU2VyaWVzIHJhbmdlcy4gSXQgc3BlY2lmaWVzIHRoZSByYW5nZSBvZiB2YWx1ZXMgdGhhdCBjYW4gYmUgY29tcGFyZWQuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuYWRkU2VyaWVzKHtcbiAgICAgKiAgIG5hbWU6ICduZXdTZXJpZXMnLFxuICAgICAqICAgZGF0YTogMjAsXG4gICAgICogICBtYXJrZXJzOiBbMjgsIDIsIDE1XSxcbiAgICAgKiAgIHJhbmdlczogW1xuICAgICAqICAgICBbLTEsIDEwXSxcbiAgICAgKiAgICAgWzEwLCAyMF0sXG4gICAgICogICAgIFsyMCwgMzBdLFxuICAgICAqICAgXSxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBhZGRTZXJpZXMoZGF0YSkge1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2FkZFNlcmllcycsIHsgZGF0YSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgY2hhcnQgZGF0YSB0byBuZXcgZGF0YS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIERhdGEgdG8gYmUgc2V0XG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2V0RGF0YSh7XG4gICAgICogICBzZXJpZXM6IFtcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgIG5hbWU6ICduZXdTZXJpZXMnLFxuICAgICAqICAgICAgIGRhdGE6IDIwLFxuICAgICAqICAgICAgIG1hcmtlcnM6IFsyOCwgMiwgMTVdLFxuICAgICAqICAgICAgIHJhbmdlczogW1xuICAgICAqICAgICAgICAgWy0xLCAxMF0sXG4gICAgICogICAgICAgICBbMTAsIDIwXSxcbiAgICAgKiAgICAgICAgIFsyMCwgMzBdLFxuICAgICAqICAgICAgIF0sXG4gICAgICogICAgIH1cbiAgICAgKiAgIF1cbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXREYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdzZXREYXRhJywgeyBzZXJpZXM6IHsgYnVsbGV0OiBkYXRhLnNlcmllcyB9IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlIHNlcmllcyBkYXRhIGxhYmVsLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmhpZGVTZXJpZXNEYXRhTGFiZWwoKTtcbiAgICAgKi9cbiAgICBoaWRlU2VyaWVzRGF0YUxhYmVsKCkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCd1cGRhdGVPcHRpb25zJywge1xuICAgICAgICAgICAgb3B0aW9uczogeyBzZXJpZXM6IHsgZGF0YUxhYmVsczogeyB2aXNpYmxlOiBmYWxzZSB9IH0gfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgc2VyaWVzIGRhdGEgbGFiZWwuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2hvd1Nlcmllc0RhdGFMYWJlbCgpO1xuICAgICAqL1xuICAgIHNob3dTZXJpZXNEYXRhTGFiZWwoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3VwZGF0ZU9wdGlvbnMnLCB7XG4gICAgICAgICAgICBvcHRpb25zOiB7IHNlcmllczogeyBkYXRhTGFiZWxzOiB7IHZpc2libGU6IHRydWUgfSB9IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBjaGFydCBvcHRpb25zIHRvIG5ldyBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ2hhcnQgb3B0aW9uc1xuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNldE9wdGlvbnMoe1xuICAgICAqICAgY2hhcnQ6IHtcbiAgICAgKiAgICAgd2lkdGg6IDUwMCxcbiAgICAgKiAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICogICAgIHRpdGxlOiAnRW5lcmd5IFVzYWdlJyxcbiAgICAgKiAgIH0sXG4gICAgICogICB4QXhpczoge1xuICAgICAqICAgICB0aXRsZTogJ01vbnRoJyxcbiAgICAgKiAgIH0sXG4gICAgICogICB5QXhpczoge1xuICAgICAqICAgICB0aXRsZTogJ0VuZXJneSAoa1doKScsXG4gICAgICogICB9LFxuICAgICAqICAgc2VyaWVzOiB7XG4gICAgICogICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICogICB9LFxuICAgICAqICAgdG9vbHRpcDoge1xuICAgICAqICAgICBmb3JtYXR0ZXI6ICh2YWx1ZSkgPT4gYCR7dmFsdWV9a1doYCxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICovXG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE9wdGlvbnNFdmVudCgnaW5pdE9wdGlvbnMnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNoYXJ0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDaGFydCBvcHRpb25zXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQudXBkYXRlT3B0aW9ucyh7XG4gICAgICogICBjaGFydDoge1xuICAgICAqICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgKiAgICAgdGl0bGU6ICdFbmVyZ3kgVXNhZ2UnLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHRvb2x0aXA6IHtcbiAgICAgKiAgICAgZm9ybWF0dGVyOiAodmFsdWUpID0+IGAke3ZhbHVlfWtXaGAsXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHVwZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hPcHRpb25zRXZlbnQoJ3VwZGF0ZU9wdGlvbnMnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXJpZXNJbmZvIC0gSW5mb3JtYXRpb24gb2YgdGhlIHNlcmllcyBmb3IgdGhlIHRvb2x0aXAgdG8gYmUgZGlzcGxheWVkLlxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHNlcmllc0luZm8uc2VyaWVzSW5kZXggLSBJbmRleCBvZiBzZXJpZXMuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2hvd1Rvb2x0aXAoe3Nlcmllc0luZGV4OiAxfSk7XG4gICAgICovXG4gICAgc2hvd1Rvb2x0aXAoc2VyaWVzSW5mbykge1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nob3dUb29sdGlwJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZXJpZXNJbmZvKSwgeyBzdGF0ZTogdGhpcy5zdG9yZS5zdGF0ZSB9KSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IFN0b3JlIGZyb20gXCIuLi9zdG9yZS9zdG9yZVwiO1xuaW1wb3J0IHJvb3QgZnJvbSBcIi4uL3N0b3JlL3Jvb3RcIjtcbmltcG9ydCBsYXlvdXQgZnJvbSBcIi4uL3N0b3JlL2xheW91dFwiO1xuaW1wb3J0IHNlcmllc0RhdGEgZnJvbSBcIi4uL3N0b3JlL3Nlcmllc0RhdGFcIjtcbmltcG9ydCBjYXRlZ29yeSBmcm9tIFwiLi4vc3RvcmUvY2F0ZWdvcnlcIjtcbmltcG9ydCBsZWdlbmQgZnJvbSBcIi4uL3N0b3JlL2xlZ2VuZFwiO1xuaW1wb3J0IG9wdGlvbnNTdG9yZSBmcm9tIFwiLi4vc3RvcmUvb3B0aW9uc1wiO1xuaW1wb3J0IHRoZW1lIGZyb20gXCIuLi9zdG9yZS90aGVtZVwiO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiLi4vZXZlbnRFbWl0dGVyXCI7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tIFwiLi4vY29tcG9uZW50L2NvbXBvbmVudE1hbmFnZXJcIjtcbmltcG9ydCBQYWludGVyIGZyb20gXCIuLi9wYWludGVyXCI7XG5pbXBvcnQgQW5pbWF0b3IgZnJvbSBcIi4uL2FuaW1hdG9yXCI7XG5pbXBvcnQgeyBkZWJvdW5jZSwgaXNCb29sZWFuLCBpc051bWJlciwgaXNVbmRlZmluZWQsIHBpY2ssIGlzQXV0b1ZhbHVlIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmltcG9ydCB7IHJlc3BvbmRlckRldGVjdG9ycyB9IGZyb20gXCIuLi9yZXNwb25kZXJEZXRlY3RvcnNcIjtcbmltcG9ydCB7IG1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZVwiO1xuaW1wb3J0IHsgc2VuZEhvc3RuYW1lIH0gZnJvbSBcIi4uL2hlbHBlcnMvZ29vZ2xlQW5hbHl0aWNzXCI7XG5pbXBvcnQgeyBtYWtlT2JzZXJ2YWJsZU9iamVjdFRvTm9ybWFsIH0gZnJvbSBcIi4uL3N0b3JlL3JlYWN0aXZlXCI7XG5pbXBvcnQgeyBpc01vdXNlSW5SZWN0IH0gZnJvbSBcIi4uL2hlbHBlcnMvY29vcmRpbmF0ZVwiO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQU5JTV9EVVJBVElPTiA9IDUwMDtcbmZ1bmN0aW9uIGdldFVzaW5nQ29udGFpbmVyU2l6ZShldmVudE5hbWUsIHVzaW5nQ29udGFpbmVyU2l6ZSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHsgd2lkdGg6IHVzaW5nQ29udGFpbmVyV2lkdGgsIGhlaWdodDogdXNpbmdDb250YWluZXJIZWlnaHQgfSA9IHVzaW5nQ29udGFpbmVyU2l6ZTtcbiAgICBjb25zdCBpc0F1dG9XaWR0aCA9IGlzQXV0b1ZhbHVlKHdpZHRoKTtcbiAgICBjb25zdCBpc0F1dG9IZWlnaHQgPSBpc0F1dG9WYWx1ZShoZWlnaHQpO1xuICAgIHJldHVybiBldmVudE5hbWUgPT09ICd1cGRhdGVPcHRpb25zJ1xuICAgICAgICA/IHtcbiAgICAgICAgICAgIHdpZHRoOiAhaXNVbmRlZmluZWQod2lkdGgpICYmIHVzaW5nQ29udGFpbmVyV2lkdGggIT09IGlzQXV0b1dpZHRoXG4gICAgICAgICAgICAgICAgPyBpc0F1dG9XaWR0aFxuICAgICAgICAgICAgICAgIDogdXNpbmdDb250YWluZXJXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogIWlzVW5kZWZpbmVkKGhlaWdodCkgJiYgdXNpbmdDb250YWluZXJIZWlnaHQgIT09IGlzQXV0b0hlaWdodFxuICAgICAgICAgICAgICAgID8gaXNBdXRvSGVpZ2h0XG4gICAgICAgICAgICAgICAgOiB1c2luZ0NvbnRhaW5lckhlaWdodCxcbiAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIHdpZHRoOiBpc0F1dG9XaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaXNBdXRvSGVpZ2h0LFxuICAgICAgICB9O1xufVxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhYnN0cmFjdFxuICogQWJzdHJhY3QgY2xhc3MgdXNlZCB0byBpbXBsZW1lbnQgZWFjaCBjaGFydC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhcnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdGhpcy5fX19hbmltSWRfX18gPSBudWxsO1xuICAgICAgICB0aGlzLnBhaW50ZXIgPSBuZXcgUGFpbnRlcih0aGlzKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5lbnRlcmVkQ29tcG9uZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkNvbnRyb2xGbGFnID0ge1xuICAgICAgICAgICAgcmVzaXppbmc6IGZhbHNlLFxuICAgICAgICAgICAgdXBkYXRpbmc6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZWJvdW5jZVJlc2l6ZUV2ZW50ID0gZGVib3VuY2UoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvZmZzZXRXaWR0aCwgb2Zmc2V0SGVpZ2h0IH0gPSB0aGlzLmNvbnRhaW5lckVsO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVDaGFydFNpemUob2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY2hlY2tlZCBsZWdlbmQgY2hhcnQgdHlwZSBhbmQgbGFiZWwsIGNoZWNrZWQgc3RhdGUuXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheTx7Y2hlY2tlZDogYm9vbGVhbiwgY2hhcnRUeXBlOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmd9Pn0gQXJyYXkgZGF0YSB0aGF0IHdoZXRoZXIgc2VyaWVzIGhhcyBjaGVja2VkXG4gICAgICAgICAqIEBhcGlcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogY29uc3QgY2hlY2tlZExlZ2VuZCA9IGNoYXJ0LmdldENoZWNrZWRMZWdlbmQoKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRDaGVja2VkTGVnZW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhIH0gPSB0aGlzLnN0b3JlLnN0YXRlLmxlZ2VuZDtcbiAgICAgICAgICAgIHJldHVybiBkYXRhXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoZGF0dW0pID0+IGRhdHVtLmNoZWNrZWQpXG4gICAgICAgICAgICAgICAgLm1hcCgoZGF0dW0pID0+IHBpY2soZGF0dW0sICdjaGFydFR5cGUnLCAnbGFiZWwnLCAnY2hlY2tlZCcpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBhcHBsaWVkIGNoYXJ0IG9wdGlvbnMuXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICogQGFwaVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBvcHRpb25zID0gY2hhcnQuZ2V0T3B0aW9ucygpO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRPcHRpb25zID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VPYnNlcnZhYmxlT2JqZWN0VG9Ob3JtYWwodGhpcy5zdG9yZS5pbml0U3RvcmVTdGF0ZS5vcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIG9mIHVzZXIgY3VzdG9tIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gRXZlbnQgbmFtZS4gJ2NsaWNrTGVnZW5kTGFiZWwnLCAnY2xpY2tMZWdlbmRDaGVja2JveCcsICdzZWxlY3RTZXJpZXMnLCAndW5zZWxlY3RTZXJpZXMnLCAnaG92ZXJTZXJpZXMnLCAndW5ob3ZlclNlcmllcycsICd6b29tJywgJ3Jlc2V0Wm9vbScgaXMgYXZhaWxhYmxlLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIC0gRXZlbnQgaGFuZGxlclxuICAgICAgICAgKiBAYXBpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uID0gKGV2ZW50TmFtZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZWdpc3RlciBFdmVudHMgdGhhdCBvY2N1ciB3aGVuIGNsaWNrIGxlZ2VuZCBsYWJlbFxuICAgICAgICAgICAgICogQGV2ZW50IENoYXJ0QmFzZSNjbGlja0xlZ2VuZExhYmVsXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5mbyBzZWxlY3RlZCBsZWdlbmQgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAqIEBhcGlcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBjaGFydC5vbignY2xpY2tMZWdlbmRMYWJlbCcsIChpbmZvKSA9PiB7XG4gICAgICAgICAgICAgKiAgIGNvbnNvbGUubG9nKGluZm8pO1xuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVnaXN0ZXIgRXZlbnRzIHRoYXQgb2NjdXIgd2hlbiBjbGljayBsZWdlbmQgY2hlY2tib3hcbiAgICAgICAgICAgICAqIEBldmVudCBDaGFydEJhc2UjY2xpY2tMZWdlbmRDaGVja2JveFxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGluZm8gc2VsZWN0ZWQgbGVnZW5kIGluZm9cbiAgICAgICAgICAgICAqIEBhcGlcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBjaGFydC5vbignY2xpY2tMZWdlbmRDaGVja2JveCcsIChpbmZvKSA9PiB7XG4gICAgICAgICAgICAgKiAgIGNvbnNvbGUubG9nKGluZm8pO1xuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVnaXN0ZXIgRXZlbnRzIHRoYXQgb2NjdXIgd2hlbiBzZWxlY3Qgc2VyaWVzXG4gICAgICAgICAgICAgKiBAZXZlbnQgQ2hhcnRCYXNlI3NlbGVjdFNlcmllc1xuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGluZm8gc2VsZWN0ZWQgc2VyaWVzIGluZm9cbiAgICAgICAgICAgICAqIEBhcGlcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBjaGFydC5vbignc2VsZWN0U2VyaWVzJywgKGluZm8pID0+IHtcbiAgICAgICAgICAgICAqICAgY29uc29sZS5sb2coaW5mbyk7XG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZWdpc3RlciBFdmVudHMgdGhhdCBvY2N1ciB3aGVuIHVuc2VsZWN0IHNlcmllc1xuICAgICAgICAgICAgICogQGV2ZW50IENoYXJ0QmFzZSN1bnNlbGVjdFNlcmllc1xuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGluZm8gdW5zZWxlY3RlZCBzZXJpZXMgaW5mb1xuICAgICAgICAgICAgICogQGFwaVxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIGNoYXJ0Lm9uKCd1bnNlbGVjdFNlcmllcycsIChpbmZvKSA9PiB7XG4gICAgICAgICAgICAgKiAgIGNvbnNvbGUubG9nKGluZm8pO1xuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVnaXN0ZXIgRXZlbnRzIHRoYXQgb2NjdXIgd2hlbiBob3ZlciB0byBzZXJpZXNcbiAgICAgICAgICAgICAqIEBldmVudCBDaGFydEJhc2UjaG92ZXJTZXJpZXNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbmZvIGhvdmVyZWQgc2VyaWVzIGluZm9cbiAgICAgICAgICAgICAqIEBhcGlcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBjaGFydC5vbignaG92ZXJTZXJpZXMnLCAoaW5mbykgPT4ge1xuICAgICAgICAgICAgICogICBjb25zb2xlLmxvZyhpbmZvKTtcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlZ2lzdGVyIEV2ZW50cyB0aGF0IG9jY3VyIHdoZW4gdW5ob3ZlciBmcm9tIHNlcmllc1xuICAgICAgICAgICAgICogQGV2ZW50IENoYXJ0QmFzZSN1bmhvdmVyU2VyaWVzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5mbyB1bmhvdmVyZWQgc2VyaWVzIGluZm9cbiAgICAgICAgICAgICAqIEBhcGlcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBjaGFydC5vbigndW5ob3ZlclNlcmllcycsIChpbmZvKSA9PiB7XG4gICAgICAgICAgICAgKiAgY29uc29sZS5sb2coaW5mbyk7XG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZWdpc3RlciBFdmVudHMgdGhhdCBvY2N1ciB3aGVuIHpvb21pbmdcbiAgICAgICAgICAgICAqIEBldmVudCBDaGFydEJhc2Ujem9vbVxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZGF0YVJhbmdlIC0gW11cbiAgICAgICAgICAgICAqIEBhcGlcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBjaGFydC5vbignem9vbScsIChkYXRhUmFuZ2UpID0+IHtcbiAgICAgICAgICAgICAqICAgIGNvbnNvbGUubG9nKGRhdGFSYW5nZSk7XG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZWdpc3RlciBFdmVudHMgdGhhdCBvY2N1ciB3aGVuIHpvb20gaXMgcmVzZXRcbiAgICAgICAgICAgICAqIEBldmVudCBDaGFydEJhc2UjcmVzZXRab29tXG4gICAgICAgICAgICAgKiBAYXBpXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogY2hhcnQub24oJ3Jlc2V0Wm9vbScsICgpID0+IHt9KTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdHJveXMgdGhlIGluc3RhbmNlLlxuICAgICAgICAgKiBAYXBpXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNoYXJ0LmRlc3Ryb3koKTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5jbGVhclJlc2l6ZUV2ZW50KCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lckVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VsZWN0IHNlcmllcy4gSXQgd29ya3Mgb25seSB3aGVuIHRoZSBzZWxlY3RhYmxlIG9wdGlvbiBpcyB0cnVlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VyaWVzSW5mbyAtIEluZm9ybWF0aW9uIG9mIHRoZSBzZXJpZXMgdG8gYmUgc2VsZWN0ZWRcbiAgICAgICAgICogICAgICBAcGFyYW0ge251bWJlcn0gW3Nlcmllc0luZm8uc2VyaWVzSW5kZXhdIC0gSW5kZXggb2Ygc2VyaWVzXG4gICAgICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IFtzZXJpZXNJbmZvLmluZGV4XSAtIEluZGV4IG9mIGRhdGEgd2l0aGluIHNlcmllc1xuICAgICAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBbc2VyaWVzSW5mby5uYW1lXSAtIFNwZWNpZnkgbmFtZSBmb3IgTmVzdGVkUGllIENoYXJ0XG4gICAgICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IFtzZXJpZXNJbmZvLmNoYXJ0VHlwZV0gLSBTcGVjaWZ5IHdoaWNoIGNoYXJ0IHRvIHNlbGVjdCB3aGVuIHVzaW5nIExpbmVBcmVhLCBMaW5lU2NhdHRlciwgYW5kIENvbHVtbkxpbmUgY2hhcnRzLnNwZWNpZmllcyB3aGljaCBjaGFydCB0byBzZWxlY3Qgd2hlbiB1c2luZyBMaW5lQXJlYSwgTGluZVNjYXR0ZXIsIGFuZCBDb2x1bW5MaW5lIGNoYXJ0cy5cbiAgICAgICAgICogQGFwaVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjaGFydC5zZWxlY3RTZXJpZXMoe2luZGV4OiAxLCBzZXJpZXNJbmRleDogMn0pO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RTZXJpZXMgPSAoc2VyaWVzSW5mbykgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzU2VsZWN0YWJsZVNlcmllcygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UuU0VMRUNUX1NFUklFU19BUElfU0VMRUNUQUJMRV9FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3NlbGVjdFNlcmllcycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VyaWVzSW5mbyksIHsgc3RhdGU6IHRoaXMuc3RvcmUuc3RhdGUgfSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5zZWxlY3Qgc2VsZWN0ZWQgc2VyaWVzLiBJdCB3b3JrcyBvbmx5IHdoZW4gdGhlIHNlbGVjdGFibGUgb3B0aW9uIGlzIHRydWUuXG4gICAgICAgICAqIEBhcGlcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogY2hhcnQudW5zZWxlY3RTZXJpZXMoKTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5zZWxlY3RTZXJpZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNTZWxlY3RhYmxlU2VyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZS5TRUxFQ1RfU0VSSUVTX0FQSV9TRUxFQ1RBQkxFX0VSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3NldEFsbExlZ2VuZEFjdGl2ZVN0YXRlJywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Jlc2V0U2VsZWN0ZWRTZXJpZXMnKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZSBjaGFydCBzaXplLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2l6ZSBDaGFydCBzaXplXG4gICAgICAgICAqICAgQHBhcmFtIHtudW1iZXJ9IFtzaXplLndpZHRoXSBXaWR0aFxuICAgICAgICAgKiAgIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZS5oZWlnaHRdIEhlaWdodFxuICAgICAgICAgKiBAYXBpXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNoYXJ0LnJlc2l6ZSh7aGVpZ2h0OiAxMDAsIHdpZHRoOiAyMDB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzaXplID0gKHNpemUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hPcHRpb25zRXZlbnQoJ3VwZGF0ZU9wdGlvbnMnLCB7IGNoYXJ0OiBPYmplY3QuYXNzaWduKHt9LCBzaXplKSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVzZXRIb3ZlcmVkU2VyaWVzJyk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Jlc2V0U2VsZWN0ZWRTZXJpZXMnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRSZXNpemVFdmVudExpc3RlbmVycyA9IChldmVudE5hbWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIGNvbnN0IHsgdXNpbmdDb250YWluZXJTaXplIH0gPSB0aGlzLnN0b3JlLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aDogdXNpbmdDb250YWluZXJXaWR0aCwgaGVpZ2h0OiB1c2luZ0NvbnRhaW5lckhlaWdodCB9ID0gdXNpbmdDb250YWluZXJTaXplO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSAoX2IgPSAoX2EgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2hhcnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IChfZCA9IChfYyA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jaGFydCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGlzQXV0b1dpZHRoID0gaXNBdXRvVmFsdWUod2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgaXNBdXRvSGVpZ2h0ID0gaXNBdXRvVmFsdWUoaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3NldFVzaW5nQ29udGFpbmVyU2l6ZScsIGdldFVzaW5nQ29udGFpbmVyU2l6ZShldmVudE5hbWUsIHVzaW5nQ29udGFpbmVyU2l6ZSwgd2lkdGgsIGhlaWdodCkpO1xuICAgICAgICAgICAgaWYgKCh1c2luZ0NvbnRhaW5lcldpZHRoIHx8IHVzaW5nQ29udGFpbmVySGVpZ2h0KSAmJiBpc051bWJlcih3aWR0aCkgJiYgaXNOdW1iZXIoaGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJSZXNpemVFdmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoISh1c2luZ0NvbnRhaW5lcldpZHRoIHx8IHVzaW5nQ29udGFpbmVySGVpZ2h0KSAmJiAoaXNBdXRvV2lkdGggfHwgaXNBdXRvSGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVzaXplRXZlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgeyBlbCwgb3B0aW9ucywgc2VyaWVzLCBjYXRlZ29yaWVzLCBtb2R1bGVzIH0gPSBwcm9wcztcbiAgICAgICAgdGhpcy5tb2R1bGVzID0gKG1vZHVsZXMgIT09IG51bGwgJiYgbW9kdWxlcyAhPT0gdm9pZCAwID8gbW9kdWxlcyA6IFtdKTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKG9wdGlvbnMudXNhZ2VTdGF0aXN0aWNzKSB8fCBvcHRpb25zLnVzYWdlU3RhdGlzdGljcykge1xuICAgICAgICAgICAgc2VuZEhvc3RuYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250YWluZXJFbCA9IGVsO1xuICAgICAgICB0aGlzLmVsID0gdGhpcy5jcmVhdGVDaGFydFdyYXBwZXIoKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcbiAgICAgICAgdGhpcy5hbmltYXRvciA9IG5ldyBBbmltYXRvcigpO1xuICAgICAgICB0aGlzLnN0b3JlID0gbmV3IFN0b3JlKHtcbiAgICAgICAgICAgIHNlcmllcyxcbiAgICAgICAgICAgIGNhdGVnb3JpZXMsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyID0gbmV3IENvbXBvbmVudE1hbmFnZXIoe1xuICAgICAgICAgICAgc3RvcmU6IHRoaXMuc3RvcmUsXG4gICAgICAgICAgICBldmVudEJ1czogdGhpcy5ldmVudEJ1cyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMub24oJ25lZWRMb29wJywgZGVib3VuY2UoKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGxldCBkdXJhdGlvbiA9IHRoaXMuZ2V0QW5pbWF0aW9uRHVyYXRpb24oKF9hID0gb3B0aW9ucy5jaGFydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFuaW1hdGlvbik7XG4gICAgICAgICAgICBpZiAodGhpcy5hbmltYXRpb25Db250cm9sRmxhZy5yZXNpemluZykge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gaXNVbmRlZmluZWQob3B0aW9ucy5yZXNwb25zaXZlKVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuZ2V0QW5pbWF0aW9uRHVyYXRpb24oKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuZ2V0QW5pbWF0aW9uRHVyYXRpb24oKF9iID0gb3B0aW9ucy5yZXNwb25zaXZlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkNvbnRyb2xGbGFnLnJlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ2xvb3BTdGFydCcpO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRvci5hZGQoe1xuICAgICAgICAgICAgICAgIG9uQ29tcGxldGVkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbG9vcENvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjaGFydDogdGhpcyxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZXI6IHRoaXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMTApKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignbmVlZFN1Ykxvb3AnLCAob3B0cykgPT4ge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRvci5hZGQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzKSwgeyBjaGFydDogdGhpcyB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLm9uKCduZWVkRHJhdycsIGRlYm91bmNlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgICB9LCAxMCkpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5zdG9yZS5vYnNlcnZlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5zZXR1cCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzQXV0b1ZhbHVlKChfYiA9IChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jaGFydCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLndpZHRoKSB8fCBpc0F1dG9WYWx1ZSgoX2QgPSAoX2MgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2hhcnQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5oZWlnaHQpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFJlc2l6ZUV2ZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0QW5pbWF0aW9uRHVyYXRpb24oYW5pbWF0aW9uT3B0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgZmlyc3RSZW5kZXJpbmcgfSA9IHRoaXMuYW5pbWF0b3I7XG4gICAgICAgIGNvbnN0IHsgcmVzaXppbmcsIHVwZGF0aW5nIH0gPSB0aGlzLmFuaW1hdGlvbkNvbnRyb2xGbGFnO1xuICAgICAgICBsZXQgZHVyYXRpb247XG4gICAgICAgIGlmICgoIWZpcnN0UmVuZGVyaW5nICYmICFyZXNpemluZykgfHwgaXNVbmRlZmluZWQoYW5pbWF0aW9uT3B0aW9uKSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBERUZBVUxUX0FOSU1fRFVSQVRJT047XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKGFuaW1hdGlvbk9wdGlvbikpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gYW5pbWF0aW9uT3B0aW9uID8gREVGQVVMVF9BTklNX0RVUkFUSU9OIDogMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc051bWJlcihhbmltYXRpb25PcHRpb24uZHVyYXRpb24pKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IGFuaW1hdGlvbk9wdGlvbi5kdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRpbmcpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuaW1hdGlvbkNvbnRyb2xGbGFnLnVwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbjtcbiAgICB9XG4gICAgY3JlYXRlQ2hhcnRXcmFwcGVyKCkge1xuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCd0b2FzdHVpLWNoYXJ0LXdyYXBwZXInKTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgICByZXNpemVDaGFydFNpemUoY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodCkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkNvbnRyb2xGbGFnLnJlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyB1c2luZ0NvbnRhaW5lclNpemU6IHsgd2lkdGg6IHVzaW5nQ29udGFpbmVyV2lkdGgsIGhlaWdodDogdXNpbmdDb250YWluZXJIZWlnaHQgfSwgY2hhcnQ6IHsgd2lkdGgsIGhlaWdodCB9LCB9ID0gdGhpcy5zdG9yZS5zdGF0ZTtcbiAgICAgICAgaWYgKCEodXNpbmdDb250YWluZXJXaWR0aCB8fCB1c2luZ0NvbnRhaW5lckhlaWdodCkgfHxcbiAgICAgICAgICAgICEoY29udGFpbmVyV2lkdGggfHwgY29udGFpbmVySGVpZ2h0KSB8fFxuICAgICAgICAgICAgKGNvbnRhaW5lcldpZHRoID09PSB3aWR0aCAmJiBjb250YWluZXJIZWlnaHQgPT09IGhlaWdodCkpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uQ29udHJvbEZsYWcucmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogRm9yIHVwZGF0ZXMgd2hlcmUgdGhlIGRhdGEgZG9lc24ndCBjaGFuZ2UsIGl0IGxvb2tzIGdvb2QgdG8gcmVjYWxjdWxhdGUgdGhlIHNlbGVjdGVkIHNlcmllcyBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdzZXRDaGFydFNpemUnLCB7XG4gICAgICAgICAgICB3aWR0aDogdXNpbmdDb250YWluZXJXaWR0aCA/IGNvbnRhaW5lcldpZHRoIDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHVzaW5nQ29udGFpbmVySGVpZ2h0ID8gY29udGFpbmVySGVpZ2h0IDogaGVpZ2h0LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgfVxuICAgIHNldFJlc2l6ZUV2ZW50KCkge1xuICAgICAgICBjb25zdCB7IHVzaW5nQ29udGFpbmVyU2l6ZSB9ID0gdGhpcy5zdG9yZS5zdGF0ZTtcbiAgICAgICAgaWYgKCh1c2luZ0NvbnRhaW5lclNpemUuaGVpZ2h0ICYmICF0aGlzLmNvbnRhaW5lckVsLnN0eWxlLmhlaWdodC5sZW5ndGgpIHx8XG4gICAgICAgICAgICAodXNpbmdDb250YWluZXJTaXplLndpZHRoICYmICF0aGlzLmNvbnRhaW5lckVsLnN0eWxlLndpZHRoLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlLkFVVE9fTEFZT1VUX0NPTlRBSU5FUl9TSVpFX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1Jlc2l6ZU9ic2VydmVyQVBJRXhpc3QgPSB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAoaXNSZXNpemVPYnNlcnZlckFQSUV4aXN0KSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5kZWJvdW5jZVJlc2l6ZUV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYm91bmNlUmVzaXplRXZlbnQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuY29udGFpbmVyRWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyUmVzaXplRXZlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZSh0aGlzLmNvbnRhaW5lckVsKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5kZWJvdW5jZVJlc2l6ZUV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDYW52YXNNb3VzZUV2ZW50KGV2ZW50VHlwZSwgbW91c2VQb3NpdGlvbikge1xuICAgICAgICBjb25zdCBuZXdFbnRlcmVkQ29tcG9uZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuZm9yRWFjaCgoY29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnRUeXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0ID0gdGhpcy5lbnRlcmVkQ29tcG9uZW50cy5zb21lKChlbnRlcmVkQ29tcG9uZW50KSA9PiBlbnRlcmVkQ29tcG9uZW50ID09PSBjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChpc01vdXNlSW5SZWN0KGNvbXBvbmVudC5yZWN0LCBtb3VzZVBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdFbnRlcmVkQ29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXhpc3QgJiYgY29tcG9uZW50Lm9uTW91c2VlbnRlckNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm9uTW91c2VlbnRlckNvbXBvbmVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV4aXN0ICYmIGNvbXBvbmVudC5vbk1vdXNlb3V0Q29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vbk1vdXNlb3V0Q29tcG9uZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRUeXBlID09PSAnbW91c2VvdXQnICYmIGNvbXBvbmVudC5vbk1vdXNlb3V0Q29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50Lm9uTW91c2VvdXRDb21wb25lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW50ZXJlZENvbXBvbmVudHMgPSBuZXdFbnRlcmVkQ29tcG9uZW50cztcbiAgICB9XG4gICAgaGFuZGxlUmVzcG9uZGVyRXZlbnQoZXZlbnQsIG1vdXNlUG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgZXZlbnRUeXBlID0gZXZlbnQudHlwZTtcbiAgICAgICAgY29uc3QgZGVsZWdhdGlvbk1ldGhvZCA9IGBvbiR7ZXZlbnRUeXBlWzBdLnRvVXBwZXJDYXNlKCkgKyBldmVudFR5cGUuc3Vic3RyaW5nKDEpfWA7XG4gICAgICAgIGNvbnN0IGFsbFJlc3BvbmRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmZvckVhY2goKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjb21wb25lbnRbZGVsZWdhdGlvbk1ldGhvZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3BvbmRlckRldGVjdG9ycy5yZWN0KG1vdXNlUG9zaXRpb24sIGNvbXBvbmVudC5yZWN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRldGVjdGVkID0gKGNvbXBvbmVudC5yZXNwb25kZXJzIHx8IFtdKS5maWx0ZXIoKG0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uZGVyRGV0ZWN0b3JzW20udHlwZV0obW91c2VQb3NpdGlvbiwgbSwgY29tcG9uZW50LnJlY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZGV0ZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYWxsUmVzcG9uZGVycy5wdXNoKHsgY29tcG9uZW50LCBkZXRlY3RlZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudFtkZWxlZ2F0aW9uTWV0aG9kXSh7IG1vdXNlUG9zaXRpb24sIHJlc3BvbmRlcnM6IGRldGVjdGVkIH0sIGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmhhbmRsZUV2ZW50Rm9yQWxsUmVzcG9uZGVycykge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFdmVudEZvckFsbFJlc3BvbmRlcnMoZXZlbnQsIGFsbFJlc3BvbmRlcnMsIGRlbGVnYXRpb25NZXRob2QsIG1vdXNlUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSwgdHlwZTogZXZlbnRUeXBlIH0gPSBldmVudDtcbiAgICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5wYWludGVyLmN0eC5jYW52YXM7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wIH0gPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBzY2FsZSBmb3IgY2hhcnQgYWZmZWN0ZWQgYnkgYSBDU1MgdHJhbnNmb3JtLlxuICAgICAgICBjb25zdCBzY2FsZVggPSB3aWR0aCAvIGNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICAgICAgY29uc3Qgc2NhbGVZID0gaGVpZ2h0IC8gY2FudmFzLm9mZnNldEhlaWdodDtcbiAgICAgICAgY29uc3QgbW91c2VQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IChjbGllbnRYIC0gbGVmdCkgLyBzY2FsZVgsXG4gICAgICAgICAgICB5OiAoY2xpZW50WSAtIHRvcCkgLyBzY2FsZVksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChldmVudFR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IGV2ZW50VHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDYW52YXNNb3VzZUV2ZW50KGV2ZW50VHlwZSwgbW91c2VQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVSZXNwb25kZXJFdmVudChldmVudCwgbW91c2VQb3NpdGlvbik7XG4gICAgfVxuICAgIGluaXRTdG9yZSgpIHtcbiAgICAgICAgW1xuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIG9wdGlvbnNTdG9yZSxcbiAgICAgICAgICAgIHRoZW1lLFxuICAgICAgICAgICAgc2VyaWVzRGF0YSxcbiAgICAgICAgICAgIGxlZ2VuZCxcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgIGNhdGVnb3J5LFxuICAgICAgICAgICAgLi4udGhpcy5tb2R1bGVzLFxuICAgICAgICBdLmZvckVhY2goKG1vZHVsZSkgPT4gdGhpcy5zdG9yZS5zZXRNb2R1bGUobW9kdWxlKSk7XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMuaW5pdFN0b3JlKCk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2luaXRDaGFydFNpemUnLCB0aGlzLmNvbnRhaW5lckVsKTtcbiAgICB9XG4gICAgZHJhdygpIHtcbiAgICAgICAgdGhpcy5wYWludGVyLmJlZm9yZUZyYW1lKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5mb3JFYWNoKChjb21wb25lbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghY29tcG9uZW50LmlzU2hvdykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5iZWZvcmVEcmF3KGNvbXBvbmVudC5yZWN0LngsIGNvbXBvbmVudC5yZWN0LnkpO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5iZWZvcmVEcmF3KSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmJlZm9yZURyYXcodGhpcy5wYWludGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudC5kcmF3KHRoaXMucGFpbnRlcik7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIuYWZ0ZXJEcmF3KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGUoZGVsdGEpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmludm9rZSgndXBkYXRlJywgZGVsdGEpO1xuICAgIH1cbiAgICBpbml0VXBkYXRlKGRlbHRhKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5pbnZva2UoJ2luaXRVcGRhdGUnLCBkZWx0YSk7XG4gICAgfVxuICAgIGlzU2VsZWN0YWJsZVNlcmllcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5zdG9yZS5pbml0U3RvcmVTdGF0ZS5vcHRpb25zLnNlcmllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlbGVjdGFibGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0b29sdGlwIG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2Zmc2V0IC0gT2Zmc2V0IHNpemVcbiAgICAgKiAgIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0LnhdIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIGhvcml6b250YWxseVxuICAgICAqICAgQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQueV0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgdmVydGljYWxseVxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNldFRvb2x0aXBPZmZzZXQoe3g6IDEwLCB5OiAtMjB9KTtcbiAgICAgKi9cbiAgICBzZXRUb29sdGlwT2Zmc2V0KG9mZnNldCkge1xuICAgICAgICBjb25zdCB7IHg6IG9mZnNldFgsIHk6IG9mZnNldFkgfSA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgndXBkYXRlT3B0aW9ucycsIHsgb3B0aW9uczogeyB0b29sdGlwOiB7IG9mZnNldFgsIG9mZnNldFkgfSB9IH0pO1xuICAgIH1cbiAgICBkaXNwYXRjaE9wdGlvbnNFdmVudChldmVudE5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZXRSZXNpemVFdmVudExpc3RlbmVycyhldmVudE5hbWUsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB7IG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQgfSA9IHRoaXMuY29udGFpbmVyRWw7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goZXZlbnROYW1lLCB7XG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgY29udGFpbmVyU2l6ZTogeyB3aWR0aDogb2Zmc2V0V2lkdGgsIGhlaWdodDogb2Zmc2V0SGVpZ2h0IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCBDaGFydCBmcm9tIFwiLi9jaGFydFwiO1xuaW1wb3J0IGRhdGFSYW5nZSBmcm9tIFwiLi4vc3RvcmUvZGF0YVJhbmdlXCI7XG5pbXBvcnQgc3RhY2tTZXJpZXNEYXRhIGZyb20gXCIuLi9zdG9yZS9zdGFja1Nlcmllc0RhdGFcIjtcbmltcG9ydCBzY2FsZSBmcm9tIFwiLi4vc3RvcmUvc2NhbGVcIjtcbmltcG9ydCBheGVzIGZyb20gXCIuLi9zdG9yZS9heGVzXCI7XG5pbXBvcnQgcGxvdCBmcm9tIFwiLi4vc3RvcmUvcGxvdFwiO1xuaW1wb3J0IEF4aXMgZnJvbSBcIi4uL2NvbXBvbmVudC9heGlzXCI7XG5pbXBvcnQgQm94U2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvYm94U2VyaWVzXCI7XG5pbXBvcnQgQm94U3RhY2tTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9ib3hTdGFja1Nlcmllc1wiO1xuaW1wb3J0IFBsb3QgZnJvbSBcIi4uL2NvbXBvbmVudC9wbG90XCI7XG5pbXBvcnQgVG9vbHRpcCBmcm9tIFwiLi4vY29tcG9uZW50L3Rvb2x0aXBcIjtcbmltcG9ydCBMZWdlbmQgZnJvbSBcIi4uL2NvbXBvbmVudC9sZWdlbmRcIjtcbmltcG9ydCBEYXRhTGFiZWxzIGZyb20gXCIuLi9jb21wb25lbnQvZGF0YUxhYmVsc1wiO1xuaW1wb3J0IFRpdGxlIGZyb20gXCIuLi9jb21wb25lbnQvdGl0bGVcIjtcbmltcG9ydCBBeGlzVGl0bGUgZnJvbSBcIi4uL2NvbXBvbmVudC9heGlzVGl0bGVcIjtcbmltcG9ydCBFeHBvcnRNZW51IGZyb20gXCIuLi9jb21wb25lbnQvZXhwb3J0TWVudVwiO1xuaW1wb3J0IFplcm9BeGlzIGZyb20gXCIuLi9jb21wb25lbnQvemVyb0F4aXNcIjtcbmltcG9ydCBIb3ZlcmVkU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvaG92ZXJlZFNlcmllc1wiO1xuaW1wb3J0IFNlbGVjdGVkU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvc2VsZWN0ZWRTZXJpZXNcIjtcbmltcG9ydCBCYWNrZ3JvdW5kIGZyb20gXCIuLi9jb21wb25lbnQvYmFja2dyb3VuZFwiO1xuaW1wb3J0IE5vRGF0YVRleHQgZnJvbSBcIi4uL2NvbXBvbmVudC9ub0RhdGFUZXh0XCI7XG5pbXBvcnQgUmFuZ2VTZWxlY3Rpb24gZnJvbSBcIi4uL2NvbXBvbmVudC9yYW5nZVNlbGVjdGlvblwiO1xuaW1wb3J0ICogYXMgYmFzaWNCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9iYXNpY1wiO1xuaW1wb3J0ICogYXMgYXhpc0JydXNoIGZyb20gXCIuLi9icnVzaGVzL2F4aXNcIjtcbmltcG9ydCAqIGFzIGxlZ2VuZEJydXNoIGZyb20gXCIuLi9icnVzaGVzL2xlZ2VuZFwiO1xuaW1wb3J0ICogYXMgbGFiZWxCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9sYWJlbFwiO1xuaW1wb3J0ICogYXMgZXhwb3J0TWVudUJydXNoIGZyb20gXCIuLi9icnVzaGVzL2V4cG9ydE1lbnVcIjtcbmltcG9ydCAqIGFzIGRhdGFMYWJlbEJydXNoIGZyb20gXCIuLi9icnVzaGVzL2RhdGFMYWJlbFwiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBjbGFzc2Rlc2MgQ29sdW1uIENoYXJ0XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gcHJvcHMuZWwgLSBUaGUgdGFyZ2V0IGVsZW1lbnQgdG8gY3JlYXRlIGNoYXJ0LlxuICogICBAcGFyYW0ge09iamVjdH0gcHJvcHMuZGF0YSAtIERhdGEgZm9yIG1ha2luZyBDb2x1bW4gQ2hhcnQuXG4gKiAgICAgQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBwcm9wcy5kYXRhLmNhdGVnb3JpZXMgLSBDYXRlZ29yaWVzLlxuICogICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcHJvcHMuZGF0YS5zZXJpZXMgLSBTZXJpZXMgZGF0YS5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy5kYXRhLnNlcmllcy5uYW1lIC0gU2VyaWVzIG5hbWUuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gcHJvcHMuZGF0YS5zZXJpZXMuY29sb3JCeUNhdGVnb3JpZXMgLSBQYWludCBSZWN0IHdpdGggY29sb3IgYmFzZWQgb24gY2F0ZWdvcmllcy5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8bnVtYmVyfEFycmF5PG51bWJlcj4+fSBwcm9wcy5kYXRhLnNlcmllcy5kYXRhIC0gU2VyaWVzIGRhdGEuXG4gKiAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9uc10gLSBPcHRpb25zIGZvciBtYWtpbmcgQ29sdW1uIENoYXJ0LlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaGFydF1cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGVdIC0gQ2hhcnQgdGl0bGUgdGV4dCBvciBvcHRpb25zLlxuICogICAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUudGV4dF0gLSBDaGFydCB0aXRsZSB0ZXh0LlxuICogICAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUub2Zmc2V0WF0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSBob3Jpem9udGFsbHkuXG4gKiAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS5vZmZzZXRZXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIHZlcnRpY2FsbHkuXG4gKiAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS5hbGlnbl0gLSBDaGFydCB0ZXh0IGFsaWduLiAnbGVmdCcsICdyaWdodCcsICdjZW50ZXInIGlzIGF2YWlsYWJsZS5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbl0gLSBXaGV0aGVyIHRvIHVzZSBhbmltYXRpb24gYW5kIGR1cmF0aW9uIHdoZW4gcmVuZGVyaW5nIHRoZSBpbml0aWFsIGNoYXJ0LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC53aWR0aF0gLSBDaGFydCB3aWR0aC4gJ2F1dG8nIG9yIGlmIG5vdCB3cml0ZSwgdGhlIHdpZHRoIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLiAnYXV0bycgb3IgaWYgbm90IGNyZWF0ZWQsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQuaGVpZ2h0XSAtIENoYXJ0IGhlaWdodC4gJ2F1dG8nIG9yIGlmIG5vdCB3cml0ZSwgdGhlIHdpZHRoIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLiAnYXV0bycgb3IgaWYgbm90IGNyZWF0ZWQsIHRoZSBoZWlnaHQgb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnNlcmllc11cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLnNlbGVjdGFibGU9ZmFsc2VdIC0gV2hldGhlciB0byBtYWtlIHNlbGVjdGFibGUgc2VyaWVzIG9yIG5vdC5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLnJhbmdlU2VsZWN0YWJsZT1mYWxzZV0gLSBXaGV0aGVyIHRvIHVzZSByYW5nZSBzZWxlY3Rpb24gZmVhdHVyZSBvciBub3QuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLmJhcldpZHRoXSAtIEJhciB3aWR0aC5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLmRpdmVyZ2luZ10gLSBXaGV0aGVyIHRvIHVzZSBkaXZlcmdpbmcgY2hhcnQgb3Igbm90LlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnNlcmllcy5zdGFja10gLSBPcHRpb24gdG8gdXNlIHRoZSBzdGFjayBjaGFydCBvciwgaWYgc28sIHdoYXQgdHlwZSBvZiBzdGFjayB0byB1c2UuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLmV2ZW50RGV0ZWN0VHlwZV0gLSBFdmVudCBkZXRlY3QgdHlwZS4gJ2dyb3VwZWQnLCAncG9pbnQnIGlzIGF2YWlsYWJsZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5zZXJpZXMuZGF0YUxhYmVsc10gLSBTZXQgdGhlIHZpc2liaWxpdHksIGxvY2F0aW9uLCBhbmQgZm9ybWF0dGluZyBvZiBkYXRhTGFiZWwuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxEYXRhTGFiZWxzIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5zaGlmdD1mYWxzZV0gLSBXaGV0aGVyIHRvIHVzZSBzaGlmdCB3aGVuIGFkZERhdGEgb3Igbm90LlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpc11cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXMudGl0bGVdIC0gQXhpcyB0aXRsZS5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMueEF4aXMucm90YXRlTGFiZWw9dHJ1ZV0gLSBXaGV0aGVyIHRvIGFsbG93IGF4aXMgbGFiZWwgcm90YXRpb24uXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy5kYXRlXSAtIFdoZXRoZXIgdGhlIHggYXhpcyBsYWJlbCBpcyBvZiBkYXRlIHR5cGUuIEZvcm1hdCBvcHRpb24gdXNlZCBmb3IgZGF0ZSB0eXBlLiBXaGV0aGVyIHRoZSB4IGF4aXMgbGFiZWwgaXMgb2YgZGF0ZSB0eXBlLiBJZiB1c2UgZGF0ZSB0eXBlLCBmb3JtYXQgb3B0aW9uIHVzZWQgZm9yIGRhdGUgdHlwZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy50aWNrXSAtIE9wdGlvbiB0byBhZGp1c3QgdGljayBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy5sYWJlbF0gLSBPcHRpb24gdG8gYWRqdXN0IGxhYmVsIGludGVydmFsLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLnNjYWxlXSAtIE9wdGlvbiB0byBhZGp1c3QgYXhpcyBtaW5pbXVtLCBtYXhpbXVtLCBzdGVwIHNpemUuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMueEF4aXMud2lkdGhdIC0gV2lkdGggb2YgeEF4aXMuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMueEF4aXMuaGVpZ2h0XSAtIEhlaWdodCBvZiB4QXhpcy5cbiAqICAgICBAcGFyYW0ge09iamVjdHxBcnJheTxPYmplY3Q+fSBbcHJvcHMub3B0aW9ucy55QXhpc10gLSBJZiB0aGlzIG9wdGlvbiBpcyBhbiBhcnJheSB0eXBlLCB1c2UgdGhlIHNlY29uZGFyeSB5IGF4aXMuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLnlBeGlzLnRpdGxlXSAtIEF4aXMgdGl0bGUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueUF4aXMudGlja10gLSBPcHRpb24gdG8gYWRqdXN0IHRpY2sgaW50ZXJ2YWwuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueUF4aXMubGFiZWxdIC0gT3B0aW9uIHRvIGFkanVzdCBsYWJlbCBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpcy5zY2FsZV0gLSBPcHRpb24gdG8gYWRqdXN0IGF4aXMgbWluaW11bSwgbWF4aW11bSwgc3RlcCBzaXplLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnlBeGlzLndpZHRoXSAtIFdpZHRoIG9mIHlBeGlzLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnlBeGlzLmhlaWdodF0gLSBIZWlnaHQgb2YgeUF4aXMuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnBsb3RdXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMucGxvdC53aWR0aF0gLSBXaWR0aCBvZiBwbG90LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnBsb3QuaGVpZ2h0XSAtIEhlaWdodCBvZiBwbG90LlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5wbG90LnZpc2libGVdIC0gV2hldGhlciB0byBzaG93IHBsb3QgbGluZS5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGVnZW5kXVxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC5hbGlnbl0gLSBMZWdlbmQgYWxpZ24uICd0b3AnLCAnYm90dG9tJywgJ3JpZ2h0JywgJ2xlZnQnIGlzIGF2YWlsYWJsZS5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5sZWdlbmQuc2hvd0NoZWNrYm94XSAtIFdoZXRoZXIgdG8gc2hvdyBjaGVja2JveC5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMubGVnZW5kLnZpc2libGVdIC0gV2hldGhlciB0byBzaG93IGxlZ2VuZC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5sZWdlbmQud2lkdGhdIC0gV2lkdGggb2YgbGVnZW5kLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC5pdGVtXSAtIGB3aWR0aGAgYW5kIGBvdmVyZmxvd2Agb3B0aW9ucyBvZiB0aGUgbGVnZW5kIGl0ZW0uIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxMZWdlbmQgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuZXhwb3J0TWVudV1cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuZXhwb3J0TWVudS52aXNpYmxlXSAtIFdoZXRoZXIgdG8gc2hvdyBleHBvcnQgbWVudS5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5leHBvcnRNZW51LmZpbGVuYW1lXSAtIEZpbGUgbmFtZSBhcHBsaWVkIHdoZW4gZG93bmxvYWRpbmcuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRvb2x0aXBdXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC5vZmZzZXRYXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIGhvcml6b250YWxseS5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy50b29sdGlwLm9mZnNldFldIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgdmVydGljYWxseS5cbiAqICAgICAgIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAuZm9ybWF0dGVyXSAtIEZ1bmN0aW9uIHRvIGZvcm1hdCBkYXRhIHZhbHVlLlxuICogICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC50ZW1wbGF0ZV0gLSBGdW5jdGlvbiB0byBjcmVhdGUgY3VzdG9tIHRlbXBsYXRlLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8VG9vbHRpcCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5yZXNwb25zaXZlXSAtIFJ1bGVzIGZvciBjaGFuZ2luZyBjaGFydCBvcHRpb25zLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8UmVzcG9uc2l2ZSBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufE9iamVjdH0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZS5hbmltYXRpb25dIC0gQW5pbWF0aW9uIGR1cmF0aW9uIHdoZW4gdGhlIGNoYXJ0IGlzIG1vZGlmaWVkLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBbcHJvcHMub3B0aW9ucy5yZXNwb25zaXZlLnJ1bGVzXSAtIFJ1bGVzIGZvciB0aGUgQ2hhcnQgdG8gUmVzcG9uZC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGFuZ10gLSBPcHRpb25zIGZvciBjaGFuZ2luZyB0aGUgdGV4dCBkaXNwbGF5ZWQgb24gdGhlIGNoYXJ0IG9yIGkxOG4gbGFuZ3VhZ2VzLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxhbmcubm9EYXRhXSAtIE5vIERhdGEgTGF5ZXIgVGV4dC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWVdIC0gQ2hhcnQgdGhlbWUgb3B0aW9ucy4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fEJhciBDaGFydCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmNoYXJ0XSAtIENoYXJ0IGZvbnQgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUubm9EYXRhXSAtIE5vIERhdGEgTGF5ZXIgVGV4dCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5zZXJpZXNdIC0gU2VyaWVzIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnRpdGxlXSAtIFRpdGxlIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnhBeGlzXSAtIFggQXhpcyB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fEFycmF5PE9iamVjdD59IFtwcm9wcy5vcHRpb25zLnRoZW1lLnlBeGlzXSAtIFkgQXhpcyB0aGVtZS4gSW4gdGhlIGNhc2Ugb2YgYW4gYXJyYW5nZW1lbnQsIHRoZSBmaXJzdCBpcyB0aGUgbWFpbiBheGlzIGFuZCB0aGUgc2Vjb25kIGlzIHRoZSB0aGVtZSBmb3IgdGhlIHNlY29uZGFyeSBheGlzLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmxlZ2VuZF0gLSBMZWdlbmQgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUudG9vbHRpcF0gLSBUb29sdGlwIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnBsb3RdIC0gUGxvdCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5leHBvcnRNZW51XSAtIEV4cG9ydE1lbnUgdGhlbWUuXG4gKiBAZXh0ZW5kcyBDaGFydFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2x1bW5DaGFydCBleHRlbmRzIENoYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcih7IGVsLCBvcHRpb25zLCBkYXRhIH0pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgc2VyaWVzOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBkYXRhLnNlcmllcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYXRlZ29yaWVzOiBkYXRhLmNhdGVnb3JpZXMsXG4gICAgICAgICAgICBtb2R1bGVzOiBbc3RhY2tTZXJpZXNEYXRhLCBkYXRhUmFuZ2UsIHNjYWxlLCBheGVzLCBwbG90XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICAgICAgICBjb25zdCBzdGFja0NoYXJ0ID0gISEoKF9hID0gdGhpcy5zdG9yZS5pbml0U3RvcmVTdGF0ZS5vcHRpb25zLnNlcmllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YWNrKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChCYWNrZ3JvdW5kKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChUaXRsZSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoUGxvdCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoTGVnZW5kKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChCb3hTdGFja1NlcmllcywgeyBuYW1lOiAnY29sdW1uJywgc3RhY2tDaGFydCB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChCb3hTZXJpZXMsIHsgbmFtZTogJ2NvbHVtbicsIHN0YWNrQ2hhcnQgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoWmVyb0F4aXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEF4aXMsIHsgbmFtZTogJ3hBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzLCB7IG5hbWU6ICd5QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpc1RpdGxlLCB7IG5hbWU6ICd4QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpc1RpdGxlLCB7IG5hbWU6ICd5QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoRXhwb3J0TWVudSwgeyBjaGFydEVsOiB0aGlzLmVsIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEhvdmVyZWRTZXJpZXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFNlbGVjdGVkU2VyaWVzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChEYXRhTGFiZWxzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChUb29sdGlwLCB7IGNoYXJ0RWw6IHRoaXMuZWwgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoTm9EYXRhVGV4dCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoUmFuZ2VTZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLnBhaW50ZXIuYWRkR3JvdXBzKFtcbiAgICAgICAgICAgIGJhc2ljQnJ1c2gsXG4gICAgICAgICAgICBheGlzQnJ1c2gsXG4gICAgICAgICAgICBsZWdlbmRCcnVzaCxcbiAgICAgICAgICAgIGxhYmVsQnJ1c2gsXG4gICAgICAgICAgICBleHBvcnRNZW51QnJ1c2gsXG4gICAgICAgICAgICBkYXRhTGFiZWxCcnVzaCxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyfEFycmF5PG51bWJlcj4+fSBkYXRhIC0gQXJyYXkgb2YgZGF0YSB0byBiZSBhZGRlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYXRlZ29yeSAtIENhdGVnb3J5IHRvIGJlIGFkZGVkXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuYWRkRGF0YShbMTAsIDIwXSwgJzYnKTtcbiAgICAgKi9cbiAgICBhZGREYXRhKGRhdGEsIGNhdGVnb3J5KSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQ29udHJvbEZsYWcudXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2FkZERhdGEnLCB7IGRhdGEsIGNhdGVnb3J5IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBiZSBhZGRlZFxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9IGRhdGEubmFtZSAtIFNlcmllcyBuYW1lXG4gICAgICogICBAcGFyYW0ge0FycmF5PG51bWJlcnxBcnJheTxudW1iZXI+Pn0gZGF0YS5kYXRhIC0gQXJyYXkgb2YgZGF0YSB0byBiZSBhZGRlZFxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmFkZFNlcmllcyh7XG4gICAgICogICBuYW1lOiAnbmV3U2VyaWVzJyxcbiAgICAgKiAgIGRhdGE6IFsxMCwgMTAwLCA1MCwgNDAsIDcwLCA1NSwgMzMsIDcwLCA5MCwgMTEwXSxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBhZGRTZXJpZXMoZGF0YSkge1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2FkZFNlcmllcycsIHsgZGF0YSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgY2hhcnQgZGF0YSB0byBuZXcgZGF0YS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIERhdGEgdG8gYmUgc2V0XG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2V0RGF0YSh7XG4gICAgICogICBjYXRlZ29yaWVzOiBbJzEnLCAnMicsICczJ10sXG4gICAgICogICBzZXJpZXM6IFtcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgIG5hbWU6ICduZXcgc2VyaWVzJyxcbiAgICAgKiAgICAgICBkYXRhOiBbMSwgMiwgM10sXG4gICAgICogICAgIH0sXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICBuYW1lOiAnbmV3IHNlcmllczInLFxuICAgICAqICAgICAgIGRhdGE6IFs0LCA1LCA2XSxcbiAgICAgKiAgICAgfVxuICAgICAqICAgXVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHNldERhdGEoZGF0YSkge1xuICAgICAgICBjb25zdCB7IGNhdGVnb3JpZXMsIHNlcmllcyB9ID0gZGF0YTtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdzZXREYXRhJywgeyBzZXJpZXM6IHsgY29sdW1uOiBzZXJpZXMgfSwgY2F0ZWdvcmllcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZSBzZXJpZXMgZGF0YSBsYWJlbC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5oaWRlU2VyaWVzRGF0YUxhYmVsKCk7XG4gICAgICovXG4gICAgaGlkZVNlcmllc0RhdGFMYWJlbCgpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgndXBkYXRlT3B0aW9ucycsIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHsgc2VyaWVzOiB7IGRhdGFMYWJlbHM6IHsgdmlzaWJsZTogZmFsc2UgfSB9IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHNlcmllcyBkYXRhIGxhYmVsLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNob3dTZXJpZXNEYXRhTGFiZWwoKTtcbiAgICAgKi9cbiAgICBzaG93U2VyaWVzRGF0YUxhYmVsKCkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCd1cGRhdGVPcHRpb25zJywge1xuICAgICAgICAgICAgb3B0aW9uczogeyBzZXJpZXM6IHsgZGF0YUxhYmVsczogeyB2aXNpYmxlOiB0cnVlIH0gfSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgY2hhcnQgb3B0aW9ucyB0byBuZXcgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENoYXJ0IG9wdGlvbnNcbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zZXRPcHRpb25zKHtcbiAgICAgKiAgIGNoYXJ0OiB7XG4gICAgICogICAgIHdpZHRoOiA1MDAsXG4gICAgICogICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAqICAgICB0aXRsZTogJ0VuZXJneSBVc2FnZScsXG4gICAgICogICB9LFxuICAgICAqICAgeEF4aXM6IHtcbiAgICAgKiAgICAgdGl0bGU6ICdNb250aCcsXG4gICAgICogICAgIGRhdGU6IHsgZm9ybWF0OiAneXkvTU0nIH0sXG4gICAgICogICB9LFxuICAgICAqICAgeUF4aXM6IHtcbiAgICAgKiAgICAgdGl0bGU6ICdFbmVyZ3kgKGtXaCknLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHNlcmllczoge1xuICAgICAqICAgICBzZWxlY3RhYmxlOiB0cnVlLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHRvb2x0aXA6IHtcbiAgICAgKiAgICAgZm9ybWF0dGVyOiAodmFsdWUpID0+IGAke3ZhbHVlfWtXaGAsXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hPcHRpb25zRXZlbnQoJ2luaXRPcHRpb25zJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBjaGFydCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ2hhcnQgb3B0aW9uc1xuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnVwZGF0ZU9wdGlvbnMoe1xuICAgICAqICAgY2hhcnQ6IHtcbiAgICAgKiAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICogICAgIHRpdGxlOiAnRW5lcmd5IFVzYWdlJyxcbiAgICAgKiAgIH0sXG4gICAgICogICB0b29sdGlwOiB7XG4gICAgICogICAgIGZvcm1hdHRlcjogKHZhbHVlKSA9PiBgJHt2YWx1ZX1rV2hgLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB1cGRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoT3B0aW9uc0V2ZW50KCd1cGRhdGVPcHRpb25zJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VyaWVzSW5mbyAtIEluZm9ybWF0aW9uIG9mIHRoZSBzZXJpZXMgZm9yIHRoZSB0b29sdGlwIHRvIGJlIGRpc3BsYXllZC5cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBzZXJpZXNJbmZvLmluZGV4IC0gSW5kZXggb2YgZGF0YSB3aXRoaW4gc2VyaWVzLiBJZiAnc2VyaWVzLmV2ZW50RGV0ZWN0VHlwZScgaXMgXCJncm91cGVkXCIsIG9ubHkgc2VyaWVzSW5kZXggaXMgbmVlZGVkLlxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IFtzZXJpZXNJbmZvLnNlcmllc0luZGV4XSAtIEluZGV4IG9mIHNlcmllcy5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zaG93VG9vbHRpcCh7aW5kZXg6IDEsIHNlcmllc0luZGV4OiAyfSk7XG4gICAgICovXG4gICAgc2hvd1Rvb2x0aXAoc2VyaWVzSW5mbykge1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nob3dUb29sdGlwJywgT2JqZWN0LmFzc2lnbih7fSwgc2VyaWVzSW5mbykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlIHRvb2x0aXAuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuaGlkZVRvb2x0aXAoKTtcbiAgICAgKi9cbiAgICBoaWRlVG9vbHRpcCgpIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdoaWRlVG9vbHRpcCcpO1xuICAgIH1cbn1cbiIsImltcG9ydCBDaGFydCBmcm9tIFwiLi9jaGFydFwiO1xuaW1wb3J0IHN0YWNrU2VyaWVzRGF0YSBmcm9tIFwiLi4vc3RvcmUvc3RhY2tTZXJpZXNEYXRhXCI7XG5pbXBvcnQgcGxvdCBmcm9tIFwiLi4vc3RvcmUvcGxvdFwiO1xuaW1wb3J0IGF4ZXMgZnJvbSBcIi4uL3N0b3JlL2F4ZXNcIjtcbmltcG9ydCBzY2FsZSBmcm9tIFwiLi4vc3RvcmUvc2NhbGVcIjtcbmltcG9ydCBkYXRhUmFuZ2UgZnJvbSBcIi4uL3N0b3JlL2RhdGFSYW5nZVwiO1xuaW1wb3J0IExlZ2VuZCBmcm9tIFwiLi4vY29tcG9uZW50L2xlZ2VuZFwiO1xuaW1wb3J0IEJveFN0YWNrU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvYm94U3RhY2tTZXJpZXNcIjtcbmltcG9ydCBCb3hTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9ib3hTZXJpZXNcIjtcbmltcG9ydCBMaW5lU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvbGluZVNlcmllc1wiO1xuaW1wb3J0IFBsb3QgZnJvbSBcIi4uL2NvbXBvbmVudC9wbG90XCI7XG5pbXBvcnQgVGl0bGUgZnJvbSBcIi4uL2NvbXBvbmVudC90aXRsZVwiO1xuaW1wb3J0IFplcm9BeGlzIGZyb20gXCIuLi9jb21wb25lbnQvemVyb0F4aXNcIjtcbmltcG9ydCBBeGlzIGZyb20gXCIuLi9jb21wb25lbnQvYXhpc1wiO1xuaW1wb3J0IEF4aXNUaXRsZSBmcm9tIFwiLi4vY29tcG9uZW50L2F4aXNUaXRsZVwiO1xuaW1wb3J0IEV4cG9ydE1lbnUgZnJvbSBcIi4uL2NvbXBvbmVudC9leHBvcnRNZW51XCI7XG5pbXBvcnQgU2VsZWN0ZWRTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9zZWxlY3RlZFNlcmllc1wiO1xuaW1wb3J0IEhvdmVyZWRTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9ob3ZlcmVkU2VyaWVzXCI7XG5pbXBvcnQgRGF0YUxhYmVscyBmcm9tIFwiLi4vY29tcG9uZW50L2RhdGFMYWJlbHNcIjtcbmltcG9ydCBUb29sdGlwIGZyb20gXCIuLi9jb21wb25lbnQvdG9vbHRpcFwiO1xuaW1wb3J0IEJhY2tncm91bmQgZnJvbSBcIi4uL2NvbXBvbmVudC9iYWNrZ3JvdW5kXCI7XG5pbXBvcnQgUmFuZ2VTZWxlY3Rpb24gZnJvbSBcIi4uL2NvbXBvbmVudC9yYW5nZVNlbGVjdGlvblwiO1xuaW1wb3J0IE5vRGF0YVRleHQgZnJvbSBcIi4uL2NvbXBvbmVudC9ub0RhdGFUZXh0XCI7XG5pbXBvcnQgKiBhcyBiYXNpY0JydXNoIGZyb20gXCIuLi9icnVzaGVzL2Jhc2ljXCI7XG5pbXBvcnQgKiBhcyBheGlzQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvYXhpc1wiO1xuaW1wb3J0ICogYXMgbGVnZW5kQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvbGVnZW5kXCI7XG5pbXBvcnQgKiBhcyBsYWJlbEJydXNoIGZyb20gXCIuLi9icnVzaGVzL2xhYmVsXCI7XG5pbXBvcnQgKiBhcyBleHBvcnRNZW51QnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvZXhwb3J0TWVudVwiO1xuaW1wb3J0ICogYXMgZGF0YUxhYmVsQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvZGF0YUxhYmVsXCI7XG5pbXBvcnQgKiBhcyBsaW5lU2VyaWVzQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvbGluZVNlcmllc1wiO1xuaW1wb3J0IHsgaXNFeGlzdCB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5mdW5jdGlvbiBoYXNQb2ludEV2ZW50VHlwZShyZXNwb25kZXJzTW9kZWwsIG5hbWUpIHtcbiAgICByZXR1cm4gcmVzcG9uZGVyc01vZGVsLmZpbmQoKHsgY29tcG9uZW50IH0pID0+IGNvbXBvbmVudC5uYW1lID09PSBuYW1lICYmIGNvbXBvbmVudC5ldmVudERldGVjdFR5cGUgPT09ICdwb2ludCcpO1xufVxuZnVuY3Rpb24gaGFzQ29sdW1uTGluZVVzaW5nUG9pbnRFdmVudFR5cGUocmVzcG9uZGVyc01vZGVsKSB7XG4gICAgcmV0dXJuIChpc0V4aXN0KGhhc1BvaW50RXZlbnRUeXBlKHJlc3BvbmRlcnNNb2RlbCwgJ2NvbHVtbicpKSAmJlxuICAgICAgICBpc0V4aXN0KGhhc1BvaW50RXZlbnRUeXBlKHJlc3BvbmRlcnNNb2RlbCwgJ2xpbmUnKSkpO1xufVxuLyoqXG4gKiBAY2xhc3NcbiAqIEBjbGFzc2Rlc2MgQ29sdW1uTGluZSBDaGFydFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHByb3BzLmVsIC0gVGhlIHRhcmdldCBlbGVtZW50IHRvIGNyZWF0ZSBjaGFydC5cbiAqICAgQHBhcmFtIHtPYmplY3R9IHByb3BzLmRhdGEgLSBEYXRhIGZvciBtYWtpbmcgQ29sdW1uTGluZSBDaGFydC5cbiAqICAgICBAcGFyYW0ge0FycmF5PHN0cmluZz59IHByb3BzLmRhdGEuY2F0ZWdvcmllcyAtIENhdGVnb3JpZXMuXG4gKiAgICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwcm9wcy5kYXRhLnNlcmllcyAtIFNlcmllcyBkYXRhLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwcm9wcy5kYXRhLnNlcmllcy5saW5lIC0gTGluZSBzZXJpZXMgZGF0YS4gQ29vcmRpbmF0ZSB0eXBlcyBkYXRhIGlzIG5vdCBwb3NzaWJsZS5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcHJvcHMuZGF0YS5zZXJpZXMuY29sdW1uIC0gQ29sdW1uIHNlcmllcyBkYXRhLlxuICogICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnNdIC0gT3B0aW9ucyBmb3IgbWFraW5nIENvbHVtbkxpbmUgQ2hhcnQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNoYXJ0XVxuICogICAgICAgQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZV0gLSBDaGFydCB0aXRsZSB0ZXh0IG9yIG9wdGlvbnMuXG4gKiAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS50ZXh0XSAtIENoYXJ0IHRpdGxlIHRleHQuXG4gKiAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS5vZmZzZXRYXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIGhvcml6b250YWxseS5cbiAqICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLm9mZnNldFldIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgdmVydGljYWxseS5cbiAqICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLmFsaWduXSAtIENoYXJ0IHRleHQgYWxpZ24uICdsZWZ0JywgJ3JpZ2h0JywgJ2NlbnRlcicgaXMgYXZhaWxhYmxlLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufE9iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2hhcnQuYW5pbWF0aW9uXSAtIFdoZXRoZXIgdG8gdXNlIGFuaW1hdGlvbiBhbmQgZHVyYXRpb24gd2hlbiByZW5kZXJpbmcgdGhlIGluaXRpYWwgY2hhcnQuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LndpZHRoXSAtIENoYXJ0IHdpZHRoLiAnYXV0bycgb3IgaWYgbm90IHdyaXRlLCB0aGUgd2lkdGggb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuICdhdXRvJyBvciBpZiBub3QgY3JlYXRlZCwgdGhlIHdpZHRoIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC5oZWlnaHRdIC0gQ2hhcnQgaGVpZ2h0LiAnYXV0bycgb3IgaWYgbm90IHdyaXRlLCB0aGUgd2lkdGggb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuICdhdXRvJyBvciBpZiBub3QgY3JlYXRlZCwgdGhlIGhlaWdodCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzXSAtIFdyaXRlIGNvbW1vbiBvcHRpb25zIGluIHRoZSB1cHBlciBkZXB0aCBhbmQgc2VwYXJhdGUgb3B0aW9ucyB0byBiZSBhcHBsaWVkIHRvIGVhY2ggY2hhcnQuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLmxpbmVdIC0gT3B0aW9ucyB0byBiZSBhcHBsaWVkIHRvIHRoZSBsaW5lIGNoYXJ0LiAnc3BsaW5lJywgJ3Nob3dEb3QnLCAnZGF0YUxhYmVscycgaXMgYXZhaWxhYmxlLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8TGluZSBDaGFydCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnNlcmllcy5jb2x1bW5dIC0gT3B0aW9ucyB0byBiZSBhcHBsaWVkIHRvIHRoZSBjb2x1bW4gY2hhcnQuICdiYXJXaWR0aCcsICdzdGFjaycsICdkYXRhTGFiZWxzJyBpcyBhdmFpbGFibGUuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxDb2x1bW4gQ2hhcnQgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLnNlbGVjdGFibGU9ZmFsc2VdIC0gV2hldGhlciB0byBtYWtlIHNlbGVjdGFibGUgc2VyaWVzIG9yIG5vdC5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLnJhbmdlU2VsZWN0YWJsZT1mYWxzZV0gLSBXaGV0aGVyIHRvIHVzZSByYW5nZSBzZWxlY3Rpb24gZmVhdHVyZSBvciBub3QuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLmV2ZW50RGV0ZWN0VHlwZV0gLSBFdmVudCBkZXRlY3QgdHlwZS4gJ25lYXInLCAnbmVhcmVzdCcsICdncm91cGVkJywgJ3BvaW50JyBpcyBhdmFpbGFibGUuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5zaGlmdD1mYWxzZV0gLSBXaGV0aGVyIHRvIHVzZSBzaGlmdCB3aGVuIGFkZERhdGEgb3Igbm90LlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnNlcmllcy5kYXRhTGFiZWxzXSAtIFNldCB0aGUgdmlzaWJpbGl0eSwgbG9jYXRpb24sIGFuZCBmb3JtYXR0aW5nIG9mIGRhdGFMYWJlbC4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fERhdGFMYWJlbHMgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXNdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLnRpdGxlXSAtIEF4aXMgdGl0bGUuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnhBeGlzLnBvaW50T25Db2x1bW49ZmFsc2VdIC0gV2hldGhlciB0byBtb3ZlIHRoZSBzdGFydCBvZiB0aGUgY2hhcnQgdG8gdGhlIGNlbnRlciBvZiB0aGUgY29sdW1uLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy54QXhpcy5yb3RhdGVMYWJlbD10cnVlXSAtIFdoZXRoZXIgdG8gYWxsb3cgYXhpcyBsYWJlbCByb3RhdGlvbi5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLmRhdGVdIC0gV2hldGhlciB0aGUgeCBheGlzIGxhYmVsIGlzIG9mIGRhdGUgdHlwZS4gRm9ybWF0IG9wdGlvbiB1c2VkIGZvciBkYXRlIHR5cGUuIFdoZXRoZXIgdGhlIHggYXhpcyBsYWJlbCBpcyBvZiBkYXRlIHR5cGUuIElmIHVzZSBkYXRlIHR5cGUsIGZvcm1hdCBvcHRpb24gdXNlZCBmb3IgZGF0ZSB0eXBlLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLnRpY2tdIC0gT3B0aW9uIHRvIGFkanVzdCB0aWNrIGludGVydmFsLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLmxhYmVsXSAtIE9wdGlvbiB0byBhZGp1c3QgbGFiZWwgaW50ZXJ2YWwuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXMuc2NhbGVdIC0gT3B0aW9uIHRvIGFkanVzdCBheGlzIG1pbmltdW0sIG1heGltdW0sIHN0ZXAgc2l6ZS5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy54QXhpcy53aWR0aF0gLSBXaWR0aCBvZiB4QXhpcy5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy54QXhpcy5oZWlnaHRdIC0gSGVpZ2h0IG9mIHhBeGlzLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fEFycmF5PE9iamVjdD59IFtwcm9wcy5vcHRpb25zLnlBeGlzXSAtIElmIHRoaXMgb3B0aW9uIGlzIGFuIGFycmF5IHR5cGUsIHVzZSB0aGUgc2Vjb25kYXJ5IHkgYXhpcy5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW3Byb3BzLm9wdGlvbnMueUF4aXMudGl0bGVdIC0gQXhpcyB0aXRsZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpcy50aWNrXSAtIE9wdGlvbiB0byBhZGp1c3QgdGljayBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpcy5sYWJlbF0gLSBPcHRpb24gdG8gYWRqdXN0IGxhYmVsIGludGVydmFsLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnlBeGlzLnNjYWxlXSAtIE9wdGlvbiB0byBhZGp1c3QgYXhpcyBtaW5pbXVtLCBtYXhpbXVtLCBzdGVwIHNpemUuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMueUF4aXMud2lkdGhdIC0gV2lkdGggb2YgeUF4aXMuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMueUF4aXMuaGVpZ2h0XSAtIEhlaWdodCBvZiB5QXhpcy5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMucGxvdF1cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5wbG90LndpZHRoXSAtIFdpZHRoIG9mIHBsb3QuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMucGxvdC5oZWlnaHRdIC0gSGVpZ2h0IG9mIHBsb3QuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnBsb3QudmlzaWJsZV0gLSBXaGV0aGVyIHRvIHNob3cgcGxvdCBsaW5lLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBbcHJvcHMub3B0aW9ucy5wbG90LmxpbmVzXSAtIFBsb3QgbGluZXMgaW5mb3JtYXRpb24uIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxQbG90IGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgICBAcGFyYW0ge0FycmF5PE9iamVjdD59IFtwcm9wcy5vcHRpb25zLnBsb3QuYmFuZHNdIC0gUGxvdCBiYW5kcyBpbmZvcm1hdGlvbi4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFBsb3QgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGVnZW5kXVxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC5hbGlnbl0gLSBMZWdlbmQgYWxpZ24uICd0b3AnLCAnYm90dG9tJywgJ3JpZ2h0JywgJ2xlZnQnIGlzIGF2YWlsYWJsZS5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5sZWdlbmQuc2hvd0NoZWNrYm94XSAtIFdoZXRoZXIgdG8gc2hvdyBjaGVja2JveC5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMubGVnZW5kLnZpc2libGVdIC0gV2hldGhlciB0byBzaG93IGxlZ2VuZC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5sZWdlbmQud2lkdGhdIC0gV2lkdGggb2YgbGVnZW5kLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC5pdGVtXSAtIGB3aWR0aGAgYW5kIGBvdmVyZmxvd2Agb3B0aW9ucyBvZiB0aGUgbGVnZW5kIGl0ZW0uIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxMZWdlbmQgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuZXhwb3J0TWVudV1cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuZXhwb3J0TWVudS52aXNpYmxlXSAtIFdoZXRoZXIgdG8gc2hvdyBleHBvcnQgbWVudS5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5leHBvcnRNZW51LmZpbGVuYW1lXSAtIEZpbGUgbmFtZSBhcHBsaWVkIHdoZW4gZG93bmxvYWRpbmcuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRvb2x0aXBdXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC5vZmZzZXRYXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIGhvcml6b250YWxseS5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy50b29sdGlwLm9mZnNldFldIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgdmVydGljYWxseS5cbiAqICAgICAgIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAuZm9ybWF0dGVyXSAtIEZ1bmN0aW9uIHRvIGZvcm1hdCBkYXRhIHZhbHVlLlxuICogICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC50ZW1wbGF0ZV0gLSBGdW5jdGlvbiB0byBjcmVhdGUgY3VzdG9tIHRlbXBsYXRlLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8VG9vbHRpcCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5yZXNwb25zaXZlXSAtIFJ1bGVzIGZvciBjaGFuZ2luZyBjaGFydCBvcHRpb25zLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8UmVzcG9uc2l2ZSBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufE9iamVjdH0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZS5hbmltYXRpb25dIC0gQW5pbWF0aW9uIGR1cmF0aW9uIHdoZW4gdGhlIGNoYXJ0IGlzIG1vZGlmaWVkLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBbcHJvcHMub3B0aW9ucy5yZXNwb25zaXZlLnJ1bGVzXSAtIFJ1bGVzIGZvciB0aGUgQ2hhcnQgdG8gUmVzcG9uZC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGFuZ10gLSBPcHRpb25zIGZvciBjaGFuZ2luZyB0aGUgdGV4dCBkaXNwbGF5ZWQgb24gdGhlIGNoYXJ0IG9yIGkxOG4gbGFuZ3VhZ2VzLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxhbmcubm9EYXRhXSAtIE5vIERhdGEgTGF5ZXIgVGV4dC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWVdIC0gQ2hhcnQgdGhlbWUgb3B0aW9ucy4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fENvbHVtbkxpbmUgQ2hhcnQgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5jaGFydF0gLSBDaGFydCBmb250IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLm5vRGF0YV0gLSBObyBEYXRhIExheWVyIFRleHQgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUuc2VyaWVzXSAtIFNlcmllcyB0aGVtZS4gRWFjaCB0aGVtZSB0byBiZSBhcHBsaWVkIHRvIHRoZSB0d28gY2hhcnRzIHNob3VsZCBiZSB3cml0dGVuIHNlcGFyYXRlbHkuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUudGl0bGVdIC0gVGl0bGUgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUueEF4aXNdIC0gWCBBeGlzIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R8QXJyYXk8T2JqZWN0Pn0gW3Byb3BzLm9wdGlvbnMudGhlbWUueUF4aXNdIC0gWSBBeGlzIHRoZW1lLiBJbiB0aGUgY2FzZSBvZiBhbiBhcnJhbmdlbWVudCwgdGhlIGZpcnN0IGlzIHRoZSBtYWluIGF4aXMgYW5kIHRoZSBzZWNvbmQgaXMgdGhlIHRoZW1lIGZvciB0aGUgc2Vjb25kYXJ5IGF4aXMuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUubGVnZW5kXSAtIExlZ2VuZCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS50b29sdGlwXSAtIFRvb2x0aXAgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUucGxvdF0gLSBQbG90IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmV4cG9ydE1lbnVdIC0gRXhwb3J0TWVudSB0aGVtZS5cbiAqIEBleHRlbmRzIENoYXJ0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbHVtbkxpbmVDaGFydCBleHRlbmRzIENoYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcih7IGVsLCBvcHRpb25zLCBkYXRhOiB7IHNlcmllcywgY2F0ZWdvcmllcyB9IH0pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICBjYXRlZ29yaWVzLFxuICAgICAgICAgICAgbW9kdWxlczogW3N0YWNrU2VyaWVzRGF0YSwgZGF0YVJhbmdlLCBzY2FsZSwgYXhlcywgcGxvdF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQmFja2dyb3VuZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoVGl0bGUpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFBsb3QpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKExlZ2VuZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQm94U3RhY2tTZXJpZXMsIHsgbmFtZTogJ2NvbHVtbicgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQm94U2VyaWVzLCB7IG5hbWU6ICdjb2x1bW4nIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKExpbmVTZXJpZXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFplcm9BeGlzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzLCB7IG5hbWU6ICd4QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpcywgeyBuYW1lOiAneUF4aXMnIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEF4aXMsIHsgbmFtZTogJ3NlY29uZGFyeVlBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzVGl0bGUsIHsgbmFtZTogJ3hBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzVGl0bGUsIHsgbmFtZTogJ3lBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzVGl0bGUsIHsgbmFtZTogJ3NlY29uZGFyeVlBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChFeHBvcnRNZW51LCB7IGNoYXJ0RWw6IHRoaXMuZWwgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoSG92ZXJlZFNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoU2VsZWN0ZWRTZXJpZXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKERhdGFMYWJlbHMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFJhbmdlU2VsZWN0aW9uKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChUb29sdGlwLCB7IGNoYXJ0RWw6IHRoaXMuZWwgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoTm9EYXRhVGV4dCk7XG4gICAgICAgIHRoaXMucGFpbnRlci5hZGRHcm91cHMoW1xuICAgICAgICAgICAgYmFzaWNCcnVzaCxcbiAgICAgICAgICAgIGF4aXNCcnVzaCxcbiAgICAgICAgICAgIGxlZ2VuZEJydXNoLFxuICAgICAgICAgICAgbGFiZWxCcnVzaCxcbiAgICAgICAgICAgIGV4cG9ydE1lbnVCcnVzaCxcbiAgICAgICAgICAgIGRhdGFMYWJlbEJydXNoLFxuICAgICAgICAgICAgbGluZVNlcmllc0JydXNoLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnRGb3JBbGxSZXNwb25kZXJzKGV2ZW50LCByZXNwb25kZXJNb2RlbHMsIGRlbGVnYXRpb25NZXRob2QsIG1vdXNlUG9zaXRpb24pIHtcbiAgICAgICAgaWYgKGhhc0NvbHVtbkxpbmVVc2luZ1BvaW50RXZlbnRUeXBlKHJlc3BvbmRlck1vZGVscykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtblNlcmllcyA9IHJlc3BvbmRlck1vZGVscy5maW5kKCh7IGNvbXBvbmVudCB9KSA9PiBjb21wb25lbnQubmFtZSA9PT0gJ2NvbHVtbicpO1xuICAgICAgICAgICAgY29sdW1uU2VyaWVzLmNvbXBvbmVudFtkZWxlZ2F0aW9uTWV0aG9kXSh7IG1vdXNlUG9zaXRpb24sIHJlc3BvbmRlcnM6IFtdIH0sIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIC0gQXJyYXkgb2YgZGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2F0ZWdvcnkgLSBDYXRlZ29yeSB0byBiZSBhZGRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIC0gV2hpY2ggdHlwZSBvZiBjaGFydCB0byBhZGQuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuYWRkRGF0YShbMTAsIDIwXSwgJzYnLCAnbGluZScpO1xuICAgICAqL1xuICAgIGFkZERhdGEoZGF0YSwgY2F0ZWdvcnksIGNoYXJ0VHlwZSkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkNvbnRyb2xGbGFnLnVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdhZGREYXRhJywgeyBkYXRhLCBjYXRlZ29yeSwgY2hhcnRUeXBlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YS5uYW1lIC0gU2VyaWVzIG5hbWUuXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBkYXRhLmRhdGEgLSBBcnJheSBvZiBkYXRhIHRvIGJlIGFkZGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhSW5mbyAtIFdoaWNoIHR5cGUgb2YgY2hhcnQgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhSW5mby5jaGFydFR5cGUgLSBDaGFydCB0eXBlLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmFkZFNlcmllcyhcbiAgICAgKiAgIHtcbiAgICAgKiAgICAgbmFtZTogJ25ld1NlcmllcycsXG4gICAgICogICAgIGRhdGE6IFsxMCwgMTAwLCA1MCwgNDAsIDcwLCA1NSwgMzMsIDcwLCA5MCwgMTEwXSxcbiAgICAgKiAgIH0sXG4gICAgICogICB7XG4gICAgICogICAgIGNoYXJ0VHlwZTogJ2xpbmUnXG4gICAgICogICB9KTtcbiAgICAgKi9cbiAgICBhZGRTZXJpZXMoZGF0YSwgZGF0YUluZm8pIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdhZGRTZXJpZXMnLCBPYmplY3QuYXNzaWduKHsgZGF0YSB9LCBkYXRhSW5mbykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBjaGFydCBkYXRhIHRvIG5ldyBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBiZSBzZXRcbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zZXREYXRhKHtcbiAgICAgKiAgIGNhdGVnb3JpZXM6IFsnMScsICcyJywgJzMnXSxcbiAgICAgKiAgIHNlcmllczoge1xuICAgICAqICAgICBjb2x1bW46IFtcbiAgICAgKiAgICAgICB7XG4gICAgICogICAgICAgICBuYW1lOiAnQScsXG4gICAgICogICAgICAgICBkYXRhOiBbMSwgMiwgM10sXG4gICAgICogICAgICAgfVxuICAgICAqICAgICBdLFxuICAgICAqICAgICBsaW5lOiBbXG4gICAgICogICAgICAge1xuICAgICAqICAgICAgICAgbmFtZTogJ0InLFxuICAgICAqICAgICAgICAgZGF0YTogWzQsIDUsIDZdLFxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgXVxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHNldERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3NldERhdGEnLCBkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHBsb3QgbGluZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFBsb3QgaW5mby5cbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gZGF0YS52YWx1ZSAtIFRoZSB2YWx1ZSB3aGVyZSB0aGUgcGxvdCBsaW5lIHdpbGwgYmUgZHJhd24uXG4gICAgICogICBAcGFyYW0ge3N0cmluZ30gZGF0YS5jb2xvciAtIFBsb3QgbGluZSBjb2xvci5cbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSBbZGF0YS5pZF0gLSBQbG90IGlkLiBUaGUgdmFsdWUgb24gd2hpY2ggdGhlIHJlbW92ZVBsb3RMaW5lIGlzIGJhc2VkLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmFkZFBsb3RMaW5lKHtcbiAgICAgKiAgIHZhbHVlOiAyLFxuICAgICAqICAgY29sb3I6ICcjMDBmZjIyJyxcbiAgICAgKiAgIGlkOiAncGxvdC0xJyxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBhZGRQbG90TGluZShkYXRhKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2FkZFBsb3RMaW5lJywgeyBkYXRhIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgcGxvdCBsaW5lIHdpdGggaWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gSWQgb2YgdGhlIHBsb3QgbGluZSB0byBiZSByZW1vdmVkXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQucmVtb3ZlUGxvdExpbmUoJ3Bsb3QtMScpO1xuICAgICAqL1xuICAgIHJlbW92ZVBsb3RMaW5lKGlkKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3JlbW92ZVBsb3RMaW5lJywgeyBpZCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHBsb3QgYmFuZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIHBsb3QgaW5mb1xuICAgICAqICAgQHBhcmFtIHtBcnJheTxzdHJpbmd8bnVtYmVyPn0gZGF0YS5yYW5nZSAtIFRoZSByYW5nZSB0byBiZSBkcmF3blxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9IGRhdGEuY29sb3IgLSBQbG90IGJhbmQgY29sb3JcbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSBbZGF0YS5pZF0gLSBQbG90IGlkLiBUaGUgdmFsdWUgb24gd2hpY2ggdGhlIHJlbW92ZVBsb3RCYW5kIGlzIGJhc2VkXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuYWRkUGxvdEJhbmQoe1xuICAgICAqICAgdmFsdWU6IFsyLCA0XSxcbiAgICAgKiAgIGNvbG9yOiAnIzAwZmYyMicsXG4gICAgICogICBpZDogJ3Bsb3QtMScsXG4gICAgICogfSk7XG4gICAgICovXG4gICAgYWRkUGxvdEJhbmQoZGF0YSkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdhZGRQbG90QmFuZCcsIHsgZGF0YSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHBsb3QgYmFuZCB3aXRoIGlkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIGlkIG9mIHRoZSBwbG90IGJhbmQgdG8gYmUgcmVtb3ZlZFxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnJlbW92ZVBsb3RCYW5kKCdwbG90LTEnKTtcbiAgICAgKi9cbiAgICByZW1vdmVQbG90QmFuZChpZCkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdyZW1vdmVQbG90QmFuZCcsIHsgaWQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGUgc2VyaWVzIGRhdGEgbGFiZWwuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuaGlkZVNlcmllc0RhdGFMYWJlbCgpO1xuICAgICAqL1xuICAgIGhpZGVTZXJpZXNEYXRhTGFiZWwoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3VwZGF0ZU9wdGlvbnMnLCB7XG4gICAgICAgICAgICBvcHRpb25zOiB7IHNlcmllczogeyBkYXRhTGFiZWxzOiB7IHZpc2libGU6IGZhbHNlIH0gfSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyBzZXJpZXMgZGF0YSBsYWJlbC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zaG93U2VyaWVzRGF0YUxhYmVsKCk7XG4gICAgICovXG4gICAgc2hvd1Nlcmllc0RhdGFMYWJlbCgpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgndXBkYXRlT3B0aW9ucycsIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHsgc2VyaWVzOiB7IGRhdGFMYWJlbHM6IHsgdmlzaWJsZTogdHJ1ZSB9IH0gfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGNoYXJ0IG9wdGlvbnMgdG8gbmV3IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDaGFydCBvcHRpb25zXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2V0T3B0aW9ucyh7XG4gICAgICogICBjaGFydDoge1xuICAgICAqICAgICB3aWR0aDogNTAwLFxuICAgICAqICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgKiAgICAgdGl0bGU6ICdFbmVyZ3kgVXNhZ2UnLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHhBeGlzOiB7XG4gICAgICogICAgIHRpdGxlOiAnTW9udGgnLFxuICAgICAqICAgICBkYXRlOiB7IGZvcm1hdDogJ3l5L01NJyB9LFxuICAgICAqICAgfSxcbiAgICAgKiAgIHlBeGlzOiB7XG4gICAgICogICAgIHRpdGxlOiAnRW5lcmd5IChrV2gpJyxcbiAgICAgKiAgIH0sXG4gICAgICogICBzZXJpZXM6IHtcbiAgICAgKiAgICAgbGluZToge1xuICAgICAqICAgICAgIHNob3dEb3Q6IHRydWUsXG4gICAgICogICAgIH0sXG4gICAgICogICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICogICB9LFxuICAgICAqICAgdG9vbHRpcDoge1xuICAgICAqICAgICBmb3JtYXR0ZXI6ICh2YWx1ZSkgPT4gYCR7dmFsdWV9a1doYCxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICovXG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE9wdGlvbnNFdmVudCgnaW5pdE9wdGlvbnMnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNoYXJ0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDaGFydCBvcHRpb25zXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQudXBkYXRlT3B0aW9ucyh7XG4gICAgICogICBjaGFydDoge1xuICAgICAqICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgKiAgICAgdGl0bGU6ICdFbmVyZ3kgVXNhZ2UnLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHNlcmllczoge1xuICAgICAqICAgICBsaW5lOiB7XG4gICAgICogICAgICAgc2hvd0RvdDogdHJ1ZSxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICovXG4gICAgdXBkYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE9wdGlvbnNFdmVudCgndXBkYXRlT3B0aW9ucycsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlcmllc0luZm8gLSBJbmZvcm1hdGlvbiBvZiB0aGUgc2VyaWVzIGZvciB0aGUgdG9vbHRpcCB0byBiZSBkaXNwbGF5ZWQuXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gc2VyaWVzSW5mby5zZXJpZXNJbmRleCAtIEluZGV4IG9mIHNlcmllcy5cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBzZXJpZXNJbmZvLmluZGV4IC0gSW5kZXggb2YgZGF0YSB3aXRoaW4gc2VyaWVzLlxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHNlcmllc0luZm8uY2hhcnRUeXBlIC0gU3BlY2lmeSB3aGljaCBjaGFydCB0byBzZWxlY3QuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2hvd1Rvb2x0aXAoe2luZGV4OiAxLCBzZXJpZXNJbmRleDogMiwgY2hhcnRUeXBlOiAnY29sdW1uJ30pO1xuICAgICAqL1xuICAgIHNob3dUb29sdGlwKHNlcmllc0luZm8pIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzaG93VG9vbHRpcCcsIE9iamVjdC5hc3NpZ24oe30sIHNlcmllc0luZm8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZSB0b29sdGlwLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmhpZGVUb29sdGlwKCk7XG4gICAgICovXG4gICAgaGlkZVRvb2x0aXAoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnaGlkZVRvb2x0aXAnKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ2hhcnQgZnJvbSBcIi4vY2hhcnRcIjtcbmltcG9ydCBkYXRhUmFuZ2UgZnJvbSBcIi4uL3N0b3JlL2RhdGFSYW5nZVwiO1xuaW1wb3J0IHNjYWxlIGZyb20gXCIuLi9zdG9yZS9zY2FsZVwiO1xuaW1wb3J0IGdhdWdlQXhlc0RhdGEgZnJvbSBcIi4uL3N0b3JlL2dhdWdlQXhlc1wiO1xuaW1wb3J0IFRvb2x0aXAgZnJvbSBcIi4uL2NvbXBvbmVudC90b29sdGlwXCI7XG5pbXBvcnQgR2F1Z2VTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9nYXVnZVNlcmllc1wiO1xuaW1wb3J0IFRpdGxlIGZyb20gXCIuLi9jb21wb25lbnQvdGl0bGVcIjtcbmltcG9ydCBFeHBvcnRNZW51IGZyb20gXCIuLi9jb21wb25lbnQvZXhwb3J0TWVudVwiO1xuaW1wb3J0IEhvdmVyZWRTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9ob3ZlcmVkU2VyaWVzXCI7XG5pbXBvcnQgRGF0YUxhYmVscyBmcm9tIFwiLi4vY29tcG9uZW50L2RhdGFMYWJlbHNcIjtcbmltcG9ydCBBeGlzVGl0bGUgZnJvbSBcIi4uL2NvbXBvbmVudC9heGlzVGl0bGVcIjtcbmltcG9ydCBTZWxlY3RlZFNlcmllcyBmcm9tIFwiLi4vY29tcG9uZW50L3NlbGVjdGVkU2VyaWVzXCI7XG5pbXBvcnQgQmFja2dyb3VuZCBmcm9tIFwiLi4vY29tcG9uZW50L2JhY2tncm91bmRcIjtcbmltcG9ydCBSYWRpYWxBeGlzIGZyb20gXCIuLi9jb21wb25lbnQvcmFkaWFsQXhpc1wiO1xuaW1wb3J0IFJhZGlhbFBsb3QgZnJvbSBcIi4uL2NvbXBvbmVudC9yYWRpYWxQbG90XCI7XG5pbXBvcnQgTm9EYXRhVGV4dCBmcm9tIFwiLi4vY29tcG9uZW50L25vRGF0YVRleHRcIjtcbmltcG9ydCAqIGFzIGJhc2ljQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvYmFzaWNcIjtcbmltcG9ydCAqIGFzIGxlZ2VuZEJydXNoIGZyb20gXCIuLi9icnVzaGVzL2xlZ2VuZFwiO1xuaW1wb3J0ICogYXMgbGFiZWxCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9sYWJlbFwiO1xuaW1wb3J0ICogYXMgZXhwb3J0TWVudUJydXNoIGZyb20gXCIuLi9icnVzaGVzL2V4cG9ydE1lbnVcIjtcbmltcG9ydCAqIGFzIHNlY3RvckJydXNoIGZyb20gXCIuLi9icnVzaGVzL3NlY3RvclwiO1xuaW1wb3J0ICogYXMgZGF0YUxhYmVsQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvZGF0YUxhYmVsXCI7XG5pbXBvcnQgKiBhcyBheGlzQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvYXhpc1wiO1xuaW1wb3J0ICogYXMgZ2F1Z2VCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9nYXVnZVwiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBjbGFzc2Rlc2MgR2F1Z2UgQ2hhcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogICBAcGFyYW0ge0hUTUxFbGVtZW50fSBwcm9wcy5lbCAtIFRoZSB0YXJnZXQgZWxlbWVudCB0byBjcmVhdGUgY2hhcnQuXG4gKiAgIEBwYXJhbSB7T2JqZWN0fSBwcm9wcy5kYXRhIC0gRGF0YSBmb3IgbWFraW5nIEdhdWdlIENoYXJ0LlxuICogICAgIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3Byb3BzLmRhdGEuY2F0ZWdvcmllc10gLSBDYXRlZ29yaWVzLlxuICogICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcHJvcHMuZGF0YS5zZXJpZXMgLSBTZXJpZXMgZGF0YS5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy5kYXRhLnNlcmllcy5uYW1lIC0gU2VyaWVzIG5hbWUuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gcHJvcHMuZGF0YS5zZXJpZXMuZGF0YSAtIFNlcmllcyBkYXRhLlxuICogICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnNdIC0gT3B0aW9ucyBmb3IgbWFraW5nIEdhdWdlIENoYXJ0LlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaGFydF1cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGVdIC0gQ2hhcnQgdGl0bGUgdGV4dCBvciBvcHRpb25zLlxuICogICAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUudGV4dF0gLSBDaGFydCB0aXRsZSB0ZXh0LlxuICogICAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUub2Zmc2V0WF0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSBob3Jpem9udGFsbHkuXG4gKiAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS5vZmZzZXRZXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIHZlcnRpY2FsbHkuXG4gKiAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS5hbGlnbl0gLSBDaGFydCB0ZXh0IGFsaWduLiAnbGVmdCcsICdyaWdodCcsICdjZW50ZXInIGlzIGF2YWlsYWJsZS5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbl0gLSBXaGV0aGVyIHRvIHVzZSBhbmltYXRpb24gYW5kIGR1cmF0aW9uIHdoZW4gcmVuZGVyaW5nIHRoZSBpbml0aWFsIGNoYXJ0LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC53aWR0aF0gLSBDaGFydCB3aWR0aC4gJ2F1dG8nIG9yIGlmIG5vdCB3cml0ZSwgdGhlIHdpZHRoIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLiAnYXV0bycgb3IgaWYgbm90IGNyZWF0ZWQsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQuaGVpZ2h0XSAtIENoYXJ0IGhlaWdodC4gJ2F1dG8nIG9yIGlmIG5vdCB3cml0ZSwgdGhlIHdpZHRoIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLiAnYXV0bycgb3IgaWYgbm90IGNyZWF0ZWQsIHRoZSBoZWlnaHQgb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnNlcmllc11cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLnNlbGVjdGFibGU9ZmFsc2VdIC0gV2hldGhlciB0byBtYWtlIHNlbGVjdGFibGUgc2VyaWVzIG9yIG5vdC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5zZXJpZXMuZGF0YUxhYmVsc10gLSBTZXQgdGhlIHZpc2liaWxpdHksIGxvY2F0aW9uLCBhbmQgZm9ybWF0dGluZyBvZiBkYXRhTGFiZWwuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxHYXVnZSBDaGFydCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbcHJvcHMub3B0aW9ucy5zZXJpZXMuYW5nbGVSYW5nZV0gLSBUaGUgcmFuZ2Ugb2YgYW5nbGVzIHRvIHdoaWNoIHRoZSBjaXJjbGUgd2lsbCBiZSBkcmF3bi4gSXQgaXMgc3BlY2lmaWVkIGJ5IHB1dHRpbmcgbnVtYmVyIGluIHN0YXJ0IGFuZCBlbmQuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5jbG9ja3dpc2VdIC0gV2hldGhlciBpdCB3aWxsIGJlIGRyYXduIGNsb2Nrd2lzZS5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbiB8IE9iamVjdH0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLnNvbGlkXSAtIFdoZW4gdGhpcyBvcHRpb24gaXMgc2V0LCB0aGUgcmFkaWFsIGJhciBpcyBkaXNwbGF5ZWQuIEl0IGNhbiBiZSB1c2VkIHdoZW4gdGhlcmUgaXMgb25lIHNlcmllcyBkYXRhLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAnZmFsc2UnLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaXJjdWxhckF4aXNdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNpcmN1bGFyQXhpcy50aXRsZV0gLSBBeGlzIHRpdGxlLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNpcmN1bGFyQXhpcy50aWNrXSAtIE9wdGlvbiB0byBhZGp1c3QgdGljayBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaXJjdWxhckF4aXMubGFiZWxdIC0gT3B0aW9uIHRvIGFkanVzdCBsYWJlbCBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaXJjdWxhckF4aXMuc2NhbGVdIC0gT3B0aW9uIHRvIGFkanVzdCBheGlzIG1pbmltdW0sIG1heGltdW0sIHN0ZXAgc2l6ZS5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMucGxvdF1cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5wbG90LndpZHRoXSAtIFdpZHRoIG9mIHBsb3QuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMucGxvdC5oZWlnaHRdIC0gSGVpZ2h0IG9mIHBsb3QuXG4gKiAgICAgICBAcGFyYW0ge0FycmF5PE9iamVjdD59IFtwcm9wcy5vcHRpb25zLnBsb3QuYmFuZHNdIC0gUGxvdCBiYW5kcyBpbmZvcm1hdGlvbi4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fEdhdWdlIENoYXJ0IGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnVdXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnUudmlzaWJsZV0gLSBXaGV0aGVyIHRvIHNob3cgZXhwb3J0IG1lbnUuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuZXhwb3J0TWVudS5maWxlbmFtZV0gLSBGaWxlIG5hbWUgYXBwbGllZCB3aGVuIGRvd25sb2FkaW5nLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50b29sdGlwXVxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAub2Zmc2V0WF0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSBob3Jpem9udGFsbHkuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC5vZmZzZXRZXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIHZlcnRpY2FsbHkuXG4gKiAgICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcHMub3B0aW9ucy50b29sdGlwLmZvcm1hdHRlcl0gLSBGdW5jdGlvbiB0byBmb3JtYXQgZGF0YSB2YWx1ZS5cbiAqICAgICAgIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAudGVtcGxhdGVdIC0gRnVuY3Rpb24gdG8gY3JlYXRlIGN1c3RvbSB0ZW1wbGF0ZS4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFRvb2x0aXAgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZV0gLSBSdWxlcyBmb3IgY2hhbmdpbmcgY2hhcnQgb3B0aW9ucy4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFJlc3BvbnNpdmUgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLnJlc3BvbnNpdmUuYW5pbWF0aW9uXSAtIEFuaW1hdGlvbiBkdXJhdGlvbiB3aGVuIHRoZSBjaGFydCBpcyBtb2RpZmllZC5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZS5ydWxlc10gLSBSdWxlcyBmb3IgdGhlIENoYXJ0IHRvIFJlc3BvbmQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lXSAtIENoYXJ0IHRoZW1lIG9wdGlvbnMuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxHYXVnZSBDaGFydCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmNoYXJ0XSAtIENoYXJ0IGZvbnQgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUuc2VyaWVzXSAtIFNlcmllcyB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS50aXRsZV0gLSBUaXRsZSB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5jaXJjdWxhckF4aXNdIC0gQ2lyY3VsYXIgQXhpcyB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS50b29sdGlwXSAtIFRvb2x0aXAgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUuZXhwb3J0TWVudV0gLSBFeHBvcnRNZW51IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnBsb3RdIC0gUGxvdCBUaGVtZS5cbiAqIEBleHRlbmRzIENoYXJ0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhdWdlQ2hhcnQgZXh0ZW5kcyBDaGFydCB7XG4gICAgY29uc3RydWN0b3IoeyBlbCwgb3B0aW9ucywgZGF0YSB9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIHNlcmllczoge1xuICAgICAgICAgICAgICAgIGdhdWdlOiBkYXRhLnNlcmllcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYXRlZ29yaWVzOiBkYXRhLmNhdGVnb3JpZXMsXG4gICAgICAgICAgICBtb2R1bGVzOiBbZGF0YVJhbmdlLCBzY2FsZSwgZ2F1Z2VBeGVzRGF0YV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQmFja2dyb3VuZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoVGl0bGUpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFJhZGlhbFBsb3QsIHsgbmFtZTogJ2dhdWdlJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChSYWRpYWxBeGlzLCB7IG5hbWU6ICdnYXVnZScgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpc1RpdGxlLCB7IG5hbWU6ICdjaXJjdWxhckF4aXMnIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEdhdWdlU2VyaWVzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChIb3ZlcmVkU2VyaWVzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChTZWxlY3RlZFNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoRGF0YUxhYmVscyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoRXhwb3J0TWVudSwgeyBjaGFydEVsOiB0aGlzLmVsIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFRvb2x0aXAsIHsgY2hhcnRFbDogdGhpcy5lbCB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChOb0RhdGFUZXh0KTtcbiAgICAgICAgdGhpcy5wYWludGVyLmFkZEdyb3VwcyhbXG4gICAgICAgICAgICBiYXNpY0JydXNoLFxuICAgICAgICAgICAgbGVnZW5kQnJ1c2gsXG4gICAgICAgICAgICBsYWJlbEJydXNoLFxuICAgICAgICAgICAgZXhwb3J0TWVudUJydXNoLFxuICAgICAgICAgICAgc2VjdG9yQnJ1c2gsXG4gICAgICAgICAgICBkYXRhTGFiZWxCcnVzaCxcbiAgICAgICAgICAgIGF4aXNCcnVzaCxcbiAgICAgICAgICAgIGdhdWdlQnJ1c2gsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSBkYXRhLm5hbWUgLSBTZXJpZXMgbmFtZS5cbiAgICAgKiAgIEBwYXJhbSB7QXJyYXk8bnVtYmVyfEFycmF5PG51bWJlcj4+fSBkYXRhLmRhdGEgLSBBcnJheSBvZiBkYXRhIHRvIGJlIGFkZGVkLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmFkZFNlcmllcyh7XG4gICAgICogICBuYW1lOiAnbmV3U2VyaWVzJyxcbiAgICAgKiAgIGRhdGE6IFsxMCwgMjBdLFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGFkZFNlcmllcyhkYXRhKSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgnYWRkU2VyaWVzJywgeyBkYXRhIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIC0gQXJyYXkgb2YgZGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NhdGVnb3J5XSAtIENhdGVnb3J5IHRvIGJlIGFkZGVkLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHdpdGhvdXQgY2F0ZWdvcmllc1xuICAgICAqIGNoYXJ0LmFkZERhdGEoWzEwXSwgJzYnKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggY2F0ZWdvcmllc1xuICAgICAqIGNoYXJ0LmFkZERhdGEoWzEwXSwgJzYnKTtcbiAgICAgKi9cbiAgICBhZGREYXRhKGRhdGEsIGNhdGVnb3J5KSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25Db250cm9sRmxhZy51cGRhdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2FkZERhdGEnLCB7IGRhdGEsIGNhdGVnb3J5IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBjaGFydCBkYXRhIHRvIG5ldyBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBiZSBzZXQuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2V0RGF0YSh7XG4gICAgICogICBjYXRlZ29yaWVzOiBbJzEnLCAnMicsICczJ10sXG4gICAgICogICBzZXJpZXM6IFtcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgIG5hbWU6ICduZXcgc2VyaWVzJyxcbiAgICAgKiAgICAgICBkYXRhOiBbMSwgMiwgM10sXG4gICAgICogICAgIH0sXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICBuYW1lOiAnbmV3IHNlcmllczInLFxuICAgICAqICAgICAgIGRhdGE6IFs0LCA1LCA2XSxcbiAgICAgKiAgICAgfVxuICAgICAqICAgXVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHNldERhdGEoZGF0YSkge1xuICAgICAgICBjb25zdCB7IGNhdGVnb3JpZXMsIHNlcmllcyB9ID0gZGF0YTtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdzZXREYXRhJywgeyBzZXJpZXM6IHsgZ2F1Z2U6IHNlcmllcyB9LCBjYXRlZ29yaWVzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlIHNlcmllcyBkYXRhIGxhYmVsLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmhpZGVTZXJpZXNEYXRhTGFiZWwoKTtcbiAgICAgKi9cbiAgICBoaWRlU2VyaWVzRGF0YUxhYmVsKCkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCd1cGRhdGVPcHRpb25zJywge1xuICAgICAgICAgICAgb3B0aW9uczogeyBzZXJpZXM6IHsgZGF0YUxhYmVsczogeyB2aXNpYmxlOiBmYWxzZSB9IH0gfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgc2VyaWVzIGRhdGEgbGFiZWwuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2hvd1Nlcmllc0RhdGFMYWJlbCgpO1xuICAgICAqL1xuICAgIHNob3dTZXJpZXNEYXRhTGFiZWwoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3VwZGF0ZU9wdGlvbnMnLCB7XG4gICAgICAgICAgICBvcHRpb25zOiB7IHNlcmllczogeyBkYXRhTGFiZWxzOiB7IHZpc2libGU6IHRydWUgfSB9IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBjaGFydCBvcHRpb25zIHRvIG5ldyBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ2hhcnQgb3B0aW9ucy5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zZXRPcHRpb25zKHtcbiAgICAgKiAgIGNoYXJ0OiB7XG4gICAgICogICAgIHdpZHRoOiA1MDAsXG4gICAgICogICAgIGhlaWdodDogNTAwLFxuICAgICAqICAgICB0aXRsZTogJ09seW1waWMgTWVkYWxzJyxcbiAgICAgKiAgIH0sXG4gICAgICogICBzZXJpZXM6IHtcbiAgICAgKiAgICAgc2VsZWN0YWJsZTogdHJ1ZVxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hPcHRpb25zRXZlbnQoJ2luaXRPcHRpb25zJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBjaGFydCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ2hhcnQgb3B0aW9ucy5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC51cGRhdGVPcHRpb25zKHtcbiAgICAgKiAgIGNoYXJ0OiB7XG4gICAgICogICAgIHRpdGxlOiAnT2x5bXBpYyBNZWRhbHMnLFxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHVwZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hPcHRpb25zRXZlbnQoJ3VwZGF0ZU9wdGlvbnMnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXJpZXNJbmZvIC0gSW5mb3JtYXRpb24gb2YgdGhlIHNlcmllcyBmb3IgdGhlIHRvb2x0aXAgdG8gYmUgZGlzcGxheWVkLlxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHNlcmllc0luZm8uaW5kZXggLSBJbmRleCBvZiBkYXRhIHdpdGhpbiBzZXJpZXMuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2hvd1Rvb2x0aXAoe2luZGV4OiAxfSk7XG4gICAgICovXG4gICAgc2hvd1Rvb2x0aXAoc2VyaWVzSW5mbykge1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nob3dUb29sdGlwJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZXJpZXNJbmZvKSwgeyBzdGF0ZTogdGhpcy5zdG9yZS5zdGF0ZSB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGUgdG9vbHRpcC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5oaWRlVG9vbHRpcCgpO1xuICAgICAqL1xuICAgIGhpZGVUb29sdGlwKCkge1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ2hpZGVUb29sdGlwJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBwbG90IGJhbmQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBQbG90IGluZm8uXG4gICAgICogICBAcGFyYW0ge0FycmF5PHN0cmluZ3xudW1iZXI+fSBkYXRhLnJhbmdlIC0gVGhlIHJhbmdlIHRvIGJlIGRyYXduLlxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9IGRhdGEuY29sb3IgLSBQbG90IGJhbmQgY29sb3IuXG4gICAgICogICBAcGFyYW0ge3N0cmluZ30gW2RhdGEuaWRdIC0gUGxvdCBpZC4gVGhlIHZhbHVlIG9uIHdoaWNoIHRoZSByZW1vdmVQbG90QmFuZCBpcyBiYXNlZC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5hZGRQbG90QmFuZCh7XG4gICAgICogICByYW5nZTogWzEwLCAyMF0sXG4gICAgICogICBjb2xvcjogJyMwMGZmMjInLFxuICAgICAqICAgaWQ6ICdwbG90LTEnLFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGFkZFBsb3RCYW5kKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgnYWRkR2F1Z2VQbG90QmFuZCcsIHsgZGF0YSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHBsb3QgYmFuZCB3aXRoIGlkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIGlkIG9mIHRoZSBwbG90IGJhbmQgdG8gYmUgcmVtb3ZlZFxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnJlbW92ZVBsb3RCYW5kKCdwbG90LTEnKTtcbiAgICAgKi9cbiAgICByZW1vdmVQbG90QmFuZChpZCkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdyZW1vdmVHYXVnZVBsb3RCYW5kJywgeyBpZCB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ2hhcnQgZnJvbSBcIi4vY2hhcnRcIjtcbmltcG9ydCBoZWF0bWFwQXhlcyBmcm9tIFwiLi4vc3RvcmUvaGVhdG1hcEF4ZXNcIjtcbmltcG9ydCBoZWF0bWFwU2VyaWVzRGF0YSBmcm9tIFwiLi4vc3RvcmUvaGVhdG1hcFNlcmllc0RhdGFcIjtcbmltcG9ydCBjb2xvclZhbHVlU2NhbGUgZnJvbSBcIi4uL3N0b3JlL2NvbG9yVmFsdWVTY2FsZVwiO1xuaW1wb3J0IFRvb2x0aXAgZnJvbSBcIi4uL2NvbXBvbmVudC90b29sdGlwXCI7XG5pbXBvcnQgVGl0bGUgZnJvbSBcIi4uL2NvbXBvbmVudC90aXRsZVwiO1xuaW1wb3J0IEV4cG9ydE1lbnUgZnJvbSBcIi4uL2NvbXBvbmVudC9leHBvcnRNZW51XCI7XG5pbXBvcnQgSG92ZXJlZFNlcmllcyBmcm9tIFwiLi4vY29tcG9uZW50L2hvdmVyZWRTZXJpZXNcIjtcbmltcG9ydCBEYXRhTGFiZWxzIGZyb20gXCIuLi9jb21wb25lbnQvZGF0YUxhYmVsc1wiO1xuaW1wb3J0IFNwZWN0cnVtTGVnZW5kIGZyb20gXCIuLi9jb21wb25lbnQvc3BlY3RydW1MZWdlbmRcIjtcbmltcG9ydCBIZWF0bWFwU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvaGVhdG1hcFNlcmllc1wiO1xuaW1wb3J0IEF4aXNUaXRsZSBmcm9tIFwiLi4vY29tcG9uZW50L2F4aXNUaXRsZVwiO1xuaW1wb3J0IEF4aXMgZnJvbSBcIi4uL2NvbXBvbmVudC9heGlzXCI7XG5pbXBvcnQgU2VsZWN0ZWRTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9zZWxlY3RlZFNlcmllc1wiO1xuaW1wb3J0IEJhY2tncm91bmQgZnJvbSBcIi4uL2NvbXBvbmVudC9iYWNrZ3JvdW5kXCI7XG5pbXBvcnQgTm9EYXRhVGV4dCBmcm9tIFwiLi4vY29tcG9uZW50L25vRGF0YVRleHRcIjtcbmltcG9ydCAqIGFzIGJhc2ljQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvYmFzaWNcIjtcbmltcG9ydCAqIGFzIGxlZ2VuZEJydXNoIGZyb20gXCIuLi9icnVzaGVzL2xlZ2VuZFwiO1xuaW1wb3J0ICogYXMgbGFiZWxCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9sYWJlbFwiO1xuaW1wb3J0ICogYXMgZXhwb3J0TWVudUJydXNoIGZyb20gXCIuLi9icnVzaGVzL2V4cG9ydE1lbnVcIjtcbmltcG9ydCAqIGFzIGRhdGFMYWJlbEJydXNoIGZyb20gXCIuLi9icnVzaGVzL2RhdGFMYWJlbFwiO1xuaW1wb3J0ICogYXMgc3BlY3RydW1MZWdlbmRCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9zcGVjdHJ1bUxlZ2VuZFwiO1xuaW1wb3J0ICogYXMgYXhpc0JydXNoIGZyb20gXCIuLi9icnVzaGVzL2F4aXNcIjtcbmZ1bmN0aW9uIGdldFNlcmllc1dpdGhZQ2F0ZWdvcnkoc2VyaWVzLCBjYXRlZ29yaWVzKSB7XG4gICAgcmV0dXJuIHNlcmllcy5tYXAoKHJvd1NlcmllcywgeSkgPT4gKHtcbiAgICAgICAgZGF0YTogcm93U2VyaWVzLFxuICAgICAgICB5Q2F0ZWdvcnk6IGNhdGVnb3JpZXMueVt5XSxcbiAgICB9KSk7XG59XG4vKipcbiAqIEBjbGFzc1xuICogQGNsYXNzZGVzYyBIZWF0bWFwIENoYXJ0XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gcHJvcHMuZWwgLSBUaGUgdGFyZ2V0IGVsZW1lbnQgdG8gY3JlYXRlIGNoYXJ0LlxuICogICBAcGFyYW0ge09iamVjdH0gcHJvcHMuZGF0YSAtIERhdGEgZm9yIG1ha2luZyBIZWF0bWFwIENoYXJ0LlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBwcm9wcy5kYXRhLmNhdGVnb3JpZXNcbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gcHJvcHMuZGF0YS5jYXRlZ29yaWVzLnggLSBYIENhdGVnb3JpZXMuXG4gKiAgICAgICBAcGFyYW0ge0FycmF5PHN0cmluZz59IHByb3BzLmRhdGEuY2F0ZWdvcmllcy55IC0gWSBDYXRlZ29yaWVzLlxuICogICAgIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHByb3BzLmRhdGEuc2VyaWVzIC0gU2VyaWVzIGRhdGEuXG4gKiAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9uc10gLSBPcHRpb25zIGZvciBtYWtpbmcgSGVhdG1hcCBDaGFydC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2hhcnRdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlXSAtIENoYXJ0IHRpdGxlIHRleHQgb3Igb3B0aW9ucy5cbiAqICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLnRleHRdIC0gQ2hhcnQgdGl0bGUgdGV4dC5cbiAqICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLm9mZnNldFhdIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgaG9yaXpvbnRhbGx5LlxuICogICAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUub2Zmc2V0WV0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSB2ZXJ0aWNhbGx5LlxuICogICAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUuYWxpZ25dIC0gQ2hhcnQgdGV4dCBhbGlnbi4gJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJyBpcyBhdmFpbGFibGUuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaGFydC5hbmltYXRpb25dIC0gV2hldGhlciB0byB1c2UgYW5pbWF0aW9uIGFuZCBkdXJhdGlvbiB3aGVuIHJlbmRlcmluZyB0aGUgaW5pdGlhbCBjaGFydC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQud2lkdGhdIC0gQ2hhcnQgd2lkdGguICdhdXRvJyBvciBpZiBub3Qgd3JpdGUsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC4gJ2F1dG8nIG9yIGlmIG5vdCBjcmVhdGVkLCB0aGUgd2lkdGggb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LmhlaWdodF0gLSBDaGFydCBoZWlnaHQuICdhdXRvJyBvciBpZiBub3Qgd3JpdGUsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC4gJ2F1dG8nIG9yIGlmIG5vdCBjcmVhdGVkLCB0aGUgaGVpZ2h0IG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5zZXJpZXNdXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5zZWxlY3RhYmxlPWZhbHNlXSAtIFdoZXRoZXIgdG8gbWFrZSBzZWxlY3RhYmxlIHNlcmllcyBvciBub3QuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5zaGlmdD1mYWxzZV0gLSBXaGV0aGVyIHRvIHVzZSBzaGlmdCB3aGVuIGFkZERhdGEgb3Igbm90LlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnNlcmllcy5kYXRhTGFiZWxzXSAtIFNldCB0aGUgdmlzaWJpbGl0eSwgbG9jYXRpb24sIGFuZCBmb3JtYXR0aW5nIG9mIGRhdGFMYWJlbC4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fERhdGFMYWJlbHMgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXNdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLnRpdGxlXSAtIEF4aXMgdGl0bGUuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnhBeGlzLnJvdGF0ZUxhYmVsPXRydWVdIC0gV2hldGhlciB0byBhbGxvdyBheGlzIGxhYmVsIHJvdGF0aW9uLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufE9iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXMuZGF0ZV0gLSBXaGV0aGVyIHRoZSB4IGF4aXMgbGFiZWwgaXMgb2YgZGF0ZSB0eXBlLiBGb3JtYXQgb3B0aW9uIHVzZWQgZm9yIGRhdGUgdHlwZS4gV2hldGhlciB0aGUgeCBheGlzIGxhYmVsIGlzIG9mIGRhdGUgdHlwZS4gSWYgdXNlIGRhdGUgdHlwZSwgZm9ybWF0IG9wdGlvbiB1c2VkIGZvciBkYXRlIHR5cGUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXMudGlja10gLSBPcHRpb24gdG8gYWRqdXN0IHRpY2sgaW50ZXJ2YWwuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXMubGFiZWxdIC0gT3B0aW9uIHRvIGFkanVzdCBsYWJlbCBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy5zY2FsZV0gLSBPcHRpb24gdG8gYWRqdXN0IGF4aXMgbWluaW11bSwgbWF4aW11bSwgc3RlcCBzaXplLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnhBeGlzLndpZHRoXSAtIFdpZHRoIG9mIHhBeGlzLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnhBeGlzLmhlaWdodF0gLSBIZWlnaHQgb2YgeEF4aXMuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R8QXJyYXk8T2JqZWN0Pn0gW3Byb3BzLm9wdGlvbnMueUF4aXNdIC0gSWYgdGhpcyBvcHRpb24gaXMgYW4gYXJyYXkgdHlwZSwgdXNlIHRoZSBzZWNvbmRhcnkgeSBheGlzLlxuICogICAgICAgQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpcy50aXRsZV0gLSBBeGlzIHRpdGxlLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufE9iamVjdH0gW3Byb3BzLm9wdGlvbnMueUF4aXMuZGF0ZV0gLSBXaGV0aGVyIHRoZSB5IGF4aXMgbGFiZWwgaXMgb2YgZGF0ZSB0eXBlLiBGb3JtYXQgb3B0aW9uIHVzZWQgZm9yIGRhdGUgdHlwZS4gV2hldGhlciB0aGUgeSBheGlzIGxhYmVsIGlzIG9mIGRhdGUgdHlwZS4gSWYgdXNlIGRhdGUgdHlwZSwgZm9ybWF0IG9wdGlvbiB1c2VkIGZvciBkYXRlIHR5cGUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueUF4aXMudGlja10gLSBPcHRpb24gdG8gYWRqdXN0IHRpY2sgaW50ZXJ2YWwuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueUF4aXMubGFiZWxdIC0gT3B0aW9uIHRvIGFkanVzdCBsYWJlbCBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpcy5zY2FsZV0gLSBPcHRpb24gdG8gYWRqdXN0IGF4aXMgbWluaW11bSwgbWF4aW11bSwgc3RlcCBzaXplLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnlBeGlzLndpZHRoXSAtIFdpZHRoIG9mIHlBeGlzLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnlBeGlzLmhlaWdodF0gLSBIZWlnaHQgb2YgeUF4aXMuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnBsb3RdXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMucGxvdC53aWR0aF0gLSBXaWR0aCBvZiBwbG90LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnBsb3QuaGVpZ2h0XSAtIEhlaWdodCBvZiBwbG90LlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5wbG90LnZpc2libGVdIC0gV2hldGhlciB0byBzaG93IHBsb3QgbGluZS5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGVnZW5kXVxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC5hbGlnbl0gLSBMZWdlbmQgYWxpZ24uICd0b3AnLCAnYm90dG9tJywgJ3JpZ2h0JywgJ2xlZnQnIGlzIGF2YWlsYWJsZS5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMubGVnZW5kLnZpc2libGVdIC0gV2hldGhlciB0byBzaG93IGxlZ2VuZC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5sZWdlbmQud2lkdGhdIC0gV2lkdGggb2YgbGVnZW5kLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5leHBvcnRNZW51XVxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5leHBvcnRNZW51LnZpc2libGVdIC0gV2hldGhlciB0byBzaG93IGV4cG9ydCBtZW51LlxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnUuZmlsZW5hbWVdIC0gRmlsZSBuYW1lIGFwcGxpZWQgd2hlbiBkb3dubG9hZGluZy5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcF1cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy50b29sdGlwLm9mZnNldFhdIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgaG9yaXpvbnRhbGx5LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAub2Zmc2V0WV0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSB2ZXJ0aWNhbGx5LlxuICogICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC5mb3JtYXR0ZXJdIC0gRnVuY3Rpb24gdG8gZm9ybWF0IGRhdGEgdmFsdWUuXG4gKiAgICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcHMub3B0aW9ucy50b29sdGlwLnRlbXBsYXRlXSAtIEZ1bmN0aW9uIHRvIGNyZWF0ZSBjdXN0b20gdGVtcGxhdGUuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxUb29sdGlwIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnJlc3BvbnNpdmVdIC0gUnVsZXMgZm9yIGNoYW5naW5nIGNoYXJ0IG9wdGlvbnMuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxSZXNwb25zaXZlIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5yZXNwb25zaXZlLmFuaW1hdGlvbl0gLSBBbmltYXRpb24gZHVyYXRpb24gd2hlbiB0aGUgY2hhcnQgaXMgbW9kaWZpZWQuXG4gKiAgICAgICBAcGFyYW0ge0FycmF5PE9iamVjdD59IFtwcm9wcy5vcHRpb25zLnJlc3BvbnNpdmUucnVsZXNdIC0gUnVsZXMgZm9yIHRoZSBDaGFydCB0byBSZXNwb25kLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sYW5nXSAtIE9wdGlvbnMgZm9yIGNoYW5naW5nIHRoZSB0ZXh0IGRpc3BsYXllZCBvbiB0aGUgY2hhcnQgb3IgaTE4biBsYW5ndWFnZXMuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGFuZy5ub0RhdGFdIC0gTm8gRGF0YSBMYXllciBUZXh0LlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZV0gLSBDaGFydCB0aGVtZSBvcHRpb25zLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8SGVhdG1hcCBDaGFydCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmNoYXJ0XSAtIENoYXJ0IGZvbnQgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUubm9EYXRhXSAtIE5vIERhdGEgTGF5ZXIgVGV4dCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5zZXJpZXNdIC0gU2VyaWVzIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnRpdGxlXSAtIFRpdGxlIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnhBeGlzXSAtIFggQXhpcyB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS55QXhpc10gLSBZIEF4aXMgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUubGVnZW5kXSAtIExlZ2VuZCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS50b29sdGlwXSAtIFRvb2x0aXAgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUucGxvdF0gLSBQbG90IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmV4cG9ydE1lbnVdIC0gRXhwb3J0TWVudSB0aGVtZS5cbiAqIEBleHRlbmRzIENoYXJ0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlYXRtYXBDaGFydCBleHRlbmRzIENoYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBlbDogcHJvcHMuZWwsXG4gICAgICAgICAgICBjYXRlZ29yaWVzOiBwcm9wcy5kYXRhLmNhdGVnb3JpZXMsXG4gICAgICAgICAgICBvcHRpb25zOiBwcm9wcy5vcHRpb25zLFxuICAgICAgICAgICAgc2VyaWVzOiB7XG4gICAgICAgICAgICAgICAgaGVhdG1hcDogZ2V0U2VyaWVzV2l0aFlDYXRlZ29yeShwcm9wcy5kYXRhLnNlcmllcywgcHJvcHMuZGF0YS5jYXRlZ29yaWVzKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb2R1bGVzOiBbaGVhdG1hcFNlcmllc0RhdGEsIGNvbG9yVmFsdWVTY2FsZSwgaGVhdG1hcEF4ZXNdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEJhY2tncm91bmQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFRpdGxlKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChTcGVjdHJ1bUxlZ2VuZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoRXhwb3J0TWVudSwgeyBjaGFydEVsOiB0aGlzLmVsIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEhlYXRtYXBTZXJpZXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEF4aXMsIHsgbmFtZTogJ3lBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzLCB7IG5hbWU6ICd4QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpc1RpdGxlLCB7IG5hbWU6ICd4QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpc1RpdGxlLCB7IG5hbWU6ICd5QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoSG92ZXJlZFNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoU2VsZWN0ZWRTZXJpZXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKERhdGFMYWJlbHMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFRvb2x0aXAsIHsgY2hhcnRFbDogdGhpcy5lbCB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChOb0RhdGFUZXh0KTtcbiAgICAgICAgdGhpcy5wYWludGVyLmFkZEdyb3VwcyhbXG4gICAgICAgICAgICBiYXNpY0JydXNoLFxuICAgICAgICAgICAgYXhpc0JydXNoLFxuICAgICAgICAgICAgbGVnZW5kQnJ1c2gsXG4gICAgICAgICAgICBsYWJlbEJydXNoLFxuICAgICAgICAgICAgZXhwb3J0TWVudUJydXNoLFxuICAgICAgICAgICAgZGF0YUxhYmVsQnJ1c2gsXG4gICAgICAgICAgICBzcGVjdHJ1bUxlZ2VuZEJydXNoLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSAtIEFycmF5IG9mIGRhdGEgdG8gYmUgYWRkZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhdGVnb3J5IC0gQ2F0ZWdvcnkgdG8gYmUgYWRkZWQuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuYWRkRGF0YShbMTAsIDIwXSwgJzYnKTtcbiAgICAgKi9cbiAgICBhZGREYXRhKGRhdGEsIGNhdGVnb3J5KSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQ29udHJvbEZsYWcudXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2FkZERhdGEnLCB7IGRhdGEsIGNhdGVnb3J5IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSBkYXRhLm5hbWUgLSBTZXJpZXMgbmFtZS5cbiAgICAgKiAgIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZGF0YS5kYXRhIC0gQXJyYXkgb2YgZGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YUluZm8gLSBDYXRlZ29yeSBpbmZvcm1hdGlvbiBvZiB0aGUgc2VyaWVzLlxuICAgICAqICAgQHBhcmFtIHtPYmplY3R9IGRhdGFJbmZvLmNhdGVnb3J5IC0gWSBjYXRlZ29yeS5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5hZGRTZXJpZXMoe1xuICAgICAqICAgbmFtZTogJ25ld1NlcmllcycsXG4gICAgICogICBkYXRhOiBbMTAsIDEwMCwgNTAsIDQwLCA3MCwgNTUsIDMzLCA3MCwgOTAsIDExMF0sXG4gICAgICogfSk7XG4gICAgICovXG4gICAgYWRkU2VyaWVzKGRhdGEsIGRhdGFJbmZvKSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgnYWRkSGVhdG1hcFNlcmllcycsIE9iamVjdC5hc3NpZ24oeyBkYXRhIH0sIGRhdGFJbmZvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGNoYXJ0IGRhdGEgdG8gbmV3IGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBEYXRhIHRvIGJlIHNldC5cbiAgICAgKiAgIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZGF0YS5jYXRlZ29yaWVzLnggLSBYIENhdGVnb3JpZXMuXG4gICAgICogICBAcGFyYW0ge0FycmF5PHN0cmluZz59IGRhdGEuY2F0ZWdvcmllcy55IC0gWSBDYXRlZ29yaWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGRhdGEuc2VyaWVzIC0gU2VyaWVzIGRhdGEuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2V0RGF0YSh7XG4gICAgICogICBjYXRlZ29yaWVzOiB7XG4gICAgICogICAgIHg6IFsnMScsICcyJywgJzMnIF0sXG4gICAgICogICAgIHk6IFsnQScsICdCJ10sXG4gICAgICogICB9LFxuICAgICAqICAgc2VyaWVzOiBbXG4gICAgICogICAgIFsxLCAyLCAzXSxcbiAgICAgKiAgICAgWzQsIDUsIDZdLFxuICAgICAqICAgXVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHNldERhdGEoZGF0YSkge1xuICAgICAgICBjb25zdCB7IGNhdGVnb3JpZXMsIHNlcmllcyB9ID0gZGF0YTtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdzZXREYXRhJywge1xuICAgICAgICAgICAgc2VyaWVzOiB7IGhlYXRtYXA6IGdldFNlcmllc1dpdGhZQ2F0ZWdvcnkoc2VyaWVzLCBjYXRlZ29yaWVzKSB9LFxuICAgICAgICAgICAgY2F0ZWdvcmllcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGUgc2VyaWVzIGRhdGEgbGFiZWwuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuaGlkZVNlcmllc0RhdGFMYWJlbCgpO1xuICAgICAqL1xuICAgIGhpZGVTZXJpZXNEYXRhTGFiZWwoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3VwZGF0ZU9wdGlvbnMnLCB7XG4gICAgICAgICAgICBvcHRpb25zOiB7IHNlcmllczogeyBkYXRhTGFiZWxzOiB7IHZpc2libGU6IGZhbHNlIH0gfSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyBzZXJpZXMgZGF0YSBsYWJlbC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zaG93U2VyaWVzRGF0YUxhYmVsKCk7XG4gICAgICovXG4gICAgc2hvd1Nlcmllc0RhdGFMYWJlbCgpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgndXBkYXRlT3B0aW9ucycsIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHsgc2VyaWVzOiB7IGRhdGFMYWJlbHM6IHsgdmlzaWJsZTogdHJ1ZSB9IH0gfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGNoYXJ0IG9wdGlvbnMgdG8gbmV3IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDaGFydCBvcHRpb25zXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2V0T3B0aW9ucyh7XG4gICAgICogICBjaGFydDoge1xuICAgICAqICAgICB3aWR0aDogNTAwLFxuICAgICAqICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgKiAgICAgdGl0bGU6ICdFbmVyZ3kgVXNhZ2UnLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHhBeGlzOiB7XG4gICAgICogICAgIHRpdGxlOiAnTW9udGgnLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHlBeGlzOiB7XG4gICAgICogICAgIHRpdGxlOiAnRW5lcmd5IChrV2gpJyxcbiAgICAgKiAgIH0sXG4gICAgICogICBzZXJpZXM6IHtcbiAgICAgKiAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgKiAgIH0sXG4gICAgICogICB0b29sdGlwOiB7XG4gICAgICogICAgIGZvcm1hdHRlcjogKHZhbHVlKSA9PiBgJHt2YWx1ZX1rV2hgLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoT3B0aW9uc0V2ZW50KCdpbml0T3B0aW9ucycsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY2hhcnQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENoYXJ0IG9wdGlvbnNcbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC51cGRhdGVPcHRpb25zKHtcbiAgICAgKiAgIGNoYXJ0OiB7XG4gICAgICogICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAqICAgICB0aXRsZTogJ0VuZXJneSBVc2FnZScsXG4gICAgICogICB9LFxuICAgICAqICAgdG9vbHRpcDoge1xuICAgICAqICAgICBmb3JtYXR0ZXI6ICh2YWx1ZSkgPT4gYCR7dmFsdWV9a1doYCxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICovXG4gICAgdXBkYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE9wdGlvbnNFdmVudCgndXBkYXRlT3B0aW9ucycsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlcmllc0luZm8gLSBJbmZvcm1hdGlvbiBvZiB0aGUgc2VyaWVzIGZvciB0aGUgdG9vbHRpcCB0byBiZSBkaXNwbGF5ZWQuXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gc2VyaWVzSW5mby5zZXJpZXNJbmRleCAtIEluZGV4IG9mIHNlcmllcy5cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBzZXJpZXNJbmZvLmluZGV4IC0gSW5kZXggb2YgZGF0YSB3aXRoaW4gc2VyaWVzLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNob3dUb29sdGlwKHtpbmRleDogMSwgc2VyaWVzSW5kZXg6IDJ9KTtcbiAgICAgKi9cbiAgICBzaG93VG9vbHRpcChzZXJpZXNJbmZvKSB7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnc2hvd1Rvb2x0aXAnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlcmllc0luZm8pLCB7IHN0YXRlOiB0aGlzLnN0b3JlLnN0YXRlIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZSB0b29sdGlwLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmhpZGVUb29sdGlwKCk7XG4gICAgICovXG4gICAgaGlkZVRvb2x0aXAoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnaGlkZVRvb2x0aXAnKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ2hhcnQgZnJvbSBcIi4vY2hhcnRcIjtcbmltcG9ydCBkYXRhUmFuZ2UgZnJvbSBcIi4uL3N0b3JlL2RhdGFSYW5nZVwiO1xuaW1wb3J0IHNjYWxlIGZyb20gXCIuLi9zdG9yZS9zY2FsZVwiO1xuaW1wb3J0IGF4ZXMgZnJvbSBcIi4uL3N0b3JlL2F4ZXNcIjtcbmltcG9ydCBwbG90IGZyb20gXCIuLi9zdG9yZS9wbG90XCI7XG5pbXBvcnQgc3RhY2tTZXJpZXNEYXRhIGZyb20gXCIuLi9zdG9yZS9zdGFja1Nlcmllc0RhdGFcIjtcbmltcG9ydCBUb29sdGlwIGZyb20gXCIuLi9jb21wb25lbnQvdG9vbHRpcFwiO1xuaW1wb3J0IFBsb3QgZnJvbSBcIi4uL2NvbXBvbmVudC9wbG90XCI7XG5pbXBvcnQgTGluZVNlcmllcyBmcm9tIFwiLi4vY29tcG9uZW50L2xpbmVTZXJpZXNcIjtcbmltcG9ydCBBcmVhU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvYXJlYVNlcmllc1wiO1xuaW1wb3J0IEF4aXMgZnJvbSBcIi4uL2NvbXBvbmVudC9heGlzXCI7XG5pbXBvcnQgTGVnZW5kIGZyb20gXCIuLi9jb21wb25lbnQvbGVnZW5kXCI7XG5pbXBvcnQgRGF0YUxhYmVscyBmcm9tIFwiLi4vY29tcG9uZW50L2RhdGFMYWJlbHNcIjtcbmltcG9ydCBBeGlzVGl0bGUgZnJvbSBcIi4uL2NvbXBvbmVudC9heGlzVGl0bGVcIjtcbmltcG9ydCBUaXRsZSBmcm9tIFwiLi4vY29tcG9uZW50L3RpdGxlXCI7XG5pbXBvcnQgRXhwb3J0TWVudSBmcm9tIFwiLi4vY29tcG9uZW50L2V4cG9ydE1lbnVcIjtcbmltcG9ydCBTZWxlY3RlZFNlcmllcyBmcm9tIFwiLi4vY29tcG9uZW50L3NlbGVjdGVkU2VyaWVzXCI7XG5pbXBvcnQgSG92ZXJlZFNlcmllcyBmcm9tIFwiLi4vY29tcG9uZW50L2hvdmVyZWRTZXJpZXNcIjtcbmltcG9ydCBSYW5nZVNlbGVjdGlvbiBmcm9tIFwiLi4vY29tcG9uZW50L3JhbmdlU2VsZWN0aW9uXCI7XG5pbXBvcnQgUmVzZXRCdXR0b24gZnJvbSBcIi4uL2NvbXBvbmVudC9yZXNldEJ1dHRvblwiO1xuaW1wb3J0IEJhY2tncm91bmQgZnJvbSBcIi4uL2NvbXBvbmVudC9iYWNrZ3JvdW5kXCI7XG5pbXBvcnQgTm9EYXRhVGV4dCBmcm9tIFwiLi4vY29tcG9uZW50L25vRGF0YVRleHRcIjtcbmltcG9ydCAqIGFzIGxpbmVTZXJpZXNCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9saW5lU2VyaWVzXCI7XG5pbXBvcnQgKiBhcyBiYXNpY0JydXNoIGZyb20gXCIuLi9icnVzaGVzL2Jhc2ljXCI7XG5pbXBvcnQgKiBhcyBheGlzQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvYXhpc1wiO1xuaW1wb3J0ICogYXMgbGVnZW5kQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvbGVnZW5kXCI7XG5pbXBvcnQgKiBhcyBsYWJlbEJydXNoIGZyb20gXCIuLi9icnVzaGVzL2xhYmVsXCI7XG5pbXBvcnQgKiBhcyBleHBvcnRNZW51QnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvZXhwb3J0TWVudVwiO1xuaW1wb3J0ICogYXMgZGF0YUxhYmVsQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvZGF0YUxhYmVsXCI7XG5pbXBvcnQgKiBhcyByZXNldEJ1dHRvbkJydXNoIGZyb20gXCIuLi9icnVzaGVzL3Jlc2V0QnV0dG9uXCI7XG4vKipcbiAqIEBjbGFzc1xuICogQGNsYXNzZGVzYyBMaW5lQXJlYSBDaGFydFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHByb3BzLmVsIC0gVGhlIHRhcmdldCBlbGVtZW50IHRvIGNyZWF0ZSBjaGFydC5cbiAqICAgQHBhcmFtIHtPYmplY3R9IHByb3BzLmRhdGEgLSBEYXRhIGZvciBtYWtpbmcgTGluZUFyZWEgQ2hhcnQuXG4gKiAgICAgQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBwcm9wcy5kYXRhLmNhdGVnb3JpZXMgLSBDYXRlZ29yaWVzLlxuICogICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcHJvcHMuZGF0YS5zZXJpZXMgLSBTZXJpZXMgZGF0YS5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcHJvcHMuZGF0YS5zZXJpZXMubGluZSAtIExpbmUgc2VyaWVzIGRhdGEuIENvb3JkaW5hdGUgdHlwZXMgZGF0YSBpcyBub3QgcG9zc2libGUuXG4gKiAgICAgICBAcGFyYW0ge0FycmF5PE9iamVjdD59IHByb3BzLmRhdGEuc2VyaWVzLmFyZWEgLSBBcmVhIHNlcmllcyBkYXRhLlxuICogICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnNdIC0gT3B0aW9ucyBmb3IgbWFraW5nIExpbmVBcmVhIENoYXJ0LlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaGFydF1cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGVdIC0gQ2hhcnQgdGl0bGUgdGV4dCBvciBvcHRpb25zLlxuICogICAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUudGV4dF0gLSBDaGFydCB0aXRsZSB0ZXh0LlxuICogICAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUub2Zmc2V0WF0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSBob3Jpem9udGFsbHkuXG4gKiAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS5vZmZzZXRZXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIHZlcnRpY2FsbHkuXG4gKiAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS5hbGlnbl0gLSBDaGFydCB0ZXh0IGFsaWduLiAnbGVmdCcsICdyaWdodCcsICdjZW50ZXInIGlzIGF2YWlsYWJsZS5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbl0gLSBXaGV0aGVyIHRvIHVzZSBhbmltYXRpb24gYW5kIGR1cmF0aW9uIHdoZW4gcmVuZGVyaW5nIHRoZSBpbml0aWFsIGNoYXJ0LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC53aWR0aF0gLSBDaGFydCB3aWR0aC4gJ2F1dG8nIG9yIGlmIG5vdCB3cml0ZSwgdGhlIHdpZHRoIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLiAnYXV0bycgb3IgaWYgbm90IGNyZWF0ZWQsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQuaGVpZ2h0XSAtIENoYXJ0IGhlaWdodC4gJ2F1dG8nIG9yIGlmIG5vdCB3cml0ZSwgdGhlIHdpZHRoIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLiAnYXV0bycgb3IgaWYgbm90IGNyZWF0ZWQsIHRoZSBoZWlnaHQgb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnNlcmllc10gLSBXcml0ZSBjb21tb24gb3B0aW9ucyBpbiB0aGUgdXBwZXIgZGVwdGggYW5kIHNlcGFyYXRlIG9wdGlvbnMgdG8gYmUgYXBwbGllZCB0byBlYWNoIGNoYXJ0LlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnNlcmllcy5saW5lXSAtIE9wdGlvbnMgdG8gYmUgYXBwbGllZCB0byB0aGUgbGluZSBjaGFydC4gJ3NwbGluZScsICdzaG93RG90JywgJ2RhdGFMYWJlbHMnIGlzIGF2YWlsYWJsZS4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fExpbmUgQ2hhcnQgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5zZXJpZXMuYXJlYV0gLSBPcHRpb25zIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGFyZWEgY2hhcnQuICdzdGFjaycsICdzcGxpbmUnLCAnc2hvd0RvdCcsICdkYXRhTGFiZWxzJyBpcyBhdmFpbGFibGUuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxBcmVhIENoYXJ0IGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy56b29tYWJsZT1mYWxzZV0gLSBXaGV0aGVyIHRvIHVzZSB6b29tIGZlYXR1cmUgb3Igbm90LlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5zZXJpZXMucmFuZ2VTZWxlY3RhYmxlPWZhbHNlXSAtIFdoZXRoZXIgdG8gdXNlIHJhbmdlIHNlbGVjdGlvbiBmZWF0dXJlIG9yIG5vdC5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLnNob3dEb3Q9ZmFsc2VdIC0gV2hldGhlciB0byBzaG93IGRvdCBvciBub3QuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5zcGxpbmU9ZmFsc2VdIC0gV2hldGhlciB0byBtYWtlIHNwbGluZSBjaGFydCBvciBub3QuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5zZWxlY3RhYmxlPWZhbHNlXSAtIFdoZXRoZXIgdG8gbWFrZSBzZWxlY3RhYmxlIHNlcmllcyBvciBub3QuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5zaGlmdD1mYWxzZV0gLSBXaGV0aGVyIHRvIHVzZSBzaGlmdCB3aGVuIGFkZERhdGEgb3Igbm90LlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnNlcmllcy5kYXRhTGFiZWxzXSAtIFNldCB0aGUgdmlzaWJpbGl0eSwgbG9jYXRpb24sIGFuZCBmb3JtYXR0aW5nIG9mIGRhdGFMYWJlbC4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fERhdGFMYWJlbHMgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXNdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLnRpdGxlXSAtIEF4aXMgdGl0bGUuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnhBeGlzLnBvaW50T25Db2x1bW49ZmFsc2VdIC0gV2hldGhlciB0byBtb3ZlIHRoZSBzdGFydCBvZiB0aGUgY2hhcnQgdG8gdGhlIGNlbnRlciBvZiB0aGUgY29sdW1uLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy54QXhpcy5yb3RhdGVMYWJlbD10cnVlXSAtIFdoZXRoZXIgdG8gYWxsb3cgYXhpcyBsYWJlbCByb3RhdGlvbi5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLmRhdGVdIC0gV2hldGhlciB0aGUgeCBheGlzIGxhYmVsIGlzIG9mIGRhdGUgdHlwZS4gRm9ybWF0IG9wdGlvbiB1c2VkIGZvciBkYXRlIHR5cGUuIFdoZXRoZXIgdGhlIHggYXhpcyBsYWJlbCBpcyBvZiBkYXRlIHR5cGUuIElmIHVzZSBkYXRlIHR5cGUsIGZvcm1hdCBvcHRpb24gdXNlZCBmb3IgZGF0ZSB0eXBlLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLnRpY2tdIC0gT3B0aW9uIHRvIGFkanVzdCB0aWNrIGludGVydmFsLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLmxhYmVsXSAtIE9wdGlvbiB0byBhZGp1c3QgbGFiZWwgaW50ZXJ2YWwuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXMuc2NhbGVdIC0gT3B0aW9uIHRvIGFkanVzdCBheGlzIG1pbmltdW0sIG1heGltdW0sIHN0ZXAgc2l6ZS5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy54QXhpcy53aWR0aF0gLSBXaWR0aCBvZiB4QXhpcy5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy54QXhpcy5oZWlnaHRdIC0gSGVpZ2h0IG9mIHhBeGlzLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fEFycmF5PE9iamVjdD59IFtwcm9wcy5vcHRpb25zLnlBeGlzXSAtIElmIHRoaXMgb3B0aW9uIGlzIGFuIGFycmF5IHR5cGUsIHVzZSB0aGUgc2Vjb25kYXJ5IHkgYXhpcy5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW3Byb3BzLm9wdGlvbnMueUF4aXMudGl0bGVdIC0gQXhpcyB0aXRsZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpcy50aWNrXSAtIE9wdGlvbiB0byBhZGp1c3QgdGljayBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpcy5sYWJlbF0gLSBPcHRpb24gdG8gYWRqdXN0IGxhYmVsIGludGVydmFsLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnlBeGlzLnNjYWxlXSAtIE9wdGlvbiB0byBhZGp1c3QgYXhpcyBtaW5pbXVtLCBtYXhpbXVtLCBzdGVwIHNpemUuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMueUF4aXMud2lkdGhdIC0gV2lkdGggb2YgeUF4aXMuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMueUF4aXMuaGVpZ2h0XSAtIEhlaWdodCBvZiB5QXhpcy5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMucGxvdF1cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5wbG90LndpZHRoXSAtIFdpZHRoIG9mIHBsb3QuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMucGxvdC5oZWlnaHRdIC0gSGVpZ2h0IG9mIHBsb3QuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnBsb3QudmlzaWJsZV0gLSBXaGV0aGVyIHRvIHNob3cgcGxvdCBsaW5lLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBbcHJvcHMub3B0aW9ucy5wbG90LmxpbmVzXSAtIFBsb3QgbGluZXMgaW5mb3JtYXRpb24uIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxQbG90IGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgICBAcGFyYW0ge0FycmF5PE9iamVjdD59IFtwcm9wcy5vcHRpb25zLnBsb3QuYmFuZHNdIC0gUGxvdCBiYW5kcyBpbmZvcm1hdGlvbi4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFBsb3QgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGVnZW5kXVxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC5hbGlnbl0gLSBMZWdlbmQgYWxpZ24uICd0b3AnLCAnYm90dG9tJywgJ3JpZ2h0JywgJ2xlZnQnIGlzIGF2YWlsYWJsZS5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5sZWdlbmQuc2hvd0NoZWNrYm94XSAtIFdoZXRoZXIgdG8gc2hvdyBjaGVja2JveC5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMubGVnZW5kLnZpc2libGVdIC0gV2hldGhlciB0byBzaG93IGxlZ2VuZC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5sZWdlbmQud2lkdGhdIC0gV2lkdGggb2YgbGVnZW5kLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC5pdGVtXSAtIGB3aWR0aGAgYW5kIGBvdmVyZmxvd2Agb3B0aW9ucyBvZiB0aGUgbGVnZW5kIGl0ZW0uIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxMZWdlbmQgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuZXhwb3J0TWVudV1cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuZXhwb3J0TWVudS52aXNpYmxlXSAtIFdoZXRoZXIgdG8gc2hvdyBleHBvcnQgbWVudS5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5leHBvcnRNZW51LmZpbGVuYW1lXSAtIEZpbGUgbmFtZSBhcHBsaWVkIHdoZW4gZG93bmxvYWRpbmcuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRvb2x0aXBdXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC5vZmZzZXRYXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIGhvcml6b250YWxseS5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy50b29sdGlwLm9mZnNldFldIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgdmVydGljYWxseS5cbiAqICAgICAgIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAuZm9ybWF0dGVyXSAtIEZ1bmN0aW9uIHRvIGZvcm1hdCBkYXRhIHZhbHVlLlxuICogICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC50ZW1wbGF0ZV0gLSBGdW5jdGlvbiB0byBjcmVhdGUgY3VzdG9tIHRlbXBsYXRlLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8VG9vbHRpcCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5yZXNwb25zaXZlXSAtIFJ1bGVzIGZvciBjaGFuZ2luZyBjaGFydCBvcHRpb25zLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8UmVzcG9uc2l2ZSBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufE9iamVjdH0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZS5hbmltYXRpb25dIC0gQW5pbWF0aW9uIGR1cmF0aW9uIHdoZW4gdGhlIGNoYXJ0IGlzIG1vZGlmaWVkLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBbcHJvcHMub3B0aW9ucy5yZXNwb25zaXZlLnJ1bGVzXSAtIFJ1bGVzIGZvciB0aGUgQ2hhcnQgdG8gUmVzcG9uZC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGFuZ10gLSBPcHRpb25zIGZvciBjaGFuZ2luZyB0aGUgdGV4dCBkaXNwbGF5ZWQgb24gdGhlIGNoYXJ0IG9yIGkxOG4gbGFuZ3VhZ2VzLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxhbmcubm9EYXRhXSAtIE5vIERhdGEgTGF5ZXIgVGV4dC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWVdIC0gQ2hhcnQgdGhlbWUgb3B0aW9ucy4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fExpbmVBcmVhIENoYXJ0IGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUuY2hhcnRdIC0gQ2hhcnQgZm9udCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5ub0RhdGFdIC0gTm8gRGF0YSBMYXllciBUZXh0IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnNlcmllc10gLSBTZXJpZXMgdGhlbWUuIEVhY2ggdGhlbWUgdG8gYmUgYXBwbGllZCB0byB0aGUgdHdvIGNoYXJ0cyBzaG91bGQgYmUgd3JpdHRlbiBzZXBhcmF0ZWx5LlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnRpdGxlXSAtIFRpdGxlIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnhBeGlzXSAtIFggQXhpcyB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fEFycmF5PE9iamVjdD59IFtwcm9wcy5vcHRpb25zLnRoZW1lLnlBeGlzXSAtIFkgQXhpcyB0aGVtZS4gSW4gdGhlIGNhc2Ugb2YgYW4gYXJyYW5nZW1lbnQsIHRoZSBmaXJzdCBpcyB0aGUgbWFpbiBheGlzIGFuZCB0aGUgc2Vjb25kIGlzIHRoZSB0aGVtZSBmb3IgdGhlIHNlY29uZGFyeSBheGlzLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmxlZ2VuZF0gLSBMZWdlbmQgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUudG9vbHRpcF0gLSBUb29sdGlwIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnBsb3RdIC0gUGxvdCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5leHBvcnRNZW51XSAtIEV4cG9ydE1lbnUgdGhlbWUuXG4gKiBAZXh0ZW5kcyBDaGFydFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lQXJlYUNoYXJ0IGV4dGVuZHMgQ2hhcnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGVsOiBwcm9wcy5lbCxcbiAgICAgICAgICAgIG9wdGlvbnM6IHByb3BzLm9wdGlvbnMsXG4gICAgICAgICAgICBzZXJpZXM6IHByb3BzLmRhdGEuc2VyaWVzLFxuICAgICAgICAgICAgY2F0ZWdvcmllczogcHJvcHMuZGF0YS5jYXRlZ29yaWVzLFxuICAgICAgICAgICAgbW9kdWxlczogW3N0YWNrU2VyaWVzRGF0YSwgZGF0YVJhbmdlLCBzY2FsZSwgYXhlcywgcGxvdF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQmFja2dyb3VuZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoVGl0bGUpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFBsb3QpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKExlZ2VuZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXJlYVNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoTGluZVNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpcywgeyBuYW1lOiAneUF4aXMnIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEF4aXMsIHsgbmFtZTogJ3hBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzLCB7IG5hbWU6ICdzZWNvbmRhcnlZQXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoRGF0YUxhYmVscyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpc1RpdGxlLCB7IG5hbWU6ICd4QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpc1RpdGxlLCB7IG5hbWU6ICd5QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpc1RpdGxlLCB7IG5hbWU6ICdzZWNvbmRhcnlZQXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoRXhwb3J0TWVudSwgeyBjaGFydEVsOiB0aGlzLmVsIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEhvdmVyZWRTZXJpZXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFNlbGVjdGVkU2VyaWVzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChUb29sdGlwLCB7IGNoYXJ0RWw6IHRoaXMuZWwgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoUmFuZ2VTZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFJlc2V0QnV0dG9uKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChOb0RhdGFUZXh0KTtcbiAgICAgICAgdGhpcy5wYWludGVyLmFkZEdyb3VwcyhbXG4gICAgICAgICAgICBiYXNpY0JydXNoLFxuICAgICAgICAgICAgYXhpc0JydXNoLFxuICAgICAgICAgICAgbGluZVNlcmllc0JydXNoLFxuICAgICAgICAgICAgbGVnZW5kQnJ1c2gsXG4gICAgICAgICAgICBsYWJlbEJydXNoLFxuICAgICAgICAgICAgZXhwb3J0TWVudUJydXNoLFxuICAgICAgICAgICAgZGF0YUxhYmVsQnJ1c2gsXG4gICAgICAgICAgICByZXNldEJ1dHRvbkJydXNoLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBkYXRhIC0gQXJyYXkgb2YgZGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2F0ZWdvcnkgLSBDYXRlZ29yeSB0byBiZSBhZGRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIC0gV2hpY2ggdHlwZSBvZiBjaGFydCB0byBhZGQuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuYWRkRGF0YShbMTAsIDIwXSwgJzYnLCAnbGluZScpO1xuICAgICAqL1xuICAgIGFkZERhdGEoZGF0YSwgY2F0ZWdvcnksIGNoYXJ0VHlwZSkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkNvbnRyb2xGbGFnLnVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdhZGREYXRhJywgeyBkYXRhLCBjYXRlZ29yeSwgY2hhcnRUeXBlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSBkYXRhLm5hbWUgLSBTZXJpZXMgbmFtZS5cbiAgICAgKiAgIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZGF0YS5kYXRhIC0gQXJyYXkgb2YgZGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YUluZm8gLSBXaGljaCB0eXBlIG9mIGNoYXJ0IHRvIGFkZC5cbiAgICAgKiAgIEBwYXJhbSB7T2JqZWN0fSBkYXRhSW5mby5jaGFydFR5cGUgLSBDaGFydCB0eXBlLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmFkZFNlcmllcyhcbiAgICAgKiAgIHtcbiAgICAgKiAgICAgbmFtZTogJ25ld1NlcmllcycsXG4gICAgICogICAgIGRhdGE6IFsxMCwgMTAwLCA1MCwgNDAsIDcwLCA1NSwgMzMsIDcwLCA5MCwgMTEwXSxcbiAgICAgKiAgIH0sXG4gICAgICogICB7XG4gICAgICogICAgIGNoYXJ0VHlwZTogJ2xpbmUnXG4gICAgICogICB9KTtcbiAgICAgKi9cbiAgICBhZGRTZXJpZXMoZGF0YSwgZGF0YUluZm8pIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdhZGRTZXJpZXMnLCBPYmplY3QuYXNzaWduKHsgZGF0YSB9LCBkYXRhSW5mbykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBjaGFydCBkYXRhIHRvIG5ldyBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBiZSBzZXRcbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zZXREYXRhKHtcbiAgICAgKiAgIGNhdGVnb3JpZXM6IFsnMScsICcyJywgJzMnXSxcbiAgICAgKiAgIHNlcmllczoge1xuICAgICAqICAgICBsaW5lOiBbXG4gICAgICogICAgICAge1xuICAgICAqICAgICAgICAgbmFtZTogJ0EnLFxuICAgICAqICAgICAgICAgZGF0YTogWzEsIDIsIDNdLFxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgXSxcbiAgICAgKiAgICAgYXJlYTogW1xuICAgICAqICAgICAgIHtcbiAgICAgKiAgICAgICAgIG5hbWU6ICdCJyxcbiAgICAgKiAgICAgICAgIGRhdGE6IFs0LCA1LCA2XSxcbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIF1cbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXREYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdzZXREYXRhJywgZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBwbG90IGxpbmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBwbG90IGluZm9cbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gZGF0YS52YWx1ZSAtIFRoZSB2YWx1ZSB3aGVyZSB0aGUgcGxvdCBsaW5lIHdpbGwgYmUgZHJhd24uXG4gICAgICogICBAcGFyYW0ge3N0cmluZ30gZGF0YS5jb2xvciAtIFBsb3QgbGluZSBjb2xvci5cbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSBbZGF0YS5pZF0gLSBQbG90IGlkLiBUaGUgdmFsdWUgb24gd2hpY2ggdGhlIHJlbW92ZVBsb3RMaW5lIGlzIGJhc2VkLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmFkZFBsb3RMaW5lKHtcbiAgICAgKiAgIHZhbHVlOiAyLFxuICAgICAqICAgY29sb3I6ICcjMDBmZjIyJyxcbiAgICAgKiAgIGlkOiAncGxvdC0xJyxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBhZGRQbG90TGluZShkYXRhKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2FkZFBsb3RMaW5lJywgeyBkYXRhIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgcGxvdCBsaW5lIHdpdGggaWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gSWQgb2YgdGhlIHBsb3QgbGluZSB0byBiZSByZW1vdmVkLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnJlbW92ZVBsb3RMaW5lKCdwbG90LTEnKTtcbiAgICAgKi9cbiAgICByZW1vdmVQbG90TGluZShpZCkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdyZW1vdmVQbG90TGluZScsIHsgaWQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBwbG90IGJhbmQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBQbG90IGluZm8uXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmd8bnVtYmVyPn0gZGF0YS5yYW5nZSAtIFRoZSByYW5nZSB0byBiZSBkcmF3bi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YS5jb2xvciAtIFBsb3QgYmFuZCBjb2xvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2RhdGEuaWRdIC0gUGxvdCBpZC4gVGhlIHZhbHVlIG9uIHdoaWNoIHRoZSByZW1vdmVQbG90QmFuZCBpcyBiYXNlZC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5hZGRQbG90QmFuZCh7XG4gICAgICogICB2YWx1ZTogWzIsIDRdLFxuICAgICAqICAgY29sb3I6ICcjMDBmZjIyJyxcbiAgICAgKiAgIGlkOiAncGxvdC0xJyxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBhZGRQbG90QmFuZChkYXRhKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2FkZFBsb3RCYW5kJywgeyBkYXRhIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgcGxvdCBiYW5kIHdpdGggaWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gSWQgb2YgdGhlIHBsb3QgYmFuZCB0byBiZSByZW1vdmVkLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnJlbW92ZVBsb3RCYW5kKCdwbG90LTEnKTtcbiAgICAgKi9cbiAgICByZW1vdmVQbG90QmFuZChpZCkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdyZW1vdmVQbG90QmFuZCcsIHsgaWQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGUgc2VyaWVzIGRhdGEgbGFiZWwuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuaGlkZVNlcmllc0RhdGFMYWJlbCgpO1xuICAgICAqL1xuICAgIGhpZGVTZXJpZXNEYXRhTGFiZWwoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3VwZGF0ZU9wdGlvbnMnLCB7XG4gICAgICAgICAgICBvcHRpb25zOiB7IHNlcmllczogeyBkYXRhTGFiZWxzOiB7IHZpc2libGU6IGZhbHNlIH0gfSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyBzZXJpZXMgZGF0YSBsYWJlbC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zaG93U2VyaWVzRGF0YUxhYmVsKCk7XG4gICAgICovXG4gICAgc2hvd1Nlcmllc0RhdGFMYWJlbCgpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgndXBkYXRlT3B0aW9ucycsIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHsgc2VyaWVzOiB7IGRhdGFMYWJlbHM6IHsgdmlzaWJsZTogdHJ1ZSB9IH0gfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGNoYXJ0IG9wdGlvbnMgdG8gbmV3IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDaGFydCBvcHRpb25zLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNldE9wdGlvbnMoe1xuICAgICAqICAgY2hhcnQ6IHtcbiAgICAgKiAgICAgd2lkdGg6IDUwMCxcbiAgICAgKiAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICogICAgIHRpdGxlOiAnRW5lcmd5IFVzYWdlJyxcbiAgICAgKiAgIH0sXG4gICAgICogICB4QXhpczoge1xuICAgICAqICAgICB0aXRsZTogJ01vbnRoJyxcbiAgICAgKiAgICAgZGF0ZTogeyBmb3JtYXQ6ICd5eS9NTScgfSxcbiAgICAgKiAgIH0sXG4gICAgICogICB5QXhpczoge1xuICAgICAqICAgICB0aXRsZTogJ0VuZXJneSAoa1doKScsXG4gICAgICogICB9LFxuICAgICAqICAgc2VyaWVzOiB7XG4gICAgICogICAgIGxpbmU6IHtcbiAgICAgKiAgICAgICBzaG93RG90OiB0cnVlXG4gICAgICogICAgIH0sXG4gICAgICogICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICogICB9LFxuICAgICAqICAgdG9vbHRpcDoge1xuICAgICAqICAgICBmb3JtYXR0ZXI6ICh2YWx1ZSkgPT4gYCR7dmFsdWV9a1doYCxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICovXG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE9wdGlvbnNFdmVudCgnaW5pdE9wdGlvbnMnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNoYXJ0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDaGFydCBvcHRpb25zLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnVwZGF0ZU9wdGlvbnMoe1xuICAgICAqICAgY2hhcnQ6IHtcbiAgICAgKiAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICogICAgIHRpdGxlOiAnRW5lcmd5IFVzYWdlJyxcbiAgICAgKiAgIH0sXG4gICAgICogICBzZXJpZXM6IHtcbiAgICAgKiAgICAgbGluZToge1xuICAgICAqICAgICAgIHNob3dEb3Q6IHRydWUsXG4gICAgICogICAgIH0sXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHVwZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hPcHRpb25zRXZlbnQoJ3VwZGF0ZU9wdGlvbnMnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXJpZXNJbmZvIC0gSW5mb3JtYXRpb24gb2YgdGhlIHNlcmllcyBmb3IgdGhlIHRvb2x0aXAgdG8gYmUgZGlzcGxheWVkLlxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHNlcmllc0luZm8uc2VyaWVzSW5kZXggLSBJbmRleCBvZiBzZXJpZXMuXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gc2VyaWVzSW5mby5pbmRleCAtIEluZGV4IG9mIGRhdGEgd2l0aGluIHNlcmllcy5cbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBzZXJpZXNJbmZvLmNoYXJ0VHlwZSAtIFNwZWNpZnkgd2hpY2ggY2hhcnQgdG8gc2VsZWN0LlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNob3dUb29sdGlwKHtpbmRleDogMSwgc2VyaWVzSW5kZXg6IDIsIGNoYXJ0VHlwZTogJ2xpbmUnfSk7XG4gICAgICovXG4gICAgc2hvd1Rvb2x0aXAoc2VyaWVzSW5mbykge1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nob3dUb29sdGlwJywgT2JqZWN0LmFzc2lnbih7fSwgc2VyaWVzSW5mbykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlIHRvb2x0aXAuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuaGlkZVRvb2x0aXAoKTtcbiAgICAgKi9cbiAgICBoaWRlVG9vbHRpcCgpIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdoaWRlVG9vbHRpcCcpO1xuICAgIH1cbn1cbiIsImltcG9ydCBDaGFydCBmcm9tIFwiLi9jaGFydFwiO1xuaW1wb3J0IGRhdGFSYW5nZSBmcm9tIFwiLi4vc3RvcmUvZGF0YVJhbmdlXCI7XG5pbXBvcnQgc2NhbGUgZnJvbSBcIi4uL3N0b3JlL3NjYWxlXCI7XG5pbXBvcnQgYXhlcyBmcm9tIFwiLi4vc3RvcmUvYXhlc1wiO1xuaW1wb3J0IHBsb3QgZnJvbSBcIi4uL3N0b3JlL3Bsb3RcIjtcbmltcG9ydCBUb29sdGlwIGZyb20gXCIuLi9jb21wb25lbnQvdG9vbHRpcFwiO1xuaW1wb3J0IFBsb3QgZnJvbSBcIi4uL2NvbXBvbmVudC9wbG90XCI7XG5pbXBvcnQgTGluZVNlcmllcyBmcm9tIFwiLi4vY29tcG9uZW50L2xpbmVTZXJpZXNcIjtcbmltcG9ydCBBeGlzIGZyb20gXCIuLi9jb21wb25lbnQvYXhpc1wiO1xuaW1wb3J0IExlZ2VuZCBmcm9tIFwiLi4vY29tcG9uZW50L2xlZ2VuZFwiO1xuaW1wb3J0IERhdGFMYWJlbHMgZnJvbSBcIi4uL2NvbXBvbmVudC9kYXRhTGFiZWxzXCI7XG5pbXBvcnQgQXhpc1RpdGxlIGZyb20gXCIuLi9jb21wb25lbnQvYXhpc1RpdGxlXCI7XG5pbXBvcnQgVGl0bGUgZnJvbSBcIi4uL2NvbXBvbmVudC90aXRsZVwiO1xuaW1wb3J0IEV4cG9ydE1lbnUgZnJvbSBcIi4uL2NvbXBvbmVudC9leHBvcnRNZW51XCI7XG5pbXBvcnQgSG92ZXJlZFNlcmllcyBmcm9tIFwiLi4vY29tcG9uZW50L2hvdmVyZWRTZXJpZXNcIjtcbmltcG9ydCBSYW5nZVNlbGVjdGlvbiBmcm9tIFwiLi4vY29tcG9uZW50L3JhbmdlU2VsZWN0aW9uXCI7XG5pbXBvcnQgUmVzZXRCdXR0b24gZnJvbSBcIi4uL2NvbXBvbmVudC9yZXNldEJ1dHRvblwiO1xuaW1wb3J0IFNlbGVjdGVkU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvc2VsZWN0ZWRTZXJpZXNcIjtcbmltcG9ydCBCYWNrZ3JvdW5kIGZyb20gXCIuLi9jb21wb25lbnQvYmFja2dyb3VuZFwiO1xuaW1wb3J0IE5vRGF0YVRleHQgZnJvbSBcIi4uL2NvbXBvbmVudC9ub0RhdGFUZXh0XCI7XG5pbXBvcnQgKiBhcyBsaW5lU2VyaWVzQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvbGluZVNlcmllc1wiO1xuaW1wb3J0ICogYXMgYmFzaWNCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9iYXNpY1wiO1xuaW1wb3J0ICogYXMgYXhpc0JydXNoIGZyb20gXCIuLi9icnVzaGVzL2F4aXNcIjtcbmltcG9ydCAqIGFzIGxlZ2VuZEJydXNoIGZyb20gXCIuLi9icnVzaGVzL2xlZ2VuZFwiO1xuaW1wb3J0ICogYXMgbGFiZWxCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9sYWJlbFwiO1xuaW1wb3J0ICogYXMgZXhwb3J0TWVudUJydXNoIGZyb20gXCIuLi9icnVzaGVzL2V4cG9ydE1lbnVcIjtcbmltcG9ydCAqIGFzIGRhdGFMYWJlbEJydXNoIGZyb20gXCIuLi9icnVzaGVzL2RhdGFMYWJlbFwiO1xuaW1wb3J0ICogYXMgcmVzZXRCdXR0b25CcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9yZXNldEJ1dHRvblwiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBjbGFzc2Rlc2MgTGluZSBDaGFydFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHByb3BzLmVsIC0gVGhlIHRhcmdldCBlbGVtZW50IHRvIGNyZWF0ZSBjaGFydC5cbiAqICAgQHBhcmFtIHtPYmplY3R9IHByb3BzLmRhdGEgLSBEYXRhIGZvciBtYWtpbmcgTGluZSBDaGFydC5cbiAqICAgICBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwcm9wcy5kYXRhLmNhdGVnb3JpZXNdIC0gQ2F0ZWdvcmllcy5cbiAqICAgICBAcGFyYW0ge0FycmF5PE9iamVjdD59IHByb3BzLmRhdGEuc2VyaWVzIC0gU2VyaWVzIGRhdGEuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gcHJvcHMuZGF0YS5zZXJpZXMubmFtZSAtIFNlcmllcyBuYW1lLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxudW1iZXJ8T2JqZWN0fEFycmF5Pn0gcHJvcHMuZGF0YS5zZXJpZXMuZGF0YSAtIFNlcmllcyBkYXRhLlxuICogICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnNdIC0gT3B0aW9ucyBmb3IgbWFraW5nIExpbmUgQ2hhcnQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNoYXJ0XVxuICogICAgICAgQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZV0gLSBDaGFydCB0aXRsZSB0ZXh0IG9yIG9wdGlvbnMuXG4gKiAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS50ZXh0XSAtIENoYXJ0IHRpdGxlIHRleHQuXG4gKiAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS5vZmZzZXRYXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIGhvcml6b250YWxseS5cbiAqICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLm9mZnNldFldIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgdmVydGljYWxseS5cbiAqICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLmFsaWduXSAtIENoYXJ0IHRleHQgYWxpZ24uICdsZWZ0JywgJ3JpZ2h0JywgJ2NlbnRlcicgaXMgYXZhaWxhYmxlLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufE9iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2hhcnQuYW5pbWF0aW9uXSAtIFdoZXRoZXIgdG8gdXNlIGFuaW1hdGlvbiBhbmQgZHVyYXRpb24gd2hlbiByZW5kZXJpbmcgdGhlIGluaXRpYWwgY2hhcnQuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LndpZHRoXSAtIENoYXJ0IHdpZHRoLiAnYXV0bycgb3IgaWYgbm90IHdyaXRlLCB0aGUgd2lkdGggb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuICdhdXRvJyBvciBpZiBub3QgY3JlYXRlZCwgdGhlIHdpZHRoIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC5oZWlnaHRdIC0gQ2hhcnQgaGVpZ2h0LiAnYXV0bycgb3IgaWYgbm90IHdyaXRlLCB0aGUgd2lkdGggb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuICdhdXRvJyBvciBpZiBub3QgY3JlYXRlZCwgdGhlIGhlaWdodCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzXVxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5zZXJpZXMuc2VsZWN0YWJsZT1mYWxzZV0gLSBXaGV0aGVyIHRvIG1ha2Ugc2VsZWN0YWJsZSBzZXJpZXMgb3Igbm90LlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5zZXJpZXMuc2hvd0RvdD1mYWxzZV0gLSBXaGV0aGVyIHRvIHNob3cgZG90IG9yIG5vdC5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLnNwbGluZT1mYWxzZV0gLSBXaGV0aGVyIHRvIG1ha2Ugc3BsaW5lIGNoYXJ0IG9yIG5vdC5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLnpvb21hYmxlPWZhbHNlXSAtIFdoZXRoZXIgdG8gdXNlIHpvb20gZmVhdHVyZSBvciBub3QuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5yYW5nZVNlbGVjdGFibGU9ZmFsc2VdIC0gV2hldGhlciB0byB1c2UgcmFuZ2Ugc2VsZWN0aW9uIGZlYXR1cmUgb3Igbm90LlxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLnNlcmllcy5ldmVudERldGVjdFR5cGVdIC0gRXZlbnQgZGV0ZWN0IHR5cGUuICduZWFyJywgJ25lYXJlc3QnLCAnZ3JvdXBlZCcsICdwb2ludCcgaXMgYXZhaWxhYmxlLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5zZXJpZXMuc2hpZnQ9ZmFsc2VdIC0gV2hldGhlciB0byB1c2Ugc2hpZnQgd2hlbiBhZGREYXRhIG9yIG5vdC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5zZXJpZXMuZGF0YUxhYmVsc10gLSBTZXQgdGhlIHZpc2liaWxpdHksIGxvY2F0aW9uLCBhbmQgZm9ybWF0dGluZyBvZiBkYXRhTGFiZWwuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxEYXRhTGFiZWxzIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzXVxuICogICAgICAgQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy50aXRsZV0gLSBBeGlzIHRpdGxlLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy54QXhpcy5wb2ludE9uQ29sdW1uPWZhbHNlXSAtIFdoZXRoZXIgdG8gbW92ZSB0aGUgc3RhcnQgb2YgdGhlIGNoYXJ0IHRvIHRoZSBjZW50ZXIgb2YgdGhlIGNvbHVtbi5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMueEF4aXMucm90YXRlTGFiZWw9dHJ1ZV0gLSBXaGV0aGVyIHRvIGFsbG93IGF4aXMgbGFiZWwgcm90YXRpb24uXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy5kYXRlXSAtIFdoZXRoZXIgdGhlIHggYXhpcyBsYWJlbCBpcyBvZiBkYXRlIHR5cGUuIEZvcm1hdCBvcHRpb24gdXNlZCBmb3IgZGF0ZSB0eXBlLiBXaGV0aGVyIHRoZSB4IGF4aXMgbGFiZWwgaXMgb2YgZGF0ZSB0eXBlLiBJZiB1c2UgZGF0ZSB0eXBlLCBmb3JtYXQgb3B0aW9uIHVzZWQgZm9yIGRhdGUgdHlwZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy50aWNrXSAtIE9wdGlvbiB0byBhZGp1c3QgdGljayBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy5sYWJlbF0gLSBPcHRpb24gdG8gYWRqdXN0IGxhYmVsIGludGVydmFsLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLnNjYWxlXSAtIE9wdGlvbiB0byBhZGp1c3QgYXhpcyBtaW5pbXVtLCBtYXhpbXVtLCBzdGVwIHNpemUuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMueEF4aXMud2lkdGhdIC0gV2lkdGggb2YgeEF4aXMuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMueEF4aXMuaGVpZ2h0XSAtIEhlaWdodCBvZiB4QXhpcy5cbiAqICAgICBAcGFyYW0ge09iamVjdHxBcnJheTxPYmplY3Q+fSBbcHJvcHMub3B0aW9ucy55QXhpc10gLSBJZiB0aGlzIG9wdGlvbiBpcyBhbiBhcnJheSB0eXBlLCB1c2UgdGhlIHNlY29uZGFyeSB5IGF4aXMuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLnlBeGlzLnRpdGxlXSAtIEF4aXMgdGl0bGUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueUF4aXMudGlja10gLSBPcHRpb24gdG8gYWRqdXN0IHRpY2sgaW50ZXJ2YWwuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueUF4aXMubGFiZWxdIC0gT3B0aW9uIHRvIGFkanVzdCBsYWJlbCBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpcy5zY2FsZV0gLSBPcHRpb24gdG8gYWRqdXN0IGF4aXMgbWluaW11bSwgbWF4aW11bSwgc3RlcCBzaXplLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnlBeGlzLndpZHRoXSAtIFdpZHRoIG9mIHlBeGlzLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnlBeGlzLmhlaWdodF0gLSBIZWlnaHQgb2YgeUF4aXMuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnBsb3RdXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMucGxvdC53aWR0aF0gLSBXaWR0aCBvZiBwbG90LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnBsb3QuaGVpZ2h0XSAtIEhlaWdodCBvZiBwbG90LlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5wbG90LnZpc2libGVdIC0gV2hldGhlciB0byBzaG93IHBsb3QgbGluZS5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gW3Byb3BzLm9wdGlvbnMucGxvdC5saW5lc10gLSBQbG90IGxpbmVzIGluZm9ybWF0aW9uLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8UGxvdCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBbcHJvcHMub3B0aW9ucy5wbG90LmJhbmRzXSAtIFBsb3QgYmFuZHMgaW5mb3JtYXRpb24uIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxQbG90IGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZF1cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5sZWdlbmQuYWxpZ25dIC0gTGVnZW5kIGFsaWduLiAndG9wJywgJ2JvdHRvbScsICdyaWdodCcsICdsZWZ0JyBpcyBhdmFpbGFibGUuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMubGVnZW5kLnNob3dDaGVja2JveF0gLSBXaGV0aGVyIHRvIHNob3cgY2hlY2tib3guXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC52aXNpYmxlXSAtIFdoZXRoZXIgdG8gc2hvdyBsZWdlbmQuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMubGVnZW5kLndpZHRoXSAtIFdpZHRoIG9mIGxlZ2VuZC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sZWdlbmQuaXRlbV0gLSBgd2lkdGhgIGFuZCBgb3ZlcmZsb3dgIG9wdGlvbnMgb2YgdGhlIGxlZ2VuZCBpdGVtLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8TGVnZW5kIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnVdXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnUudmlzaWJsZV0gLSBXaGV0aGVyIHRvIHNob3cgZXhwb3J0IG1lbnUuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuZXhwb3J0TWVudS5maWxlbmFtZV0gLSBGaWxlIG5hbWUgYXBwbGllZCB3aGVuIGRvd25sb2FkaW5nLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50b29sdGlwXVxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAub2Zmc2V0WF0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSBob3Jpem9udGFsbHkuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC5vZmZzZXRZXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIHZlcnRpY2FsbHkuXG4gKiAgICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcHMub3B0aW9ucy50b29sdGlwLmZvcm1hdHRlcl0gLSBGdW5jdGlvbiB0byBmb3JtYXQgZGF0YSB2YWx1ZS5cbiAqICAgICAgIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAudGVtcGxhdGVdIC0gRnVuY3Rpb24gdG8gY3JlYXRlIGN1c3RvbSB0ZW1wbGF0ZS4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFRvb2x0aXAgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZV0gLSBSdWxlcyBmb3IgY2hhbmdpbmcgY2hhcnQgb3B0aW9ucy4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFJlc3BvbnNpdmUgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLnJlc3BvbnNpdmUuYW5pbWF0aW9uXSAtIEFuaW1hdGlvbiBkdXJhdGlvbiB3aGVuIHRoZSBjaGFydCBpcyBtb2RpZmllZC5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZS5ydWxlc10gLSBSdWxlcyBmb3IgdGhlIENoYXJ0IHRvIFJlc3BvbmQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxhbmddIC0gT3B0aW9ucyBmb3IgY2hhbmdpbmcgdGhlIHRleHQgZGlzcGxheWVkIG9uIHRoZSBjaGFydCBvciBpMThuIGxhbmd1YWdlcy5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sYW5nLm5vRGF0YV0gLSBObyBEYXRhIExheWVyIFRleHQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lXSAtIENoYXJ0IHRoZW1lIG9wdGlvbnMuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxMaW5lIENoYXJ0IGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUuY2hhcnRdIC0gQ2hhcnQgZm9udCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5ub0RhdGFdIC0gTm8gRGF0YSBMYXllciBUZXh0IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnNlcmllc10gLSBTZXJpZXMgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUudGl0bGVdIC0gVGl0bGUgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUueEF4aXNdIC0gWCBBeGlzIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R8QXJyYXk8T2JqZWN0Pn0gW3Byb3BzLm9wdGlvbnMudGhlbWUueUF4aXNdIC0gWSBBeGlzIHRoZW1lLiBJbiB0aGUgY2FzZSBvZiBhbiBhcnJhbmdlbWVudCwgdGhlIGZpcnN0IGlzIHRoZSBtYWluIGF4aXMgYW5kIHRoZSBzZWNvbmQgaXMgdGhlIHRoZW1lIGZvciB0aGUgc2Vjb25kYXJ5IGF4aXMuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUubGVnZW5kXSAtIExlZ2VuZCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS50b29sdGlwXSAtIFRvb2x0aXAgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUucGxvdF0gLSBQbG90IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmV4cG9ydE1lbnVdIC0gRXhwb3J0TWVudSB0aGVtZS5cbiAqIEBleHRlbmRzIENoYXJ0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVDaGFydCBleHRlbmRzIENoYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGVsOiBwcm9wcy5lbCxcbiAgICAgICAgICAgIG9wdGlvbnM6IHByb3BzLm9wdGlvbnMsXG4gICAgICAgICAgICBzZXJpZXM6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBwcm9wcy5kYXRhLnNlcmllcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYXRlZ29yaWVzOiAoX2EgPSBwcm9wcy5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2F0ZWdvcmllcyxcbiAgICAgICAgICAgIG1vZHVsZXM6IFtkYXRhUmFuZ2UsIHNjYWxlLCBheGVzLCBwbG90XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChCYWNrZ3JvdW5kKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChUaXRsZSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoUGxvdCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoTGVnZW5kKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChMaW5lU2VyaWVzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzLCB7IG5hbWU6ICd5QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpcywgeyBuYW1lOiAneEF4aXMnIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEF4aXMsIHsgbmFtZTogJ3NlY29uZGFyeVlBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChEYXRhTGFiZWxzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzVGl0bGUsIHsgbmFtZTogJ3hBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzVGl0bGUsIHsgbmFtZTogJ3lBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzVGl0bGUsIHsgbmFtZTogJ3NlY29uZGFyeVlBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChFeHBvcnRNZW51LCB7IGNoYXJ0RWw6IHRoaXMuZWwgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoSG92ZXJlZFNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoU2VsZWN0ZWRTZXJpZXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFRvb2x0aXAsIHsgY2hhcnRFbDogdGhpcy5lbCB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChSYW5nZVNlbGVjdGlvbik7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoUmVzZXRCdXR0b24pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKE5vRGF0YVRleHQpO1xuICAgICAgICB0aGlzLnBhaW50ZXIuYWRkR3JvdXBzKFtcbiAgICAgICAgICAgIGJhc2ljQnJ1c2gsXG4gICAgICAgICAgICBheGlzQnJ1c2gsXG4gICAgICAgICAgICBsaW5lU2VyaWVzQnJ1c2gsXG4gICAgICAgICAgICBsZWdlbmRCcnVzaCxcbiAgICAgICAgICAgIGxhYmVsQnJ1c2gsXG4gICAgICAgICAgICBleHBvcnRNZW51QnJ1c2gsXG4gICAgICAgICAgICBkYXRhTGFiZWxCcnVzaCxcbiAgICAgICAgICAgIHJlc2V0QnV0dG9uQnJ1c2gsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcnxPYmplY3R8QXJyYXk+fSBkYXRhIC0gQXJyYXkgb2YgZGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2F0ZWdvcnkgLSBDYXRlZ29yeSB0byBiZSBhZGRlZC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5hZGREYXRhKFsxMCwgMjBdLCAnNicpO1xuICAgICAqL1xuICAgIGFkZERhdGEoZGF0YSwgY2F0ZWdvcnkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy5zdG9yZS5zdGF0ZS5vcHRpb25zLnNlcmllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNob3dEb3QpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uQ29udHJvbEZsYWcudXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgnYWRkRGF0YScsIHsgZGF0YSwgY2F0ZWdvcnkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBEYXRhIHRvIGJlIGFkZGVkLlxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9IGRhdGEubmFtZSAtIFNlcmllcyBuYW1lLlxuICAgICAqICAgQHBhcmFtIHtBcnJheTxudW1iZXJ8T2JqZWN0fEFycmF5Pn0gZGF0YS5kYXRhIC0gQXJyYXkgb2YgZGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5hZGRTZXJpZXMoe1xuICAgICAqICAgbmFtZTogJ25ld1NlcmllcycsXG4gICAgICogICBkYXRhOiBbMTAsIDEwMCwgNTAsIDQwLCA3MCwgNTUsIDMzLCA3MCwgOTAsIDExMF0sXG4gICAgICogfSk7XG4gICAgICovXG4gICAgYWRkU2VyaWVzKGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdhZGRTZXJpZXMnLCB7IGRhdGEgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGNoYXJ0IGRhdGEgdG8gbmV3IGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBEYXRhIHRvIGJlIHNldC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zZXREYXRhKHtcbiAgICAgKiAgIGNhdGVnb3JpZXM6IFsnMScsICcyJywgJzMnXSxcbiAgICAgKiAgIHNlcmllczogW1xuICAgICAqICAgICB7XG4gICAgICogICAgICAgbmFtZTogJ25ldyBzZXJpZXMnLFxuICAgICAqICAgICAgIGRhdGE6IFsxLCAyLCAzXSxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgIG5hbWU6ICduZXcgc2VyaWVzMicsXG4gICAgICogICAgICAgZGF0YTogWzQsIDUsIDZdLFxuICAgICAqICAgICB9XG4gICAgICogICBdXG4gICAgICogfSk7XG4gICAgICovXG4gICAgc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgY2F0ZWdvcmllcywgc2VyaWVzIH0gPSBkYXRhO1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3NldERhdGEnLCB7IHNlcmllczogeyBsaW5lOiBzZXJpZXMgfSwgY2F0ZWdvcmllcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHBsb3QgbGluZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFBsb3QgaW5mby5cbiAgICAgKiAgICBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRhdGEudmFsdWUgLSBUaGUgdmFsdWUgd2hlcmUgdGhlIHBsb3QgbGluZSB3aWxsIGJlIGRyYXduLlxuICAgICAqICAgIEBwYXJhbSB7c3RyaW5nfSBkYXRhLmNvbG9yIC0gUGxvdCBsaW5lIGNvbG9yLlxuICAgICAqICAgIEBwYXJhbSB7c3RyaW5nfSBbZGF0YS5pZF0gLSBQbG90IGlkLiBUaGUgdmFsdWUgb24gd2hpY2ggdGhlIHJlbW92ZVBsb3RMaW5lIGlzIGJhc2VkLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmFkZFBsb3RMaW5lKHtcbiAgICAgKiAgIHZhbHVlOiAyLFxuICAgICAqICAgY29sb3I6ICcjMDBmZjIyJyxcbiAgICAgKiAgIGlkOiAncGxvdC0xJyxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBhZGRQbG90TGluZShkYXRhKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2FkZFBsb3RMaW5lJywgeyBkYXRhIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgcGxvdCBsaW5lIHdpdGggaWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gSWQgb2YgdGhlIHBsb3QgbGluZSB0byBiZSByZW1vdmVkLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnJlbW92ZVBsb3RMaW5lKCdwbG90LTEnKTtcbiAgICAgKi9cbiAgICByZW1vdmVQbG90TGluZShpZCkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdyZW1vdmVQbG90TGluZScsIHsgaWQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBwbG90IGJhbmQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBQbG90IGluZm8uXG4gICAgICogICBAcGFyYW0ge0FycmF5PHN0cmluZ3xudW1iZXI+fSBkYXRhLnJhbmdlIC0gVGhlIHJhbmdlIHRvIGJlIGRyYXduLlxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9IGRhdGEuY29sb3IgLSBQbG90IGJhbmQgY29sb3IuXG4gICAgICogICBAcGFyYW0ge3N0cmluZ30gW2RhdGEuaWRdIC0gUGxvdCBpZC4gVGhlIHZhbHVlIG9uIHdoaWNoIHRoZSByZW1vdmVQbG90QmFuZCBpcyBiYXNlZC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5hZGRQbG90QmFuZCh7XG4gICAgICogICB2YWx1ZTogWzIsIDRdLFxuICAgICAqICAgY29sb3I6ICcjMDBmZjIyJyxcbiAgICAgKiAgIGlkOiAncGxvdC0xJyxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBhZGRQbG90QmFuZChkYXRhKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2FkZFBsb3RCYW5kJywgeyBkYXRhIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgcGxvdCBiYW5kIHdpdGggaWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gaWQgb2YgdGhlIHBsb3QgYmFuZCB0byBiZSByZW1vdmVkXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQucmVtb3ZlUGxvdEJhbmQoJ3Bsb3QtMScpO1xuICAgICAqL1xuICAgIHJlbW92ZVBsb3RCYW5kKGlkKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3JlbW92ZVBsb3RCYW5kJywgeyBpZCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZSBzZXJpZXMgZGF0YSBsYWJlbC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5oaWRlU2VyaWVzRGF0YUxhYmVsKCk7XG4gICAgICovXG4gICAgaGlkZVNlcmllc0RhdGFMYWJlbCgpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgndXBkYXRlT3B0aW9ucycsIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHsgc2VyaWVzOiB7IGRhdGFMYWJlbHM6IHsgdmlzaWJsZTogZmFsc2UgfSB9IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHNlcmllcyBkYXRhIGxhYmVsLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNob3dTZXJpZXNEYXRhTGFiZWwoKTtcbiAgICAgKi9cbiAgICBzaG93U2VyaWVzRGF0YUxhYmVsKCkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCd1cGRhdGVPcHRpb25zJywge1xuICAgICAgICAgICAgb3B0aW9uczogeyBzZXJpZXM6IHsgZGF0YUxhYmVsczogeyB2aXNpYmxlOiB0cnVlIH0gfSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgY2hhcnQgb3B0aW9ucyB0byBuZXcgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENoYXJ0IG9wdGlvbnMuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2V0T3B0aW9ucyh7XG4gICAgICogICBjaGFydDoge1xuICAgICAqICAgICB3aWR0aDogNTAwLFxuICAgICAqICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgKiAgICAgdGl0bGU6ICdFbmVyZ3kgVXNhZ2UnLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHhBeGlzOiB7XG4gICAgICogICAgIHRpdGxlOiAnTW9udGgnLFxuICAgICAqICAgICBkYXRlOiB7IGZvcm1hdDogJ3l5L01NJyB9LFxuICAgICAqICAgfSxcbiAgICAgKiAgIHlBeGlzOiB7XG4gICAgICogICAgIHRpdGxlOiAnRW5lcmd5IChrV2gpJyxcbiAgICAgKiAgIH0sXG4gICAgICogICBzZXJpZXM6IHtcbiAgICAgKiAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgKiAgIH0sXG4gICAgICogICB0b29sdGlwOiB7XG4gICAgICogICAgIGZvcm1hdHRlcjogKHZhbHVlKSA9PiBgJHt2YWx1ZX1rV2hgLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoT3B0aW9uc0V2ZW50KCdpbml0T3B0aW9ucycsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY2hhcnQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENoYXJ0IG9wdGlvbnMuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQudXBkYXRlT3B0aW9ucyh7XG4gICAgICogICBjaGFydDoge1xuICAgICAqICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgKiAgICAgdGl0bGU6ICdFbmVyZ3kgVXNhZ2UnLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHRvb2x0aXA6IHtcbiAgICAgKiAgICAgZm9ybWF0dGVyOiAodmFsdWUpID0+IGAke3ZhbHVlfWtXaGAsXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHVwZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hPcHRpb25zRXZlbnQoJ3VwZGF0ZU9wdGlvbnMnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXJpZXNJbmZvIC0gSW5mb3JtYXRpb24gb2YgdGhlIHNlcmllcyBmb3IgdGhlIHRvb2x0aXAgdG8gYmUgZGlzcGxheWVkLlxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHNlcmllc0luZm8uaW5kZXggLSBJbmRleCBvZiBkYXRhIHdpdGhpbiBzZXJpZXMuIElmICdzZXJpZXMuZXZlbnREZXRlY3RUeXBlJyBpcyBcImdyb3VwZWRcIiwgb25seSBzZXJpZXNJbmRleCBpcyBuZWVkZWQuXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gW3Nlcmllc0luZm8uc2VyaWVzSW5kZXhdIC0gSW5kZXggb2Ygc2VyaWVzLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNob3dUb29sdGlwKHtpbmRleDogMSwgc2VyaWVzSW5kZXg6IDJ9KTtcbiAgICAgKi9cbiAgICBzaG93VG9vbHRpcChzZXJpZXNJbmZvKSB7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnc2hvd1Rvb2x0aXAnLCBPYmplY3QuYXNzaWduKHt9LCBzZXJpZXNJbmZvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGUgdG9vbHRpcC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5oaWRlVG9vbHRpcCgpO1xuICAgICAqL1xuICAgIGhpZGVUb29sdGlwKCkge1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ2hpZGVUb29sdGlwJyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IENoYXJ0IGZyb20gXCIuL2NoYXJ0XCI7XG5pbXBvcnQgZGF0YVJhbmdlIGZyb20gXCIuLi9zdG9yZS9kYXRhUmFuZ2VcIjtcbmltcG9ydCBzY2FsZSBmcm9tIFwiLi4vc3RvcmUvc2NhbGVcIjtcbmltcG9ydCBheGVzIGZyb20gXCIuLi9zdG9yZS9heGVzXCI7XG5pbXBvcnQgcGxvdCBmcm9tIFwiLi4vc3RvcmUvcGxvdFwiO1xuaW1wb3J0IFRvb2x0aXAgZnJvbSBcIi4uL2NvbXBvbmVudC90b29sdGlwXCI7XG5pbXBvcnQgUGxvdCBmcm9tIFwiLi4vY29tcG9uZW50L3Bsb3RcIjtcbmltcG9ydCBMaW5lU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvbGluZVNlcmllc1wiO1xuaW1wb3J0IFNjYXR0ZXJTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9zY2F0dGVyU2VyaWVzXCI7XG5pbXBvcnQgQXhpcyBmcm9tIFwiLi4vY29tcG9uZW50L2F4aXNcIjtcbmltcG9ydCBMZWdlbmQgZnJvbSBcIi4uL2NvbXBvbmVudC9sZWdlbmRcIjtcbmltcG9ydCBEYXRhTGFiZWxzIGZyb20gXCIuLi9jb21wb25lbnQvZGF0YUxhYmVsc1wiO1xuaW1wb3J0IEF4aXNUaXRsZSBmcm9tIFwiLi4vY29tcG9uZW50L2F4aXNUaXRsZVwiO1xuaW1wb3J0IFRpdGxlIGZyb20gXCIuLi9jb21wb25lbnQvdGl0bGVcIjtcbmltcG9ydCBFeHBvcnRNZW51IGZyb20gXCIuLi9jb21wb25lbnQvZXhwb3J0TWVudVwiO1xuaW1wb3J0IFNlbGVjdGVkU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvc2VsZWN0ZWRTZXJpZXNcIjtcbmltcG9ydCBIb3ZlcmVkU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvaG92ZXJlZFNlcmllc1wiO1xuaW1wb3J0IFJhbmdlU2VsZWN0aW9uIGZyb20gXCIuLi9jb21wb25lbnQvcmFuZ2VTZWxlY3Rpb25cIjtcbmltcG9ydCBCYWNrZ3JvdW5kIGZyb20gXCIuLi9jb21wb25lbnQvYmFja2dyb3VuZFwiO1xuaW1wb3J0IE5vRGF0YVRleHQgZnJvbSBcIi4uL2NvbXBvbmVudC9ub0RhdGFUZXh0XCI7XG5pbXBvcnQgKiBhcyBsaW5lU2VyaWVzQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvbGluZVNlcmllc1wiO1xuaW1wb3J0ICogYXMgYmFzaWNCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9iYXNpY1wiO1xuaW1wb3J0ICogYXMgYXhpc0JydXNoIGZyb20gXCIuLi9icnVzaGVzL2F4aXNcIjtcbmltcG9ydCAqIGFzIGxlZ2VuZEJydXNoIGZyb20gXCIuLi9icnVzaGVzL2xlZ2VuZFwiO1xuaW1wb3J0ICogYXMgbGFiZWxCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9sYWJlbFwiO1xuaW1wb3J0ICogYXMgZXhwb3J0TWVudUJydXNoIGZyb20gXCIuLi9icnVzaGVzL2V4cG9ydE1lbnVcIjtcbmltcG9ydCAqIGFzIGRhdGFMYWJlbEJydXNoIGZyb20gXCIuLi9icnVzaGVzL2RhdGFMYWJlbFwiO1xuaW1wb3J0ICogYXMgcmVzZXRCdXR0b25CcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9yZXNldEJ1dHRvblwiO1xuaW1wb3J0ICogYXMgc2NhdHRlclNlcmllc0JydXNoIGZyb20gXCIuLi9icnVzaGVzL3NjYXR0ZXJTZXJpZXNcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIExpbmVTY2F0dGVyIENoYXJ0XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gcHJvcHMuZWwgLSBUaGUgdGFyZ2V0IGVsZW1lbnQgdG8gY3JlYXRlIGNoYXJ0LlxuICogICBAcGFyYW0ge09iamVjdH0gcHJvcHMuZGF0YSAtIERhdGEgZm9yIG1ha2luZyBMaW5lQXJlYSBDaGFydC5cbiAqICAgICBAcGFyYW0ge0FycmF5PE9iamVjdD59IHByb3BzLmRhdGEuc2VyaWVzIC0gU2VyaWVzIGRhdGEuXG4gKiAgICAgICBAcGFyYW0ge0FycmF5PE9iamVjdD59IHByb3BzLmRhdGEuc2VyaWVzLmxpbmUgLSBMaW5lIHNlcmllcyBkYXRhLiBPbmx5IGNvb3JkaW5hdGUgdHlwZSBkYXRhIGlzIHBvc3NpYmxlLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwcm9wcy5kYXRhLnNlcmllcy5zY2F0dGVyIC0gU2NhdHRlciBzZXJpZXMgZGF0YS5cbiAqICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zXSAtIE9wdGlvbnMgZm9yIG1ha2luZyBMaW5lU2NhdHRlciBDaGFydC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2hhcnRdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlXSAtIENoYXJ0IHRpdGxlIHRleHQgb3Igb3B0aW9ucy5cbiAqICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLnRleHRdIC0gQ2hhcnQgdGl0bGUgdGV4dC5cbiAqICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLm9mZnNldFhdIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgaG9yaXpvbnRhbGx5LlxuICogICAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUub2Zmc2V0WV0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSB2ZXJ0aWNhbGx5LlxuICogICAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUuYWxpZ25dIC0gQ2hhcnQgdGV4dCBhbGlnbi4gJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJyBpcyBhdmFpbGFibGUuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaGFydC5hbmltYXRpb25dIC0gV2hldGhlciB0byB1c2UgYW5pbWF0aW9uIGFuZCBkdXJhdGlvbiB3aGVuIHJlbmRlcmluZyB0aGUgaW5pdGlhbCBjaGFydC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQud2lkdGhdIC0gQ2hhcnQgd2lkdGguICdhdXRvJyBvciBpZiBub3Qgd3JpdGUsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC4gJ2F1dG8nIG9yIGlmIG5vdCBjcmVhdGVkLCB0aGUgd2lkdGggb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LmhlaWdodF0gLSBDaGFydCBoZWlnaHQuICdhdXRvJyBvciBpZiBub3Qgd3JpdGUsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC4gJ2F1dG8nIG9yIGlmIG5vdCBjcmVhdGVkLCB0aGUgaGVpZ2h0IG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5zZXJpZXNdIC0gV3JpdGUgY29tbW9uIG9wdGlvbnMgaW4gdGhlIHVwcGVyIGRlcHRoIGFuZCBzZXBhcmF0ZSBvcHRpb25zIHRvIGJlIGFwcGxpZWQgdG8gZWFjaCBjaGFydC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5zZXJpZXMubGluZV0gLSBPcHRpb25zIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGxpbmUgY2hhcnQuICdzcGxpbmUnLCAnc2hvd0RvdCcgaXMgYXZhaWxhYmxlLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8TGluZSBDaGFydCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5zZXJpZXMuc2VsZWN0YWJsZT1mYWxzZV0gLSBXaGV0aGVyIHRvIG1ha2Ugc2VsZWN0YWJsZSBzZXJpZXMgb3Igbm90LlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnNlcmllcy5kYXRhTGFiZWxzXSAtIFNldCB0aGUgdmlzaWJpbGl0eSwgbG9jYXRpb24sIGFuZCBmb3JtYXR0aW5nIG9mIGRhdGFMYWJlbC4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fERhdGFMYWJlbHMgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXNdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLnRpdGxlXSAtIEF4aXMgdGl0bGUuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnhBeGlzLnBvaW50T25Db2x1bW49ZmFsc2VdIC0gV2hldGhlciB0byBtb3ZlIHRoZSBzdGFydCBvZiB0aGUgY2hhcnQgdG8gdGhlIGNlbnRlciBvZiB0aGUgY29sdW1uLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy54QXhpcy5yb3RhdGVMYWJlbD10cnVlXSAtIFdoZXRoZXIgdG8gYWxsb3cgYXhpcyBsYWJlbCByb3RhdGlvbi5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLmRhdGVdIC0gV2hldGhlciB0aGUgeCBheGlzIGxhYmVsIGlzIG9mIGRhdGUgdHlwZS4gRm9ybWF0IG9wdGlvbiB1c2VkIGZvciBkYXRlIHR5cGUuIFdoZXRoZXIgdGhlIHggYXhpcyBsYWJlbCBpcyBvZiBkYXRlIHR5cGUuIElmIHVzZSBkYXRlIHR5cGUsIGZvcm1hdCBvcHRpb24gdXNlZCBmb3IgZGF0ZSB0eXBlLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLnRpY2tdIC0gT3B0aW9uIHRvIGFkanVzdCB0aWNrIGludGVydmFsLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLmxhYmVsXSAtIE9wdGlvbiB0byBhZGp1c3QgbGFiZWwgaW50ZXJ2YWwuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXMuc2NhbGVdIC0gT3B0aW9uIHRvIGFkanVzdCBheGlzIG1pbmltdW0sIG1heGltdW0sIHN0ZXAgc2l6ZS5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy54QXhpcy53aWR0aF0gLSBXaWR0aCBvZiB4QXhpcy5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy54QXhpcy5oZWlnaHRdIC0gSGVpZ2h0IG9mIHhBeGlzLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fEFycmF5PE9iamVjdD59IFtwcm9wcy5vcHRpb25zLnlBeGlzXSAtIElmIHRoaXMgb3B0aW9uIGlzIGFuIGFycmF5IHR5cGUsIHVzZSB0aGUgc2Vjb25kYXJ5IHkgYXhpcy5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW3Byb3BzLm9wdGlvbnMueUF4aXMudGl0bGVdIC0gQXhpcyB0aXRsZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpcy50aWNrXSAtIE9wdGlvbiB0byBhZGp1c3QgdGljayBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpcy5sYWJlbF0gLSBPcHRpb24gdG8gYWRqdXN0IGxhYmVsIGludGVydmFsLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnlBeGlzLnNjYWxlXSAtIE9wdGlvbiB0byBhZGp1c3QgYXhpcyBtaW5pbXVtLCBtYXhpbXVtLCBzdGVwIHNpemUuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMueUF4aXMud2lkdGhdIC0gV2lkdGggb2YgeUF4aXMuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMueUF4aXMuaGVpZ2h0XSAtIEhlaWdodCBvZiB5QXhpcy5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMucGxvdF1cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5wbG90LndpZHRoXSAtIFdpZHRoIG9mIHBsb3QuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMucGxvdC5oZWlnaHRdIC0gSGVpZ2h0IG9mIHBsb3QuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnBsb3QudmlzaWJsZV0gLSBXaGV0aGVyIHRvIHNob3cgcGxvdCBsaW5lLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sZWdlbmRdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMubGVnZW5kLmFsaWduXSAtIExlZ2VuZCBhbGlnbi4gJ3RvcCcsICdib3R0b20nLCAncmlnaHQnLCAnbGVmdCcgaXMgYXZhaWxhYmxlLlxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC5zaG93Q2hlY2tib3hdIC0gV2hldGhlciB0byBzaG93IGNoZWNrYm94LlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5sZWdlbmQudmlzaWJsZV0gLSBXaGV0aGVyIHRvIHNob3cgbGVnZW5kLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC53aWR0aF0gLSBXaWR0aCBvZiBsZWdlbmQuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGVnZW5kLml0ZW1dIC0gYHdpZHRoYCBhbmQgYG92ZXJmbG93YCBvcHRpb25zIG9mIHRoZSBsZWdlbmQgaXRlbS4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fExlZ2VuZCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5leHBvcnRNZW51XVxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5leHBvcnRNZW51LnZpc2libGVdIC0gV2hldGhlciB0byBzaG93IGV4cG9ydCBtZW51LlxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnUuZmlsZW5hbWVdIC0gRmlsZSBuYW1lIGFwcGxpZWQgd2hlbiBkb3dubG9hZGluZy5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcF1cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy50b29sdGlwLm9mZnNldFhdIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgaG9yaXpvbnRhbGx5LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAub2Zmc2V0WV0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSB2ZXJ0aWNhbGx5LlxuICogICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC5mb3JtYXR0ZXJdIC0gRnVuY3Rpb24gdG8gZm9ybWF0IGRhdGEgdmFsdWUuXG4gKiAgICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcHMub3B0aW9ucy50b29sdGlwLnRlbXBsYXRlXSAtIEZ1bmN0aW9uIHRvIGNyZWF0ZSBjdXN0b20gdGVtcGxhdGUuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxUb29sdGlwIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnJlc3BvbnNpdmVdIC0gUnVsZXMgZm9yIGNoYW5naW5nIGNoYXJ0IG9wdGlvbnMuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxSZXNwb25zaXZlIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5yZXNwb25zaXZlLmFuaW1hdGlvbl0gLSBBbmltYXRpb24gZHVyYXRpb24gd2hlbiB0aGUgY2hhcnQgaXMgbW9kaWZpZWQuXG4gKiAgICAgICBAcGFyYW0ge0FycmF5PE9iamVjdD59IFtwcm9wcy5vcHRpb25zLnJlc3BvbnNpdmUucnVsZXNdIC0gUnVsZXMgZm9yIHRoZSBDaGFydCB0byBSZXNwb25kLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sYW5nXSAtIE9wdGlvbnMgZm9yIGNoYW5naW5nIHRoZSB0ZXh0IGRpc3BsYXllZCBvbiB0aGUgY2hhcnQgb3IgaTE4biBsYW5ndWFnZXMuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGFuZy5ub0RhdGFdIC0gTm8gRGF0YSBMYXllciBUZXh0LlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZV0gLSBDaGFydCB0aGVtZSBvcHRpb25zLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8TGluZVNjYXR0ZXIgQ2hhcnQgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5jaGFydF0gLSBDaGFydCBmb250IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLm5vRGF0YV0gLSBObyBEYXRhIExheWVyIFRleHQgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUuc2VyaWVzXSAtIFNlcmllcyB0aGVtZS4gRWFjaCB0aGVtZSB0byBiZSBhcHBsaWVkIHRvIHRoZSB0d28gY2hhcnRzIHNob3VsZCBiZSB3cml0dGVuIHNlcGFyYXRlbHkuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUudGl0bGVdIC0gVGl0bGUgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUueEF4aXNdIC0gWCBBeGlzIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R8QXJyYXk8T2JqZWN0Pn0gW3Byb3BzLm9wdGlvbnMudGhlbWUueUF4aXNdIC0gWSBBeGlzIHRoZW1lLiBJbiB0aGUgY2FzZSBvZiBhbiBhcnJhbmdlbWVudCwgdGhlIGZpcnN0IGlzIHRoZSBtYWluIGF4aXMgYW5kIHRoZSBzZWNvbmQgaXMgdGhlIHRoZW1lIGZvciB0aGUgc2Vjb25kYXJ5IGF4aXMuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUubGVnZW5kXSAtIExlZ2VuZCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS50b29sdGlwXSAtIFRvb2x0aXAgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUucGxvdF0gLSBQbG90IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmV4cG9ydE1lbnVdIC0gRXhwb3J0TWVudSB0aGVtZS5cbiAqIEBleHRlbmRzIENoYXJ0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVTY2F0dGVyQ2hhcnQgZXh0ZW5kcyBDaGFydCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgZWw6IHByb3BzLmVsLFxuICAgICAgICAgICAgb3B0aW9uczogcHJvcHMub3B0aW9ucyxcbiAgICAgICAgICAgIHNlcmllczogcHJvcHMuZGF0YS5zZXJpZXMsXG4gICAgICAgICAgICBtb2R1bGVzOiBbZGF0YVJhbmdlLCBzY2FsZSwgYXhlcywgcGxvdF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQmFja2dyb3VuZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoVGl0bGUpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFBsb3QpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKExlZ2VuZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoTGluZVNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoU2NhdHRlclNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpcywgeyBuYW1lOiAneUF4aXMnIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEF4aXMsIHsgbmFtZTogJ3hBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzLCB7IG5hbWU6ICdzZWNvbmRhcnlZQXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoRGF0YUxhYmVscyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpc1RpdGxlLCB7IG5hbWU6ICd4QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpc1RpdGxlLCB7IG5hbWU6ICd5QXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpc1RpdGxlLCB7IG5hbWU6ICdzZWNvbmRhcnlZQXhpcycgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoRXhwb3J0TWVudSwgeyBjaGFydEVsOiB0aGlzLmVsIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEhvdmVyZWRTZXJpZXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFNlbGVjdGVkU2VyaWVzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChUb29sdGlwLCB7IGNoYXJ0RWw6IHRoaXMuZWwgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoUmFuZ2VTZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKE5vRGF0YVRleHQpO1xuICAgICAgICB0aGlzLnBhaW50ZXIuYWRkR3JvdXBzKFtcbiAgICAgICAgICAgIGJhc2ljQnJ1c2gsXG4gICAgICAgICAgICBheGlzQnJ1c2gsXG4gICAgICAgICAgICBsaW5lU2VyaWVzQnJ1c2gsXG4gICAgICAgICAgICBsZWdlbmRCcnVzaCxcbiAgICAgICAgICAgIGxhYmVsQnJ1c2gsXG4gICAgICAgICAgICBleHBvcnRNZW51QnJ1c2gsXG4gICAgICAgICAgICBkYXRhTGFiZWxCcnVzaCxcbiAgICAgICAgICAgIHJlc2V0QnV0dG9uQnJ1c2gsXG4gICAgICAgICAgICBzY2F0dGVyU2VyaWVzQnJ1c2gsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIC0gQXJyYXkgb2YgZGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIC0gV2hpY2ggdHlwZSBvZiBjaGFydCB0byBhZGQuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuYWRkRGF0YShbe3g6IDEwLCB5OiAyMH0sIHt4OiAzMCwgeTogNDB9XSwgJ2xpbmUnKTtcbiAgICAgKi9cbiAgICBhZGREYXRhKGRhdGEsIGNoYXJ0VHlwZSkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkNvbnRyb2xGbGFnLnVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdhZGREYXRhJywgeyBkYXRhLCBjaGFydFR5cGUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBEYXRhIHRvIGJlIGFkZGVkLlxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9IGRhdGEubmFtZSAtIFNlcmllcyBuYW1lLlxuICAgICAqICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBkYXRhLmRhdGEgLSBBcnJheSBvZiBkYXRhIHRvIGJlIGFkZGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhSW5mbyAtIFdoaWNoIHR5cGUgb2YgY2hhcnQgdG8gYWRkLlxuICAgICAqICAgQHBhcmFtIHtPYmplY3R9IGRhdGFJbmZvLmNoYXJ0VHlwZSAtIENoYXJ0IHR5cGUuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuYWRkU2VyaWVzKFxuICAgICAqICAge1xuICAgICAqICAgICBuYW1lOiAnbmV3U2VyaWVzJyxcbiAgICAgKiAgICAgZGF0YTogW3t4OiAxMCwgeTogMjB9LCB7eDogMzAsIHk6IDQwfV0sXG4gICAgICogICB9LFxuICAgICAqICAge1xuICAgICAqICAgICBjaGFydFR5cGU6ICdsaW5lJ1xuICAgICAqICAgfSk7XG4gICAgICovXG4gICAgYWRkU2VyaWVzKGRhdGEsIGRhdGFJbmZvKSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgnYWRkU2VyaWVzJywgT2JqZWN0LmFzc2lnbih7IGRhdGEgfSwgZGF0YUluZm8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgY2hhcnQgZGF0YSB0byBuZXcgZGF0YS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIERhdGEgdG8gYmUgc2V0XG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2V0RGF0YSh7XG4gICAgICogICBzZXJpZXM6IHtcbiAgICAgKiAgICAgbGluZTogW1xuICAgICAqICAgICAgIHtcbiAgICAgKiAgICAgICAgIG5hbWU6ICdBJyxcbiAgICAgKiAgICAgICAgIGRhdGE6IFt7eDogMTAsIHk6IDIwfSwge3g6IDMwLCB5OiA0MH1dLFxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgXSxcbiAgICAgKiAgICAgc2NhdHRlcjogW1xuICAgICAqICAgICAgIHtcbiAgICAgKiAgICAgICAgIG5hbWU6ICdCJyxcbiAgICAgKiAgICAgICAgIGRhdGE6IFt7eDogMzAsIHk6IDIwfSwge3g6IDQwLCB5OiA0MH1dLFxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgXVxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHNldERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3NldERhdGEnLCBkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgY2hhcnQgb3B0aW9ucyB0byBuZXcgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENoYXJ0IG9wdGlvbnNcbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zZXRPcHRpb25zKHtcbiAgICAgKiAgIGNoYXJ0OiB7XG4gICAgICogICAgIHdpZHRoOiA1MDAsXG4gICAgICogICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAqICAgICB0aXRsZTogJ0VuZXJneSBVc2FnZScsXG4gICAgICogICB9LFxuICAgICAqICAgeEF4aXM6IHtcbiAgICAgKiAgICAgdGl0bGU6ICdNb250aCcsXG4gICAgICogICAgIGRhdGU6IHsgZm9ybWF0OiAneXkvTU0nIH0sXG4gICAgICogICB9LFxuICAgICAqICAgeUF4aXM6IHtcbiAgICAgKiAgICAgdGl0bGU6ICdFbmVyZ3kgKGtXaCknLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHNlcmllczoge1xuICAgICAqICAgICBsaW5lOiB7XG4gICAgICogICAgICAgc2hvd0RvdDogdHJ1ZSxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgKiAgIH0sXG4gICAgICogICB0b29sdGlwOiB7XG4gICAgICogICAgIGZvcm1hdHRlcjogKHZhbHVlKSA9PiBgJHt2YWx1ZX1rV2hgLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoT3B0aW9uc0V2ZW50KCdpbml0T3B0aW9ucycsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY2hhcnQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENoYXJ0IG9wdGlvbnNcbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC51cGRhdGVPcHRpb25zKHtcbiAgICAgKiAgIGNoYXJ0OiB7XG4gICAgICogICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAqICAgICB0aXRsZTogJ0VuZXJneSBVc2FnZScsXG4gICAgICogICB9LFxuICAgICAqICAgc2VyaWVzOiB7XG4gICAgICogICAgIGxpbmU6IHtcbiAgICAgKiAgICAgICBzaG93RG90OiB0cnVlLFxuICAgICAqICAgICB9LFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB1cGRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoT3B0aW9uc0V2ZW50KCd1cGRhdGVPcHRpb25zJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VyaWVzSW5mbyAtIEluZm9ybWF0aW9uIG9mIHRoZSBzZXJpZXMgZm9yIHRoZSB0b29sdGlwIHRvIGJlIGRpc3BsYXllZFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHNlcmllc0luZm8uc2VyaWVzSW5kZXggLSBJbmRleCBvZiBzZXJpZXNcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBzZXJpZXNJbmZvLmluZGV4IC0gSW5kZXggb2YgZGF0YSB3aXRoaW4gc2VyaWVzXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gc2VyaWVzSW5mby5jaGFydFR5cGUgLSBTcGVjaWZ5IHdoaWNoIGNoYXJ0IHRvIHNlbGVjdC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zaG93VG9vbHRpcCh7aW5kZXg6IDEsIHNlcmllc0luZGV4OiAyLCBjaGFydFR5cGU6ICdzY2F0dGVyJ30pO1xuICAgICAqL1xuICAgIHNob3dUb29sdGlwKHNlcmllc0luZm8pIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzaG93VG9vbHRpcCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VyaWVzSW5mbyksIHsgc3RhdGU6IHRoaXMuc3RvcmUuc3RhdGUgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlIHRvb2x0aXAuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuaGlkZVRvb2x0aXAoKTtcbiAgICAgKi9cbiAgICBoaWRlVG9vbHRpcCgpIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdoaWRlVG9vbHRpcCcpO1xuICAgIH1cbn1cbiIsImltcG9ydCBDaGFydCBmcm9tIFwiLi9jaGFydFwiO1xuaW1wb3J0IG5lc3RlZFBpZVNlcmllc0RhdGEgZnJvbSBcIi4uL3N0b3JlL25lc3RlZFBpZVNlcmllc0RhdGFcIjtcbmltcG9ydCBUb29sdGlwIGZyb20gXCIuLi9jb21wb25lbnQvdG9vbHRpcFwiO1xuaW1wb3J0IExlZ2VuZCBmcm9tIFwiLi4vY29tcG9uZW50L2xlZ2VuZFwiO1xuaW1wb3J0IFRpdGxlIGZyb20gXCIuLi9jb21wb25lbnQvdGl0bGVcIjtcbmltcG9ydCBFeHBvcnRNZW51IGZyb20gXCIuLi9jb21wb25lbnQvZXhwb3J0TWVudVwiO1xuaW1wb3J0IEhvdmVyZWRTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9ob3ZlcmVkU2VyaWVzXCI7XG5pbXBvcnQgRGF0YUxhYmVscyBmcm9tIFwiLi4vY29tcG9uZW50L2RhdGFMYWJlbHNcIjtcbmltcG9ydCBTZWxlY3RlZFNlcmllcyBmcm9tIFwiLi4vY29tcG9uZW50L3NlbGVjdGVkU2VyaWVzXCI7XG5pbXBvcnQgQmFja2dyb3VuZCBmcm9tIFwiLi4vY29tcG9uZW50L2JhY2tncm91bmRcIjtcbmltcG9ydCBQaWVTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9waWVTZXJpZXNcIjtcbmltcG9ydCBOb0RhdGFUZXh0IGZyb20gXCIuLi9jb21wb25lbnQvbm9EYXRhVGV4dFwiO1xuaW1wb3J0ICogYXMgYmFzaWNCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9iYXNpY1wiO1xuaW1wb3J0ICogYXMgbGVnZW5kQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvbGVnZW5kXCI7XG5pbXBvcnQgKiBhcyBsYWJlbEJydXNoIGZyb20gXCIuLi9icnVzaGVzL2xhYmVsXCI7XG5pbXBvcnQgKiBhcyBleHBvcnRNZW51QnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvZXhwb3J0TWVudVwiO1xuaW1wb3J0ICogYXMgc2VjdG9yQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvc2VjdG9yXCI7XG5pbXBvcnQgKiBhcyBkYXRhTGFiZWxCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9kYXRhTGFiZWxcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIE5lc3RlZFBpZSBDaGFydFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHByb3BzLmVsIC0gVGhlIHRhcmdldCBlbGVtZW50IHRvIGNyZWF0ZSBjaGFydC5cbiAqICAgQHBhcmFtIHtPYmplY3R9IHByb3BzLmRhdGEgLSBEYXRhIGZvciBtYWtpbmcgTmVzdGVkUGllIENoYXJ0LlxuICogICAgIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3Byb3BzLmRhdGEuY2F0ZWdvcmllc10gLSBDYXRlZ29yaWVzLlxuICogICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcHJvcHMuZGF0YS5zZXJpZXMgLSBTZXJpZXMgZGF0YS5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy5kYXRhLnNlcmllcy5uYW1lIC0gU2VyaWVzIG5hbWUuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gcHJvcHMuZGF0YS5zZXJpZXMuZGF0YSAtIFNlcmllcyBkYXRhLlxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5kYXRhLnNlcmllcy5wYXJlbnROYW1lXSAtIFZhbHVlIHNwZWNpZnlpbmcgcGFyZW50IGRhdGEgd2hlbiB1c2luZyBncm91cCBuZXN0ZWQgcGllIGNoYXJ0LlxuICogICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnNdIC0gT3B0aW9ucyBmb3IgbWFraW5nIE5lc3RlZFBpZSBDaGFydC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2hhcnRdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlXSAtIENoYXJ0IHRpdGxlIHRleHQgb3Igb3B0aW9ucy5cbiAqICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLnRleHRdIC0gQ2hhcnQgdGl0bGUgdGV4dC5cbiAqICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLm9mZnNldFhdIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgaG9yaXpvbnRhbGx5LlxuICogICAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUub2Zmc2V0WV0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSB2ZXJ0aWNhbGx5LlxuICogICAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUuYWxpZ25dIC0gQ2hhcnQgdGV4dCBhbGlnbi4gJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJyBpcyBhdmFpbGFibGUuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaGFydC5hbmltYXRpb25dIC0gV2hldGhlciB0byB1c2UgYW5pbWF0aW9uIGFuZCBkdXJhdGlvbiB3aGVuIHJlbmRlcmluZyB0aGUgaW5pdGlhbCBjaGFydC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQud2lkdGhdIC0gQ2hhcnQgd2lkdGguICdhdXRvJyBvciBpZiBub3Qgd3JpdGUsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC4gJ2F1dG8nIG9yIGlmIG5vdCBjcmVhdGVkLCB0aGUgd2lkdGggb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LmhlaWdodF0gLSBDaGFydCBoZWlnaHQuICdhdXRvJyBvciBpZiBub3Qgd3JpdGUsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC4gJ2F1dG8nIG9yIGlmIG5vdCBjcmVhdGVkLCB0aGUgaGVpZ2h0IG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5zZXJpZXNdXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5zZWxlY3RhYmxlPWZhbHNlXSAtIFdoZXRoZXIgdG8gbWFrZSBzZWxlY3RhYmxlIHNlcmllcyBvciBub3QuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLmRhdGFMYWJlbHNdIC0gU2V0IHRoZSB2aXNpYmlsaXR5LCBsb2NhdGlvbiwgYW5kIGZvcm1hdHRpbmcgb2YgZGF0YUxhYmVsLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8RGF0YUxhYmVscyBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnNlcmllcy5hbGlhc05hbWVdIC0gQ2hhcnQgb3B0aW9ucyBhcmUgc3BlY2lmaWVkIGJhc2VkIG9uIHRoZSBhbGlhcyBuYW1lLiAncmFkaXVzUmFuZ2UnLCAnYW5nbGVSYW5nZScsICdjbG9ja3dpc2UnLCAnZGF0YUxhYmVscycgaXMgYXZhaWxhYmxlLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8TmVzdGVkUGllIENoYXJ0IGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZF1cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5sZWdlbmQuYWxpZ25dIC0gTGVnZW5kIGFsaWduLiAndG9wJywgJ2JvdHRvbScsICdyaWdodCcsICdsZWZ0JyBpcyBhdmFpbGFibGUuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMubGVnZW5kLnNob3dDaGVja2JveF0gLSBXaGV0aGVyIHRvIHNob3cgY2hlY2tib3guXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC52aXNpYmxlXSAtIFdoZXRoZXIgdG8gc2hvdyBsZWdlbmQuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMubGVnZW5kLndpZHRoXSAtIFdpZHRoIG9mIGxlZ2VuZC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sZWdlbmQuaXRlbV0gLSBgd2lkdGhgIGFuZCBgb3ZlcmZsb3dgIG9wdGlvbnMgb2YgdGhlIGxlZ2VuZCBpdGVtLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8TGVnZW5kIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnVdXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnUudmlzaWJsZV0gLSBXaGV0aGVyIHRvIHNob3cgZXhwb3J0IG1lbnUuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuZXhwb3J0TWVudS5maWxlbmFtZV0gLSBGaWxlIG5hbWUgYXBwbGllZCB3aGVuIGRvd25sb2FkaW5nLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50b29sdGlwXVxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAub2Zmc2V0WF0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSBob3Jpem9udGFsbHkuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC5vZmZzZXRZXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIHZlcnRpY2FsbHkuXG4gKiAgICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcHMub3B0aW9ucy50b29sdGlwLmZvcm1hdHRlcl0gLSBGdW5jdGlvbiB0byBmb3JtYXQgZGF0YSB2YWx1ZS5cbiAqICAgICAgIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAudGVtcGxhdGVdIC0gRnVuY3Rpb24gdG8gY3JlYXRlIGN1c3RvbSB0ZW1wbGF0ZS4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFRvb2x0aXAgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZV0gLSBSdWxlcyBmb3IgY2hhbmdpbmcgY2hhcnQgb3B0aW9ucy4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFJlc3BvbnNpdmUgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLnJlc3BvbnNpdmUuYW5pbWF0aW9uXSAtIEFuaW1hdGlvbiBkdXJhdGlvbiB3aGVuIHRoZSBjaGFydCBpcyBtb2RpZmllZC5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZS5ydWxlc10gLSBSdWxlcyBmb3IgdGhlIENoYXJ0IHRvIFJlc3BvbmQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxhbmddIC0gT3B0aW9ucyBmb3IgY2hhbmdpbmcgdGhlIHRleHQgZGlzcGxheWVkIG9uIHRoZSBjaGFydCBvciBpMThuIGxhbmd1YWdlcy5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sYW5nLm5vRGF0YV0gLSBObyBEYXRhIExheWVyIFRleHQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lXSAtIENoYXJ0IHRoZW1lIG9wdGlvbnMuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxOZXN0ZWRQaWUgQ2hhcnQgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5jaGFydF0gLSBDaGFydCBmb250IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLm5vRGF0YV0gLSBObyBEYXRhIExheWVyIFRleHQgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUuc2VyaWVzXSAtIFNlcmllcyB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS50aXRsZV0gLSBUaXRsZSB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5sZWdlbmRdIC0gTGVnZW5kIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnRvb2x0aXBdIC0gVG9vbHRpcCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5leHBvcnRNZW51XSAtIEV4cG9ydE1lbnUgdGhlbWUuXG4gKiBAZXh0ZW5kcyBDaGFydFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOZXN0ZWRQaWVDaGFydCBleHRlbmRzIENoYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcih7IGVsLCBvcHRpb25zLCBkYXRhOiB7IHNlcmllcywgY2F0ZWdvcmllcyB9IH0pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgc2VyaWVzOiB7IHBpZTogc2VyaWVzIH0sXG4gICAgICAgICAgICBjYXRlZ29yaWVzLFxuICAgICAgICAgICAgbW9kdWxlczogW25lc3RlZFBpZVNlcmllc0RhdGFdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQmFja2dyb3VuZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoVGl0bGUpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKExlZ2VuZCk7XG4gICAgICAgIChfYSA9IHRoaXMuc3RvcmUuaW5pdFN0b3JlU3RhdGUuc2VyaWVzLnBpZSwgKF9hICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSkuZm9yRWFjaCgoeyBuYW1lIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoUGllU2VyaWVzLCB7IGFsaWFzOiBuYW1lIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChFeHBvcnRNZW51LCB7IGNoYXJ0RWw6IHRoaXMuZWwgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoSG92ZXJlZFNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoU2VsZWN0ZWRTZXJpZXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKERhdGFMYWJlbHMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFRvb2x0aXAsIHsgY2hhcnRFbDogdGhpcy5lbCB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChOb0RhdGFUZXh0KTtcbiAgICAgICAgdGhpcy5wYWludGVyLmFkZEdyb3VwcyhbXG4gICAgICAgICAgICBiYXNpY0JydXNoLFxuICAgICAgICAgICAgbGVnZW5kQnJ1c2gsXG4gICAgICAgICAgICBsYWJlbEJydXNoLFxuICAgICAgICAgICAgZXhwb3J0TWVudUJydXNoLFxuICAgICAgICAgICAgc2VjdG9yQnJ1c2gsXG4gICAgICAgICAgICBkYXRhTGFiZWxCcnVzaCxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBEYXRhIHRvIGJlIGFkZGVkLlxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9IGRhdGEubmFtZSAtIFNlcmllcyBuYW1lLlxuICAgICAqICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBkYXRhLmRhdGEgLSBBcnJheSBvZiBkYXRhIHRvIGJlIGFkZGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhSW5mbyAtIFdoaWNoIG5hbWUgb2YgY2hhcnQgdG8gYWRkLlxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9IGRhdGFJbmZvLm5hbWUgLSBDaGFydCBzZXJpZXMgbmFtZS5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5hZGRTZXJpZXMoXG4gICAgICogICB7XG4gICAgICogICAgIG5hbWU6ICduZXdTZXJpZXMnLFxuICAgICAqICAgICBkYXRhOiBbXG4gICAgICogICAgICAgeyBuYW1lOiAnQScsIGRhdGE6IDEwIH0sXG4gICAgICogICAgICAgeyBuYW1lOiAnQicsIGRhdGE6IDIwIH0sXG4gICAgICogICAgIF0sXG4gICAgICogICB9LFxuICAgICAqICAge1xuICAgICAqICAgICBuYW1lOiAnc2VyaWVzIG5hbWUnXG4gICAgICogICB9KTtcbiAgICAgKi9cbiAgICBhZGRTZXJpZXMoZGF0YSwgZGF0YUluZm8pIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdhZGRTZXJpZXMnLCBPYmplY3QuYXNzaWduKHsgZGF0YSB9LCBkYXRhSW5mbykpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFBpZVNlcmllcywgeyBhbGlhczogZGF0YS5uYW1lIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBjaGFydCBkYXRhIHRvIG5ldyBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBiZSBzZXRcbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zZXREYXRhKHtcbiAgICAgKiAgIGNhdGVnb3JpZXM6IFsnQScsICdCJ10sXG4gICAgICogICBzZXJpZXM6IFtcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgIG5hbWU6ICdicm93c2VycycsXG4gICAgICogICAgICAgZGF0YTogW1xuICAgICAqICAgICAgICAge1xuICAgICAqICAgICAgICAgICBuYW1lOiAnQ2hyb21lJyxcbiAgICAgKiAgICAgICAgICAgZGF0YTogNTAsXG4gICAgICogICAgICAgICB9LFxuICAgICAqICAgICAgICAge1xuICAgICAqICAgICAgICAgICBuYW1lOiAnU2FmYXJpJyxcbiAgICAgKiAgICAgICAgICAgZGF0YTogMjAsXG4gICAgICogICAgICAgICB9LFxuICAgICAqICAgICAgIF1cbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgIG5hbWU6ICd2ZXJzaW9ucycsXG4gICAgICogICAgICAgZGF0YTogW1xuICAgICAqICAgICAgICAge1xuICAgICAqICAgICAgICAgICBuYW1lOiAnMScsXG4gICAgICogICAgICAgICAgIGRhdGE6IDUwLFxuICAgICAqICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgbmFtZTogJzInLFxuICAgICAqICAgICAgICAgICBkYXRhOiAyMCxcbiAgICAgKiAgICAgICAgIH0sXG4gICAgICogICAgICAgXVxuICAgICAqICAgICB9XG4gICAgICogICBdXG4gICAgICogfSk7XG4gICAgICovXG4gICAgc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLnJlbW92ZShQaWVTZXJpZXMpO1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3NldERhdGEnLCB7IHNlcmllczogeyBwaWU6IGRhdGEuc2VyaWVzIH0gfSk7XG4gICAgICAgIChfYSA9IHRoaXMuc3RvcmUuaW5pdFN0b3JlU3RhdGUuc2VyaWVzLnBpZSwgKF9hICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSkuZm9yRWFjaCgoeyBuYW1lIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoUGllU2VyaWVzLCB7IGFsaWFzOiBuYW1lIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZSBzZXJpZXMgZGF0YSBsYWJlbC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5oaWRlU2VyaWVzRGF0YUxhYmVsKCk7XG4gICAgICovXG4gICAgaGlkZVNlcmllc0RhdGFMYWJlbCgpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgndXBkYXRlT3B0aW9ucycsIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHsgc2VyaWVzOiB7IGRhdGFMYWJlbHM6IHsgdmlzaWJsZTogZmFsc2UgfSB9IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHNlcmllcyBkYXRhIGxhYmVsLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNob3dTZXJpZXNEYXRhTGFiZWwoKTtcbiAgICAgKi9cbiAgICBzaG93U2VyaWVzRGF0YUxhYmVsKCkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCd1cGRhdGVPcHRpb25zJywge1xuICAgICAgICAgICAgb3B0aW9uczogeyBzZXJpZXM6IHsgZGF0YUxhYmVsczogeyB2aXNpYmxlOiB0cnVlIH0gfSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgY2hhcnQgb3B0aW9ucyB0byBuZXcgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENoYXJ0IG9wdGlvbnMuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2V0T3B0aW9ucyh7XG4gICAgICogICBjaGFydDoge1xuICAgICAqICAgICB3aWR0aDogNTAwLFxuICAgICAqICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgKiAgICAgdGl0bGU6ICdFbmVyZ3kgVXNhZ2UnLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHNlcmllczoge1xuICAgICAqICAgICBhbGlhczI6IHtcbiAgICAgKiAgICAgICByYWRpdXNSYW5nZTogWzIwJSwgNTAlXSxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgIH0sXG4gICAgICogICB0b29sdGlwOiB7XG4gICAgICogICAgIGZvcm1hdHRlcjogKHZhbHVlKSA9PiBgJHt2YWx1ZX1rV2hgLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoT3B0aW9uc0V2ZW50KCdpbml0T3B0aW9ucycsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY2hhcnQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENoYXJ0IG9wdGlvbnMuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQudXBkYXRlT3B0aW9ucyh7XG4gICAgICogICBjaGFydDoge1xuICAgICAqICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgKiAgICAgdGl0bGU6ICdFbmVyZ3kgVXNhZ2UnLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHNlcmllczoge1xuICAgICAqICAgICBhbGlhczE6IHtcbiAgICAgKiAgICAgICBzaG93RG90OiB0cnVlLFxuICAgICAqICAgICB9LFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB1cGRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoT3B0aW9uc0V2ZW50KCd1cGRhdGVPcHRpb25zJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VyaWVzSW5mbyAtIEluZm9ybWF0aW9uIG9mIHRoZSBzZXJpZXMgZm9yIHRoZSB0b29sdGlwIHRvIGJlIGRpc3BsYXllZC5cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBzZXJpZXNJbmZvLnNlcmllc0luZGV4IC0gSW5kZXggb2Ygc2VyaWVzLlxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHNlcmllc0luZm8uYWxpYXMgLSBhbGlhcyBuYW1lLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNob3dUb29sdGlwKHtzZXJpZXNJbmRleDogMSwgYWxpYXM6ICduYW1lJ30pO1xuICAgICAqL1xuICAgIHNob3dUb29sdGlwKHNlcmllc0luZm8pIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzaG93VG9vbHRpcCcsIE9iamVjdC5hc3NpZ24oe30sIHNlcmllc0luZm8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZSB0b29sdGlwLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmhpZGVUb29sdGlwKCk7XG4gICAgICovXG4gICAgaGlkZVRvb2x0aXAoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnaGlkZVRvb2x0aXAnKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ2hhcnQgZnJvbSBcIi4vY2hhcnRcIjtcbmltcG9ydCBUb29sdGlwIGZyb20gXCIuLi9jb21wb25lbnQvdG9vbHRpcFwiO1xuaW1wb3J0IExlZ2VuZCBmcm9tIFwiLi4vY29tcG9uZW50L2xlZ2VuZFwiO1xuaW1wb3J0IFBpZVNlcmllcyBmcm9tIFwiLi4vY29tcG9uZW50L3BpZVNlcmllc1wiO1xuaW1wb3J0IFRpdGxlIGZyb20gXCIuLi9jb21wb25lbnQvdGl0bGVcIjtcbmltcG9ydCBFeHBvcnRNZW51IGZyb20gXCIuLi9jb21wb25lbnQvZXhwb3J0TWVudVwiO1xuaW1wb3J0IEhvdmVyZWRTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9ob3ZlcmVkU2VyaWVzXCI7XG5pbXBvcnQgRGF0YUxhYmVscyBmcm9tIFwiLi4vY29tcG9uZW50L2RhdGFMYWJlbHNcIjtcbmltcG9ydCBTZWxlY3RlZFNlcmllcyBmcm9tIFwiLi4vY29tcG9uZW50L3NlbGVjdGVkU2VyaWVzXCI7XG5pbXBvcnQgQmFja2dyb3VuZCBmcm9tIFwiLi4vY29tcG9uZW50L2JhY2tncm91bmRcIjtcbmltcG9ydCBOb0RhdGFUZXh0IGZyb20gXCIuLi9jb21wb25lbnQvbm9EYXRhVGV4dFwiO1xuaW1wb3J0ICogYXMgYmFzaWNCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9iYXNpY1wiO1xuaW1wb3J0ICogYXMgbGVnZW5kQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvbGVnZW5kXCI7XG5pbXBvcnQgKiBhcyBsYWJlbEJydXNoIGZyb20gXCIuLi9icnVzaGVzL2xhYmVsXCI7XG5pbXBvcnQgKiBhcyBleHBvcnRNZW51QnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvZXhwb3J0TWVudVwiO1xuaW1wb3J0ICogYXMgc2VjdG9yQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvc2VjdG9yXCI7XG5pbXBvcnQgKiBhcyBkYXRhTGFiZWxCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9kYXRhTGFiZWxcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIFBpZSBDaGFydFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHByb3BzLmVsIC0gVGhlIHRhcmdldCBlbGVtZW50IHRvIGNyZWF0ZSBjaGFydC5cbiAqICAgQHBhcmFtIHtPYmplY3R9IHByb3BzLmRhdGEgLSBEYXRhIGZvciBtYWtpbmcgUGllIENoYXJ0LlxuICogICAgIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3Byb3BzLmRhdGEuY2F0ZWdvcmllc10gLSBDYXRlZ29yaWVzLlxuICogICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcHJvcHMuZGF0YS5zZXJpZXMgLSBTZXJpZXMgZGF0YS5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy5kYXRhLnNlcmllcy5uYW1lIC0gU2VyaWVzIG5hbWUuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gcHJvcHMuZGF0YS5zZXJpZXMuZGF0YSAtIFNlcmllcyBkYXRhLlxuICogICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnNdIC0gT3B0aW9ucyBmb3IgbWFraW5nIFBpZSBDaGFydC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2hhcnRdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlXSAtIENoYXJ0IHRpdGxlIHRleHQgb3Igb3B0aW9ucy5cbiAqICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLnRleHRdIC0gQ2hhcnQgdGl0bGUgdGV4dC5cbiAqICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLm9mZnNldFhdIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgaG9yaXpvbnRhbGx5LlxuICogICAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUub2Zmc2V0WV0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSB2ZXJ0aWNhbGx5LlxuICogICAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUuYWxpZ25dIC0gQ2hhcnQgdGV4dCBhbGlnbi4gJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJyBpcyBhdmFpbGFibGUuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaGFydC5hbmltYXRpb25dIC0gV2hldGhlciB0byB1c2UgYW5pbWF0aW9uIGFuZCBkdXJhdGlvbiB3aGVuIHJlbmRlcmluZyB0aGUgaW5pdGlhbCBjaGFydC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQud2lkdGhdIC0gQ2hhcnQgd2lkdGguICdhdXRvJyBvciBpZiBub3Qgd3JpdGUsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC4gJ2F1dG8nIG9yIGlmIG5vdCBjcmVhdGVkLCB0aGUgd2lkdGggb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LmhlaWdodF0gLSBDaGFydCBoZWlnaHQuICdhdXRvJyBvciBpZiBub3Qgd3JpdGUsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC4gJ2F1dG8nIG9yIGlmIG5vdCBjcmVhdGVkLCB0aGUgaGVpZ2h0IG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5zZXJpZXNdXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5zZWxlY3RhYmxlPWZhbHNlXSAtIFdoZXRoZXIgdG8gbWFrZSBzZWxlY3RhYmxlIHNlcmllcyBvciBub3QuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLmRhdGFMYWJlbHNdIC0gU2V0IHRoZSB2aXNpYmlsaXR5LCBsb2NhdGlvbiwgYW5kIGZvcm1hdHRpbmcgb2YgZGF0YUxhYmVsLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8RGF0YUxhYmVscyBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxudW1iZXI+fEFycmF5PHN0cmluZz59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5yYWRpdXNSYW5nZV0gLSBTcGVjaWZpZXMgdGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlIGRyYXduLiBJdCBpcyBzcGVjaWZpZWQgYnkgZW50ZXJpbmcgYSBudW1iZXIgb3IgcGVyY2VudCBzdHJpbmcgdmFsdWUgaW4gc3RhcnQgYW5kIGVuZC5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLmFuZ2xlUmFuZ2VdIC0gVGhlIHJhbmdlIG9mIGFuZ2xlcyB0byB3aGljaCB0aGUgY2lyY2xlIHdpbGwgYmUgZHJhd24uIEl0IGlzIHNwZWNpZmllZCBieSBwdXR0aW5nIG51bWJlciBpbiBzdGFydCBhbmQgZW5kLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5zZXJpZXMuY2xvY2t3aXNlXSAtIFdoZXRoZXIgaXQgd2lsbCBiZSBkcmF3biBjbG9ja3dpc2UuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZF1cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5sZWdlbmQuYWxpZ25dIC0gTGVnZW5kIGFsaWduLiAndG9wJywgJ2JvdHRvbScsICdyaWdodCcsICdsZWZ0JyBpcyBhdmFpbGFibGUuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMubGVnZW5kLnNob3dDaGVja2JveF0gLSBXaGV0aGVyIHRvIHNob3cgY2hlY2tib3guXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC52aXNpYmxlXSAtIFdoZXRoZXIgdG8gc2hvdyBsZWdlbmQuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMubGVnZW5kLndpZHRoXSAtIFdpZHRoIG9mIGxlZ2VuZC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sZWdlbmQuaXRlbV0gLSBgd2lkdGhgIGFuZCBgb3ZlcmZsb3dgIG9wdGlvbnMgb2YgdGhlIGxlZ2VuZCBpdGVtLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8TGVnZW5kIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnVdXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnUudmlzaWJsZV0gLSBXaGV0aGVyIHRvIHNob3cgZXhwb3J0IG1lbnUuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuZXhwb3J0TWVudS5maWxlbmFtZV0gLSBGaWxlIG5hbWUgYXBwbGllZCB3aGVuIGRvd25sb2FkaW5nLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50b29sdGlwXVxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAub2Zmc2V0WF0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSBob3Jpem9udGFsbHkuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC5vZmZzZXRZXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIHZlcnRpY2FsbHkuXG4gKiAgICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcHMub3B0aW9ucy50b29sdGlwLmZvcm1hdHRlcl0gLSBGdW5jdGlvbiB0byBmb3JtYXQgZGF0YSB2YWx1ZS5cbiAqICAgICAgIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAudGVtcGxhdGVdIC0gRnVuY3Rpb24gdG8gY3JlYXRlIGN1c3RvbSB0ZW1wbGF0ZS4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFRvb2x0aXAgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZV0gLSBSdWxlcyBmb3IgY2hhbmdpbmcgY2hhcnQgb3B0aW9ucy4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFJlc3BvbnNpdmUgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLnJlc3BvbnNpdmUuYW5pbWF0aW9uXSAtIEFuaW1hdGlvbiBkdXJhdGlvbiB3aGVuIHRoZSBjaGFydCBpcyBtb2RpZmllZC5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZS5ydWxlc10gLSBSdWxlcyBmb3IgdGhlIENoYXJ0IHRvIFJlc3BvbmQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxhbmddIC0gT3B0aW9ucyBmb3IgY2hhbmdpbmcgdGhlIHRleHQgZGlzcGxheWVkIG9uIHRoZSBjaGFydCBvciBpMThuIGxhbmd1YWdlcy5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sYW5nLm5vRGF0YV0gLSBObyBEYXRhIExheWVyIFRleHQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lXSAtIENoYXJ0IHRoZW1lIG9wdGlvbnMuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxQaWUgQ2hhcnQgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5jaGFydF0gLSBDaGFydCBmb250IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLm5vRGF0YV0gLSBObyBEYXRhIExheWVyIFRleHQgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUuc2VyaWVzXSAtIFNlcmllcyB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS50aXRsZV0gLSBUaXRsZSB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5sZWdlbmRdIC0gTGVnZW5kIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnRvb2x0aXBdIC0gVG9vbHRpcCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5leHBvcnRNZW51XSAtIEV4cG9ydE1lbnUgdGhlbWUuXG4gKiBAZXh0ZW5kcyBDaGFydFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQaWVDaGFydCBleHRlbmRzIENoYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcih7IGVsLCBvcHRpb25zLCBkYXRhIH0pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgc2VyaWVzOiB7XG4gICAgICAgICAgICAgICAgcGllOiBkYXRhLnNlcmllcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYXRlZ29yaWVzOiBkYXRhLmNhdGVnb3JpZXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQmFja2dyb3VuZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoVGl0bGUpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKExlZ2VuZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoUGllU2VyaWVzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChFeHBvcnRNZW51LCB7IGNoYXJ0RWw6IHRoaXMuZWwgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoSG92ZXJlZFNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoU2VsZWN0ZWRTZXJpZXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKERhdGFMYWJlbHMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFRvb2x0aXAsIHsgY2hhcnRFbDogdGhpcy5lbCB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChOb0RhdGFUZXh0KTtcbiAgICAgICAgdGhpcy5wYWludGVyLmFkZEdyb3VwcyhbXG4gICAgICAgICAgICBiYXNpY0JydXNoLFxuICAgICAgICAgICAgbGVnZW5kQnJ1c2gsXG4gICAgICAgICAgICBsYWJlbEJydXNoLFxuICAgICAgICAgICAgZXhwb3J0TWVudUJydXNoLFxuICAgICAgICAgICAgc2VjdG9yQnJ1c2gsXG4gICAgICAgICAgICBkYXRhTGFiZWxCcnVzaCxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBEYXRhIHRvIGJlIGFkZGVkLlxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9IGRhdGEubmFtZSAtIFNlcmllcyBuYW1lLlxuICAgICAqICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBkYXRhLmRhdGEgLSBBcnJheSBvZiBkYXRhIHRvIGJlIGFkZGVkLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmFkZFNlcmllcyh7XG4gICAgICogICBuYW1lOiAnbmV3U2VyaWVzJyxcbiAgICAgKiAgIGRhdGE6IDEwLFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGFkZFNlcmllcyhkYXRhKSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgnYWRkU2VyaWVzJywgeyBkYXRhIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBjaGFydCBkYXRhIHRvIG5ldyBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBiZSBzZXQuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2V0RGF0YSh7XG4gICAgICogICBjYXRlZ29yaWVzOiBbJ0EnXSxcbiAgICAgKiAgIHNlcmllczogW1xuICAgICAqICAgICB7bmFtZTogJ2EnLCBkYXRhOiAxMH0sXG4gICAgICogICAgIHtuYW1lOiAnYicsIGRhdGE6IDIwfSxcbiAgICAgKiAgIF1cbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXREYXRhKGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBjYXRlZ29yaWVzLCBzZXJpZXMgfSA9IGRhdGE7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgnc2V0RGF0YScsIHsgc2VyaWVzOiB7IHBpZTogc2VyaWVzIH0sIGNhdGVnb3JpZXMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGUgc2VyaWVzIGRhdGEgbGFiZWwuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuaGlkZVNlcmllc0RhdGFMYWJlbCgpO1xuICAgICAqL1xuICAgIGhpZGVTZXJpZXNEYXRhTGFiZWwoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3VwZGF0ZU9wdGlvbnMnLCB7XG4gICAgICAgICAgICBvcHRpb25zOiB7IHNlcmllczogeyBkYXRhTGFiZWxzOiB7IHZpc2libGU6IGZhbHNlIH0gfSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyBzZXJpZXMgZGF0YSBsYWJlbC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zaG93U2VyaWVzRGF0YUxhYmVsKCk7XG4gICAgICovXG4gICAgc2hvd1Nlcmllc0RhdGFMYWJlbCgpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgndXBkYXRlT3B0aW9ucycsIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHsgc2VyaWVzOiB7IGRhdGFMYWJlbHM6IHsgdmlzaWJsZTogdHJ1ZSB9IH0gfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGNoYXJ0IG9wdGlvbnMgdG8gbmV3IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDaGFydCBvcHRpb25zLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNldE9wdGlvbnMoe1xuICAgICAqICAgY2hhcnQ6IHtcbiAgICAgKiAgICAgd2lkdGg6IDUwMCxcbiAgICAgKiAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICogICAgIHRpdGxlOiAnRW5lcmd5IFVzYWdlJyxcbiAgICAgKiAgIH0sXG4gICAgICogICBzZXJpZXM6IHtcbiAgICAgKiAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgKiAgIH0sXG4gICAgICogICB0b29sdGlwOiB7XG4gICAgICogICAgIGZvcm1hdHRlcjogKHZhbHVlKSA9PiBgJHt2YWx1ZX1rV2hgLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoT3B0aW9uc0V2ZW50KCdpbml0T3B0aW9ucycsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY2hhcnQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENoYXJ0IG9wdGlvbnMuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQudXBkYXRlT3B0aW9ucyh7XG4gICAgICogICBjaGFydDoge1xuICAgICAqICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgKiAgICAgdGl0bGU6ICdFbmVyZ3kgVXNhZ2UnLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHRvb2x0aXA6IHtcbiAgICAgKiAgICAgZm9ybWF0dGVyOiAodmFsdWUpID0+IGAke3ZhbHVlfWtXaGAsXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHVwZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hPcHRpb25zRXZlbnQoJ3VwZGF0ZU9wdGlvbnMnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXJpZXNJbmZvIC0gSW5mb3JtYXRpb24gb2YgdGhlIHNlcmllcyBmb3IgdGhlIHRvb2x0aXAgdG8gYmUgZGlzcGxheWVkLlxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHNlcmllc0luZm8uc2VyaWVzSW5kZXggLSBJbmRleCBvZiBzZXJpZXMuXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gc2VyaWVzSW5mby5hbGlhcyAtIGFsaWFzIG5hbWUuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2hvd1Rvb2x0aXAoe3Nlcmllc0luZGV4OiAxLCBhbGlhczogJ25hbWUnfSk7XG4gICAgICovXG4gICAgc2hvd1Rvb2x0aXAoc2VyaWVzSW5mbykge1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nob3dUb29sdGlwJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZXJpZXNJbmZvKSwgeyBzdGF0ZTogdGhpcy5zdG9yZS5zdGF0ZSB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGUgdG9vbHRpcC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5oaWRlVG9vbHRpcCgpO1xuICAgICAqL1xuICAgIGhpZGVUb29sdGlwKCkge1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ2hpZGVUb29sdGlwJyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IENoYXJ0IGZyb20gXCIuL2NoYXJ0XCI7XG5pbXBvcnQgZGF0YVJhbmdlIGZyb20gXCIuLi9zdG9yZS9kYXRhUmFuZ2VcIjtcbmltcG9ydCBzY2FsZSBmcm9tIFwiLi4vc3RvcmUvc2NhbGVcIjtcbmltcG9ydCByYWRpYWxBeGVzIGZyb20gXCIuLi9zdG9yZS9yYWRpYWxBeGVzXCI7XG5pbXBvcnQgTGVnZW5kIGZyb20gXCIuLi9jb21wb25lbnQvbGVnZW5kXCI7XG5pbXBvcnQgUmFkYXJTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9yYWRhclNlcmllc1wiO1xuaW1wb3J0IFJhZGlhbFBsb3QgZnJvbSBcIi4uL2NvbXBvbmVudC9yYWRpYWxQbG90XCI7XG5pbXBvcnQgVGl0bGUgZnJvbSBcIi4uL2NvbXBvbmVudC90aXRsZVwiO1xuaW1wb3J0IEV4cG9ydE1lbnUgZnJvbSBcIi4uL2NvbXBvbmVudC9leHBvcnRNZW51XCI7XG5pbXBvcnQgU2VsZWN0ZWRTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9zZWxlY3RlZFNlcmllc1wiO1xuaW1wb3J0IEhvdmVyZWRTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9ob3ZlcmVkU2VyaWVzXCI7XG5pbXBvcnQgVG9vbHRpcCBmcm9tIFwiLi4vY29tcG9uZW50L3Rvb2x0aXBcIjtcbmltcG9ydCBSYWRpYWxBeGlzIGZyb20gXCIuLi9jb21wb25lbnQvcmFkaWFsQXhpc1wiO1xuaW1wb3J0IEJhY2tncm91bmQgZnJvbSBcIi4uL2NvbXBvbmVudC9iYWNrZ3JvdW5kXCI7XG5pbXBvcnQgTm9EYXRhVGV4dCBmcm9tIFwiLi4vY29tcG9uZW50L25vRGF0YVRleHRcIjtcbmltcG9ydCAqIGFzIGJhc2ljQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvYmFzaWNcIjtcbmltcG9ydCAqIGFzIGxlZ2VuZEJydXNoIGZyb20gXCIuLi9icnVzaGVzL2xlZ2VuZFwiO1xuaW1wb3J0ICogYXMgbGFiZWxCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9sYWJlbFwiO1xuaW1wb3J0ICogYXMgZXhwb3J0TWVudUJydXNoIGZyb20gXCIuLi9icnVzaGVzL2V4cG9ydE1lbnVcIjtcbmltcG9ydCAqIGFzIHBvbHlnb25CcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9wb2x5Z29uXCI7XG5pbXBvcnQgKiBhcyBheGlzQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvYXhpc1wiO1xuaW1wb3J0ICogYXMgbGluZVNlcmllc0JydXNoIGZyb20gXCIuLi9icnVzaGVzL2xpbmVTZXJpZXNcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIFJhZGFyIENoYXJ0XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gcHJvcHMuZWwgLSBUaGUgdGFyZ2V0IGVsZW1lbnQgdG8gY3JlYXRlIGNoYXJ0LlxuICogICBAcGFyYW0ge09iamVjdH0gcHJvcHMuZGF0YSAtIERhdGEgZm9yIG1ha2luZyBSYWRhciBDaGFydC5cbiAqICAgICBAcGFyYW0ge0FycmF5PHN0cmluZz59IHByb3BzLmRhdGEuY2F0ZWdvcmllcyAtIENhdGVnb3JpZXMuXG4gKiAgICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwcm9wcy5kYXRhLnNlcmllcyAtIFNlcmllcyBkYXRhLlxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IHByb3BzLmRhdGEuc2VyaWVzLm5hbWUgLSBTZXJpZXMgbmFtZS5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcHJvcHMuZGF0YS5zZXJpZXMuZGF0YSAtIFNlcmllcyBkYXRhLlxuICogICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnNdIC0gT3B0aW9ucyBmb3IgbWFraW5nIFJhZGFyIENoYXJ0LlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaGFydF1cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGVdIC0gQ2hhcnQgdGl0bGUgdGV4dCBvciBvcHRpb25zLlxuICogICAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUudGV4dF0gLSBDaGFydCB0aXRsZSB0ZXh0LlxuICogICAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUub2Zmc2V0WF0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSBob3Jpem9udGFsbHkuXG4gKiAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS5vZmZzZXRZXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIHZlcnRpY2FsbHkuXG4gKiAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS5hbGlnbl0gLSBDaGFydCB0ZXh0IGFsaWduLiAnbGVmdCcsICdyaWdodCcsICdjZW50ZXInIGlzIGF2YWlsYWJsZS5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbl0gLSBXaGV0aGVyIHRvIHVzZSBhbmltYXRpb24gYW5kIGR1cmF0aW9uIHdoZW4gcmVuZGVyaW5nIHRoZSBpbml0aWFsIGNoYXJ0LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC53aWR0aF0gLSBDaGFydCB3aWR0aC4gJ2F1dG8nIG9yIGlmIG5vdCB3cml0ZSwgdGhlIHdpZHRoIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLiAnYXV0bycgb3IgaWYgbm90IGNyZWF0ZWQsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQuaGVpZ2h0XSAtIENoYXJ0IGhlaWdodC4gJ2F1dG8nIG9yIGlmIG5vdCB3cml0ZSwgdGhlIHdpZHRoIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLiAnYXV0bycgb3IgaWYgbm90IGNyZWF0ZWQsIHRoZSBoZWlnaHQgb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnNlcmllc11cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLnNlbGVjdGFibGU9ZmFsc2VdIC0gV2hldGhlciB0byBtYWtlIHNlbGVjdGFibGUgc2VyaWVzIG9yIG5vdC5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLnNob3dEb3Q9ZmFsc2VdIC0gV2hldGhlciB0byBzaG93IGRvdCBvciBub3QuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5zaG93QXJlYT1mYWxzZV0gLSBXaGV0aGVyIHRvIGZpbGwgYXJlYSBvciBub3QuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNpcmN1bGFyQXhpc11cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaXJjdWxhckF4aXMudGlja10gLSBPcHRpb24gdG8gYWRqdXN0IHRpY2sgaW50ZXJ2YWwuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2lyY3VsYXJBeGlzLmxhYmVsXSAtIE9wdGlvbiB0byBhZGp1c3QgbGFiZWwgaW50ZXJ2YWwuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnZlcnRpY2FsQXhpc11cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy52ZXJ0aWNhbEF4aXMudGlja10gLSBPcHRpb24gdG8gYWRqdXN0IHRpY2sgaW50ZXJ2YWwuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudmVydGljYWxBeGlzLmxhYmVsXSAtIE9wdGlvbiB0byBhZGp1c3QgbGFiZWwgaW50ZXJ2YWwuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudmVydGljYWxBeGlzLnNjYWxlXSAtIE9wdGlvbiB0byBhZGp1c3QgYXhpcyBtaW5pbXVtLCBtYXhpbXVtLCBzdGVwIHNpemUuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnBsb3RdXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMucGxvdC53aWR0aF0gLSBXaWR0aCBvZiBwbG90LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnBsb3QuaGVpZ2h0XSAtIEhlaWdodCBvZiBwbG90LlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5wbG90LnR5cGVdIC0gUmFkYXIgcGxvdCB0eXBlLiAnc3BpZGVyd2ViJywgJ2NpcmNsZScgaXMgYXZhaWxhYmxlLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sZWdlbmRdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMubGVnZW5kLmFsaWduXSAtIExlZ2VuZCBhbGlnbi4gJ3RvcCcsICdib3R0b20nLCAncmlnaHQnLCAnbGVmdCcgaXMgYXZhaWxhYmxlLlxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC5zaG93Q2hlY2tib3hdIC0gV2hldGhlciB0byBzaG93IGNoZWNrYm94LlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5sZWdlbmQudmlzaWJsZV0gLSBXaGV0aGVyIHRvIHNob3cgbGVnZW5kLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC53aWR0aF0gLSBXaWR0aCBvZiBsZWdlbmQuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGVnZW5kLml0ZW1dIC0gYHdpZHRoYCBhbmQgYG92ZXJmbG93YCBvcHRpb25zIG9mIHRoZSBsZWdlbmQgaXRlbS4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fExlZ2VuZCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5leHBvcnRNZW51XVxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5leHBvcnRNZW51LnZpc2libGVdIC0gV2hldGhlciB0byBzaG93IGV4cG9ydCBtZW51LlxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnUuZmlsZW5hbWVdIC0gRmlsZSBuYW1lIGFwcGxpZWQgd2hlbiBkb3dubG9hZGluZy5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcF1cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy50b29sdGlwLm9mZnNldFhdIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgaG9yaXpvbnRhbGx5LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAub2Zmc2V0WV0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSB2ZXJ0aWNhbGx5LlxuICogICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC5mb3JtYXR0ZXJdIC0gRnVuY3Rpb24gdG8gZm9ybWF0IGRhdGEgdmFsdWUuXG4gKiAgICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcHMub3B0aW9ucy50b29sdGlwLnRlbXBsYXRlXSAtIEZ1bmN0aW9uIHRvIGNyZWF0ZSBjdXN0b20gdGVtcGxhdGUuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxUb29sdGlwIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnJlc3BvbnNpdmVdIC0gUnVsZXMgZm9yIGNoYW5naW5nIGNoYXJ0IG9wdGlvbnMuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxSZXNwb25zaXZlIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5yZXNwb25zaXZlLmFuaW1hdGlvbl0gLSBBbmltYXRpb24gZHVyYXRpb24gd2hlbiB0aGUgY2hhcnQgaXMgbW9kaWZpZWQuXG4gKiAgICAgICBAcGFyYW0ge0FycmF5PE9iamVjdD59IFtwcm9wcy5vcHRpb25zLnJlc3BvbnNpdmUucnVsZXNdIC0gUnVsZXMgZm9yIHRoZSBDaGFydCB0byBSZXNwb25kLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sYW5nXSAtIE9wdGlvbnMgZm9yIGNoYW5naW5nIHRoZSB0ZXh0IGRpc3BsYXllZCBvbiB0aGUgY2hhcnQgb3IgaTE4biBsYW5ndWFnZXMuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGFuZy5ub0RhdGFdIC0gTm8gRGF0YSBMYXllciBUZXh0LlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZV0gLSBDaGFydCB0aGVtZSBvcHRpb25zLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8UmFkYXIgQ2hhcnQgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5jaGFydF0gLSBDaGFydCBmb250IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLm5vRGF0YV0gLSBObyBEYXRhIExheWVyIFRleHQgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUuc2VyaWVzXSAtIFNlcmllcyB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS50aXRsZV0gLSBUaXRsZSB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5jaXJjdWxhckF4aXNdIC0gQ2lyY3VsYXIgQXhpcyB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS52ZXJ0aWNhbEF4aXNdIC0gVmVydGljYWwgQXhpcyB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5sZWdlbmRdIC0gTGVnZW5kIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnRvb2x0aXBdIC0gVG9vbHRpcCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5wbG90XSAtIFBsb3QgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUuZXhwb3J0TWVudV0gLSBFeHBvcnRNZW51IHRoZW1lLlxuICogQGV4dGVuZHMgQ2hhcnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkYXJDaGFydCBleHRlbmRzIENoYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcih7IGVsLCBvcHRpb25zLCBkYXRhIH0pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgc2VyaWVzOiB7XG4gICAgICAgICAgICAgICAgcmFkYXI6IGRhdGEuc2VyaWVzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhdGVnb3JpZXM6IGRhdGEuY2F0ZWdvcmllcyxcbiAgICAgICAgICAgIG1vZHVsZXM6IFtkYXRhUmFuZ2UsIHNjYWxlLCByYWRpYWxBeGVzXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChCYWNrZ3JvdW5kKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChUaXRsZSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoTGVnZW5kKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChSYWRpYWxQbG90KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChSYWRpYWxBeGlzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChSYWRhclNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoRXhwb3J0TWVudSwgeyBjaGFydEVsOiB0aGlzLmVsIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEhvdmVyZWRTZXJpZXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFNlbGVjdGVkU2VyaWVzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChUb29sdGlwLCB7IGNoYXJ0RWw6IHRoaXMuZWwgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoTm9EYXRhVGV4dCk7XG4gICAgICAgIHRoaXMucGFpbnRlci5hZGRHcm91cHMoW1xuICAgICAgICAgICAgYmFzaWNCcnVzaCxcbiAgICAgICAgICAgIGxlZ2VuZEJydXNoLFxuICAgICAgICAgICAgbGFiZWxCcnVzaCxcbiAgICAgICAgICAgIGV4cG9ydE1lbnVCcnVzaCxcbiAgICAgICAgICAgIHBvbHlnb25CcnVzaCxcbiAgICAgICAgICAgIGF4aXNCcnVzaCxcbiAgICAgICAgICAgIGxpbmVTZXJpZXNCcnVzaCxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZGF0YSAtIEFycmF5IG9mIGRhdGEgdG8gYmUgYWRkZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNhdGVnb3J5IC0gQ2F0ZWdvcnkgdG8gYmUgYWRkZWQuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuYWRkRGF0YShbMTAsIDIwXSwgJzYnKTtcbiAgICAgKi9cbiAgICBhZGREYXRhKGRhdGEsIGNhdGVnb3J5KSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQ29udHJvbEZsYWcudXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2FkZERhdGEnLCB7IGRhdGEsIGNhdGVnb3J5IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSBkYXRhLm5hbWUgLSBTZXJpZXMgbmFtZS5cbiAgICAgKiAgIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZGF0YS5kYXRhIC0gQXJyYXkgb2YgZGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5hZGRTZXJpZXMoe1xuICAgICAqICAgbmFtZTogJ25ld1NlcmllcycsXG4gICAgICogICBkYXRhOiBbMTAsIDEwMCwgNTAsIDQwLCA3MCwgNTUsIDMzLCA3MCwgOTAsIDExMF0sXG4gICAgICogfSk7XG4gICAgICovXG4gICAgYWRkU2VyaWVzKGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdhZGRTZXJpZXMnLCB7IGRhdGEgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGNoYXJ0IGRhdGEgdG8gbmV3IGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBEYXRhIHRvIGJlIHNldC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zZXREYXRhKHtcbiAgICAgKiAgIGNhdGVnb3JpZXM6IFsnMScsICcyJywgJzMnXSxcbiAgICAgKiAgIHNlcmllczogW1xuICAgICAqICAgICB7XG4gICAgICogICAgICAgbmFtZTogJ25ldyBzZXJpZXMnLFxuICAgICAqICAgICAgIGRhdGE6IFsxLCAyLCAzXSxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgIG5hbWU6ICduZXcgc2VyaWVzMicsXG4gICAgICogICAgICAgZGF0YTogWzQsIDUsIDZdLFxuICAgICAqICAgICB9XG4gICAgICogICBdXG4gICAgICogfSk7XG4gICAgICovXG4gICAgc2V0RGF0YShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgY2F0ZWdvcmllcywgc2VyaWVzIH0gPSBkYXRhO1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3NldERhdGEnLCB7IHNlcmllczogeyByYWRhcjogc2VyaWVzIH0sIGNhdGVnb3JpZXMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGNoYXJ0IG9wdGlvbnMgdG8gbmV3IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDaGFydCBvcHRpb25zLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNldE9wdGlvbnMoe1xuICAgICAqICAgY2hhcnQ6IHtcbiAgICAgKiAgICAgd2lkdGg6IDUwMCxcbiAgICAgKiAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICogICAgIHRpdGxlOiAnRW5lcmd5IFVzYWdlJyxcbiAgICAgKiAgIH0sXG4gICAgICogICBzZXJpZXM6IHtcbiAgICAgKiAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgKiAgIH0sXG4gICAgICogICB0b29sdGlwOiB7XG4gICAgICogICAgIGZvcm1hdHRlcjogKHZhbHVlKSA9PiBgJHt2YWx1ZX1rV2hgLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE9wdGlvbnNFdmVudCgnaW5pdE9wdGlvbnMnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNoYXJ0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDaGFydCBvcHRpb25zLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnVwZGF0ZU9wdGlvbnMoe1xuICAgICAqICAgY2hhcnQ6IHtcbiAgICAgKiAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICogICAgIHRpdGxlOiAnRW5lcmd5IFVzYWdlJyxcbiAgICAgKiAgIH0sXG4gICAgICogICB0b29sdGlwOiB7XG4gICAgICogICAgIGZvcm1hdHRlcjogKHZhbHVlKSA9PiBgJHt2YWx1ZX1rV2hgLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB1cGRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoT3B0aW9uc0V2ZW50KCd1cGRhdGVPcHRpb25zJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VyaWVzSW5mbyAtIEluZm9ybWF0aW9uIG9mIHRoZSBzZXJpZXMgZm9yIHRoZSB0b29sdGlwIHRvIGJlIGRpc3BsYXllZC5cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBzZXJpZXNJbmZvLnNlcmllc0luZGV4IC0gSW5kZXggb2Ygc2VyaWVzLlxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHNlcmllc0luZm8uaW5kZXggLSBJbmRleCBvZiBkYXRhIHdpdGhpbiBzZXJpZXMuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2hvd1Rvb2x0aXAoe2luZGV4OiAxLCBzZXJpZXNJbmRleDogMn0pO1xuICAgICAqL1xuICAgIHNob3dUb29sdGlwKHNlcmllc0luZm8pIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzaG93VG9vbHRpcCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VyaWVzSW5mbyksIHsgc3RhdGU6IHRoaXMuc3RvcmUuc3RhdGUgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlIHRvb2x0aXAuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuaGlkZVRvb2x0aXAoKTtcbiAgICAgKi9cbiAgICBoaWRlVG9vbHRpcCgpIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdoaWRlVG9vbHRpcCcpO1xuICAgIH1cbn1cbiIsImltcG9ydCBDaGFydCBmcm9tIFwiLi9jaGFydFwiO1xuaW1wb3J0IGRhdGFSYW5nZSBmcm9tIFwiLi4vc3RvcmUvZGF0YVJhbmdlXCI7XG5pbXBvcnQgc3RhY2tTZXJpZXNEYXRhIGZyb20gXCIuLi9zdG9yZS9zdGFja1Nlcmllc0RhdGFcIjtcbmltcG9ydCBzY2FsZSBmcm9tIFwiLi4vc3RvcmUvc2NhbGVcIjtcbmltcG9ydCByYWRpYWxBeGVzIGZyb20gXCIuLi9zdG9yZS9yYWRpYWxBeGVzXCI7XG5pbXBvcnQgVG9vbHRpcCBmcm9tIFwiLi4vY29tcG9uZW50L3Rvb2x0aXBcIjtcbmltcG9ydCBMZWdlbmQgZnJvbSBcIi4uL2NvbXBvbmVudC9sZWdlbmRcIjtcbmltcG9ydCBSYWRpYWxCYXJTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9yYWRpYWxCYXJTZXJpZXNcIjtcbmltcG9ydCBUaXRsZSBmcm9tIFwiLi4vY29tcG9uZW50L3RpdGxlXCI7XG5pbXBvcnQgRXhwb3J0TWVudSBmcm9tIFwiLi4vY29tcG9uZW50L2V4cG9ydE1lbnVcIjtcbmltcG9ydCBIb3ZlcmVkU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvaG92ZXJlZFNlcmllc1wiO1xuaW1wb3J0IERhdGFMYWJlbHMgZnJvbSBcIi4uL2NvbXBvbmVudC9kYXRhTGFiZWxzXCI7XG5pbXBvcnQgU2VsZWN0ZWRTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9zZWxlY3RlZFNlcmllc1wiO1xuaW1wb3J0IEJhY2tncm91bmQgZnJvbSBcIi4uL2NvbXBvbmVudC9iYWNrZ3JvdW5kXCI7XG5pbXBvcnQgUmFkaWFsUGxvdCBmcm9tIFwiLi4vY29tcG9uZW50L3JhZGlhbFBsb3RcIjtcbmltcG9ydCBSYWRpYWxBeGlzIGZyb20gXCIuLi9jb21wb25lbnQvcmFkaWFsQXhpc1wiO1xuaW1wb3J0IE5vRGF0YVRleHQgZnJvbSBcIi4uL2NvbXBvbmVudC9ub0RhdGFUZXh0XCI7XG5pbXBvcnQgKiBhcyBiYXNpY0JydXNoIGZyb20gXCIuLi9icnVzaGVzL2Jhc2ljXCI7XG5pbXBvcnQgKiBhcyBsZWdlbmRCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9sZWdlbmRcIjtcbmltcG9ydCAqIGFzIGxhYmVsQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvbGFiZWxcIjtcbmltcG9ydCAqIGFzIGV4cG9ydE1lbnVCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9leHBvcnRNZW51XCI7XG5pbXBvcnQgKiBhcyBzZWN0b3JCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9zZWN0b3JcIjtcbmltcG9ydCAqIGFzIGRhdGFMYWJlbEJydXNoIGZyb20gXCIuLi9icnVzaGVzL2RhdGFMYWJlbFwiO1xuaW1wb3J0ICogYXMgYXhpc0JydXNoIGZyb20gXCIuLi9icnVzaGVzL2F4aXNcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIFJhZGlhbEJhciBDaGFydFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHByb3BzLmVsIC0gVGhlIHRhcmdldCBlbGVtZW50IHRvIGNyZWF0ZSBjaGFydC5cbiAqICAgQHBhcmFtIHtPYmplY3R9IHByb3BzLmRhdGEgLSBEYXRhIGZvciBtYWtpbmcgUmFkaWFsQmFyIENoYXJ0LlxuICogICAgIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3Byb3BzLmRhdGEuY2F0ZWdvcmllc10gLSBDYXRlZ29yaWVzLlxuICogICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcHJvcHMuZGF0YS5zZXJpZXMgLSBTZXJpZXMgZGF0YS5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy5kYXRhLnNlcmllcy5uYW1lIC0gU2VyaWVzIG5hbWUuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gcHJvcHMuZGF0YS5zZXJpZXMuZGF0YSAtIFNlcmllcyBkYXRhLlxuICogICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnNdIC0gT3B0aW9ucyBmb3IgbWFraW5nIFJhZGlhbEJhciBDaGFydC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2hhcnRdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlXSAtIENoYXJ0IHRpdGxlIHRleHQgb3Igb3B0aW9ucy5cbiAqICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLnRleHRdIC0gQ2hhcnQgdGl0bGUgdGV4dC5cbiAqICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLm9mZnNldFhdIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgaG9yaXpvbnRhbGx5LlxuICogICAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUub2Zmc2V0WV0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSB2ZXJ0aWNhbGx5LlxuICogICAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUuYWxpZ25dIC0gQ2hhcnQgdGV4dCBhbGlnbi4gJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJyBpcyBhdmFpbGFibGUuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaGFydC5hbmltYXRpb25dIC0gV2hldGhlciB0byB1c2UgYW5pbWF0aW9uIGFuZCBkdXJhdGlvbiB3aGVuIHJlbmRlcmluZyB0aGUgaW5pdGlhbCBjaGFydC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQud2lkdGhdIC0gQ2hhcnQgd2lkdGguICdhdXRvJyBvciBpZiBub3Qgd3JpdGUsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC4gJ2F1dG8nIG9yIGlmIG5vdCBjcmVhdGVkLCB0aGUgd2lkdGggb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LmhlaWdodF0gLSBDaGFydCBoZWlnaHQuICdhdXRvJyBvciBpZiBub3Qgd3JpdGUsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC4gJ2F1dG8nIG9yIGlmIG5vdCBjcmVhdGVkLCB0aGUgaGVpZ2h0IG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5zZXJpZXNdXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5zZWxlY3RhYmxlPWZhbHNlXSAtIFdoZXRoZXIgdG8gbWFrZSBzZWxlY3RhYmxlIHNlcmllcyBvciBub3QuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLmV2ZW50RGV0ZWN0VHlwZV0gLSBFdmVudCBkZXRlY3QgdHlwZS4gJ2dyb3VwZWQnLCAncG9pbnQnIGlzIGF2YWlsYWJsZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5zZXJpZXMuZGF0YUxhYmVsc10gLSBTZXQgdGhlIHZpc2liaWxpdHksIGxvY2F0aW9uLCBhbmQgZm9ybWF0dGluZyBvZiBkYXRhTGFiZWwuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxEYXRhTGFiZWxzIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgICBAcGFyYW0ge0FycmF5PG51bWJlcj58QXJyYXk8c3RyaW5nPn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLnJhZGl1c1JhbmdlXSAtIFNwZWNpZmllcyB0aGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUgZHJhd24uIEl0IGlzIHNwZWNpZmllZCBieSBlbnRlcmluZyBhIG51bWJlciBvciBwZXJjZW50IHN0cmluZyB2YWx1ZSBpbiBzdGFydCBhbmQgZW5kLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbcHJvcHMub3B0aW9ucy5zZXJpZXMuYW5nbGVSYW5nZV0gLSBUaGUgcmFuZ2Ugb2YgYW5nbGVzIHRvIHdoaWNoIHRoZSBjaXJjbGUgd2lsbCBiZSBkcmF3bi4gSXQgaXMgc3BlY2lmaWVkIGJ5IHB1dHRpbmcgbnVtYmVyIGluIHN0YXJ0IGFuZCBlbmQuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5jbG9ja3dpc2VdIC0gV2hldGhlciBpdCB3aWxsIGJlIGRyYXduIGNsb2Nrd2lzZS5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2lyY3VsYXJBeGlzXVxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNpcmN1bGFyQXhpcy50aWNrXSAtIE9wdGlvbiB0byBhZGp1c3QgdGljayBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaXJjdWxhckF4aXMubGFiZWxdIC0gT3B0aW9uIHRvIGFkanVzdCBsYWJlbCBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaXJjdWxhckF4aXMuc2NhbGVdIC0gT3B0aW9uIHRvIGFkanVzdCBheGlzIG1pbmltdW0sIG1heGltdW0sIHN0ZXAgc2l6ZS5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudmVydGljYWxBeGlzXVxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnZlcnRpY2FsQXhpcy50aWNrXSAtIE9wdGlvbiB0byBhZGp1c3QgdGljayBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy52ZXJ0aWNhbEF4aXMubGFiZWxdIC0gT3B0aW9uIHRvIGFkanVzdCBsYWJlbCBpbnRlcnZhbC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGVnZW5kXVxuICogICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC5hbGlnbl0gLSBMZWdlbmQgYWxpZ24uICd0b3AnLCAnYm90dG9tJywgJ3JpZ2h0JywgJ2xlZnQnIGlzIGF2YWlsYWJsZS5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5sZWdlbmQuc2hvd0NoZWNrYm94XSAtIFdoZXRoZXIgdG8gc2hvdyBjaGVja2JveC5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMubGVnZW5kLnZpc2libGVdIC0gV2hldGhlciB0byBzaG93IGxlZ2VuZC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5sZWdlbmQud2lkdGhdIC0gV2lkdGggb2YgbGVnZW5kLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC5pdGVtXSAtIGB3aWR0aGAgYW5kIGBvdmVyZmxvd2Agb3B0aW9ucyBvZiB0aGUgbGVnZW5kIGl0ZW0uIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxMZWdlbmQgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuZXhwb3J0TWVudV1cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuZXhwb3J0TWVudS52aXNpYmxlXSAtIFdoZXRoZXIgdG8gc2hvdyBleHBvcnQgbWVudS5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5leHBvcnRNZW51LmZpbGVuYW1lXSAtIEZpbGUgbmFtZSBhcHBsaWVkIHdoZW4gZG93bmxvYWRpbmcuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRvb2x0aXBdXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC5vZmZzZXRYXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIGhvcml6b250YWxseS5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy50b29sdGlwLm9mZnNldFldIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgdmVydGljYWxseS5cbiAqICAgICAgIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAuZm9ybWF0dGVyXSAtIEZ1bmN0aW9uIHRvIGZvcm1hdCBkYXRhIHZhbHVlLlxuICogICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC50ZW1wbGF0ZV0gLSBGdW5jdGlvbiB0byBjcmVhdGUgY3VzdG9tIHRlbXBsYXRlLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8VG9vbHRpcCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5yZXNwb25zaXZlXSAtIFJ1bGVzIGZvciBjaGFuZ2luZyBjaGFydCBvcHRpb25zLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8UmVzcG9uc2l2ZSBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufE9iamVjdH0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZS5hbmltYXRpb25dIC0gQW5pbWF0aW9uIGR1cmF0aW9uIHdoZW4gdGhlIGNoYXJ0IGlzIG1vZGlmaWVkLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBbcHJvcHMub3B0aW9ucy5yZXNwb25zaXZlLnJ1bGVzXSAtIFJ1bGVzIGZvciB0aGUgQ2hhcnQgdG8gUmVzcG9uZC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMubGFuZ10gLSBPcHRpb25zIGZvciBjaGFuZ2luZyB0aGUgdGV4dCBkaXNwbGF5ZWQgb24gdGhlIGNoYXJ0IG9yIGkxOG4gbGFuZ3VhZ2VzLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxhbmcubm9EYXRhXSAtIE5vIERhdGEgTGF5ZXIgVGV4dC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWVdIC0gQ2hhcnQgdGhlbWUgb3B0aW9ucy4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFJhZGlhbEJhciBDaGFydCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmNoYXJ0XSAtIENoYXJ0IGZvbnQgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUubm9EYXRhXSAtIE5vIERhdGEgTGF5ZXIgVGV4dCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5zZXJpZXNdIC0gU2VyaWVzIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnRpdGxlXSAtIFRpdGxlIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmNpcmN1bGFyQXhpc10gLSBDaXJjdWxhciBBeGlzIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnZlcnRpY2FsQXhpc10gLSBWZXJ0aWNhbCBBeGlzIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmxlZ2VuZF0gLSBMZWdlbmQgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUudG9vbHRpcF0gLSBUb29sdGlwIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmV4cG9ydE1lbnVdIC0gRXhwb3J0TWVudSB0aGVtZS5cbiAqIEBleHRlbmRzIENoYXJ0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhZGlhbEJhckNoYXJ0IGV4dGVuZHMgQ2hhcnQge1xuICAgIGNvbnN0cnVjdG9yKHsgZWwsIG9wdGlvbnMsIGRhdGEgfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBlbCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBzZXJpZXM6IHtcbiAgICAgICAgICAgICAgICByYWRpYWxCYXI6IGRhdGEuc2VyaWVzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhdGVnb3JpZXM6IGRhdGEuY2F0ZWdvcmllcyxcbiAgICAgICAgICAgIG1vZHVsZXM6IFtzdGFja1Nlcmllc0RhdGEsIGRhdGFSYW5nZSwgc2NhbGUsIHJhZGlhbEF4ZXNdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEJhY2tncm91bmQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFRpdGxlKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChMZWdlbmQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFJhZGlhbFBsb3QpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFJhZGlhbEJhclNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoSG92ZXJlZFNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoU2VsZWN0ZWRTZXJpZXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKERhdGFMYWJlbHMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFJhZGlhbEF4aXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEV4cG9ydE1lbnUsIHsgY2hhcnRFbDogdGhpcy5lbCB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChUb29sdGlwLCB7IGNoYXJ0RWw6IHRoaXMuZWwgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoTm9EYXRhVGV4dCk7XG4gICAgICAgIHRoaXMucGFpbnRlci5hZGRHcm91cHMoW1xuICAgICAgICAgICAgYmFzaWNCcnVzaCxcbiAgICAgICAgICAgIGxlZ2VuZEJydXNoLFxuICAgICAgICAgICAgbGFiZWxCcnVzaCxcbiAgICAgICAgICAgIGV4cG9ydE1lbnVCcnVzaCxcbiAgICAgICAgICAgIHNlY3RvckJydXNoLFxuICAgICAgICAgICAgZGF0YUxhYmVsQnJ1c2gsXG4gICAgICAgICAgICBheGlzQnJ1c2gsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSBkYXRhLm5hbWUgLSBTZXJpZXMgbmFtZS5cbiAgICAgKiAgIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZGF0YS5kYXRhIC0gQXJyYXkgb2YgZGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5hZGRTZXJpZXMoe1xuICAgICAqICAgbmFtZTogJ25ld1NlcmllcycsXG4gICAgICogICBkYXRhOiBbMTAsIDIwLCAzMCwgNDBdLFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGFkZFNlcmllcyhkYXRhKSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgnYWRkU2VyaWVzJywgeyBkYXRhIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBjaGFydCBkYXRhIHRvIG5ldyBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBiZSBzZXQuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2V0RGF0YSh7XG4gICAgICogICBjYXRlZ29yaWVzOiBbJzEnLCAnMicsICczJ10sXG4gICAgICogICBzZXJpZXM6IFtcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgIG5hbWU6ICduZXcgc2VyaWVzJyxcbiAgICAgKiAgICAgICBkYXRhOiBbMSwgMiwgM10sXG4gICAgICogICAgIH0sXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICBuYW1lOiAnbmV3IHNlcmllczInLFxuICAgICAqICAgICAgIGRhdGE6IFs0LCA1LCA2XSxcbiAgICAgKiAgICAgfVxuICAgICAqICAgXVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHNldERhdGEoZGF0YSkge1xuICAgICAgICBjb25zdCB7IGNhdGVnb3JpZXMsIHNlcmllcyB9ID0gZGF0YTtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdzZXREYXRhJywgeyBzZXJpZXM6IHsgcmFkaWFsQmFyOiBzZXJpZXMgfSwgY2F0ZWdvcmllcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZSBzZXJpZXMgZGF0YSBsYWJlbC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5oaWRlU2VyaWVzRGF0YUxhYmVsKCk7XG4gICAgICovXG4gICAgaGlkZVNlcmllc0RhdGFMYWJlbCgpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgndXBkYXRlT3B0aW9ucycsIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHsgc2VyaWVzOiB7IGRhdGFMYWJlbHM6IHsgdmlzaWJsZTogZmFsc2UgfSB9IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHNlcmllcyBkYXRhIGxhYmVsLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNob3dTZXJpZXNEYXRhTGFiZWwoKTtcbiAgICAgKi9cbiAgICBzaG93U2VyaWVzRGF0YUxhYmVsKCkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCd1cGRhdGVPcHRpb25zJywge1xuICAgICAgICAgICAgb3B0aW9uczogeyBzZXJpZXM6IHsgZGF0YUxhYmVsczogeyB2aXNpYmxlOiB0cnVlIH0gfSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgY2hhcnQgb3B0aW9ucyB0byBuZXcgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENoYXJ0IG9wdGlvbnMuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2V0T3B0aW9ucyh7XG4gICAgICogICBjaGFydDoge1xuICAgICAqICAgICB3aWR0aDogNTAwLFxuICAgICAqICAgICBoZWlnaHQ6IDUwMCxcbiAgICAgKiAgICAgdGl0bGU6ICdPbHltcGljIE1lZGFscycsXG4gICAgICogICB9LFxuICAgICAqICAgc2VyaWVzOiB7XG4gICAgICogICAgIHNlbGVjdGFibGU6IHRydWVcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoT3B0aW9uc0V2ZW50KCdpbml0T3B0aW9ucycsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY2hhcnQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENoYXJ0IG9wdGlvbnMuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQudXBkYXRlT3B0aW9ucyh7XG4gICAgICogICBjaGFydDoge1xuICAgICAqICAgICB0aXRsZTogJ09seW1waWMgTWVkYWxzJyxcbiAgICAgKiAgIH0sXG4gICAgICogICBzZXJpZXM6IHtcbiAgICAgKiAgICAgZXZlbnREZXRlY3RUeXBlOiAnZ3JvdXBlZCdcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB1cGRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoT3B0aW9uc0V2ZW50KCd1cGRhdGVPcHRpb25zJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VyaWVzSW5mbyAtIEluZm9ybWF0aW9uIG9mIHRoZSBzZXJpZXMgZm9yIHRoZSB0b29sdGlwIHRvIGJlIGRpc3BsYXllZC5cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBzZXJpZXNJbmZvLmluZGV4IC0gSW5kZXggb2YgZGF0YSB3aXRoaW4gc2VyaWVzLiBJZiAnc2VyaWVzLmV2ZW50RGV0ZWN0VHlwZScgaXMgXCJncm91cGVkXCIsIG9ubHkgaW5kZXggaXMgbmVlZGVkLlxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IFtzZXJpZXNJbmZvLnNlcmllc0luZGV4XSAtIEluZGV4IG9mIHNlcmllc1xuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGV2ZW50RGV0ZWN0VHlwZSBpcyAnZ3JvdXBlZCdcbiAgICAgKiBjaGFydC5zaG93VG9vbHRpcCh7aW5kZXg6IDF9KTtcbiAgICAgKlxuICAgICAqIC8vIGV2ZW50RGV0ZWN0VHlwZSBpcyAncG9pbnQnXG4gICAgICogY2hhcnQuc2hvd1Rvb2x0aXAoe2luZGV4OiAxLCBzZXJpZXNJbmRleDogMn0pO1xuICAgICAqL1xuICAgIHNob3dUb29sdGlwKHNlcmllc0luZm8pIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzaG93VG9vbHRpcCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VyaWVzSW5mbyksIHsgc3RhdGU6IHRoaXMuc3RvcmUuc3RhdGUgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlIHRvb2x0aXAuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuaGlkZVRvb2x0aXAoKTtcbiAgICAgKi9cbiAgICBoaWRlVG9vbHRpcCgpIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdoaWRlVG9vbHRpcCcpO1xuICAgIH1cbn1cbiIsImltcG9ydCBDaGFydCBmcm9tIFwiLi9jaGFydFwiO1xuaW1wb3J0IGRhdGFSYW5nZSBmcm9tIFwiLi4vc3RvcmUvZGF0YVJhbmdlXCI7XG5pbXBvcnQgc2NhbGUgZnJvbSBcIi4uL3N0b3JlL3NjYWxlXCI7XG5pbXBvcnQgYXhlcyBmcm9tIFwiLi4vc3RvcmUvYXhlc1wiO1xuaW1wb3J0IHBsb3QgZnJvbSBcIi4uL3N0b3JlL3Bsb3RcIjtcbmltcG9ydCBUb29sdGlwIGZyb20gXCIuLi9jb21wb25lbnQvdG9vbHRpcFwiO1xuaW1wb3J0IFBsb3QgZnJvbSBcIi4uL2NvbXBvbmVudC9wbG90XCI7XG5pbXBvcnQgU2NhdHRlclNlcmllcyBmcm9tIFwiLi4vY29tcG9uZW50L3NjYXR0ZXJTZXJpZXNcIjtcbmltcG9ydCBBeGlzIGZyb20gXCIuLi9jb21wb25lbnQvYXhpc1wiO1xuaW1wb3J0IExlZ2VuZCBmcm9tIFwiLi4vY29tcG9uZW50L2xlZ2VuZFwiO1xuaW1wb3J0IFRpdGxlIGZyb20gXCIuLi9jb21wb25lbnQvdGl0bGVcIjtcbmltcG9ydCBBeGlzVGl0bGUgZnJvbSBcIi4uL2NvbXBvbmVudC9heGlzVGl0bGVcIjtcbmltcG9ydCBFeHBvcnRNZW51IGZyb20gXCIuLi9jb21wb25lbnQvZXhwb3J0TWVudVwiO1xuaW1wb3J0IEhvdmVyZWRTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9ob3ZlcmVkU2VyaWVzXCI7XG5pbXBvcnQgU2VsZWN0ZWRTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9zZWxlY3RlZFNlcmllc1wiO1xuaW1wb3J0IEJhY2tncm91bmQgZnJvbSBcIi4uL2NvbXBvbmVudC9iYWNrZ3JvdW5kXCI7XG5pbXBvcnQgTm9EYXRhVGV4dCBmcm9tIFwiLi4vY29tcG9uZW50L25vRGF0YVRleHRcIjtcbmltcG9ydCAqIGFzIGJhc2ljQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvYmFzaWNcIjtcbmltcG9ydCAqIGFzIGF4aXNCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9heGlzXCI7XG5pbXBvcnQgKiBhcyBsZWdlbmRCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9sZWdlbmRcIjtcbmltcG9ydCAqIGFzIGxhYmVsQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvbGFiZWxcIjtcbmltcG9ydCAqIGFzIGV4cG9ydE1lbnVCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9leHBvcnRNZW51XCI7XG5pbXBvcnQgKiBhcyBzY2F0dGVyU2VyaWVzQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvc2NhdHRlclNlcmllc1wiO1xuaW1wb3J0IHsgaXNOdWxsIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmltcG9ydCB7IGdldENvb3JkaW5hdGVYVmFsdWUsIGdldENvb3JkaW5hdGVZVmFsdWUgfSBmcm9tIFwiLi4vaGVscGVycy9jb29yZGluYXRlXCI7XG5mdW5jdGlvbiBjbGVhclVubmVjZXNzYXJ5RGF0YShzY2F0dGVyU2VyaWVzKSB7XG4gICAgcmV0dXJuIHNjYXR0ZXJTZXJpZXMubWFwKChzZXJpZXMpID0+IHtcbiAgICAgICAgY29uc3QgZXhpc3QgPSB7fTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VyaWVzKSwgeyBkYXRhOiBzZXJpZXMuZGF0YVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGRhdHVtKSA9PiAhaXNOdWxsKGRhdHVtKSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhY2MsIGN1cikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBnZXRDb29yZGluYXRlWFZhbHVlKGN1cik7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IGdldENvb3JkaW5hdGVZVmFsdWUoY3VyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgJHt4fS0ke3l9YDtcbiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0W2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3Rba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbLi4uYWNjLCBjdXJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwgW10pIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBAY2xhc3NcbiAqIEBjbGFzc2Rlc2MgU2NhdHRlciBDaGFydFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHByb3BzLmVsIC0gVGhlIHRhcmdldCBlbGVtZW50IHRvIGNyZWF0ZSBjaGFydC5cbiAqICAgQHBhcmFtIHtPYmplY3R9IHByb3BzLmRhdGEgLSBEYXRhIGZvciBtYWtpbmcgU2NhdHRlciBDaGFydC5cbiAqICAgICBAcGFyYW0ge0FycmF5PE9iamVjdD59IHByb3BzLmRhdGEuc2VyaWVzIC0gU2VyaWVzIGRhdGEuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gcHJvcHMuZGF0YS5zZXJpZXMubmFtZSAtIFNlcmllcyBuYW1lLlxuICogICAgICAgQHBhcmFtIHtBcnJheTxPYmplY3R8QXJyYXk8bnVtYmVyPj59IHByb3BzLmRhdGEuc2VyaWVzLmRhdGEgLSBTZXJpZXMgZGF0YS5cbiAqICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zXSAtIE9wdGlvbnMgZm9yIG1ha2luZyBTY2F0dGVyIENoYXJ0LlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaGFydF1cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGVdIC0gQ2hhcnQgdGl0bGUgdGV4dCBvciBvcHRpb25zLlxuICogICAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUudGV4dF0gLSBDaGFydCB0aXRsZSB0ZXh0LlxuICogICAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUub2Zmc2V0WF0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSBob3Jpem9udGFsbHkuXG4gKiAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS5vZmZzZXRZXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIHZlcnRpY2FsbHkuXG4gKiAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC50aXRsZS5hbGlnbl0gLSBDaGFydCB0ZXh0IGFsaWduLiAnbGVmdCcsICdyaWdodCcsICdjZW50ZXInIGlzIGF2YWlsYWJsZS5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbl0gLSBXaGV0aGVyIHRvIHVzZSBhbmltYXRpb24gYW5kIGR1cmF0aW9uIHdoZW4gcmVuZGVyaW5nIHRoZSBpbml0aWFsIGNoYXJ0LlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5jaGFydC53aWR0aF0gLSBDaGFydCB3aWR0aC4gJ2F1dG8nIG9yIGlmIG5vdCB3cml0ZSwgdGhlIHdpZHRoIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLiAnYXV0bycgb3IgaWYgbm90IGNyZWF0ZWQsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQuaGVpZ2h0XSAtIENoYXJ0IGhlaWdodC4gJ2F1dG8nIG9yIGlmIG5vdCB3cml0ZSwgdGhlIHdpZHRoIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLiAnYXV0bycgb3IgaWYgbm90IGNyZWF0ZWQsIHRoZSBoZWlnaHQgb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnNlcmllc11cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLnNlbGVjdGFibGU9ZmFsc2VdIC0gV2hldGhlciB0byBtYWtlIHNlbGVjdGFibGUgc2VyaWVzIG9yIG5vdC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXNdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLnhBeGlzLnRpdGxlXSAtIEF4aXMgdGl0bGUuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnhBeGlzLnJvdGF0ZUxhYmVsPXRydWVdIC0gV2hldGhlciB0byBhbGxvdyBheGlzIGxhYmVsIHJvdGF0aW9uLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufE9iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXMuZGF0ZV0gLSBXaGV0aGVyIHRoZSB4IGF4aXMgbGFiZWwgaXMgb2YgZGF0ZSB0eXBlLiBGb3JtYXQgb3B0aW9uIHVzZWQgZm9yIGRhdGUgdHlwZS4gV2hldGhlciB0aGUgeCBheGlzIGxhYmVsIGlzIG9mIGRhdGUgdHlwZS4gSWYgdXNlIGRhdGUgdHlwZSwgZm9ybWF0IG9wdGlvbiB1c2VkIGZvciBkYXRlIHR5cGUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXMudGlja10gLSBPcHRpb24gdG8gYWRqdXN0IHRpY2sgaW50ZXJ2YWwuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueEF4aXMubGFiZWxdIC0gT3B0aW9uIHRvIGFkanVzdCBsYWJlbCBpbnRlcnZhbC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy54QXhpcy5zY2FsZV0gLSBPcHRpb24gdG8gYWRqdXN0IGF4aXMgbWluaW11bSwgbWF4aW11bSwgc3RlcCBzaXplLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnhBeGlzLndpZHRoXSAtIFdpZHRoIG9mIHhBeGlzLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnhBeGlzLmhlaWdodF0gLSBIZWlnaHQgb2YgeEF4aXMuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnlBeGlzXVxuICogICAgICAgQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBbcHJvcHMub3B0aW9ucy55QXhpcy50aXRsZV0gLSBBeGlzIHRpdGxlLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnlBeGlzLnRpY2tdIC0gT3B0aW9uIHRvIGFkanVzdCB0aWNrIGludGVydmFsLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnlBeGlzLmxhYmVsXSAtIE9wdGlvbiB0byBhZGp1c3QgbGFiZWwgaW50ZXJ2YWwuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMueUF4aXMuc2NhbGVdIC0gT3B0aW9uIHRvIGFkanVzdCBheGlzIG1pbmltdW0sIG1heGltdW0sIHN0ZXAgc2l6ZS5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy55QXhpcy53aWR0aF0gLSBXaWR0aCBvZiB5QXhpcy5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy55QXhpcy5oZWlnaHRdIC0gSGVpZ2h0IG9mIHlBeGlzLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5wbG90XVxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnBsb3Qud2lkdGhdIC0gV2lkdGggb2YgcGxvdC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMub3B0aW9ucy5wbG90LmhlaWdodF0gLSBIZWlnaHQgb2YgcGxvdC5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMucGxvdC52aXNpYmxlXSAtIFdoZXRoZXIgdG8gc2hvdyBwbG90IGxpbmUuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZF1cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMub3B0aW9ucy5sZWdlbmQuYWxpZ25dIC0gTGVnZW5kIGFsaWduLiAndG9wJywgJ2JvdHRvbScsICdyaWdodCcsICdsZWZ0JyBpcyBhdmFpbGFibGUuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMubGVnZW5kLnNob3dDaGVja2JveF0gLSBXaGV0aGVyIHRvIHNob3cgY2hlY2tib3guXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC52aXNpYmxlXSAtIFdoZXRoZXIgdG8gc2hvdyBsZWdlbmQuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMubGVnZW5kLndpZHRoXSAtIFdpZHRoIG9mIGxlZ2VuZC5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sZWdlbmQuaXRlbV0gLSBgd2lkdGhgIGFuZCBgb3ZlcmZsb3dgIG9wdGlvbnMgb2YgdGhlIGxlZ2VuZCBpdGVtLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8TGVnZW5kIGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnVdXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnUudmlzaWJsZV0gLSBXaGV0aGVyIHRvIHNob3cgZXhwb3J0IG1lbnUuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuZXhwb3J0TWVudS5maWxlbmFtZV0gLSBGaWxlIG5hbWUgYXBwbGllZCB3aGVuIGRvd25sb2FkaW5nLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50b29sdGlwXVxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAub2Zmc2V0WF0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSBob3Jpem9udGFsbHkuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC5vZmZzZXRZXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIHZlcnRpY2FsbHkuXG4gKiAgICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcHMub3B0aW9ucy50b29sdGlwLmZvcm1hdHRlcl0gLSBGdW5jdGlvbiB0byBmb3JtYXQgZGF0YSB2YWx1ZS5cbiAqICAgICAgIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAudGVtcGxhdGVdIC0gRnVuY3Rpb24gdG8gY3JlYXRlIGN1c3RvbSB0ZW1wbGF0ZS4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFRvb2x0aXAgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZV0gLSBSdWxlcyBmb3IgY2hhbmdpbmcgY2hhcnQgb3B0aW9ucy4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFJlc3BvbnNpdmUgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLnJlc3BvbnNpdmUuYW5pbWF0aW9uXSAtIEFuaW1hdGlvbiBkdXJhdGlvbiB3aGVuIHRoZSBjaGFydCBpcyBtb2RpZmllZC5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZS5ydWxlc10gLSBSdWxlcyBmb3IgdGhlIENoYXJ0IHRvIFJlc3BvbmQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxhbmddIC0gT3B0aW9ucyBmb3IgY2hhbmdpbmcgdGhlIHRleHQgZGlzcGxheWVkIG9uIHRoZSBjaGFydCBvciBpMThuIGxhbmd1YWdlcy5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sYW5nLm5vRGF0YV0gLSBObyBEYXRhIExheWVyIFRleHQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lXSAtIENoYXJ0IHRoZW1lIG9wdGlvbnMuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxTY2F0dHRlciBDaGFydCBndWlkZX0gb24gZ2l0aHViLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmNoYXJ0XSAtIENoYXJ0IGZvbnQgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUubm9EYXRhXSAtIE5vIERhdGEgTGF5ZXIgVGV4dCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5zZXJpZXNdIC0gU2VyaWVzIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnRpdGxlXSAtIFRpdGxlIHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnhBeGlzXSAtIFggQXhpcyB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS55QXhpc10gLSBZIEF4aXMgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUubGVnZW5kXSAtIExlZ2VuZCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS50b29sdGlwXSAtIFRvb2x0aXAgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUucGxvdF0gLSBQbG90IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmV4cG9ydE1lbnVdIC0gRXhwb3J0TWVudSB0aGVtZS5cbiAqIEBleHRlbmRzIENoYXJ0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjYXR0ZXJDaGFydCBleHRlbmRzIENoYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGVsOiBwcm9wcy5lbCxcbiAgICAgICAgICAgIG9wdGlvbnM6IHByb3BzLm9wdGlvbnMsXG4gICAgICAgICAgICBzZXJpZXM6IHtcbiAgICAgICAgICAgICAgICBzY2F0dGVyOiBjbGVhclVubmVjZXNzYXJ5RGF0YShwcm9wcy5kYXRhLnNlcmllcyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2F0ZWdvcmllczogKF9hID0gcHJvcHMuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhdGVnb3JpZXMsXG4gICAgICAgICAgICBtb2R1bGVzOiBbZGF0YVJhbmdlLCBzY2FsZSwgYXhlcywgcGxvdF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQmFja2dyb3VuZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoVGl0bGUpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFBsb3QpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKExlZ2VuZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoU2NhdHRlclNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQXhpcywgeyBuYW1lOiAneEF4aXMnIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEF4aXMsIHsgbmFtZTogJ3lBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzVGl0bGUsIHsgbmFtZTogJ3hBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChBeGlzVGl0bGUsIHsgbmFtZTogJ3lBeGlzJyB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChFeHBvcnRNZW51LCB7IGNoYXJ0RWw6IHRoaXMuZWwgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoSG92ZXJlZFNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoU2VsZWN0ZWRTZXJpZXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFRvb2x0aXAsIHsgY2hhcnRFbDogdGhpcy5lbCB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChOb0RhdGFUZXh0KTtcbiAgICAgICAgdGhpcy5wYWludGVyLmFkZEdyb3VwcyhbXG4gICAgICAgICAgICBiYXNpY0JydXNoLFxuICAgICAgICAgICAgYXhpc0JydXNoLFxuICAgICAgICAgICAgbGVnZW5kQnJ1c2gsXG4gICAgICAgICAgICBsYWJlbEJydXNoLFxuICAgICAgICAgICAgZXhwb3J0TWVudUJydXNoLFxuICAgICAgICAgICAgc2NhdHRlclNlcmllc0JydXNoLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBkYXRhIC0gQXJyYXkgb2YgZGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5hZGREYXRhKFtcbiAgICAgKiAgIHt4OiAxMCwgeTogMjB9LFxuICAgICAqICAge3g6IDMwLCB5OiA0MH0sXG4gICAgICogXSk7XG4gICAgICovXG4gICAgYWRkRGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQ29udHJvbEZsYWcudXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2FkZERhdGEnLCB7IGRhdGEgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBEYXRhIHRvIGJlIGFkZGVkLlxuICAgICAqICAgQHBhcmFtIHtzdHJpbmd9IGRhdGEubmFtZSAtIFNlcmllcyBuYW1lLlxuICAgICAqICAgQHBhcmFtIHtBcnJheX0gZGF0YS5kYXRhIC0gQXJyYXkgb2YgZGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5hZGRTZXJpZXMoe1xuICAgICAqICAgbmFtZTogJ25ld1NlcmllcycsXG4gICAgICogICBkYXRhOiBbXG4gICAgICogICAgIHt4OiAxMCwgeTogMjB9LFxuICAgICAqICAgICB7eDogMzAsIHk6IDQwfSxcbiAgICAgKiAgIF0sXG4gICAgICogfSk7XG4gICAgICovXG4gICAgYWRkU2VyaWVzKGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdhZGRTZXJpZXMnLCB7IGRhdGEgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGNoYXJ0IGRhdGEgdG8gbmV3IGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBEYXRhIHRvIGJlIHNldC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zZXREYXRhKHtcbiAgICAgKiAgIHNlcmllczogW1xuICAgICAqICAgICB7XG4gICAgICogICAgICAgbmFtZTogJ25hbWUnXG4gICAgICogICAgICAgZGF0YTogW1xuICAgICAqICAgICAgICAge3g6IDEwLCB5OiAyMH0sXG4gICAgICogICAgICAgICB7eDogMzAsIHk6IDQwfSxcbiAgICAgKiAgICAgICBdXG4gICAgICogICAgIH1cbiAgICAgKiAgIF1cbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXREYXRhKGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBjYXRlZ29yaWVzLCBzZXJpZXMgfSA9IGRhdGE7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgnc2V0RGF0YScsIHsgc2VyaWVzOiB7IHNjYXR0ZXI6IHNlcmllcyB9LCBjYXRlZ29yaWVzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBjaGFydCBvcHRpb25zIHRvIG5ldyBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ2hhcnQgb3B0aW9uc1xuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNldE9wdGlvbnMoe1xuICAgICAqICAgY2hhcnQ6IHtcbiAgICAgKiAgICAgd2lkdGg6IDUwMCxcbiAgICAgKiAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICogICAgIHRpdGxlOiAnRW5lcmd5IFVzYWdlJyxcbiAgICAgKiAgIH0sXG4gICAgICogICB4QXhpczoge1xuICAgICAqICAgICB0aXRsZTogJ01vbnRoJyxcbiAgICAgKiAgIH0sXG4gICAgICogICB5QXhpczoge1xuICAgICAqICAgICB0aXRsZTogJ0VuZXJneSAoa1doKScsXG4gICAgICogICB9LFxuICAgICAqICAgc2VyaWVzOiB7XG4gICAgICogICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICogICB9LFxuICAgICAqICAgdG9vbHRpcDoge1xuICAgICAqICAgICBmb3JtYXR0ZXI6ICh2YWx1ZSkgPT4gYCR7dmFsdWV9a1doYCxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICovXG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE9wdGlvbnNFdmVudCgnaW5pdE9wdGlvbnMnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNoYXJ0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDaGFydCBvcHRpb25zXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQudXBkYXRlT3B0aW9ucyh7XG4gICAgICogICBjaGFydDoge1xuICAgICAqICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgKiAgICAgdGl0bGU6ICdFbmVyZ3kgVXNhZ2UnLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHRvb2x0aXA6IHtcbiAgICAgKiAgICAgZm9ybWF0dGVyOiAodmFsdWUpID0+IGAke3ZhbHVlfWtXaGAsXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHVwZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hPcHRpb25zRXZlbnQoJ3VwZGF0ZU9wdGlvbnMnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXJpZXNJbmZvIC0gSW5mb3JtYXRpb24gb2YgdGhlIHNlcmllcyBmb3IgdGhlIHRvb2x0aXAgdG8gYmUgZGlzcGxheWVkLlxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHNlcmllc0luZm8uc2VyaWVzSW5kZXggLSBJbmRleCBvZiBzZXJpZXMuXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gc2VyaWVzSW5mby5pbmRleCAtIEluZGV4IG9mIGRhdGEgd2l0aGluIHNlcmllcy5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zaG93VG9vbHRpcCh7aW5kZXg6IDEsIHNlcmllc0luZGV4OiAyfSk7XG4gICAgICovXG4gICAgc2hvd1Rvb2x0aXAoc2VyaWVzSW5mbykge1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nob3dUb29sdGlwJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZXJpZXNJbmZvKSwgeyBzdGF0ZTogdGhpcy5zdG9yZS5zdGF0ZSB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGUgdG9vbHRpcC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5oaWRlVG9vbHRpcCgpO1xuICAgICAqL1xuICAgIGhpZGVUb29sdGlwKCkge1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ2hpZGVUb29sdGlwJyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IENoYXJ0IGZyb20gXCIuL2NoYXJ0XCI7XG5pbXBvcnQgY29sb3JWYWx1ZVNjYWxlIGZyb20gXCIuLi9zdG9yZS9jb2xvclZhbHVlU2NhbGVcIjtcbmltcG9ydCB0cmVlbWFwU2VyaWVzRGF0YSBmcm9tIFwiLi4vc3RvcmUvdHJlZW1hcFNlcmllc0RhdGFcIjtcbmltcG9ydCBUb29sdGlwIGZyb20gXCIuLi9jb21wb25lbnQvdG9vbHRpcFwiO1xuaW1wb3J0IFRpdGxlIGZyb20gXCIuLi9jb21wb25lbnQvdGl0bGVcIjtcbmltcG9ydCBFeHBvcnRNZW51IGZyb20gXCIuLi9jb21wb25lbnQvZXhwb3J0TWVudVwiO1xuaW1wb3J0IEhvdmVyZWRTZXJpZXMgZnJvbSBcIi4uL2NvbXBvbmVudC9ob3ZlcmVkU2VyaWVzXCI7XG5pbXBvcnQgRGF0YUxhYmVscyBmcm9tIFwiLi4vY29tcG9uZW50L2RhdGFMYWJlbHNcIjtcbmltcG9ydCBUcmVlbWFwU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvdHJlZW1hcFNlcmllc1wiO1xuaW1wb3J0IFNwZWN0cnVtTGVnZW5kIGZyb20gXCIuLi9jb21wb25lbnQvc3BlY3RydW1MZWdlbmRcIjtcbmltcG9ydCBCYWNrQnV0dG9uIGZyb20gXCIuLi9jb21wb25lbnQvYmFja0J1dHRvblwiO1xuaW1wb3J0IFNlbGVjdGVkU2VyaWVzIGZyb20gXCIuLi9jb21wb25lbnQvc2VsZWN0ZWRTZXJpZXNcIjtcbmltcG9ydCBCYWNrZ3JvdW5kIGZyb20gXCIuLi9jb21wb25lbnQvYmFja2dyb3VuZFwiO1xuaW1wb3J0IE5vRGF0YVRleHQgZnJvbSBcIi4uL2NvbXBvbmVudC9ub0RhdGFUZXh0XCI7XG5pbXBvcnQgKiBhcyBiYXNpY0JydXNoIGZyb20gXCIuLi9icnVzaGVzL2Jhc2ljXCI7XG5pbXBvcnQgKiBhcyBsZWdlbmRCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9sZWdlbmRcIjtcbmltcG9ydCAqIGFzIGxhYmVsQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvbGFiZWxcIjtcbmltcG9ydCAqIGFzIGV4cG9ydE1lbnVCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9leHBvcnRNZW51XCI7XG5pbXBvcnQgKiBhcyBkYXRhTGFiZWxCcnVzaCBmcm9tIFwiLi4vYnJ1c2hlcy9kYXRhTGFiZWxcIjtcbmltcG9ydCAqIGFzIHNwZWN0cnVtTGVnZW5kQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvc3BlY3RydW1MZWdlbmRcIjtcbmltcG9ydCAqIGFzIHJlc2V0QnV0dG9uQnJ1c2ggZnJvbSBcIi4uL2JydXNoZXMvcmVzZXRCdXR0b25cIjtcbi8qKlxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIFRyZWVtYXAgQ2hhcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogICBAcGFyYW0ge0hUTUxFbGVtZW50fSBwcm9wcy5lbCAtIFRoZSB0YXJnZXQgZWxlbWVudCB0byBjcmVhdGUgY2hhcnQuXG4gKiAgIEBwYXJhbSB7T2JqZWN0fSBwcm9wcy5kYXRhIC0gRGF0YSBmb3IgbWFraW5nIFRyZWVtYXAgQ2hhcnQuXG4gKiAgICAgQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBwcm9wcy5kYXRhLmNhdGVnb3JpZXMgLSBDYXRlZ29yaWVzLlxuICogICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcHJvcHMuZGF0YS5zZXJpZXMgLSBTZXJpZXMgZGF0YS5cbiAqICAgICAgIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy5kYXRhLnNlcmllcy5sYWJlbCAtIERhdGEgbmFtZS5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbcHJvcHMuZGF0YS5zZXJpZXMuZGF0YV0gLSBkYXRhIHZhbHVlLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5kYXRhLnNlcmllcy5jb2xvclZhbHVlXSAtIGNvbG9yIHZhbHVlLiBJZiB5b3UgdXNlIHRoZSB1c2VDb2xvclZhbHVlIG9wdGlvbiwgdGhlIGNvbG9yIGlzIHBhaW50ZWQgYmFzZWQgb24gdGhpcyB2YWx1ZS5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gW3Byb3BzLmRhdGEuc2VyaWVzLmNoaWxkcmVuXSAtIENoaWxkIGVsZW1lbnQgdmFsdWUuXG4gKiAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9uc10gLSBPcHRpb25zIGZvciBtYWtpbmcgVHJlZW1hcCBDaGFydC5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuY2hhcnRdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlXSAtIENoYXJ0IHRpdGxlIHRleHQgb3Igb3B0aW9ucy5cbiAqICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLnRleHRdIC0gQ2hhcnQgdGl0bGUgdGV4dC5cbiAqICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LnRpdGxlLm9mZnNldFhdIC0gT2Zmc2V0IHZhbHVlIHRvIG1vdmUgdGl0bGUgaG9yaXpvbnRhbGx5LlxuICogICAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUub2Zmc2V0WV0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSB2ZXJ0aWNhbGx5LlxuICogICAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQudGl0bGUuYWxpZ25dIC0gQ2hhcnQgdGV4dCBhbGlnbi4gJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJyBpcyBhdmFpbGFibGUuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5jaGFydC5hbmltYXRpb25dIC0gV2hldGhlciB0byB1c2UgYW5pbWF0aW9uIGFuZCBkdXJhdGlvbiB3aGVuIHJlbmRlcmluZyB0aGUgaW5pdGlhbCBjaGFydC5cbiAqICAgICAgIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3Byb3BzLm9wdGlvbnMuY2hhcnQud2lkdGhdIC0gQ2hhcnQgd2lkdGguICdhdXRvJyBvciBpZiBub3Qgd3JpdGUsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC4gJ2F1dG8nIG9yIGlmIG5vdCBjcmVhdGVkLCB0aGUgd2lkdGggb2YgdGhlIHBhcmVudCBjb250YWluZXIgaXMgZm9sbG93ZWQuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwcm9wcy5vcHRpb25zLmNoYXJ0LmhlaWdodF0gLSBDaGFydCBoZWlnaHQuICdhdXRvJyBvciBpZiBub3Qgd3JpdGUsIHRoZSB3aWR0aCBvZiB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBmb2xsb3dlZC4gJ2F1dG8nIG9yIGlmIG5vdCBjcmVhdGVkLCB0aGUgaGVpZ2h0IG9mIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIGZvbGxvd2VkLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5zZXJpZXNdXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy5zZWxlY3RhYmxlPWZhbHNlXSAtIFdoZXRoZXIgdG8gbWFrZSBzZWxlY3RhYmxlIHNlcmllcyBvciBub3QuXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLnNlcmllcy51c2VDb2xvclZhbHVlXSAtIFdoZXRoZXIgdG8gdXNlIGNvbG9yIHZhbHVlIG9yIG5vdC5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLnpvb21hYmxlXSAtIFdoZXRoZXIgdG8gdXNlIHpvb20gZmVhdHVyZSBvciBub3QuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMuc2VyaWVzLmRhdGFMYWJlbHNdIC0gU2V0IHRoZSB2aXNpYmlsaXR5LCBsb2NhdGlvbiwgYW5kIGZvcm1hdHRpbmcgb2YgZGF0YUxhYmVsLiBGb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY2hhcnR8RGF0YUxhYmVscyBndWlkZX0gb24gZ2l0aHViLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sZWdlbmRdXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMubGVnZW5kLmFsaWduXSAtIExlZ2VuZCBhbGlnbi4gJ3RvcCcsICdib3R0b20nLCAncmlnaHQnLCAnbGVmdCcgaXMgYXZhaWxhYmxlLlxuICogICAgICAgQHBhcmFtIHtib29sZWFufSBbcHJvcHMub3B0aW9ucy5sZWdlbmQudmlzaWJsZT1mYWxzZV0gLSBXaGV0aGVyIHRvIHNob3cgbGVnZW5kLlxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLmxlZ2VuZC53aWR0aF0gLSBXaWR0aCBvZiBsZWdlbmQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnVdXG4gKiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vcHRpb25zLmV4cG9ydE1lbnUudmlzaWJsZV0gLSBXaGV0aGVyIHRvIHNob3cgZXhwb3J0IG1lbnUuXG4gKiAgICAgICBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLm9wdGlvbnMuZXhwb3J0TWVudS5maWxlbmFtZV0gLSBGaWxlIG5hbWUgYXBwbGllZCB3aGVuIGRvd25sb2FkaW5nLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50b29sdGlwXVxuICogICAgICAgQHBhcmFtIHtudW1iZXJ9IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAub2Zmc2V0WF0gLSBPZmZzZXQgdmFsdWUgdG8gbW92ZSB0aXRsZSBob3Jpem9udGFsbHkuXG4gKiAgICAgICBAcGFyYW0ge251bWJlcn0gW3Byb3BzLm9wdGlvbnMudG9vbHRpcC5vZmZzZXRZXSAtIE9mZnNldCB2YWx1ZSB0byBtb3ZlIHRpdGxlIHZlcnRpY2FsbHkuXG4gKiAgICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcHMub3B0aW9ucy50b29sdGlwLmZvcm1hdHRlcl0gLSBGdW5jdGlvbiB0byBmb3JtYXQgZGF0YSB2YWx1ZS5cbiAqICAgICAgIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wcy5vcHRpb25zLnRvb2x0aXAudGVtcGxhdGVdIC0gRnVuY3Rpb24gdG8gY3JlYXRlIGN1c3RvbSB0ZW1wbGF0ZS4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFRvb2x0aXAgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZV0gLSBSdWxlcyBmb3IgY2hhbmdpbmcgY2hhcnQgb3B0aW9ucy4gRm9yIHNwZWNpZmljIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uaG4vdHVpLmNoYXJ0fFJlc3BvbnNpdmUgZ3VpZGV9IG9uIGdpdGh1Yi5cbiAqICAgICAgIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IFtwcm9wcy5vcHRpb25zLnJlc3BvbnNpdmUuYW5pbWF0aW9uXSAtIEFuaW1hdGlvbiBkdXJhdGlvbiB3aGVuIHRoZSBjaGFydCBpcyBtb2RpZmllZC5cbiAqICAgICAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gW3Byb3BzLm9wdGlvbnMucmVzcG9uc2l2ZS5ydWxlc10gLSBSdWxlcyBmb3IgdGhlIENoYXJ0IHRvIFJlc3BvbmQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLmxhbmddIC0gT3B0aW9ucyBmb3IgY2hhbmdpbmcgdGhlIHRleHQgZGlzcGxheWVkIG9uIHRoZSBjaGFydCBvciBpMThuIGxhbmd1YWdlcy5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy5sYW5nLm5vRGF0YV0gLSBObyBEYXRhIExheWVyIFRleHQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lXSAtIENoYXJ0IHRoZW1lIG9wdGlvbnMuIEZvciBzcGVjaWZpYyBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmhuL3R1aS5jaGFydHxUcmVlbWFwIENoYXJ0IGd1aWRlfSBvbiBnaXRodWIuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUuY2hhcnRdIC0gQ2hhcnQgZm9udCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS5ub0RhdGFdIC0gTm8gRGF0YSBMYXllciBUZXh0IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLnNlcmllc10gLSBTZXJpZXMgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUudGl0bGVdIC0gVGl0bGUgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUubGVnZW5kXSAtIExlZ2VuZCB0aGVtZS5cbiAqICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMub3B0aW9ucy50aGVtZS50b29sdGlwXSAtIFRvb2x0aXAgdGhlbWUuXG4gKiAgICAgICBAcGFyYW0ge09iamVjdH0gW3Byb3BzLm9wdGlvbnMudGhlbWUucGxvdF0gLSBQbG90IHRoZW1lLlxuICogICAgICAgQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5vcHRpb25zLnRoZW1lLmV4cG9ydE1lbnVdIC0gRXhwb3J0TWVudSB0aGVtZS5cbiAqIEBleHRlbmRzIENoYXJ0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyZWVtYXBDaGFydCBleHRlbmRzIENoYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBlbDogcHJvcHMuZWwsXG4gICAgICAgICAgICBvcHRpb25zOiBwcm9wcy5vcHRpb25zLFxuICAgICAgICAgICAgc2VyaWVzOiB7XG4gICAgICAgICAgICAgICAgdHJlZW1hcDogcHJvcHMuZGF0YS5zZXJpZXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW9kdWxlczogW3RyZWVtYXBTZXJpZXNEYXRhLCBjb2xvclZhbHVlU2NhbGVdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEJhY2tncm91bmQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFRpdGxlKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChTcGVjdHJ1bUxlZ2VuZCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoVHJlZW1hcFNlcmllcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoRXhwb3J0TWVudSwgeyBjaGFydEVsOiB0aGlzLmVsIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKEhvdmVyZWRTZXJpZXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuYWRkKFNlbGVjdGVkU2VyaWVzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChEYXRhTGFiZWxzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmFkZChUb29sdGlwLCB7IGNoYXJ0RWw6IHRoaXMuZWwgfSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoQmFja0J1dHRvbik7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5hZGQoTm9EYXRhVGV4dCk7XG4gICAgICAgIHRoaXMucGFpbnRlci5hZGRHcm91cHMoW1xuICAgICAgICAgICAgYmFzaWNCcnVzaCxcbiAgICAgICAgICAgIGxlZ2VuZEJydXNoLFxuICAgICAgICAgICAgbGFiZWxCcnVzaCxcbiAgICAgICAgICAgIGV4cG9ydE1lbnVCcnVzaCxcbiAgICAgICAgICAgIGRhdGFMYWJlbEJydXNoLFxuICAgICAgICAgICAgc3BlY3RydW1MZWdlbmRCcnVzaCxcbiAgICAgICAgICAgIHJlc2V0QnV0dG9uQnJ1c2gsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiAgIEBwYXJhbSB7c3RyaW5nfSBkYXRhLm5hbWUgLSBTZXJpZXMgbmFtZS5cbiAgICAgKiAgIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZGF0YS5kYXRhIC0gQXJyYXkgb2YgZGF0YSB0byBiZSBhZGRlZC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5hZGRTZXJpZXMoe1xuICAgICAqICAgbGFiZWw6ICdEb2N1bWVudHMnLFxuICAgICAqICAgY2hpbGRyZW46IFtcbiAgICAgKiAgICAge2xhYmVsOiAnQScsIGRhdGE6IDIwfSxcbiAgICAgKiAgICAge2xhYmVsOiAnQicsIGRhdGE6IDQwfSxcbiAgICAgKiAgIF0sXG4gICAgICogfSk7XG4gICAgICovXG4gICAgYWRkU2VyaWVzKGRhdGEsIGRhdGFJbmZvKSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgnYWRkVHJlZW1hcFNlcmllcycsIE9iamVjdC5hc3NpZ24oeyBkYXRhIH0sIGRhdGFJbmZvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGNoYXJ0IGRhdGEgdG8gbmV3IGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBEYXRhIHRvIGJlIHNldC5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zZXREYXRhKFxuICAgICAqICAgc2VyaWVzOiBbXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICBsYWJlbDogJ0RvY3VtZW50cycsXG4gICAgICogICAgICAgY2hpbGRyZW46IFtcbiAgICAgKiAgICAgICAgIHtsYWJlbDogJ0EnLCBkYXRhOiAyMH0sXG4gICAgICogICAgICAgICB7bGFiZWw6ICdCJywgZGF0YTogNDB9LFxuICAgICAqICAgICAgIF0sXG4gICAgICogICAgIH0sXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICBsYWJlbDogJ0RvY3VtZW50cycsXG4gICAgICogICAgICAgZGF0YTogMzAsXG4gICAgICogICAgIH1cbiAgICAgKiAgIF1cbiAgICAgKiApO1xuICAgICAqL1xuICAgIHNldERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLnJlc2V0U2VyaWVzKCk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3NldERhdGEnLCB7IHNlcmllczogeyB0cmVlbWFwOiBkYXRhLnNlcmllcyB9IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlIHNlcmllcyBkYXRhIGxhYmVsLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmhpZGVTZXJpZXNEYXRhTGFiZWwoKTtcbiAgICAgKi9cbiAgICBoaWRlU2VyaWVzRGF0YUxhYmVsKCkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCd1cGRhdGVPcHRpb25zJywge1xuICAgICAgICAgICAgb3B0aW9uczogeyBzZXJpZXM6IHsgZGF0YUxhYmVsczogeyB2aXNpYmxlOiBmYWxzZSB9IH0gfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgc2VyaWVzIGRhdGEgbGFiZWwuXG4gICAgICogQGFwaVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2hhcnQuc2hvd1Nlcmllc0RhdGFMYWJlbCgpO1xuICAgICAqL1xuICAgIHNob3dTZXJpZXNEYXRhTGFiZWwoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3VwZGF0ZU9wdGlvbnMnLCB7XG4gICAgICAgICAgICBvcHRpb25zOiB7IHNlcmllczogeyBkYXRhTGFiZWxzOiB7IHZpc2libGU6IHRydWUgfSB9IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBjaGFydCBvcHRpb25zIHRvIG5ldyBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ2hhcnQgb3B0aW9uc1xuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LnNldE9wdGlvbnMoe1xuICAgICAqICAgY2hhcnQ6IHtcbiAgICAgKiAgICAgd2lkdGg6IDUwMCxcbiAgICAgKiAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICogICAgIHRpdGxlOiAnRW5lcmd5IFVzYWdlJyxcbiAgICAgKiAgIH0sXG4gICAgICogICBzZXJpZXM6IHtcbiAgICAgKiAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgKiAgIH0sXG4gICAgICogICB0b29sdGlwOiB7XG4gICAgICogICAgIGZvcm1hdHRlcjogKHZhbHVlKSA9PiBgJHt2YWx1ZX1rV2hgLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlcmllcygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoT3B0aW9uc0V2ZW50KCdpbml0T3B0aW9ucycsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY2hhcnQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENoYXJ0IG9wdGlvbnNcbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC51cGRhdGVPcHRpb25zKHtcbiAgICAgKiAgIGNoYXJ0OiB7XG4gICAgICogICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAqICAgICB0aXRsZTogJ0VuZXJneSBVc2FnZScsXG4gICAgICogICB9LFxuICAgICAqICAgdG9vbHRpcDoge1xuICAgICAqICAgICBmb3JtYXR0ZXI6ICh2YWx1ZSkgPT4gYCR7dmFsdWV9a1doYCxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICovXG4gICAgdXBkYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucmVzZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE9wdGlvbnNFdmVudCgndXBkYXRlT3B0aW9ucycsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlcmllc0luZm8gLSBJbmZvcm1hdGlvbiBvZiB0aGUgc2VyaWVzIGZvciB0aGUgdG9vbHRpcCB0byBiZSBkaXNwbGF5ZWQuXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gc2VyaWVzSW5mby5zZXJpZXNJbmRleCAtIEluZGV4IG9mIHNlcmllcy5cbiAgICAgKiBAYXBpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjaGFydC5zaG93VG9vbHRpcCh7c2VyaWVzSW5kZXg6IDF9KTtcbiAgICAgKi9cbiAgICBzaG93VG9vbHRpcChzZXJpZXNJbmZvKSB7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnc2hvd1Rvb2x0aXAnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlcmllc0luZm8pLCB7IHN0YXRlOiB0aGlzLnN0b3JlLnN0YXRlIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZSB0b29sdGlwLlxuICAgICAqIEBhcGlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNoYXJ0LmhpZGVUb29sdGlwKCk7XG4gICAgICovXG4gICAgaGlkZVRvb2x0aXAoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnaGlkZVRvb2x0aXAnKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuL2NvbXBvbmVudFwiO1xuaW1wb3J0IHsgZ2V0VmFsdWVSYXRpbywgc2V0U3BsaW5lQ29udHJvbFBvaW50IH0gZnJvbSBcIi4uL2hlbHBlcnMvY2FsY3VsYXRvclwiO1xuaW1wb3J0IHsgZ2V0UkdCQSB9IGZyb20gXCIuLi9oZWxwZXJzL2NvbG9yXCI7XG5pbXBvcnQgeyBkZWVwQ29weSwgZGVlcE1lcmdlZENvcHksIGdldEZpcnN0VmFsaWRWYWx1ZSwgaXNOdWxsLCBpc1VuZGVmaW5lZCwgcmFuZ2UsIHN1bSwgfSBmcm9tIFwiLi4vaGVscGVycy91dGlsc1wiO1xuaW1wb3J0IHsgaXNSYW5nZURhdGEgfSBmcm9tIFwiLi4vaGVscGVycy9yYW5nZVwiO1xuaW1wb3J0IHsgZ2V0QWN0aXZlU2VyaWVzTWFwIH0gZnJvbSBcIi4uL2hlbHBlcnMvbGVnZW5kXCI7XG5pbXBvcnQgeyBnZXROZWFyZXN0UmVzcG9uZGVyLCBtYWtlUmVjdFJlc3BvbmRlck1vZGVsLCBtYWtlVG9vbHRpcENpcmNsZU1hcCwgfSBmcm9tIFwiLi4vaGVscGVycy9yZXNwb25kZXJzXCI7XG5pbXBvcnQgeyBnZXRWYWx1ZUF4aXNOYW1lIH0gZnJvbSBcIi4uL2hlbHBlcnMvYXhlc1wiO1xuaW1wb3J0IHsgZ2V0RGF0YUxhYmVsc09wdGlvbnMgfSBmcm9tIFwiLi4vaGVscGVycy9kYXRhTGFiZWxzXCI7XG5pbXBvcnQgeyBtZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2VcIjtcbmltcG9ydCB7IGlzQXZhaWxhYmxlU2VsZWN0U2VyaWVzLCBpc0F2YWlsYWJsZVNob3dUb29sdGlwSW5mbyB9IGZyb20gXCIuLi9oZWxwZXJzL3ZhbGlkYXRpb25cIjtcbmNvbnN0IHNlcmllc09wYWNpdHkgPSB7XG4gICAgSU5BQ1RJVkU6IDAuMDYsXG4gICAgQUNUSVZFOiAxLFxufTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFyZWFTZXJpZXMgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1vZGVscyA9IHsgcmVjdDogW10sIHNlcmllczogW10sIGRvdDogW10gfTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZWRSZXNwb25kZXJzID0gW107XG4gICAgICAgIHRoaXMuZXZlbnREZXRlY3RUeXBlID0gJ25lYXJlc3QnO1xuICAgICAgICB0aGlzLmlzU3RhY2tDaGFydCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUmFuZ2VDaGFydCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3BsaW5lQ2hhcnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbk1vdXNlb3V0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzZXJpZXNQb2ludEhvdmVyZWQnLCB7IG1vZGVsczogW10sIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVySG92ZXJlZFNlcmllcycsIHtcbiAgICAgICAgICAgICAgICBtb2RlbHM6IFtdLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBldmVudERldGVjdFR5cGU6IHRoaXMuZXZlbnREZXRlY3RUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VsZWN0U2VyaWVzID0gKGluZm8pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5kZXgsIHNlcmllc0luZGV4IH0gPSBpbmZvO1xuICAgICAgICAgICAgaWYgKCFpc0F2YWlsYWJsZVNlbGVjdFNlcmllcyhpbmZvLCAnYXJlYScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSB0aGlzLmdldFJlc3BvbmRlckNhdGVnb3J5QnlJbmRleChpbmRleCk7XG4gICAgICAgICAgICBpZiAoIWNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UuU0VMRUNUX1NFUklFU19BUElfSU5ERVhfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLnRvb2x0aXBDaXJjbGVNYXBbY2F0ZWdvcnldW3Nlcmllc0luZGV4XTtcbiAgICAgICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZS5TRUxFQ1RfU0VSSUVTX0FQSV9JTkRFWF9FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2RlbHMgPSB0aGlzLmdldFJlc3BvbmRlclNlcmllc1dpdGhUaGVtZShbbW9kZWxdLCAnc2VsZWN0Jyk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlclNlbGVjdGVkU2VyaWVzJywgeyBtb2RlbHMsIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zaG93VG9vbHRpcCA9IChpbmZvKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGluZGV4LCBzZXJpZXNJbmRleCB9ID0gaW5mbztcbiAgICAgICAgICAgIGlmICghaXNBdmFpbGFibGVTaG93VG9vbHRpcEluZm8oaW5mbywgdGhpcy5ldmVudERldGVjdFR5cGUsICdhcmVhJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IHRoaXMuZ2V0UmVzcG9uZGVyQ2F0ZWdvcnlCeUluZGV4KGluZGV4KTtcbiAgICAgICAgICAgIGlmICghY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2RlbHMgPSB0aGlzLmV2ZW50RGV0ZWN0VHlwZSA9PT0gJ2dyb3VwZWQnXG4gICAgICAgICAgICAgICAgPyB0aGlzLnRvb2x0aXBDaXJjbGVNYXBbY2F0ZWdvcnldXG4gICAgICAgICAgICAgICAgOiBbdGhpcy50b29sdGlwQ2lyY2xlTWFwW2NhdGVnb3J5XVtzZXJpZXNJbmRleF1dO1xuICAgICAgICAgICAgaWYgKCFtb2RlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vbk1vdXNlbW92ZU5lYXJUeXBlKG1vZGVscyk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nlcmllc1BvaW50SG92ZXJlZCcsIHsgbW9kZWxzOiB0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMsIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ3Nlcmllcyc7XG4gICAgICAgIHRoaXMubmFtZSA9ICdhcmVhJztcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignc2VsZWN0U2VyaWVzJywgdGhpcy5zZWxlY3RTZXJpZXMpO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLm9uKCdzaG93VG9vbHRpcCcsIHRoaXMuc2hvd1Rvb2x0aXApO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLm9uKCdoaWRlVG9vbHRpcCcsIHRoaXMub25Nb3VzZW91dENvbXBvbmVudCk7XG4gICAgfVxuICAgIGluaXRVcGRhdGUoZGVsdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRyYXdNb2RlbHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYXdNb2RlbHMucmVjdFswXS53aWR0aCA9IHRoaXMubW9kZWxzLnJlY3RbMF0ud2lkdGggKiBkZWx0YTtcbiAgICB9XG4gICAgZ2V0QmFzZVlQb3NpdGlvbihsaW1pdCkge1xuICAgICAgICBjb25zdCBiYXNlVmFsdWUgPSBsaW1pdC5taW4gPj0gMCA/IGxpbWl0Lm1pbiA6IE1hdGgubWluKGxpbWl0Lm1heCwgMCk7XG4gICAgICAgIGNvbnN0IGludGVydmFsU2l6ZSA9IHRoaXMucmVjdC5oZWlnaHQgLyAobGltaXQubWF4IC0gbGltaXQubWluKTtcbiAgICAgICAgcmV0dXJuIChsaW1pdC5tYXggLSBiYXNlVmFsdWUpICogaW50ZXJ2YWxTaXplO1xuICAgIH1cbiAgICBnZXRTdGFja1ZhbHVlKGFyZWFTdGFja1Nlcmllcywgc2VyaWVzSW5kZXgsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gYXJlYVN0YWNrU2VyaWVzLnN0YWNrO1xuICAgICAgICBjb25zdCB7IHZhbHVlcywgc3VtOiBzdW1WYWx1ZSB9ID0gYXJlYVN0YWNrU2VyaWVzLnN0YWNrRGF0YVtpbmRleF07XG4gICAgICAgIGNvbnN0IHN0YWNrZWRWYWx1ZSA9IHN1bSh2YWx1ZXMuc2xpY2UoMCwgc2VyaWVzSW5kZXggKyAxKSk7XG4gICAgICAgIHJldHVybiB0eXBlID09PSAncGVyY2VudCcgPyAoc3RhY2tlZFZhbHVlICogMTAwKSAvIHN1bVZhbHVlIDogc3RhY2tlZFZhbHVlO1xuICAgIH1cbiAgICBzZXRFdmVudERldGVjdFR5cGUoc2VyaWVzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICgoX2IgPSAoX2EgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VyaWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZXZlbnREZXRlY3RUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGV0ZWN0VHlwZSA9IG9wdGlvbnMuc2VyaWVzLmV2ZW50RGV0ZWN0VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VyaWVzLmxpbmUgfHwgdGhpcy5pc1N0YWNrQ2hhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnREZXRlY3RUeXBlID0gJ2dyb3VwZWQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEFyZWFPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBuZXdPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgIGlmICgoX2EgPSBuZXdPcHRpb25zLnNlcmllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFyZWEpIHtcbiAgICAgICAgICAgIG5ld09wdGlvbnMuc2VyaWVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBuZXdPcHRpb25zLnNlcmllcyksIG5ld09wdGlvbnMuc2VyaWVzLmFyZWEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdPcHRpb25zO1xuICAgIH1cbiAgICByZW5kZXIoY2hhcnRTdGF0ZSwgY29tcHV0ZWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgY29uc3QgeyB2aWV3UmFuZ2UgfSA9IGNvbXB1dGVkO1xuICAgICAgICBjb25zdCB7IGxheW91dCwgc2VyaWVzLCBzY2FsZSwgYXhlcywgbGVnZW5kLCBzdGFja1NlcmllcywgdGhlbWUgfSA9IGNoYXJ0U3RhdGU7XG4gICAgICAgIGlmICghc2VyaWVzLmFyZWEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlLm5vRGF0YUVycm9yKHRoaXMubmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhcmVhU3RhY2tTZXJpZXM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldEFyZWFPcHRpb25zKGNoYXJ0U3RhdGUub3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBjaGFydFN0YXRlLmNhdGVnb3JpZXM7XG4gICAgICAgIGNvbnN0IHJhd0NhdGVnb3JpZXMgPSAoX2EgPSBjaGFydFN0YXRlLnJhd0NhdGVnb3JpZXMsIChfYSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkpO1xuICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWUuc2VyaWVzLmFyZWE7XG4gICAgICAgIHRoaXMucmVjdCA9IGxheW91dC5wbG90O1xuICAgICAgICB0aGlzLmFjdGl2ZVNlcmllc01hcCA9IGdldEFjdGl2ZVNlcmllc01hcChsZWdlbmQpO1xuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSAoX2MgPSAoX2IgPSB2aWV3UmFuZ2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlswXSwgKF9jICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDApKTtcbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlID0gdGhpcy5nZXRTZWxlY3RhYmxlT3B0aW9uKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmlzU3BsaW5lQ2hhcnQgPSAoX2UgPSAoX2QgPSBvcHRpb25zLnNlcmllcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnNwbGluZSwgKF9lICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGZhbHNlKSk7XG4gICAgICAgIGNvbnN0IHsgbGltaXQgfSA9IHNjYWxlW2dldFZhbHVlQXhpc05hbWUob3B0aW9ucywgdGhpcy5uYW1lLCAneUF4aXMnKV07XG4gICAgICAgIGNvbnN0IHsgdGlja0Rpc3RhbmNlLCBwb2ludE9uQ29sdW1uLCB0aWNrQ291bnQgfSA9IGF4ZXMueEF4aXM7XG4gICAgICAgIGNvbnN0IGFyZWFEYXRhID0gc2VyaWVzLmFyZWEuZGF0YTtcbiAgICAgICAgdGhpcy5iYXNlWVBvc2l0aW9uID0gdGhpcy5nZXRCYXNlWVBvc2l0aW9uKGxpbWl0KTtcbiAgICAgICAgaWYgKChfZiA9IHN0YWNrU2VyaWVzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuYXJlYSkge1xuICAgICAgICAgICAgdGhpcy5pc1N0YWNrQ2hhcnQgPSB0cnVlO1xuICAgICAgICAgICAgYXJlYVN0YWNrU2VyaWVzID0gc3RhY2tTZXJpZXMuYXJlYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1JhbmdlRGF0YSgoX2cgPSBnZXRGaXJzdFZhbGlkVmFsdWUoYXJlYURhdGEpKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuaXNSYW5nZUNoYXJ0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEV2ZW50RGV0ZWN0VHlwZShzZXJpZXMsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByZW5kZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgcG9pbnRPbkNvbHVtbixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMuc2VyaWVzIHx8IHt9LFxuICAgICAgICAgICAgdGlja0Rpc3RhbmNlLFxuICAgICAgICAgICAgdGlja0NvdW50LFxuICAgICAgICAgICAgYXJlYVN0YWNrU2VyaWVzLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpbmVQb2ludHNNb2RlbCA9IHRoaXMucmVuZGVyTGluZVBvaW50c01vZGVsKGFyZWFEYXRhLCBsaW1pdCwgcmVuZGVyT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGFyZWFTZXJpZXNNb2RlbCA9IHRoaXMucmVuZGVyQXJlYVBvaW50c01vZGVsKCk7XG4gICAgICAgIGNvbnN0IHNob3dEb3QgPSAhISgoX2ggPSBvcHRpb25zLnNlcmllcykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLnNob3dEb3QpO1xuICAgICAgICBjb25zdCB7IGRvdFNlcmllc01vZGVsLCByZXNwb25kZXJNb2RlbCB9ID0gdGhpcy5yZW5kZXJDaXJjbGVNb2RlbChzaG93RG90KTtcbiAgICAgICAgY29uc3QgdG9vbHRpcERhdGFBcnIgPSB0aGlzLm1ha2VUb29sdGlwRGF0YShhcmVhRGF0YSwgcmF3Q2F0ZWdvcmllcyk7XG4gICAgICAgIHRoaXMubW9kZWxzID0gZGVlcENvcHkoe1xuICAgICAgICAgICAgcmVjdDogW3RoaXMucmVuZGVyQ2xpcFJlY3RBcmVhTW9kZWwoKV0sXG4gICAgICAgICAgICBzZXJpZXM6IFsuLi50aGlzLmxpbmVQb2ludHNNb2RlbCwgLi4uYXJlYVNlcmllc01vZGVsXSxcbiAgICAgICAgICAgIGRvdDogZG90U2VyaWVzTW9kZWwsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMuZHJhd01vZGVscykge1xuICAgICAgICAgICAgdGhpcy5kcmF3TW9kZWxzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm1vZGVscyksIHsgcmVjdDogW3RoaXMucmVuZGVyQ2xpcFJlY3RBcmVhTW9kZWwodHJ1ZSldIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXREYXRhTGFiZWxzT3B0aW9ucyhvcHRpb25zLCB0aGlzLm5hbWUpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRGF0YUxhYmVscyh0aGlzLmdldERhdGFMYWJlbHMoYXJlYVNlcmllc01vZGVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b29sdGlwQ2lyY2xlTWFwID0gbWFrZVRvb2x0aXBDaXJjbGVNYXAocmVzcG9uZGVyTW9kZWwsIHRvb2x0aXBEYXRhQXJyKTtcbiAgICAgICAgdGhpcy5yZXNwb25kZXJzID0gdGhpcy5nZXRSZXNwb25kZXJzKHJlc3BvbmRlck1vZGVsLCB0b29sdGlwRGF0YUFyciwgY2F0ZWdvcmllcywgcmF3Q2F0ZWdvcmllcywgYXhlcy54QXhpcyk7XG4gICAgfVxuICAgIGdldFJlc3BvbmRlcnMocmVzcG9uZGVyTW9kZWwsIHRvb2x0aXBEYXRhQXJyLCBjYXRlZ29yaWVzLCByYXdDYXRlZ29yaWVzLCBheGlzRGF0YSkge1xuICAgICAgICBpZiAodGhpcy5ldmVudERldGVjdFR5cGUgPT09ICduZWFyJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZU5lYXJUeXBlUmVzcG9uZGVyTW9kZWwocmVzcG9uZGVyTW9kZWwsIHRvb2x0aXBEYXRhQXJyLCByYXdDYXRlZ29yaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ldmVudERldGVjdFR5cGUgPT09ICdwb2ludCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VOZWFyVHlwZVJlc3BvbmRlck1vZGVsKHJlc3BvbmRlck1vZGVsLCB0b29sdGlwRGF0YUFyciwgcmF3Q2F0ZWdvcmllcywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ha2VSZWN0UmVzcG9uZGVyTW9kZWwodGhpcy5yZWN0LCBheGlzRGF0YSwgY2F0ZWdvcmllcyk7XG4gICAgfVxuICAgIG1ha2VOZWFyVHlwZVJlc3BvbmRlck1vZGVsKHNlcmllc0NpcmNsZU1vZGVsLCB0b29sdGlwRGF0YUFyciwgY2F0ZWdvcmllcywgZGV0ZWN0aW9uU2l6ZSkge1xuICAgICAgICBjb25zdCB0b29sdGlwRGF0YUxlbmd0aCA9IHRvb2x0aXBEYXRhQXJyLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHNlcmllc0NpcmNsZU1vZGVsLm1hcCgobSwgZGF0YUluZGV4KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyBkYXRhOiB0b29sdGlwRGF0YUFycltkYXRhSW5kZXggJSB0b29sdGlwRGF0YUxlbmd0aF0sIGRldGVjdGlvblNpemUsIGxhYmVsOiBjYXRlZ29yaWVzW20uaW5kZXhdIH0pKSk7XG4gICAgfVxuICAgIHJlbmRlckNsaXBSZWN0QXJlYU1vZGVsKGlzRHJhd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnY2xpcFJlY3RBcmVhJyxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IGlzRHJhd01vZGVsID8gMCA6IHRoaXMucmVjdC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5yZWN0LmhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbWFrZVRvb2x0aXBEYXRhKGFyZWFEYXRhLCBjYXRlZ29yaWVzKSB7XG4gICAgICAgIHJldHVybiBhcmVhRGF0YS5mbGF0TWFwKCh7IHJhd0RhdGEsIG5hbWUsIGNvbG9yIH0sIHNlcmllc0luZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0b29sdGlwRGF0YSA9IFtdO1xuICAgICAgICAgICAgcmF3RGF0YS5mb3JFYWNoKChkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChkYXR1bSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmlzUmFuZ2VDaGFydCA/IGAke2RhdHVtWzBdfSB+ICR7ZGF0dW1bMV19YCA6IGRhdHVtO1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBjYXRlZ29yaWVzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRvb2x0aXBEYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TGluZVBvaW50TW9kZWxWYWx1ZShkYXR1bSwgcGFpck1vZGVsKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmFuZ2VDaGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhaXJNb2RlbCA/IGRhdHVtWzBdIDogZGF0dW1bMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdHVtO1xuICAgIH1cbiAgICBnZXRMaW5lUG9pbnRNb2RlbChzZXJpZXMsIHNlcmllc0luZGV4LCBsaW1pdCwgcmVuZGVyT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHBvaW50T25Db2x1bW4sIHRpY2tEaXN0YW5jZSwgcGFpck1vZGVsLCBhcmVhU3RhY2tTZXJpZXMgfSA9IHJlbmRlck9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgcmF3RGF0YSwgbmFtZSwgY29sb3I6IHNlcmllc0NvbG9yIH0gPSBzZXJpZXM7XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuYWN0aXZlU2VyaWVzTWFwW25hbWVdO1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgY29uc3QgY29sb3IgPSBnZXRSR0JBKHNlcmllc0NvbG9yLCBhY3RpdmUgPyBzZXJpZXNPcGFjaXR5LkFDVElWRSA6IHNlcmllc09wYWNpdHkuSU5BQ1RJVkUpO1xuICAgICAgICBjb25zdCB7IGxpbmVXaWR0aCwgZGFzaFNlZ21lbnRzIH0gPSB0aGlzLnRoZW1lO1xuICAgICAgICByYXdEYXRhLmZvckVhY2goKGRhdHVtLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc051bGwoZGF0dW0pKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldExpbmVQb2ludE1vZGVsVmFsdWUoZGF0dW0sIHBhaXJNb2RlbCk7XG4gICAgICAgICAgICBjb25zdCBzdGFja2VkVmFsdWUgPSB0aGlzLmlzU3RhY2tDaGFydFxuICAgICAgICAgICAgICAgID8gdGhpcy5nZXRTdGFja1ZhbHVlKGFyZWFTdGFja1Nlcmllcywgc2VyaWVzSW5kZXgsIGlkeClcbiAgICAgICAgICAgICAgICA6IHZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVSYXRpbyA9IGdldFZhbHVlUmF0aW8oc3RhY2tlZFZhbHVlLCBsaW1pdCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gdGlja0Rpc3RhbmNlICogKGlkeCAtIHRoaXMuc3RhcnRJbmRleCkgKyAocG9pbnRPbkNvbHVtbiA/IHRpY2tEaXN0YW5jZSAvIDIgOiAwKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSAoMSAtIHZhbHVlUmF0aW8pICogdGhpcy5yZWN0LmhlaWdodDtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHsgeCwgeSwgdmFsdWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFpck1vZGVsKSB7XG4gICAgICAgICAgICBwb2ludHMucmV2ZXJzZSgpOyAvLyBmb3IgcmFuZ2Ugc3BsaW5lXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNTcGxpbmVDaGFydCkge1xuICAgICAgICAgICAgc2V0U3BsaW5lQ29udHJvbFBvaW50KHBvaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdsaW5lUG9pbnRzJyxcbiAgICAgICAgICAgIGxpbmVXaWR0aCxcbiAgICAgICAgICAgIGRhc2hTZWdtZW50cyxcbiAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgICAgc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXJMaW5lUG9pbnRzTW9kZWwoc2VyaWVzUmF3RGF0YSwgbGltaXQsIHJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbGluZVBvaW50c01vZGVscyA9IHNlcmllc1Jhd0RhdGEubWFwKChzZXJpZXMsIHNlcmllc0luZGV4KSA9PiB0aGlzLmdldExpbmVQb2ludE1vZGVsKHNlcmllcywgc2VyaWVzSW5kZXgsIGxpbWl0LCByZW5kZXJPcHRpb25zKSk7XG4gICAgICAgIGlmICh0aGlzLmlzUmFuZ2VDaGFydCkge1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyT3B0aW9uc0ZvclBhaXIgPSBkZWVwTWVyZ2VkQ29weShyZW5kZXJPcHRpb25zLCB7IHBhaXJNb2RlbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBzZXJpZXNSYXdEYXRhLm1hcCgoc2VyaWVzLCBzZXJpZXNJbmRleCkgPT4gdGhpcy5nZXRMaW5lUG9pbnRNb2RlbChzZXJpZXMsIHNlcmllc0luZGV4LCBsaW1pdCwgcmVuZGVyT3B0aW9uc0ZvclBhaXIpKTtcbiAgICAgICAgICAgIGxpbmVQb2ludHNNb2RlbHMucHVzaCguLi5wYWlyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZVBvaW50c01vZGVscztcbiAgICB9XG4gICAgZ2V0Q29tYmluZWRQb2ludHMoc3RhcnQsIGVuZCkge1xuICAgICAgICBjb25zdCBzdGFydFBvaW50cyA9IHN0YXJ0ID49IDAgPyB0aGlzLmxpbmVQb2ludHNNb2RlbFtzdGFydF0ucG9pbnRzIDogW107XG4gICAgICAgIGNvbnN0IHJldmVyc2VkRW5kUG9pbnRzID0gWy4uLnRoaXMubGluZVBvaW50c01vZGVsW2VuZF0ucG9pbnRzXS5yZXZlcnNlKCk7XG4gICAgICAgIHJldHVybiBbLi4uc3RhcnRQb2ludHMsIC4uLnJldmVyc2VkRW5kUG9pbnRzXTtcbiAgICB9XG4gICAgcmVuZGVyUmFuZ2VBcmVhU2VyaWVzKGxpbmVQb2ludHNNb2RlbCkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IFtdO1xuICAgICAgICBsaW5lUG9pbnRzTW9kZWwuZm9yRWFjaCgobSkgPT4ge1xuICAgICAgICAgICAgbGV0IGFyZWFQb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHsgcG9pbnRzIH0gPSBtO1xuICAgICAgICAgICAgcG9pbnRzLnNsaWNlKDAsIHBvaW50cy5sZW5ndGggLyAyICsgMSkuZm9yRWFjaCgocG9pbnQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UG9pbnQgPSBpID09PSBwb2ludHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVsbFBvaW50ID0gaXNOdWxsKHBvaW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIW51bGxQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBhcmVhUG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJlYVBvaW50cy5sZW5ndGggJiYgKGxhc3RQb2ludCB8fCBudWxsUG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhaXJQb2ludHMgPSBhcmVhUG9pbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChhcmVhUG9pbnQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VySWR4ID0gcG9pbnRzLmxlbmd0aCAvIDIgKyBpIC0gYXJlYVBvaW50cy5sZW5ndGggKyBpZHggKyAoIW51bGxQb2ludCAmJiBsYXN0UG9pbnQgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRzW2N1cklkeF07XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbSksIHsgdHlwZTogJ2FyZWFQb2ludHMnLCBsaW5lV2lkdGg6IDAsIGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwKScsIGZpbGxDb2xvcjogdGhpcy5nZXRBcmVhT3BhY2l0eShtLm5hbWUsIG0uY29sb3IpLCBwb2ludHM6IFsuLi5hcmVhUG9pbnRzLCAuLi5wYWlyUG9pbnRzXSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGFyZWFQb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9XG4gICAgcmVuZGVyQXJlYVNlcmllcyhsaW5lUG9pbnRzTW9kZWwpIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSBbXTtcbiAgICAgICAgY29uc3QgYm90dG9tWVBvaW50ID0gW107XG4gICAgICAgIGxpbmVQb2ludHNNb2RlbC5mb3JFYWNoKChtKSA9PiB7XG4gICAgICAgICAgICBsZXQgYXJlYVBvaW50cyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgY3VyQm90dG9tWVBvaW50ID0gWy4uLmJvdHRvbVlQb2ludF07XG4gICAgICAgICAgICBjb25zdCB7IHBvaW50cyB9ID0gbTtcbiAgICAgICAgICAgIHBvaW50cy5mb3JFYWNoKChwb2ludCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RQb2ludCA9IGkgPT09IHBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bGxQb2ludCA9IGlzTnVsbChwb2ludCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwocG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZWFQb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhcmVhUG9pbnRzLmxlbmd0aCAmJiAobnVsbFBvaW50IHx8IGxhc3RQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFpclBvaW50cyA9IGFyZWFQb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGFyZWFQb2ludCwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJJZHggPSBpIC0gYXJlYVBvaW50cy5sZW5ndGggKyBpZHggKyAoIW51bGxQb2ludCAmJiBsYXN0UG9pbnQgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBib3R0b20gPSBpc1VuZGVmaW5lZChjdXJCb3R0b21ZUG9pbnRbY3VySWR4XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuYmFzZVlQb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VyQm90dG9tWVBvaW50W2N1cklkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0YWNrQ2hhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b21ZUG9pbnRbY3VySWR4XSA9IGFyZWFQb2ludC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogYXJlYVBvaW50LngsIHk6IGJvdHRvbSB9O1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFja0NoYXJ0ICYmIHRoaXMuaXNTcGxpbmVDaGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3BsaW5lQ29udHJvbFBvaW50KHBhaXJQb2ludHMpOyAvLyBzZXQgc3BsaW5lIGZvciBuZXcgc3RhY2sgcGFpciBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtb2RlbC5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbSksIHsgdHlwZTogJ2FyZWFQb2ludHMnLCBsaW5lV2lkdGg6IDAsIGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwKScsIGZpbGxDb2xvcjogdGhpcy5nZXRBcmVhT3BhY2l0eShtLm5hbWUsIG0uY29sb3IpLCBwb2ludHM6IFsuLi5hcmVhUG9pbnRzLCAuLi5wYWlyUG9pbnRzXSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGFyZWFQb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9XG4gICAgZ2V0Q29tYmluZWRMaW5lUG9pbnRzTW9kZWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1JhbmdlQ2hhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVQb2ludHNNb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxpbmVQb2ludHNNb2RlbC5sZW5ndGggLyAyO1xuICAgICAgICByZXR1cm4gcmFuZ2UoMCwgbGVuKS5yZWR1Y2UoKGFjYywgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBpO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gbGVuICsgaTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuZ2V0Q29tYmluZWRQb2ludHMoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICByZXR1cm4gWy4uLmFjYywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxpbmVQb2ludHNNb2RlbFtpXSksIHsgcG9pbnRzIH0pXTtcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICBnZXRBcmVhT3BhY2l0eShuYW1lLCBjb2xvcikge1xuICAgICAgICBjb25zdCB7IHNlbGVjdCwgYXJlYU9wYWNpdHkgfSA9IHRoaXMudGhlbWU7XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuYWN0aXZlU2VyaWVzTWFwW25hbWVdO1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IE9iamVjdC52YWx1ZXModGhpcy5hY3RpdmVTZXJpZXNNYXApLnNvbWUoKGVsZW0pID0+ICFlbGVtKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkXG4gICAgICAgICAgICA/IGdldFJHQkEoY29sb3IsIGFjdGl2ZSA/IHNlbGVjdC5hcmVhT3BhY2l0eSA6IHNlbGVjdC5yZXN0U2VyaWVzLmFyZWFPcGFjaXR5KVxuICAgICAgICAgICAgOiBnZXRSR0JBKGNvbG9yLCBhcmVhT3BhY2l0eSk7XG4gICAgfVxuICAgIHJlbmRlckFyZWFQb2ludHNNb2RlbCgpIHtcbiAgICAgICAgY29uc3QgY29tYmluZWRMaW5lUG9pbnRzTW9kZWwgPSB0aGlzLmdldENvbWJpbmVkTGluZVBvaW50c01vZGVsKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzUmFuZ2VDaGFydFxuICAgICAgICAgICAgPyB0aGlzLnJlbmRlclJhbmdlQXJlYVNlcmllcyhjb21iaW5lZExpbmVQb2ludHNNb2RlbClcbiAgICAgICAgICAgIDogdGhpcy5yZW5kZXJBcmVhU2VyaWVzKGNvbWJpbmVkTGluZVBvaW50c01vZGVsKTtcbiAgICB9XG4gICAgcmVuZGVyQ2lyY2xlTW9kZWwoc2hvd0RvdCkge1xuICAgICAgICBjb25zdCBkb3RTZXJpZXNNb2RlbCA9IFtdO1xuICAgICAgICBjb25zdCByZXNwb25kZXJNb2RlbCA9IFtdO1xuICAgICAgICBjb25zdCB7IGRvdDogZG90VGhlbWUgfSA9IHRoaXMudGhlbWU7XG4gICAgICAgIHRoaXMubGluZVBvaW50c01vZGVsLmZvckVhY2goKHsgcG9pbnRzLCBjb2xvciwgc2VyaWVzSW5kZXgsIG5hbWUgfSwgbW9kZWxJbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNQYWlyTGluZVBvaW50c01vZGVsID0gdGhpcy5pc1JhbmdlQ2hhcnQgJiYgbW9kZWxJbmRleCA+PSB0aGlzLmxpbmVQb2ludHNNb2RlbC5sZW5ndGggLyAyO1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5hY3RpdmVTZXJpZXNNYXBbbmFtZV07XG4gICAgICAgICAgICBwb2ludHMuZm9yRWFjaCgocG9pbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmIChpc051bGwocG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB0eXBlOiAnY2lyY2xlJyB9LCBwb2ludCksIHsgc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsIGluZGV4OiBpc1BhaXJMaW5lUG9pbnRzTW9kZWwgPyBwb2ludHMubGVuZ3RoIC0gaW5kZXggLSAxIDogaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3dEb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZG90U2VyaWVzTW9kZWwucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1vZGVsKSwgeyByYWRpdXM6IGRvdFRoZW1lLnJhZGl1cywgY29sb3I6IGdldFJHQkEoY29sb3IsIGFjdGl2ZSA/IDEgOiAwLjMpLCBzdHlsZTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbGluZVdpZHRoOiBkb3RUaGVtZS5ib3JkZXJXaWR0aCwgc3Ryb2tlU3R5bGU6IChfYSA9IGRvdFRoZW1lLmJvcmRlckNvbG9yLCAoX2EgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29sb3IpKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbmRlck1vZGVsLnB1c2goLi4udGhpcy5nZXRSZXNwb25kZXJTZXJpZXNXaXRoVGhlbWUoW21vZGVsXSwgJ2hvdmVyJywgY29sb3IpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgZG90U2VyaWVzTW9kZWwsIHJlc3BvbmRlck1vZGVsIH07XG4gICAgfVxuICAgIGdldFBhaXJDaXJjbGVNb2RlbChjaXJjbGVNb2RlbHMpIHtcbiAgICAgICAgY29uc3QgcGFpckNpcmNsZU1vZGVscyA9IFtdO1xuICAgICAgICBjaXJjbGVNb2RlbHMuZm9yRWFjaCgoY2lyY2xlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHNlcmllc0luZGV4LCB5LCBkYXRhIH0gPSBjaXJjbGU7XG4gICAgICAgICAgICBjb25zdCB7IGNhdGVnb3J5IH0gPSBkYXRhO1xuICAgICAgICAgICAgY29uc3QgcGFpckNpcmNsZU1vZGVsID0gdGhpcy50b29sdGlwQ2lyY2xlTWFwW2NhdGVnb3J5XS5maW5kKChtb2RlbCkgPT4gbW9kZWwuc2VyaWVzSW5kZXggPT09IHNlcmllc0luZGV4ICYmIG1vZGVsLnkgIT09IHkpO1xuICAgICAgICAgICAgcGFpckNpcmNsZU1vZGVscy5wdXNoKHBhaXJDaXJjbGVNb2RlbCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGFpckNpcmNsZU1vZGVscztcbiAgICB9XG4gICAgZ2V0Q2lyY2xlTW9kZWxzRnJvbVJlY3RSZXNwb25kZXJzKHJlc3BvbmRlcnMsIG1vdXNlUG9zaXRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFyZXNwb25kZXJzLmxlbmd0aCB8fCAhcmVzcG9uZGVyc1swXS5sYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVscyA9IChfYSA9IHRoaXMudG9vbHRpcENpcmNsZU1hcFtyZXNwb25kZXJzWzBdLmxhYmVsXSwgKF9hICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50RGV0ZWN0VHlwZSA9PT0gJ2dyb3VwZWQnXG4gICAgICAgICAgICA/IG1vZGVsc1xuICAgICAgICAgICAgOiBnZXROZWFyZXN0UmVzcG9uZGVyKG1vZGVscywgbW91c2VQb3NpdGlvbnMsIHRoaXMucmVjdCk7XG4gICAgfVxuICAgIG9uTW91c2Vtb3ZlR3JvdXBlZFR5cGUocmVzcG9uZGVycykge1xuICAgICAgICBjb25zdCBjaXJjbGVNb2RlbHMgPSB0aGlzLmdldENpcmNsZU1vZGVsc0Zyb21SZWN0UmVzcG9uZGVycyhyZXNwb25kZXJzKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJIb3ZlcmVkU2VyaWVzJywge1xuICAgICAgICAgICAgbW9kZWxzOiBjaXJjbGVNb2RlbHMsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBldmVudERldGVjdFR5cGU6IHRoaXMuZXZlbnREZXRlY3RUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZWRSZXNwb25kZXJzID0gdGhpcy5pc1JhbmdlQ2hhcnRcbiAgICAgICAgICAgID8gY2lyY2xlTW9kZWxzLnNsaWNlKDAsIGNpcmNsZU1vZGVscy5sZW5ndGggLyAyKSAvLyBmb3IgcmVuZGVyaW5nIHVuaXF1ZSB0b29sdGlwIGRhdGFcbiAgICAgICAgICAgIDogY2lyY2xlTW9kZWxzO1xuICAgIH1cbiAgICBvbk1vdXNlbW92ZU5lYXJlc3RUeXBlKHJlc3BvbmRlcnMsIG1vdXNlUG9zaXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNpcmNsZU1vZGVscyA9IHRoaXMuZ2V0Q2lyY2xlTW9kZWxzRnJvbVJlY3RSZXNwb25kZXJzKHJlc3BvbmRlcnMsIG1vdXNlUG9zaXRpb25zKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlbW92ZU5lYXJUeXBlKGNpcmNsZU1vZGVscyk7XG4gICAgfVxuICAgIG9uTW91c2Vtb3ZlTmVhclR5cGUocmVzcG9uZGVycykge1xuICAgICAgICBsZXQgcGFpckNpcmNsZU1vZGVscyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5pc1JhbmdlQ2hhcnQpIHtcbiAgICAgICAgICAgIHBhaXJDaXJjbGVNb2RlbHMgPSB0aGlzLmdldFBhaXJDaXJjbGVNb2RlbChyZXNwb25kZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3ZlcmVkU2VyaWVzID0gWy4uLnJlc3BvbmRlcnMsIC4uLnBhaXJDaXJjbGVNb2RlbHNdO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlckhvdmVyZWRTZXJpZXMnLCB7XG4gICAgICAgICAgICBtb2RlbHM6IGhvdmVyZWRTZXJpZXMsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBldmVudERldGVjdFR5cGU6IHRoaXMuZXZlbnREZXRlY3RUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZWRSZXNwb25kZXJzID0gcmVzcG9uZGVycztcbiAgICB9XG4gICAgb25Nb3VzZW1vdmUoeyByZXNwb25kZXJzLCBtb3VzZVBvc2l0aW9uIH0pIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnREZXRlY3RUeXBlID09PSAnbmVhcmVzdCcpIHtcbiAgICAgICAgICAgIHRoaXMub25Nb3VzZW1vdmVOZWFyZXN0VHlwZShyZXNwb25kZXJzLCBtb3VzZVBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChbJ25lYXInLCAncG9pbnQnXS5pbmNsdWRlcyh0aGlzLmV2ZW50RGV0ZWN0VHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMub25Nb3VzZW1vdmVOZWFyVHlwZShyZXNwb25kZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25Nb3VzZW1vdmVHcm91cGVkVHlwZShyZXNwb25kZXJzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nlcmllc1BvaW50SG92ZXJlZCcsIHsgbW9kZWxzOiB0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMsIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCduZWVkRHJhdycpO1xuICAgIH1cbiAgICBnZXREYXRhTGFiZWxzKHNlcmllc01vZGVscykge1xuICAgICAgICBjb25zdCBkYXRhTGFiZWxUaGVtZSA9IHRoaXMudGhlbWUuZGF0YUxhYmVscztcbiAgICAgICAgcmV0dXJuIHNlcmllc01vZGVscy5mbGF0TWFwKCh7IHBvaW50cywgbmFtZSwgZmlsbENvbG9yIH0pID0+IHBvaW50cy5tYXAoKHBvaW50KSA9PiBpc051bGwocG9pbnQpXG4gICAgICAgICAgICA/IHt9XG4gICAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdwb2ludCcgfSwgcG9pbnQpLCB7IG5hbWUsIHRoZW1lOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGFMYWJlbFRoZW1lKSwgeyBjb2xvcjogZGF0YUxhYmVsVGhlbWUudXNlU2VyaWVzQ29sb3IgPyBnZXRSR0JBKGZpbGxDb2xvciwgMSkgOiBkYXRhTGFiZWxUaGVtZS5jb2xvciB9KSB9KSkpO1xuICAgIH1cbiAgICBnZXRSZXNwb25kZXJTZXJpZXNXaXRoVGhlbWUobW9kZWxzLCB0eXBlLCBzZXJpZXNDb2xvcikge1xuICAgICAgICBjb25zdCB7IHJhZGl1cywgY29sb3IsIGJvcmRlcldpZHRoLCBib3JkZXJDb2xvciB9ID0gdGhpcy50aGVtZVt0eXBlXS5kb3Q7XG4gICAgICAgIHJldHVybiBtb2RlbHMubWFwKChtb2RlbCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgbW9kZWxDb2xvciA9IChfYSA9IChjb2xvciAhPT0gbnVsbCAmJiBjb2xvciAhPT0gdm9pZCAwID8gY29sb3IgOiBtb2RlbC5jb2xvciksIChfYSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzZXJpZXNDb2xvcikpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbW9kZWwpLCB7IHJhZGl1cywgY29sb3I6IG1vZGVsQ29sb3IsIHN0eWxlOiBbeyBsaW5lV2lkdGg6IGJvcmRlcldpZHRoLCBzdHJva2VTdHlsZTogKGJvcmRlckNvbG9yICE9PSBudWxsICYmIGJvcmRlckNvbG9yICE9PSB2b2lkIDAgPyBib3JkZXJDb2xvciA6IGdldFJHQkEobW9kZWxDb2xvciwgMC41KSkgfV0gfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbkNsaWNrKHsgcmVzcG9uZGVycywgbW91c2VQb3NpdGlvbiB9KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIGxldCBtb2RlbHM7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudERldGVjdFR5cGUgPT09ICduZWFyJykge1xuICAgICAgICAgICAgICAgIG1vZGVscyA9IHJlc3BvbmRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb2RlbHMgPSB0aGlzLmdldENpcmNsZU1vZGVsc0Zyb21SZWN0UmVzcG9uZGVycyhyZXNwb25kZXJzLCBtb3VzZVBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVyU2VsZWN0ZWRTZXJpZXMnLCB7XG4gICAgICAgICAgICAgICAgbW9kZWxzOiB0aGlzLmdldFJlc3BvbmRlclNlcmllc1dpdGhUaGVtZShtb2RlbHMsICdzZWxlY3QnKSxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSZXNwb25kZXJDYXRlZ29yeUJ5SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgcmVzcG9uZGVyID0gT2JqZWN0LnZhbHVlcyh0aGlzLnRvb2x0aXBDaXJjbGVNYXApXG4gICAgICAgICAgICAuZmxhdE1hcCgodmFsKSA9PiB2YWwpXG4gICAgICAgICAgICAuZmluZCgobW9kZWwpID0+IG1vZGVsLmluZGV4ID09PSBpbmRleCk7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSByZXNwb25kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2F0ZWdvcnk7XG4gICAgfVxufVxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi9jb21wb25lbnRcIjtcbmltcG9ydCB7IG1ha2VUaWNrUGl4ZWxQb3NpdGlvbnMsIGNyaXNwUGl4ZWwgfSBmcm9tIFwiLi4vaGVscGVycy9jYWxjdWxhdG9yXCI7XG5pbXBvcnQgeyBUSUNLX1NJWkUgfSBmcm9tIFwiLi4vYnJ1c2hlcy9heGlzXCI7XG5pbXBvcnQgeyBpbmNsdWRlcyB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXRBeGlzVGhlbWUgfSBmcm9tIFwiLi4vaGVscGVycy9heGVzXCI7XG5pbXBvcnQgeyBnZXRUaXRsZUZvbnRTdHJpbmcgfSBmcm9tIFwiLi4vaGVscGVycy9zdHlsZVwiO1xuZXhwb3J0IHZhciBBeGlzVHlwZTtcbihmdW5jdGlvbiAoQXhpc1R5cGUpIHtcbiAgICBBeGlzVHlwZVtcIlhcIl0gPSBcInhBeGlzXCI7XG4gICAgQXhpc1R5cGVbXCJZXCJdID0gXCJ5QXhpc1wiO1xuICAgIEF4aXNUeXBlW1wiU0VDT05EQVJZX1lcIl0gPSBcInNlY29uZGFyeVlBeGlzXCI7XG4gICAgQXhpc1R5cGVbXCJDSVJDVUxBUlwiXSA9IFwiY2lyY3VsYXJBeGlzXCI7XG4gICAgQXhpc1R5cGVbXCJWRVJUSUNBTFwiXSA9IFwidmVydGljYWxBeGlzXCI7XG59KShBeGlzVHlwZSB8fCAoQXhpc1R5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0T2Zmc2V0QW5kQW5jaG9yS2V5KGhhc0Jhc2VkWUF4aXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXRLZXk6IGhhc0Jhc2VkWUF4aXMgPyAneScgOiAneCcsXG4gICAgICAgIGFuY2hvcktleTogaGFzQmFzZWRZQXhpcyA/ICd4JyA6ICd5JyxcbiAgICB9O1xufVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXhpcyBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubW9kZWxzID0geyBsYWJlbDogW10sIHRpY2s6IFtdLCBheGlzTGluZTogW10gfTtcbiAgICAgICAgdGhpcy5heGlzU2l6ZSA9IDA7XG4gICAgfVxuICAgIGluaXRpYWxpemUoeyBuYW1lIH0pIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ2F4aXMnO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnlBeGlzQ29tcG9uZW50ID0gaW5jbHVkZXMoW0F4aXNUeXBlLlksIEF4aXNUeXBlLlNFQ09OREFSWV9ZXSwgbmFtZSk7XG4gICAgfVxuICAgIHJlbmRlcih7IGxheW91dCwgYXhlcywgdGhlbWUsIHNjYWxlIH0pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoYXhlcy5jZW50ZXJZQXhpcyB8fCAhYXhlc1t0aGlzLm5hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aGVtZSA9IGdldEF4aXNUaGVtZSh0aGVtZSwgdGhpcy5uYW1lKTtcbiAgICAgICAgdGhpcy5yZWN0ID0gbGF5b3V0W3RoaXMubmFtZV07XG4gICAgICAgIHRoaXMuYXhpc1NpemUgPSB0aGlzLnlBeGlzQ29tcG9uZW50ID8gdGhpcy5yZWN0LmhlaWdodCA6IHRoaXMucmVjdC53aWR0aDtcbiAgICAgICAgY29uc3QgeyB2aWV3TGFiZWxzIH0gPSBheGVzW3RoaXMubmFtZV07XG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0S2V5LCBhbmNob3JLZXkgfSA9IGdldE9mZnNldEFuZEFuY2hvcktleSh0aGlzLnlBeGlzQ29tcG9uZW50KTtcbiAgICAgICAgY29uc3QgcmVuZGVyT3B0aW9ucyA9IHRoaXMubWFrZVJlbmRlck9wdGlvbnMoYXhlc1t0aGlzLm5hbWVdLCAoX2EgPSBzY2FsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3RoaXMubmFtZV0pO1xuICAgICAgICBjb25zdCBoYXNPbmx5QXhpc0xpbmUgPSB0aGlzLmhhc09ubHlBeGlzTGluZSgpO1xuICAgICAgICBpZiAoIWhhc09ubHlBeGlzTGluZSkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbHMubGFiZWwgPSB0aGlzLnJlbmRlckxhYmVsTW9kZWxzKHZpZXdMYWJlbHMsIG9mZnNldEtleSwgYW5jaG9yS2V5LCByZW5kZXJPcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWxzLnRpY2sgPSB0aGlzLnJlbmRlclRpY2tNb2RlbHMob2Zmc2V0S2V5LCBhbmNob3JLZXksIHJlbmRlck9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWxzLmF4aXNMaW5lID0gW3RoaXMucmVuZGVyQXhpc0xpbmVNb2RlbCgpXTtcbiAgICAgICAgaWYgKCF0aGlzLmRyYXdNb2RlbHMpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd01vZGVscyA9IHtcbiAgICAgICAgICAgICAgICB0aWNrOiBbXSxcbiAgICAgICAgICAgICAgICBsYWJlbDogW10sXG4gICAgICAgICAgICAgICAgYXhpc0xpbmU6IHRoaXMubW9kZWxzLmF4aXNMaW5lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFsndGljaycsICdsYWJlbCddLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdNb2RlbHNbdHlwZV0gPSB0aGlzLm1vZGVsc1t0eXBlXS5tYXAoKG0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHJhd01vZGVsID0gT2JqZWN0LmFzc2lnbih7fSwgbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnlBeGlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3TW9kZWwueSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3TW9kZWwueCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRyYXdNb2RlbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlckF4aXNMaW5lTW9kZWwoKSB7XG4gICAgICAgIGNvbnN0IHplcm9QaXhlbCA9IGNyaXNwUGl4ZWwoMCk7XG4gICAgICAgIGxldCBsaW5lTW9kZWw7XG4gICAgICAgIGNvbnN0IHsgY29sb3I6IHN0cm9rZVN0eWxlLCB3aWR0aDogbGluZVdpZHRoIH0gPSB0aGlzLnRoZW1lO1xuICAgICAgICBpZiAodGhpcy55QXhpc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMuZ2V0WUF4aXNYUG9pbnQoKTtcbiAgICAgICAgICAgIGxpbmVNb2RlbCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5OiB6ZXJvUGl4ZWwsXG4gICAgICAgICAgICAgICAgeDI6IHgsXG4gICAgICAgICAgICAgICAgeTI6IGNyaXNwUGl4ZWwodGhpcy5heGlzU2l6ZSksXG4gICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGUsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVNb2RlbCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgeDogemVyb1BpeGVsLFxuICAgICAgICAgICAgICAgIHk6IHplcm9QaXhlbCxcbiAgICAgICAgICAgICAgICB4MjogY3Jpc3BQaXhlbCh0aGlzLmF4aXNTaXplKSxcbiAgICAgICAgICAgICAgICB5MjogemVyb1BpeGVsLFxuICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVNb2RlbDtcbiAgICB9XG4gICAgcmVuZGVyVGlja01vZGVscyhvZmZzZXRLZXksIGFuY2hvcktleSwgcmVuZGVyT3B0aW9ucykge1xuICAgICAgICBjb25zdCB0aWNrQW5jaG9yUG9pbnQgPSB0aGlzLnlBeGlzQ29tcG9uZW50ID8gdGhpcy5nZXRZQXhpc1hQb2ludCgpIDogY3Jpc3BQaXhlbCgwKTtcbiAgICAgICAgY29uc3QgeyB0aWNrSW50ZXJ2YWwsIHJlbGF0aXZlUG9zaXRpb25zIH0gPSByZW5kZXJPcHRpb25zO1xuICAgICAgICBjb25zdCB0aWNrU2l6ZSA9IGluY2x1ZGVzKFtBeGlzVHlwZS5TRUNPTkRBUllfWSwgQXhpc1R5cGUuWF0sIHRoaXMubmFtZSlcbiAgICAgICAgICAgID8gVElDS19TSVpFXG4gICAgICAgICAgICA6IC1USUNLX1NJWkU7XG4gICAgICAgIHJldHVybiByZWxhdGl2ZVBvc2l0aW9ucy5yZWR1Y2UoKHBvc2l0aW9ucywgcG9zaXRpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXggJSB0aWNrSW50ZXJ2YWxcbiAgICAgICAgICAgICAgICA/IHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgIDogW1xuICAgICAgICAgICAgICAgICAgICAuLi5wb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0aWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzWUF4aXM6IHRoaXMueUF4aXNDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtvZmZzZXRLZXldOiBjcmlzcFBpeGVsKHBvc2l0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFthbmNob3JLZXldOiB0aWNrQW5jaG9yUG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogdGhpcy50aGVtZS5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogdGhpcy50aGVtZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIHJlbmRlckxhYmVsTW9kZWxzKGxhYmVscywgb2Zmc2V0S2V5LCBhbmNob3JLZXksIHJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBuZWVkUm90YXRlTGFiZWwsIHJhZGlhbiwgb2Zmc2V0WSB9ID0gcmVuZGVyT3B0aW9ucztcbiAgICAgICAgY29uc3QgbGFiZWxUaGVtZSA9IHRoaXMudGhlbWUubGFiZWw7XG4gICAgICAgIGNvbnN0IGZvbnQgPSBnZXRUaXRsZUZvbnRTdHJpbmcobGFiZWxUaGVtZSk7XG4gICAgICAgIGNvbnN0IHRleHRBbGlnbiA9IHRoaXMuZ2V0TGFiZWxUZXh0QWxpZ24obmVlZFJvdGF0ZUxhYmVsKTtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBbJ2RlZmF1bHQnLCB7IHRleHRBbGlnbiwgZm9udCwgZmlsbFN0eWxlOiBsYWJlbFRoZW1lLmNvbG9yIH1dO1xuICAgICAgICBjb25zdCBsYWJlbEFuY2hvclBvaW50ID0gdGhpcy55QXhpc0NvbXBvbmVudCA/IHRoaXMuZ2V0WUF4aXNBbmNob3JQb2ludCgpIDogb2Zmc2V0WTtcbiAgICAgICAgcmV0dXJuIGxhYmVscy5tYXAoKHsgdGV4dCwgb2Zmc2V0UG9zIH0pID0+ICh7XG4gICAgICAgICAgICB0eXBlOiAnbGFiZWwnLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgICAgcmFkaWFuLFxuICAgICAgICAgICAgW29mZnNldEtleV06IGNyaXNwUGl4ZWwob2Zmc2V0UG9zKSxcbiAgICAgICAgICAgIFthbmNob3JLZXldOiBsYWJlbEFuY2hvclBvaW50LFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIG1ha2VSZW5kZXJPcHRpb25zKGF4aXNEYXRhLCBzY2FsZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IHsgdGlja0NvdW50LCB0aWNrSW50ZXJ2YWwgfSA9IGF4aXNEYXRhO1xuICAgICAgICBjb25zdCBzaXplUmF0aW8gPSAoX2IgPSAoX2EgPSBzY2FsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpemVSYXRpbywgKF9iICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDEpKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb25SYXRpbyA9IChfZCA9IChfYyA9IHNjYWxlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucG9zaXRpb25SYXRpbywgKF9kICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDApKTtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQb3NpdGlvbnMgPSBtYWtlVGlja1BpeGVsUG9zaXRpb25zKHRoaXMuYXhpc1NpemUgKiBzaXplUmF0aW8sIHRpY2tDb3VudCwgdGhpcy5heGlzU2l6ZSAqIHBvc2l0aW9uUmF0aW8pO1xuICAgICAgICBpZiAodGhpcy55QXhpc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVBvc2l0aW9ucyxcbiAgICAgICAgICAgICAgICB0aWNrSW50ZXJ2YWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmVlZFJvdGF0ZUxhYmVsLCByYWRpYW4sIG9mZnNldFkgfSA9IGF4aXNEYXRhO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVsYXRpdmVQb3NpdGlvbnMsXG4gICAgICAgICAgICB0aWNrSW50ZXJ2YWwsXG4gICAgICAgICAgICBuZWVkUm90YXRlTGFiZWwsXG4gICAgICAgICAgICByYWRpYW4sXG4gICAgICAgICAgICBvZmZzZXRZLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRZQXhpc0FuY2hvclBvaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1JpZ2h0U2lkZSgpID8gY3Jpc3BQaXhlbCh0aGlzLnJlY3Qud2lkdGgpIDogY3Jpc3BQaXhlbCgwKTtcbiAgICB9XG4gICAgZ2V0TGFiZWxUZXh0QWxpZ24obmVlZFJvdGF0ZUxhYmVsKSB7XG4gICAgICAgIGNvbnN0IHlBeGlzVGV4dEFsaWduID0gdGhpcy5pc1JpZ2h0U2lkZSgpID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgeEF4aXNUZXh0QWxpZ24gPSBuZWVkUm90YXRlTGFiZWwgPyAnbGVmdCcgOiAnY2VudGVyJztcbiAgICAgICAgcmV0dXJuIHRoaXMueUF4aXNDb21wb25lbnQgPyB5QXhpc1RleHRBbGlnbiA6IHhBeGlzVGV4dEFsaWduO1xuICAgIH1cbiAgICBpc1JpZ2h0U2lkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSA9PT0gQXhpc1R5cGUuU0VDT05EQVJZX1k7XG4gICAgfVxuICAgIGdldFlBeGlzWFBvaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1JpZ2h0U2lkZSgpID8gY3Jpc3BQaXhlbCgwKSA6IGNyaXNwUGl4ZWwodGhpcy5yZWN0LndpZHRoKTtcbiAgICB9XG4gICAgaGFzT25seUF4aXNMaW5lKCkge1xuICAgICAgICByZXR1cm4gKCh0aGlzLnlBeGlzQ29tcG9uZW50ICYmICF0aGlzLnJlY3Qud2lkdGgpIHx8ICh0aGlzLm5hbWUgPT09IEF4aXNUeXBlLlggJiYgIXRoaXMucmVjdC5oZWlnaHQpKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuL2NvbXBvbmVudFwiO1xuaW1wb3J0IHsgQXhpc1R5cGUgfSBmcm9tIFwiLi9heGlzXCI7XG5pbXBvcnQgeyBpbmNsdWRlcyB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXRUaXRsZUZvbnRTdHJpbmcgfSBmcm9tIFwiLi4vaGVscGVycy9zdHlsZVwiO1xuaW1wb3J0IHsgZ2V0QXhpc1RoZW1lIH0gZnJvbSBcIi4uL2hlbHBlcnMvYXhlc1wiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXhpc1RpdGxlIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBpbml0aWFsaXplKHsgbmFtZSB9KSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdheGlzVGl0bGUnO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmlzWUF4aXMgPSBpbmNsdWRlcyhbQXhpc1R5cGUuWSwgQXhpc1R5cGUuU0VDT05EQVJZX1ldLCBuYW1lKTtcbiAgICAgICAgdGhpcy5pc0NpcmN1bGFyQXhpcyA9IHRoaXMubmFtZSA9PT0gQXhpc1R5cGUuQ0lSQ1VMQVI7XG4gICAgfVxuICAgIGdldFRpdGxlUG9zaXRpb24ob2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgICAgICBpZiAodGhpcy5pc0NpcmN1bGFyQXhpcykge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnJlY3Qud2lkdGggLyAyICsgb2Zmc2V0WCwgdGhpcy5yZWN0LmhlaWdodCAvIDIgKyBvZmZzZXRZXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pc1lBeGlzXG4gICAgICAgICAgICA/IFt0aGlzLm5hbWUgPT09IEF4aXNUeXBlLlkgPyBvZmZzZXRYIDogdGhpcy5yZWN0LndpZHRoICsgb2Zmc2V0WCwgb2Zmc2V0WV1cbiAgICAgICAgICAgIDogW3RoaXMucmVjdC53aWR0aCArIG9mZnNldFgsIG9mZnNldFldO1xuICAgIH1cbiAgICByZW5kZXJBeGlzVGl0bGUob3B0aW9uLCB0ZXh0QWxpZ24pIHtcbiAgICAgICAgY29uc3QgeyB0ZXh0LCBvZmZzZXRYLCBvZmZzZXRZIH0gPSBvcHRpb247XG4gICAgICAgIGNvbnN0IFt4LCB5XSA9IHRoaXMuZ2V0VGl0bGVQb3NpdGlvbihvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgY29uc3QgZm9udCA9IGdldFRpdGxlRm9udFN0cmluZyh0aGlzLnRoZW1lKTtcbiAgICAgICAgY29uc3QgZmlsbFN0eWxlID0gdGhpcy50aGVtZS5jb2xvcjtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGFiZWwnLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgIHN0eWxlOiBbJ2F4aXNUaXRsZScsIHsgdGV4dEFsaWduLCBmaWxsU3R5bGUsIGZvbnQgfV0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH1cbiAgICBnZXRUZXh0QWxpZ24oaGFzQ2VudGVyWUF4aXMgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5uYW1lID09PSBBeGlzVHlwZS5ZKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzQ2VudGVyWUF4aXMgPyAnY2VudGVyJyA6ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0NpcmN1bGFyQXhpcykge1xuICAgICAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAncmlnaHQnO1xuICAgIH1cbiAgICBnZXRDaXJjdWxhckF4aXNUaXRsZVJlY3Qob3B0aW9uLCBwbG90UmVjdCwgY2lyY3VsYXJBeGlzRGF0YSkge1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHBsb3RSZWN0O1xuICAgICAgICBjb25zdCB7IGNlbnRlclgsIGNlbnRlclksIGF4aXNTaXplLCByYWRpdXM6IHsgb3V0ZXI6IG91dGVyUmFkaXVzIH0sIH0gPSBjaXJjdWxhckF4aXNEYXRhO1xuICAgICAgICBjb25zdCB7IG9mZnNldFkgfSA9IG9wdGlvbjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGNlbnRlclggKyB4IC0gYXhpc1NpemUgLyAyLFxuICAgICAgICAgICAgeTogY2VudGVyWSArIHkgLSBvdXRlclJhZGl1cyAvIDIsXG4gICAgICAgICAgICB3aWR0aDogYXhpc1NpemUsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMudGhlbWUuZm9udFNpemUgKyBvZmZzZXRZLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoeyBheGVzLCByYWRpYWxBeGVzLCBsYXlvdXQsIHRoZW1lIH0pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IHRpdGxlT3B0aW9uID0gdGhpcy5pc0NpcmN1bGFyQXhpcyA/IChfYSA9IHJhZGlhbEF4ZXNbdGhpcy5uYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRpdGxlIDogKF9iID0gYXhlc1t0aGlzLm5hbWVdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudGl0bGU7XG4gICAgICAgIHRoaXMuaXNTaG93ID0gISF0aXRsZU9wdGlvbjtcbiAgICAgICAgaWYgKCF0aGlzLmlzU2hvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhlbWUgPSBnZXRBeGlzVGhlbWUodGhlbWUsIHRoaXMubmFtZSkudGl0bGU7XG4gICAgICAgIHRoaXMucmVjdCA9IGxheW91dFtgJHt0aGlzLm5hbWV9VGl0bGVgXTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSB0aGlzLnJlbmRlckF4aXNUaXRsZSh0aXRsZU9wdGlvbiwgdGhpcy5nZXRUZXh0QWxpZ24oISEoKF9jID0gYXhlcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNlbnRlcllBeGlzKSkpO1xuICAgIH1cbn1cbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIi4vY29tcG9uZW50XCI7XG5pbXBvcnQgeyBtYWtlVGlja1BpeGVsUG9zaXRpb25zLCBjcmlzcFBpeGVsIH0gZnJvbSBcIi4uL2hlbHBlcnMvY2FsY3VsYXRvclwiO1xuaW1wb3J0IHsgZ2V0QXhpc1RoZW1lIH0gZnJvbSBcIi4uL2hlbHBlcnMvYXhlc1wiO1xuaW1wb3J0IHsgZ2V0VGl0bGVGb250U3RyaW5nIH0gZnJvbSBcIi4uL2hlbHBlcnMvc3R5bGVcIjtcbmltcG9ydCB7IEF4aXNUeXBlIH0gZnJvbSBcIi4vYXhpc1wiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXhpc1VzaW5nQ2VudGVyWSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubW9kZWxzID0geyBsYWJlbDogW10sIHRpY2s6IFtdLCBheGlzTGluZTogW10gfTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSh7IG5hbWUgfSkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnYXhpcyc7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMueUF4aXNDb21wb25lbnQgPSBuYW1lID09PSBBeGlzVHlwZS5ZO1xuICAgIH1cbiAgICByZW5kZXIoeyBsYXlvdXQsIGF4ZXMsIHRoZW1lIH0pIHtcbiAgICAgICAgY29uc3QgeyBjZW50ZXJZQXhpcyB9ID0gYXhlcztcbiAgICAgICAgaWYgKCFjZW50ZXJZQXhpcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhlbWUgPSBnZXRBeGlzVGhlbWUodGhlbWUsIHRoaXMubmFtZSk7XG4gICAgICAgIHRoaXMucmVjdCA9IGxheW91dFt0aGlzLm5hbWVdO1xuICAgICAgICBpZiAodGhpcy5uYW1lID09PSAneUF4aXMnKSB7XG4gICAgICAgICAgICB0aGlzLnJlY3QgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucmVjdCksIHsgeDogY2VudGVyWUF4aXMueCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHZpZXdMYWJlbHMsIHRpY2tDb3VudCwgdGlja0ludGVydmFsLCBuZWVkUm90YXRlTGFiZWwsIHJhZGlhbiwgb2Zmc2V0WSB9ID0gYXhlc1t0aGlzLm5hbWVdO1xuICAgICAgICBjb25zdCByZW5kZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgdGlja0ludGVydmFsLFxuICAgICAgICAgICAgY2VudGVyWUF4aXMsXG4gICAgICAgICAgICBuZWVkUm90YXRlTGFiZWwsXG4gICAgICAgICAgICByYWRpYW4sXG4gICAgICAgICAgICBvZmZzZXRZLFxuICAgICAgICAgICAgcmVsYXRpdmVQb3NpdGlvbnM6IG1ha2VUaWNrUGl4ZWxQb3NpdGlvbnModGhpcy5heGlzU2l6ZShjZW50ZXJZQXhpcyksIHRpY2tDb3VudCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9mZnNldEtleSA9IHRoaXMueUF4aXNDb21wb25lbnQgPyAneScgOiAneCc7XG4gICAgICAgIGNvbnN0IGFuY2hvcktleSA9IHRoaXMueUF4aXNDb21wb25lbnQgPyAneCcgOiAneSc7XG4gICAgICAgIHRoaXMubW9kZWxzLmxhYmVsID0gdGhpcy5yZW5kZXJMYWJlbE1vZGVscyh2aWV3TGFiZWxzLCBvZmZzZXRLZXksIGFuY2hvcktleSwgcmVuZGVyT3B0aW9ucyk7XG4gICAgICAgIHRoaXMubW9kZWxzLnRpY2sgPSB0aGlzLnJlbmRlclRpY2tNb2RlbHMob2Zmc2V0S2V5LCBhbmNob3JLZXksIHJlbmRlck9wdGlvbnMpO1xuICAgICAgICB0aGlzLm1vZGVscy5heGlzTGluZSA9IHRoaXMucmVuZGVyQXhpc0xpbmVNb2RlbChjZW50ZXJZQXhpcyk7XG4gICAgICAgIGlmICghdGhpcy5kcmF3TW9kZWxzKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdNb2RlbHMgPSB7XG4gICAgICAgICAgICAgICAgdGljazogW10sXG4gICAgICAgICAgICAgICAgbGFiZWw6IFtdLFxuICAgICAgICAgICAgICAgIGF4aXNMaW5lOiB0aGlzLm1vZGVscy5heGlzTGluZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBbJ3RpY2snLCAnbGFiZWwnXS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TW9kZWxzW3R5cGVdID0gdGhpcy5tb2RlbHNbdHlwZV0ubWFwKChtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRyYXdNb2RlbCA9IE9iamVjdC5hc3NpZ24oe30sIG0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy55QXhpc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd01vZGVsLnkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd01vZGVsLnggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkcmF3TW9kZWw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJBeGlzTGluZU1vZGVsKHsgeEF4aXNIYWxmU2l6ZSwgc2Vjb25kU3RhcnRYIH0pIHtcbiAgICAgICAgY29uc3QgemVyb1BpeGVsID0gY3Jpc3BQaXhlbCgwKTtcbiAgICAgICAgY29uc3Qgd2lkdGhQaXhlbCA9IGNyaXNwUGl4ZWwodGhpcy5yZWN0LndpZHRoKTtcbiAgICAgICAgbGV0IGF4aXNMaW5lO1xuICAgICAgICBpZiAodGhpcy55QXhpc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0UGl4ZWwgPSBjcmlzcFBpeGVsKHRoaXMucmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgYXhpc0xpbmUgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgICAgIHg6IHdpZHRoUGl4ZWwsXG4gICAgICAgICAgICAgICAgICAgIHk6IHplcm9QaXhlbCxcbiAgICAgICAgICAgICAgICAgICAgeDI6IHdpZHRoUGl4ZWwsXG4gICAgICAgICAgICAgICAgICAgIHkyOiBoZWlnaHRQaXhlbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgICAgICB4OiB6ZXJvUGl4ZWwsXG4gICAgICAgICAgICAgICAgICAgIHk6IHplcm9QaXhlbCxcbiAgICAgICAgICAgICAgICAgICAgeDI6IHplcm9QaXhlbCxcbiAgICAgICAgICAgICAgICAgICAgeTI6IGhlaWdodFBpeGVsLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXhpc0xpbmUgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgICAgIHg6IHplcm9QaXhlbCxcbiAgICAgICAgICAgICAgICAgICAgeTogemVyb1BpeGVsLFxuICAgICAgICAgICAgICAgICAgICB4MjogY3Jpc3BQaXhlbCh4QXhpc0hhbGZTaXplKSxcbiAgICAgICAgICAgICAgICAgICAgeTI6IHplcm9QaXhlbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgICAgICB4OiBjcmlzcFBpeGVsKHNlY29uZFN0YXJ0WCksXG4gICAgICAgICAgICAgICAgICAgIHk6IHplcm9QaXhlbCxcbiAgICAgICAgICAgICAgICAgICAgeDI6IHdpZHRoUGl4ZWwsXG4gICAgICAgICAgICAgICAgICAgIHkyOiB6ZXJvUGl4ZWwsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF4aXNMaW5lO1xuICAgIH1cbiAgICByZW5kZXJUaWNrTW9kZWxzKG9mZnNldEtleSwgYW5jaG9yS2V5LCByZW5kZXJPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHRpY2tBbmNob3JQb2ludCA9IHRoaXMueUF4aXNDb21wb25lbnQgPyBjcmlzcFBpeGVsKHRoaXMucmVjdC53aWR0aCkgOiBjcmlzcFBpeGVsKDApO1xuICAgICAgICBjb25zdCB7IHRpY2tJbnRlcnZhbCwgY2VudGVyWUF4aXM6IHsgc2Vjb25kU3RhcnRYIH0sIHJlbGF0aXZlUG9zaXRpb25zLCB9ID0gcmVuZGVyT3B0aW9ucztcbiAgICAgICAgcmV0dXJuIHJlbGF0aXZlUG9zaXRpb25zLnJlZHVjZSgocG9zaXRpb25zLCBwb3NpdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRleCAlIHRpY2tJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2RlbCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGljaycsXG4gICAgICAgICAgICAgICAgaXNZQXhpczogdGhpcy55QXhpc0NvbXBvbmVudCxcbiAgICAgICAgICAgICAgICB0aWNrU2l6ZTogdGhpcy55QXhpc0NvbXBvbmVudCA/IC01IDogNSxcbiAgICAgICAgICAgICAgICBbb2Zmc2V0S2V5XTogY3Jpc3BQaXhlbChwb3NpdGlvbiksXG4gICAgICAgICAgICAgICAgW2FuY2hvcktleV06IHRpY2tBbmNob3JQb2ludCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBhZGRlZFRpY2tNb2RlbCA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGVsKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnlBeGlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgYWRkZWRUaWNrTW9kZWxbYW5jaG9yS2V5XSA9IGNyaXNwUGl4ZWwoMCk7XG4gICAgICAgICAgICAgICAgYWRkZWRUaWNrTW9kZWwudGlja1NpemUgPSA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkZWRUaWNrTW9kZWxbb2Zmc2V0S2V5XSA9IGNyaXNwUGl4ZWwocG9zaXRpb24gKyBzZWNvbmRTdGFydFgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFsuLi5wb3NpdGlvbnMsIG1vZGVsLCBhZGRlZFRpY2tNb2RlbF07XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgcmVuZGVyTGFiZWxNb2RlbHMobGFiZWxzLCBvZmZzZXRLZXksIGFuY2hvcktleSwgcmVuZGVyT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGNlbnRlcllBeGlzOiB7IHNlY29uZFN0YXJ0WCwgeUF4aXNMYWJlbEFuY2hvclBvaW50IH0sIG9mZnNldFksIG5lZWRSb3RhdGVMYWJlbCwgcmFkaWFuLCB9ID0gcmVuZGVyT3B0aW9ucztcbiAgICAgICAgY29uc3QgbGFiZWxUaGVtZSA9IHRoaXMudGhlbWUubGFiZWw7XG4gICAgICAgIGNvbnN0IGZvbnQgPSBnZXRUaXRsZUZvbnRTdHJpbmcobGFiZWxUaGVtZSk7XG4gICAgICAgIGxldCBsYWJlbEFuY2hvclBvaW50LCB0ZXh0QWxpZ24sIHRleHRMYWJlbHM7XG4gICAgICAgIGlmICh0aGlzLnlBeGlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBsYWJlbEFuY2hvclBvaW50ID0gY3Jpc3BQaXhlbCh5QXhpc0xhYmVsQW5jaG9yUG9pbnQpO1xuICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICB0ZXh0TGFiZWxzID0gbGFiZWxzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFiZWxBbmNob3JQb2ludCA9IG9mZnNldFk7XG4gICAgICAgICAgICB0ZXh0TGFiZWxzID0gWy4uLmxhYmVsc10ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgdGV4dEFsaWduID0gbmVlZFJvdGF0ZUxhYmVsID8gJ2xlZnQnIDogJ2NlbnRlcic7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3R5bGUgPSBbJ2RlZmF1bHQnLCB7IHRleHRBbGlnbiwgZm9udCwgZmlsbFN0eWxlOiBsYWJlbFRoZW1lLmNvbG9yIH1dO1xuICAgICAgICByZXR1cm4gdGV4dExhYmVscy5yZWR1Y2UoKHBvc2l0aW9ucywgeyB0ZXh0LCBvZmZzZXRQb3MgfSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsYWJlbCcsXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICAgICAgICBbb2Zmc2V0S2V5XTogY3Jpc3BQaXhlbChvZmZzZXRQb3MpICsgKHRoaXMueUF4aXNDb21wb25lbnQgPyAwIDogc2Vjb25kU3RhcnRYKSxcbiAgICAgICAgICAgICAgICBbYW5jaG9yS2V5XTogbGFiZWxBbmNob3JQb2ludCxcbiAgICAgICAgICAgICAgICByYWRpYW4sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgbW9kZWxzID0gW21vZGVsXTtcbiAgICAgICAgICAgIGlmICghdGhpcy55QXhpc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZGVkTGFiZWxNb2RlbCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbW9kZWwpLCB7IHRleHQ6IGxhYmVsc1tpbmRleF0udGV4dCwgW29mZnNldEtleV06IGNyaXNwUGl4ZWwobW9kZWxbb2Zmc2V0S2V5XSAtIHNlY29uZFN0YXJ0WCkgfSk7XG4gICAgICAgICAgICAgICAgbW9kZWxzLnB1c2goYWRkZWRMYWJlbE1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbLi4ucG9zaXRpb25zLCAuLi5tb2RlbHNdO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIGF4aXNTaXplKGNlbnRlcllBeGlzKSB7XG4gICAgICAgIGxldCBzaXplO1xuICAgICAgICBpZiAodGhpcy55QXhpc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgc2l6ZSA9IHRoaXMucmVjdC5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaXplID0gY2VudGVyWUF4aXMueEF4aXNIYWxmU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgYmVmb3JlRHJhdyhwYWludGVyKSB7XG4gICAgICAgIHBhaW50ZXIuY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwgMCwgMCwgMC41KSc7XG4gICAgICAgIHBhaW50ZXIuY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgfVxufVxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi9jb21wb25lbnRcIjtcbmltcG9ydCB7IGlzVXNpbmdSZXNldEJ1dHRvbiB9IGZyb20gXCIuLi9zdG9yZS9sYXlvdXRcIjtcbmltcG9ydCB7IEJVVFRPTl9SRUNUX1NJWkUgfSBmcm9tIFwiLi9leHBvcnRNZW51XCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYWNrQnV0dG9uIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnYmFja0J1dHRvbic7XG4gICAgICAgIHRoaXMubmFtZSA9ICdiYWNrQnV0dG9uJztcbiAgICB9XG4gICAgb25DbGljayh7IHJlc3BvbmRlcnMgfSkge1xuICAgICAgICBpZiAocmVzcG9uZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3pvb21CYWNrJyk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Jlc2V0U2VsZWN0ZWRTZXJpZXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoeyBvcHRpb25zLCBsYXlvdXQgfSwgY29tcHV0ZWQpIHtcbiAgICAgICAgaWYgKCFpc1VzaW5nUmVzZXRCdXR0b24ob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlY3QgPSBsYXlvdXQucmVzZXRCdXR0b247XG4gICAgICAgIHRoaXMuaXNTaG93ID0gY29tcHV0ZWQuaXNUcmVlbWFwU2VyaWVzWm9vbWluZztcbiAgICAgICAgdGhpcy5tb2RlbHMgPSB0aGlzLmlzU2hvdyA/IFt7IHR5cGU6ICdiYWNrQnV0dG9uJywgeDogMCwgeTogMCB9XSA6IFtdO1xuICAgICAgICB0aGlzLnJlc3BvbmRlcnMgPSB0aGlzLmlzU2hvd1xuICAgICAgICAgICAgPyBbeyB0eXBlOiAncmVjdCcsIHg6IDAsIHk6IDAsIHdpZHRoOiBCVVRUT05fUkVDVF9TSVpFLCBoZWlnaHQ6IEJVVFRPTl9SRUNUX1NJWkUgfV1cbiAgICAgICAgICAgIDogW107XG4gICAgfVxufVxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi9jb21wb25lbnRcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhY2tncm91bmQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdiYWNrZ3JvdW5kJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ2JhY2tncm91bmQnO1xuICAgIH1cbiAgICByZW5kZXIoeyBsYXlvdXQsIHRoZW1lIH0pIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBsYXlvdXQuY2hhcnQ7XG4gICAgICAgIHRoaXMudGhlbWUgPSB0aGVtZS5jaGFydDtcbiAgICAgICAgdGhpcy5yZWN0ID0geyB4OiAwLCB5OiAwLCB3aWR0aCwgaGVpZ2h0IH07XG4gICAgICAgIHRoaXMubW9kZWxzID0gW1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdHlwZTogJ3JlY3QnIH0sIHRoaXMucmVjdCksIHsgY29sb3I6IHRoaXMudGhlbWUuYmFja2dyb3VuZENvbG9yIH0pLFxuICAgICAgICBdO1xuICAgIH1cbn1cbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIi4vY29tcG9uZW50XCI7XG5pbXBvcnQgeyBnZXRBY3RpdmVTZXJpZXNNYXAgfSBmcm9tIFwiLi4vaGVscGVycy9sZWdlbmRcIjtcbmltcG9ydCB7IGdldFJHQkEgfSBmcm9tIFwiLi4vaGVscGVycy9jb2xvclwiO1xuaW1wb3J0IHsgZ2V0Qm94VHlwZVNlcmllc1BhZGRpbmcgfSBmcm9tIFwiLi4vaGVscGVycy9zdHlsZVwiO1xuaW1wb3J0IHsgaXNOdW1iZXIsIGNhbGN1bGF0ZVNpemVXaXRoUGVyY2VudFN0cmluZywgaXNOdWxsIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmltcG9ydCB7IGNyaXNwUGl4ZWwgfSBmcm9tIFwiLi4vaGVscGVycy9jYWxjdWxhdG9yXCI7XG5pbXBvcnQgeyBtZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2VcIjtcbmNvbnN0IE1JTl9CQVJfV0lEVEggPSA1O1xuZnVuY3Rpb24gZ2V0UGFkZGluZyh0aWNrRGlzdGFuY2UsIGJhcldpZHRoLCBzZXJpZXNMZW5ndGgpIHtcbiAgICByZXR1cm4gKHRpY2tEaXN0YW5jZSAtIGJhcldpZHRoICogc2VyaWVzTGVuZ3RoKSAvIChzZXJpZXNMZW5ndGggKyAxKTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRDb2xvcihkZWZhdWx0Q29sb3IsIGNvbG9yKSB7XG4gICAgcmV0dXJuIChjb2xvciAhPT0gbnVsbCAmJiBjb2xvciAhPT0gdm9pZCAwID8gY29sb3IgOiBkZWZhdWx0Q29sb3IpO1xufVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm94UGxvdFNlcmllcyBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubW9kZWxzID0geyByZWN0OiBbXSwgbGluZTogW10sIGNpcmNsZTogW10gfTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZWRSZXNwb25kZXJzID0gW107XG4gICAgICAgIHRoaXMuZXZlbnREZXRlY3RUeXBlID0gJ3BvaW50JztcbiAgICAgICAgdGhpcy5vbk1vdXNlb3V0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzZXJpZXNQb2ludEhvdmVyZWQnLCB7IG1vZGVsczogW10sIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVySG92ZXJlZFNlcmllcycsIHtcbiAgICAgICAgICAgICAgICBtb2RlbHM6IFtdLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBldmVudERldGVjdFR5cGU6IHRoaXMuZXZlbnREZXRlY3RUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VsZWN0U2VyaWVzID0gKHsgaW5kZXgsIHNlcmllc0luZGV4LCBzdGF0ZSwgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc051bWJlcihpbmRleCkgfHwgIWlzTnVtYmVyKHNlcmllc0luZGV4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gc3RhdGUuc2VyaWVzLmJveFBsb3Rbc2VyaWVzSW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgbW9kZWxzID0gdGhpcy5nZXRSZXNwb25kZXJzV2l0aFRoZW1lKHRoaXMudG9vbHRpcFJlY3RNYXBbYCR7bmFtZX0tJHtpbmRleH1gXSwgJ3NlbGVjdCcpO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJTZWxlY3RlZFNlcmllcycsIHtcbiAgICAgICAgICAgICAgICBtb2RlbHMsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGV2ZW50RGV0ZWN0VHlwZTogdGhpcy5ldmVudERldGVjdFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zaG93VG9vbHRpcCA9ICh7IGluZGV4LCBzZXJpZXNJbmRleCwgc3RhdGUgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc051bWJlcihpbmRleCkgfHwgIWlzTnVtYmVyKHNlcmllc0luZGV4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gc3RhdGUuc2VyaWVzLmJveFBsb3Rbc2VyaWVzSW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgbW9kZWxzID0gdGhpcy5nZXRSZXNwb25kZXJzV2l0aFRoZW1lKHRoaXMudG9vbHRpcFJlY3RNYXBbYCR7bmFtZX0tJHtpbmRleH1gXSwgJ2hvdmVyJyk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlckhvdmVyZWRTZXJpZXMnLCB7XG4gICAgICAgICAgICAgICAgbW9kZWxzLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBldmVudERldGVjdFR5cGU6IHRoaXMuZXZlbnREZXRlY3RUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMgPSBtb2RlbHM7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nlcmllc1BvaW50SG92ZXJlZCcsIHsgbW9kZWxzOiB0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMsIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ3Nlcmllcyc7XG4gICAgICAgIHRoaXMubmFtZSA9ICdib3hQbG90JztcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignc2VsZWN0U2VyaWVzJywgdGhpcy5zZWxlY3RTZXJpZXMpO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLm9uKCdzaG93VG9vbHRpcCcsIHRoaXMuc2hvd1Rvb2x0aXApO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLm9uKCdoaWRlVG9vbHRpcCcsIHRoaXMub25Nb3VzZW91dENvbXBvbmVudCk7XG4gICAgfVxuICAgIHJlbmRlcihzdGF0ZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB7IGxheW91dCwgYXhlcywgc2VyaWVzLCBzY2FsZSwgbGVnZW5kLCBvcHRpb25zLCB0aGVtZSB9ID0gc3RhdGU7XG4gICAgICAgIGlmICghc2VyaWVzLmJveFBsb3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlLm5vRGF0YUVycm9yKHRoaXMubmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoX2IgPSAoX2EgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VyaWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZXZlbnREZXRlY3RUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGV0ZWN0VHlwZSA9IG9wdGlvbnMuc2VyaWVzLmV2ZW50RGV0ZWN0VHlwZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWUuc2VyaWVzLmJveFBsb3Q7XG4gICAgICAgIHRoaXMucmVjdCA9IGxheW91dC5wbG90O1xuICAgICAgICB0aGlzLmFjdGl2ZVNlcmllc01hcCA9IGdldEFjdGl2ZVNlcmllc01hcChsZWdlbmQpO1xuICAgICAgICB0aGlzLnNlbGVjdGFibGUgPSB0aGlzLmdldFNlbGVjdGFibGVPcHRpb24ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBzdGF0ZS5jYXRlZ29yaWVzO1xuICAgICAgICBjb25zdCB7IHRpY2tEaXN0YW5jZSB9ID0gYXhlcy54QXhpcztcbiAgICAgICAgY29uc3QgeyBtaW4sIG1heCB9ID0gc2NhbGUueUF4aXMubGltaXQ7XG4gICAgICAgIGNvbnN0IGJveFBsb3REYXRhID0gc2VyaWVzLmJveFBsb3QuZGF0YTtcbiAgICAgICAgY29uc3Qgc2VyaWVzTGVuZ3RoID0gYm94UGxvdERhdGEubGVuZ3RoO1xuICAgICAgICBjb25zdCByZW5kZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHJhdGlvOiB0aGlzLnJlY3QuaGVpZ2h0IC8gKG1heCAtIG1pbiksIHRpY2tEaXN0YW5jZSB9LCB0aGlzLmdldEJhcldpZHRocyh0aWNrRGlzdGFuY2UsIHNlcmllc0xlbmd0aCkpO1xuICAgICAgICBjb25zdCBib3hQbG90TW9kZWxEYXRhID0gdGhpcy5tYWtlQm94UGxvdHMoYm94UGxvdERhdGEsIHJlbmRlck9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzZXJpZXNNb2RlbHMgPSB0aGlzLnJlbmRlclNlcmllc01vZGVscyhib3hQbG90TW9kZWxEYXRhKTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSBzZXJpZXNNb2RlbHM7XG4gICAgICAgIGlmICghdGhpcy5kcmF3TW9kZWxzKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdNb2RlbHMgPSB7XG4gICAgICAgICAgICAgICAgcmVjdDogc2VyaWVzTW9kZWxzLnJlY3QubWFwKChtKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyB5OiBtLnkgKyBtLmhlaWdodCwgaGVpZ2h0OiAwIH0pKSksXG4gICAgICAgICAgICAgICAgbGluZTogc2VyaWVzTW9kZWxzLmxpbmUsXG4gICAgICAgICAgICAgICAgY2lyY2xlOiBzZXJpZXNNb2RlbHMuY2lyY2xlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b29sdGlwRGF0YSA9IHRoaXMubWFrZVRvb2x0aXBNb2RlbChib3hQbG90RGF0YSwgY2F0ZWdvcmllcyk7XG4gICAgICAgIHRoaXMudG9vbHRpcFJlY3RNYXAgPSB0aGlzLm1ha2VUb29sdGlwUmVjdE1hcChib3hQbG90TW9kZWxEYXRhLCB0b29sdGlwRGF0YSk7XG4gICAgICAgIHRoaXMucmVzcG9uZGVycyA9XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGV0ZWN0VHlwZSA9PT0gJ2dyb3VwZWQnXG4gICAgICAgICAgICAgICAgPyB0aGlzLm1ha2VHcm91cGVkUmVzcG9uZGVyTW9kZWwoYm94UGxvdE1vZGVsRGF0YSlcbiAgICAgICAgICAgICAgICA6IHRoaXMubWFrZURlZmF1bHRSZXNwb25kZXJNb2RlbChib3hQbG90TW9kZWxEYXRhLCB0b29sdGlwRGF0YSk7XG4gICAgfVxuICAgIG1ha2VUb29sdGlwUmVjdE1hcChib3hQbG90TW9kZWxEYXRhLCB0b29sdGlwRGF0YSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgYm94UGxvdE1vZGVsRGF0YS5mb3JFYWNoKChtLCB0b29sdGlwSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNOdWxsKG0pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSBgJHttLm5hbWV9LSR7bS5pbmRleH1gO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0W3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcHJvcE5hbWVdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wTmFtZV0ucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubWFrZUhvdmVyZWRNb2RlbChtKSksIHsgZGF0YTogdG9vbHRpcERhdGFbdG9vbHRpcEluZGV4XSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBtYWtlR3JvdXBlZFJlc3BvbmRlck1vZGVsKGJveFBsb3RNb2RlbERhdGEpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGJveFBsb3RNb2RlbERhdGEuZm9yRWFjaCgobSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB0eXBlLCBpbmRleCwgbmFtZSB9ID0gbTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gYCR7bmFtZX0tJHtpbmRleH1gO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdib3hQbG90JyAmJiAhcmVzdWx0W3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYm94UGxvdERldGVjdGlvbiB9ID0gbTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB0eXBlOiAncmVjdCcsIG5hbWU6IHByb3BOYW1lIH0sIGJveFBsb3REZXRlY3Rpb24pLCB7IHk6IDAsIGhlaWdodDogdGhpcy5yZWN0LmhlaWdodCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBtYWtlRGVmYXVsdFJlc3BvbmRlck1vZGVsKGJveFBsb3RNb2RlbERhdGEsIHRvb2x0aXBEYXRhQXJyKSB7XG4gICAgICAgIHJldHVybiBib3hQbG90TW9kZWxEYXRhLm1hcCgobSwgaW5kZXgpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubWFrZUhvdmVyZWRNb2RlbChtKSksIHsgZGF0YTogdG9vbHRpcERhdGFBcnJbaW5kZXhdLCBjb2xvcjogZ2V0UkdCQShtLmNvbG9yLCAxKSB9KSkpO1xuICAgIH1cbiAgICBtYWtlSG92ZXJlZE1vZGVsKG1vZGVsKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gbW9kZWwudHlwZSA9PT0gJ2JveFBsb3QnICYmIG1vZGVsLnJlY3RcbiAgICAgICAgICAgID8geyB4OiBtb2RlbC5yZWN0LngsIHk6IG1vZGVsLnJlY3QueSB9XG4gICAgICAgICAgICA6IHsgeDogbW9kZWwueCwgeTogbW9kZWwueSB9O1xuICAgICAgICBjb25zdCBob3ZlcmVkTW9kZWwgPSBPYmplY3QuYXNzaWduKHt9LCBtb2RlbCk7XG4gICAgICAgIGlmIChtb2RlbC50eXBlID09PSAnYm94UGxvdCcpIHtcbiAgICAgICAgICAgIFsnbG93ZXJXaGlza2VyJywgJ3VwcGVyV2hpc2tlcicsICdtYXhpbXVtJywgJ21pbmltdW0nLCAnbWVkaWFuJ10uZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlbFtwcm9wXSkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbFtwcm9wXS5kZXRlY3Rpb25TaXplID0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1vZGVsLmNvbG9yID0gZ2V0UkdCQShob3ZlcmVkTW9kZWwuY29sb3IsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvdmVyZWRNb2RlbCksIHBvaW50KTtcbiAgICB9XG4gICAgZ2V0UmVzcG9uZGVyTW9kZWxGcm9tTWFwKHJlc3BvbmRlcnMpIHtcbiAgICAgICAgaWYgKCFyZXNwb25kZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BOYW1lID0gcmVzcG9uZGVyc1swXS5uYW1lO1xuICAgICAgICByZXR1cm4gdGhpcy50b29sdGlwUmVjdE1hcFtwcm9wTmFtZV07XG4gICAgfVxuICAgIG9uTW91c2Vtb3ZlKHsgcmVzcG9uZGVycyB9KSB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50RGV0ZWN0VHlwZSA9PT0gJ2dyb3VwZWQnKSB7XG4gICAgICAgICAgICBjb25zdCBtb2RlbHMgPSB0aGlzLmdldFJlc3BvbmRlck1vZGVsRnJvbU1hcChyZXNwb25kZXJzKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVySG92ZXJlZFNlcmllcycsIHtcbiAgICAgICAgICAgICAgICBtb2RlbHM6IHRoaXMuZ2V0UmVzcG9uZGVyc1dpdGhUaGVtZShtb2RlbHMsICdzZWxlY3QnKSxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgZXZlbnREZXRlY3RUeXBlOiB0aGlzLmV2ZW50RGV0ZWN0VHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZWRSZXNwb25kZXJzID0gbW9kZWxzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJIb3ZlcmVkU2VyaWVzJywge1xuICAgICAgICAgICAgICAgIG1vZGVsczogdGhpcy5nZXRSZXNwb25kZXJzV2l0aFRoZW1lKHJlc3BvbmRlcnMsICdob3ZlcicpLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBldmVudERldGVjdFR5cGU6IHRoaXMuZXZlbnREZXRlY3RUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMgPSByZXNwb25kZXJzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnc2VyaWVzUG9pbnRIb3ZlcmVkJywgeyBtb2RlbHM6IHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycywgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgfVxuICAgIG9uQ2xpY2soeyByZXNwb25kZXJzIH0pIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgbGV0IG1vZGVscztcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50RGV0ZWN0VHlwZSA9PT0gJ2dyb3VwZWQnKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxzID0gdGhpcy5nZXRSZXNwb25kZXJzV2l0aFRoZW1lKHRoaXMuZ2V0UmVzcG9uZGVyTW9kZWxGcm9tTWFwKHJlc3BvbmRlcnMpLCAnc2VsZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb2RlbHMgPSB0aGlzLmdldFJlc3BvbmRlcnNXaXRoVGhlbWUocmVzcG9uZGVycywgJ3NlbGVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJTZWxlY3RlZFNlcmllcycsIHtcbiAgICAgICAgICAgICAgICBtb2RlbHMsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGV2ZW50RGV0ZWN0VHlwZTogdGhpcy5ldmVudERldGVjdFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJTZXJpZXNNb2RlbHMoYm94UGxvdHMpIHtcbiAgICAgICAgcmV0dXJuIGJveFBsb3RzLnJlZHVjZSgoYWNjLCBjdXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSwgbmFtZSB9ID0gY3VyO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdib3hQbG90Jykge1xuICAgICAgICAgICAgICAgIGFjYy5yZWN0LnB1c2goT2JqZWN0LmFzc2lnbih7IG5hbWUgfSwgY3VyLnJlY3QpKTtcbiAgICAgICAgICAgICAgICBbJ21heGltdW0nLCAnbWluaW11bScsICdtZWRpYW4nLCAndXBwZXJXaGlza2VyJywgJ2xvd2VyV2hpc2tlciddLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjLmxpbmUucHVzaChPYmplY3QuYXNzaWduKHsgbmFtZSB9LCBjdXJbcHJvcF0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjYy5jaXJjbGUucHVzaChPYmplY3QuYXNzaWduKHt9LCBjdXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHsgcmVjdDogW10sIGxpbmU6IFtdLCBjaXJjbGU6IFtdIH0pO1xuICAgIH1cbiAgICBtYWtlQm94UGxvdHMoc2VyaWVzRGF0YSwgcmVuZGVyT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHJhdGlvLCBiYXJXaWR0aCB9ID0gcmVuZGVyT3B0aW9ucztcbiAgICAgICAgY29uc3QgYm94UGxvdE1vZGVscyA9IFtdO1xuICAgICAgICBjb25zdCBzZXJpZXNMZW5ndGggPSBzZXJpZXNEYXRhLmxlbmd0aDtcbiAgICAgICAgY29uc3QgeyBkb3QgfSA9IHRoaXMudGhlbWU7XG4gICAgICAgIHNlcmllc0RhdGEuZm9yRWFjaCgoeyBvdXRsaWVycywgZGF0YSwgbmFtZSwgY29sb3IgfSwgc2VyaWVzSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlcmllc0NvbG9yID0gdGhpcy5nZXRTZXJpZXNDb2xvcihuYW1lLCBjb2xvcik7XG4gICAgICAgICAgICAoKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdm9pZCAwID8gZGF0YSA6IFtdKSkuZm9yRWFjaCgoZGF0dW0sIGRhdGFJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKGRhdHVtKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydFggPSB0aGlzLmdldFN0YXJ0WChzZXJpZXNJbmRleCwgZGF0YUluZGV4LCByZW5kZXJPcHRpb25zLCBzZXJpZXNMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0gdGhpcy5nZXRSZWN0KGRhdHVtLCBzdGFydFgsIHNlcmllc0NvbG9yLCByZW5kZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgYm94UGxvdE1vZGVscy5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdib3hQbG90JywgY29sb3I6IHNlcmllc0NvbG9yLCBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdCwgbWVkaWFuOiB0aGlzLmdldE1lZGlhbihkYXR1bSwgc3RhcnRYLCBzZXJpZXNDb2xvciwgcmVuZGVyT3B0aW9ucyksIG1pbmltdW06IHRoaXMuZ2V0TWluaW11bShkYXR1bSwgc3RhcnRYLCBzZXJpZXNDb2xvciwgcmVuZGVyT3B0aW9ucyksIG1heGltdW06IHRoaXMuZ2V0TWF4aW11bShkYXR1bSwgc3RhcnRYLCBzZXJpZXNDb2xvciwgcmVuZGVyT3B0aW9ucykgfSwgdGhpcy5nZXRXaGlza2VyKGRhdHVtLCBzdGFydFgsIHNlcmllc0NvbG9yLCByZW5kZXJPcHRpb25zLCByZWN0KSksIHsgaW5kZXg6IGRhdGFJbmRleCwgYm94UGxvdERldGVjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHN0YXJ0WCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgY29sb3I6IGRvdENvbG9yLCByYWRpdXMsIGJvcmRlckNvbG9yLCBib3JkZXJXaWR0aCwgdXNlU2VyaWVzQ29sb3IsIH0gPSBkb3Q7XG4gICAgICAgICAgICAoKG91dGxpZXJzICE9PSBudWxsICYmIG91dGxpZXJzICE9PSB2b2lkIDAgPyBvdXRsaWVycyA6IFtdKSkuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbZGF0YUluZGV4LCB2YWx1ZV0gPSBkYXR1bTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydFggPSB0aGlzLmdldFN0YXJ0WChzZXJpZXNJbmRleCwgZGF0YUluZGV4LCByZW5kZXJPcHRpb25zLCBzZXJpZXNMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJveFBsb3RNb2RlbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjaXJjbGUnLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB4OiBzdGFydFggKyBiYXJXaWR0aCAvIDIsXG4gICAgICAgICAgICAgICAgICAgIHk6IHRoaXMuZ2V0WVBvcyh2YWx1ZSwgcmF0aW8pLFxuICAgICAgICAgICAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFt7IHN0cm9rZVN0eWxlOiAoYm9yZGVyQ29sb3IgIT09IG51bGwgJiYgYm9yZGVyQ29sb3IgIT09IHZvaWQgMCA/IGJvcmRlckNvbG9yIDogc2VyaWVzQ29sb3IpLCBsaW5lV2lkdGg6IGJvcmRlcldpZHRoIH1dLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdXNlU2VyaWVzQ29sb3IgPyBzZXJpZXNDb2xvciA6IGRvdENvbG9yLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogZGF0YUluZGV4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYm94UGxvdE1vZGVscztcbiAgICB9XG4gICAgbWFrZVRvb2x0aXBNb2RlbChzZXJpZXNEYXRhLCBjYXRlZ29yaWVzKSB7XG4gICAgICAgIGNvbnN0IHRvb2x0aXBEYXRhID0gW107XG4gICAgICAgIHNlcmllc0RhdGEuZm9yRWFjaCgoeyBvdXRsaWVycywgZGF0YSwgbmFtZSwgY29sb3IgfSkgPT4ge1xuICAgICAgICAgICAgKChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHZvaWQgMCA/IGRhdGEgOiBbXSkpLmZvckVhY2goKGRhdHVtLCBkYXRhSW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChkYXR1bSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm94UGxvdERhdGEgPSBbLi4uZGF0dW1dLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcERhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ01heGltdW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdVcHBlciBRdWFydGlsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ01lZGlhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0xvd2VyIFF1YXJ0aWxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTWluaW11bScsXG4gICAgICAgICAgICAgICAgICAgICAgICBdLnJlZHVjZSgoYWNjLCB0aXRsZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGJveFBsb3REYXRhW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNOdWxsKHZhbHVlKSA/IGFjYyA6IFsuLi5hY2MsIHsgdGl0bGUsIHZhbHVlIH1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6IGNhdGVnb3JpZXNbZGF0YUluZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlVHlwZTogJ2JveFBsb3QnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICgob3V0bGllcnMgIT09IG51bGwgJiYgb3V0bGllcnMgIT09IHZvaWQgMCA/IG91dGxpZXJzIDogW10pKS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKGRhdHVtKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbZGF0YUluZGV4LCBkYXRhVmFsdWVdID0gZGF0dW07XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW3sgdGl0bGU6ICdPdXRsaWVyJywgdmFsdWU6IGRhdGFWYWx1ZSB9XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBjYXRlZ29yaWVzW2RhdGFJbmRleF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVR5cGU6ICdib3hQbG90JyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG9vbHRpcERhdGE7XG4gICAgfVxuICAgIGdldFN0YXJ0WChzZXJpZXNJbmRleCwgZGF0YUluZGV4LCByZW5kZXJPcHRpb25zLCBzZXJpZXNMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgeyB0aWNrRGlzdGFuY2UsIGJhcldpZHRoIH0gPSByZW5kZXJPcHRpb25zO1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gZ2V0UGFkZGluZyh0aWNrRGlzdGFuY2UsIGJhcldpZHRoLCBzZXJpZXNMZW5ndGgpO1xuICAgICAgICByZXR1cm4gZGF0YUluZGV4ICogdGlja0Rpc3RhbmNlICsgKHNlcmllc0luZGV4ICsgMSkgKiBwYWRkaW5nICsgYmFyV2lkdGggKiBzZXJpZXNJbmRleDtcbiAgICB9XG4gICAgZ2V0WVBvcyh2YWx1ZSwgcmF0aW8sIGxpbmVXaWR0aCkge1xuICAgICAgICByZXR1cm4gaXNOdW1iZXIobGluZVdpZHRoKVxuICAgICAgICAgICAgPyBjcmlzcFBpeGVsKHRoaXMucmVjdC5oZWlnaHQgLSB2YWx1ZSAqIHJhdGlvLCBsaW5lV2lkdGgpXG4gICAgICAgICAgICA6IHRoaXMucmVjdC5oZWlnaHQgLSB2YWx1ZSAqIHJhdGlvO1xuICAgIH1cbiAgICBnZXRCYXJXaWR0aHModGlja0Rpc3RhbmNlLCBzZXJpZXNMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgeyBiYXJXaWR0aDogYmFyVGhlbWVXaWR0aCwgYmFyV2lkdGhSYXRpb3MgfSA9IHRoaXMudGhlbWU7XG4gICAgICAgIGNvbnN0IHsgYmFyUmF0aW8sIG1pbk1heEJhclJhdGlvIH0gPSBiYXJXaWR0aFJhdGlvcztcbiAgICAgICAgY29uc3QgZGVmYXVsdEJhcldpZHRoID0gTWF0aC5tYXgoKHRpY2tEaXN0YW5jZSAtIGdldEJveFR5cGVTZXJpZXNQYWRkaW5nKHRpY2tEaXN0YW5jZSkgKiAoMiArIChzZXJpZXNMZW5ndGggLSAxKSkpIC9cbiAgICAgICAgICAgIHNlcmllc0xlbmd0aCwgTUlOX0JBUl9XSURUSCk7XG4gICAgICAgIGNvbnN0IGJhcldpZHRoID0gYmFyVGhlbWVXaWR0aFxuICAgICAgICAgICAgPyBjYWxjdWxhdGVTaXplV2l0aFBlcmNlbnRTdHJpbmcodGlja0Rpc3RhbmNlIC8gc2VyaWVzTGVuZ3RoLCBiYXJUaGVtZVdpZHRoKVxuICAgICAgICAgICAgOiBkZWZhdWx0QmFyV2lkdGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGggKiBiYXJSYXRpbyxcbiAgICAgICAgICAgIG1pbk1heEJhcldpZHRoOiBiYXJXaWR0aCAqIG1pbk1heEJhclJhdGlvLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRSZXNwb25kZXJzV2l0aFRoZW1lKHJlc3BvbmRlcnMsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgeyBjb2xvciwgcmVjdCwgZG90LCBsaW5lLCBzaGFkb3dDb2xvciwgc2hhZG93T2Zmc2V0WCwgc2hhZG93T2Zmc2V0WSwgc2hhZG93Qmx1ciwgfSA9IHRoaXMudGhlbWVbdHlwZV07XG4gICAgICAgIGNvbnN0IHsgd2hpc2tlciwgbWVkaWFuLCBtYXhpbXVtLCBtaW5pbXVtIH0gPSBsaW5lO1xuICAgICAgICBjb25zdCB7IGNvbG9yOiBkb3RDb2xvciwgcmFkaXVzLCBib3JkZXJDb2xvciwgYm9yZGVyV2lkdGgsIHVzZVNlcmllc0NvbG9yLCB9ID0gZG90O1xuICAgICAgICByZXR1cm4gcmVzcG9uZGVycy5tYXAoKG0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZTogbW9kZWxUeXBlLCBkYXRhIH0gPSBtO1xuICAgICAgICAgICAgbGV0IHNlcmllc0NvbG9yID0gbS5jb2xvcjtcbiAgICAgICAgICAgIGxldCBtb2RlbDtcbiAgICAgICAgICAgIGlmIChtb2RlbFR5cGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzQ29sb3IgPSBkYXRhLmNvbG9yO1xuICAgICAgICAgICAgICAgIG1vZGVsID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyByYWRpdXMsIGNvbG9yOiB1c2VTZXJpZXNDb2xvciA/IHNlcmllc0NvbG9yIDogZG90Q29sb3IsIHN0eWxlOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHN0cm9rZVN0eWxlOiBnZXREZWZhdWx0Q29sb3Ioc2VyaWVzQ29sb3IsIGJvcmRlckNvbG9yKSwgbGluZVdpZHRoOiBib3JkZXJXaWR0aCB9LFxuICAgICAgICAgICAgICAgICAgICBdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZWN0OiBzZXJpZXNSZWN0LCB1cHBlcldoaXNrZXIsIGxvd2VyV2hpc2tlciwgbWVkaWFuOiBzZXJpZXNNZWRpYW4sIG1heGltdW06IHNlcmllc01heGltdW0sIG1pbmltdW06IHNlcmllc01pbmltdW0sIH0gPSBtO1xuICAgICAgICAgICAgICAgIG1vZGVsID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyByZWN0OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlcmllc1JlY3QpLCB7IGNvbG9yOiAoY29sb3IgIT09IG51bGwgJiYgY29sb3IgIT09IHZvaWQgMCA/IGNvbG9yIDogZ2V0UkdCQShzZXJpZXNDb2xvciwgMSkpLCB0aGlja25lc3M6IHJlY3QuYm9yZGVyV2lkdGgsIGJvcmRlckNvbG9yOiByZWN0LmJvcmRlckNvbG9yLCBzdHlsZTogW3sgc2hhZG93Q29sb3IsIHNoYWRvd09mZnNldFgsIHNoYWRvd09mZnNldFksIHNoYWRvd0JsdXIgfV0gfSksIHVwcGVyV2hpc2tlcjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB1cHBlcldoaXNrZXIpLCB7IHN0cm9rZVN0eWxlOiBnZXREZWZhdWx0Q29sb3Ioc2VyaWVzQ29sb3IsIHdoaXNrZXIuY29sb3IpLCBsaW5lV2lkdGg6IHdoaXNrZXIubGluZVdpZHRoIH0pLCBsb3dlcldoaXNrZXI6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG93ZXJXaGlza2VyKSwgeyBzdHJva2VTdHlsZTogZ2V0RGVmYXVsdENvbG9yKHNlcmllc0NvbG9yLCB3aGlza2VyLmNvbG9yKSwgbGluZVdpZHRoOiB3aGlza2VyLmxpbmVXaWR0aCB9KSwgbWVkaWFuOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlcmllc01lZGlhbiksIHsgc3Ryb2tlU3R5bGU6IGdldERlZmF1bHRDb2xvcihzZXJpZXNDb2xvciwgbWVkaWFuLmNvbG9yKSwgbGluZVdpZHRoOiBtZWRpYW4ubGluZVdpZHRoIH0pLCBtYXhpbXVtOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlcmllc01heGltdW0pLCB7IHN0cm9rZVN0eWxlOiBnZXREZWZhdWx0Q29sb3Ioc2VyaWVzQ29sb3IsIG1heGltdW0uY29sb3IpLCBsaW5lV2lkdGg6IG1heGltdW0ubGluZVdpZHRoIH0pLCBtaW5pbXVtOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlcmllc01pbmltdW0pLCB7IHN0cm9rZVN0eWxlOiBnZXREZWZhdWx0Q29sb3Ioc2VyaWVzQ29sb3IsIG1pbmltdW0uY29sb3IpLCBsaW5lV2lkdGg6IG1pbmltdW0ubGluZVdpZHRoIH0pIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UmVjdChkYXR1bSwgc3RhcnRYLCBzZXJpZXNDb2xvciwgeyBiYXJXaWR0aCwgcmF0aW8gfSkge1xuICAgICAgICBjb25zdCB7IHJlY3QgfSA9IHRoaXMudGhlbWU7XG4gICAgICAgIGNvbnN0IFssIGxvd2VyUXVhcnRpbGUsICwgaGlnaFF1YXJ0aWxlXSA9IGRhdHVtO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3JlY3QnLFxuICAgICAgICAgICAgeDogc3RhcnRYLFxuICAgICAgICAgICAgeTogdGhpcy5nZXRZUG9zKGhpZ2hRdWFydGlsZSwgcmF0aW8pLFxuICAgICAgICAgICAgd2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiAoaGlnaFF1YXJ0aWxlIC0gbG93ZXJRdWFydGlsZSkgKiByYXRpbyxcbiAgICAgICAgICAgIHRoaWNrbmVzczogcmVjdC5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiByZWN0LmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgY29sb3I6IHNlcmllc0NvbG9yLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRXaGlza2VyKGRhdHVtLCBzdGFydFgsIHNlcmllc0NvbG9yLCB7IGJhcldpZHRoLCByYXRpbyB9LCByZWN0KSB7XG4gICAgICAgIGNvbnN0IFttaW5pbXVtLCAsICwgLCBtYXhpbXVtXSA9IGRhdHVtO1xuICAgICAgICBjb25zdCB7IGxpbmVXaWR0aCwgY29sb3IgfSA9IHRoaXMudGhlbWUubGluZS53aGlza2VyO1xuICAgICAgICBjb25zdCB4ID0gY3Jpc3BQaXhlbChzdGFydFggKyBiYXJXaWR0aCAvIDIsIGxpbmVXaWR0aCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cHBlcldoaXNrZXI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLmdldFlQb3MobWF4aW11bSwgcmF0aW8sIGxpbmVXaWR0aCksXG4gICAgICAgICAgICAgICAgeDI6IHgsXG4gICAgICAgICAgICAgICAgeTI6IHJlY3QueSxcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogKGNvbG9yICE9PSBudWxsICYmIGNvbG9yICE9PSB2b2lkIDAgPyBjb2xvciA6IHNlcmllc0NvbG9yKSxcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGgsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG93ZXJXaGlza2VyOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5nZXRZUG9zKG1pbmltdW0sIHJhdGlvLCBsaW5lV2lkdGgpLFxuICAgICAgICAgICAgICAgIHgyOiB4LFxuICAgICAgICAgICAgICAgIHkyOiBjcmlzcFBpeGVsKHJlY3QueSArIHJlY3QuaGVpZ2h0LCBsaW5lV2lkdGgpLFxuICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiAoY29sb3IgIT09IG51bGwgJiYgY29sb3IgIT09IHZvaWQgMCA/IGNvbG9yIDogc2VyaWVzQ29sb3IpLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldE1lZGlhbihkYXR1bSwgc3RhcnRYLCBzZXJpZXNDb2xvciwgeyBiYXJXaWR0aCwgcmF0aW8gfSkge1xuICAgICAgICBjb25zdCBtZWRpYW4gPSBkYXR1bVsyXTtcbiAgICAgICAgY29uc3QgeyBsaW5lV2lkdGgsIGNvbG9yIH0gPSB0aGlzLnRoZW1lLmxpbmUubWVkaWFuO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgeDogY3Jpc3BQaXhlbChzdGFydFgsIGxpbmVXaWR0aCksXG4gICAgICAgICAgICB5OiB0aGlzLmdldFlQb3MobWVkaWFuLCByYXRpbywgbGluZVdpZHRoKSxcbiAgICAgICAgICAgIHgyOiBjcmlzcFBpeGVsKHN0YXJ0WCArIGJhcldpZHRoLCBsaW5lV2lkdGgpLFxuICAgICAgICAgICAgeTI6IHRoaXMuZ2V0WVBvcyhtZWRpYW4sIHJhdGlvLCBsaW5lV2lkdGgpLFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IChjb2xvciAhPT0gbnVsbCAmJiBjb2xvciAhPT0gdm9pZCAwID8gY29sb3IgOiBzZXJpZXNDb2xvciksXG4gICAgICAgICAgICBsaW5lV2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0TWluaW11bShkYXR1bSwgc3RhcnRYLCBzZXJpZXNDb2xvciwgeyBiYXJXaWR0aCwgcmF0aW8sIG1pbk1heEJhcldpZHRoIH0pIHtcbiAgICAgICAgY29uc3QgbWluaW11bSA9IGRhdHVtWzBdO1xuICAgICAgICBjb25zdCB7IGxpbmVXaWR0aCwgY29sb3IgfSA9IHRoaXMudGhlbWUubGluZS5taW5pbXVtO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgeDogY3Jpc3BQaXhlbChzdGFydFggKyAoYmFyV2lkdGggLSBtaW5NYXhCYXJXaWR0aCkgLyAyLCBsaW5lV2lkdGgpLFxuICAgICAgICAgICAgeTogdGhpcy5nZXRZUG9zKG1pbmltdW0sIHJhdGlvLCBsaW5lV2lkdGgpLFxuICAgICAgICAgICAgeDI6IGNyaXNwUGl4ZWwoc3RhcnRYICsgKGJhcldpZHRoIC0gbWluTWF4QmFyV2lkdGgpIC8gMiArIG1pbk1heEJhcldpZHRoLCBsaW5lV2lkdGgpLFxuICAgICAgICAgICAgeTI6IHRoaXMuZ2V0WVBvcyhtaW5pbXVtLCByYXRpbywgbGluZVdpZHRoKSxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlOiAoY29sb3IgIT09IG51bGwgJiYgY29sb3IgIT09IHZvaWQgMCA/IGNvbG9yIDogc2VyaWVzQ29sb3IpLFxuICAgICAgICAgICAgbGluZVdpZHRoOiBsaW5lV2lkdGgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldE1heGltdW0oZGF0dW0sIHN0YXJ0WCwgc2VyaWVzQ29sb3IsIHsgYmFyV2lkdGgsIHJhdGlvLCBtaW5NYXhCYXJXaWR0aCB9KSB7XG4gICAgICAgIGNvbnN0IG1heGltdW0gPSBkYXR1bVs0XTtcbiAgICAgICAgY29uc3QgeyBsaW5lV2lkdGgsIGNvbG9yIH0gPSB0aGlzLnRoZW1lLmxpbmUubWF4aW11bTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgIHg6IGNyaXNwUGl4ZWwoc3RhcnRYICsgKGJhcldpZHRoIC0gbWluTWF4QmFyV2lkdGgpIC8gMiwgbGluZVdpZHRoKSxcbiAgICAgICAgICAgIHk6IHRoaXMuZ2V0WVBvcyhtYXhpbXVtLCByYXRpbywgbGluZVdpZHRoKSxcbiAgICAgICAgICAgIHgyOiBjcmlzcFBpeGVsKHN0YXJ0WCArIChiYXJXaWR0aCAtIG1pbk1heEJhcldpZHRoKSAvIDIgKyBtaW5NYXhCYXJXaWR0aCwgbGluZVdpZHRoKSxcbiAgICAgICAgICAgIHkyOiB0aGlzLmdldFlQb3MobWF4aW11bSwgcmF0aW8sIGxpbmVXaWR0aCksXG4gICAgICAgICAgICBzdHJva2VTdHlsZTogKGNvbG9yICE9PSBudWxsICYmIGNvbG9yICE9PSB2b2lkIDAgPyBjb2xvciA6IHNlcmllc0NvbG9yKSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogbGluZVdpZHRoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRTZXJpZXNDb2xvcihzZXJpZXNOYW1lLCBzZXJpZXNDb2xvcikge1xuICAgICAgICBjb25zdCB7IHNlbGVjdCwgYXJlYU9wYWNpdHkgfSA9IHRoaXMudGhlbWU7XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuYWN0aXZlU2VyaWVzTWFwW3Nlcmllc05hbWVdO1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IE9iamVjdC52YWx1ZXModGhpcy5hY3RpdmVTZXJpZXNNYXApLnNvbWUoKGVsZW0pID0+ICFlbGVtKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRPcGFjaXR5ID0gYWN0aXZlID8gc2VsZWN0LmFyZWFPcGFjaXR5IDogc2VsZWN0LnJlc3RTZXJpZXMuYXJlYU9wYWNpdHk7XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSBzZWxlY3RlZCA/IHNlbGVjdGVkT3BhY2l0eSA6IGFyZWFPcGFjaXR5O1xuICAgICAgICByZXR1cm4gZ2V0UkdCQShzZXJpZXNDb2xvciwgb3BhY2l0eSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi9jb21wb25lbnRcIjtcbmltcG9ydCB7IGZpcnN0LCBoYXNOZWdhdGl2ZSwgZGVlcENvcHlBcnJheSwgbGFzdCwgaGFzTmVnYXRpdmVPbmx5LCBoYXNQb3NpdGl2ZU9ubHksIGlzTnVsbCwgaXNOdW1iZXIsIGNhbGN1bGF0ZVNpemVXaXRoUGVyY2VudFN0cmluZywgb21pdCwgfSBmcm9tIFwiLi4vaGVscGVycy91dGlsc1wiO1xuaW1wb3J0IHsgbWFrZVRpY2tQaXhlbFBvc2l0aW9ucywgbWFrZUxhYmVsc0Zyb21MaW1pdCB9IGZyb20gXCIuLi9oZWxwZXJzL2NhbGN1bGF0b3JcIjtcbmltcG9ydCB7IGdldFJHQkEsIGdldEFscGhhIH0gZnJvbSBcIi4uL2hlbHBlcnMvY29sb3JcIjtcbmltcG9ydCB7IGdldERhdGFJblJhbmdlLCBpc1JhbmdlRGF0YSwgaXNSYW5nZVZhbHVlIH0gZnJvbSBcIi4uL2hlbHBlcnMvcmFuZ2VcIjtcbmltcG9ydCB7IGdldExpbWl0T25BeGlzLCBnZXRWYWx1ZUF4aXNOYW1lIH0gZnJvbSBcIi4uL2hlbHBlcnMvYXhlc1wiO1xuaW1wb3J0IHsgY2FsaWJyYXRlRHJhd2luZ1ZhbHVlIH0gZnJvbSBcIi4uL2hlbHBlcnMvYm94U2VyaWVzXCI7XG5pbXBvcnQgeyBnZXREYXRhTGFiZWxzT3B0aW9ucyB9IGZyb20gXCIuLi9oZWxwZXJzL2RhdGFMYWJlbHNcIjtcbmltcG9ydCB7IGdldEFjdGl2ZVNlcmllc01hcCB9IGZyb20gXCIuLi9oZWxwZXJzL2xlZ2VuZFwiO1xuaW1wb3J0IHsgZ2V0Qm94VHlwZVNlcmllc1BhZGRpbmcgfSBmcm9tIFwiLi4vaGVscGVycy9zdHlsZVwiO1xuaW1wb3J0IHsgbWFrZVJlY3RSZXNwb25kZXJNb2RlbCB9IGZyb20gXCIuLi9oZWxwZXJzL3Jlc3BvbmRlcnNcIjtcbmltcG9ydCB7IG1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZVwiO1xuaW1wb3J0IHsgaXNBdmFpbGFibGVTZWxlY3RTZXJpZXMsIGlzQXZhaWxhYmxlU2hvd1Rvb2x0aXBJbmZvIH0gZnJvbSBcIi4uL2hlbHBlcnMvdmFsaWRhdGlvblwiO1xuZXhwb3J0IHZhciBTZXJpZXNEaXJlY3Rpb247XG4oZnVuY3Rpb24gKFNlcmllc0RpcmVjdGlvbikge1xuICAgIFNlcmllc0RpcmVjdGlvbltTZXJpZXNEaXJlY3Rpb25bXCJQT1NJVElWRVwiXSA9IDBdID0gXCJQT1NJVElWRVwiO1xuICAgIFNlcmllc0RpcmVjdGlvbltTZXJpZXNEaXJlY3Rpb25bXCJORUdBVElWRVwiXSA9IDFdID0gXCJORUdBVElWRVwiO1xuICAgIFNlcmllc0RpcmVjdGlvbltTZXJpZXNEaXJlY3Rpb25bXCJCT1RIXCJdID0gMl0gPSBcIkJPVEhcIjtcbn0pKFNlcmllc0RpcmVjdGlvbiB8fCAoU2VyaWVzRGlyZWN0aW9uID0ge30pKTtcbmNvbnN0IEJPWCA9IHtcbiAgICBCQVI6ICdiYXInLFxuICAgIENPTFVNTjogJ2NvbHVtbicsXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGlzTGVmdEJvdHRvbVNpZGUoc2VyaWVzSW5kZXgpIHtcbiAgICByZXR1cm4gISEoc2VyaWVzSW5kZXggJSAyKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUJhckxlbmd0aCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICBpZiAoaXNSYW5nZVZhbHVlKHZhbHVlKSkge1xuICAgICAgICBsZXQgW3N0YXJ0LCBlbmRdID0gdmFsdWU7XG4gICAgICAgIGlmIChzdGFydCA8IG1pbikge1xuICAgICAgICAgICAgc3RhcnQgPSBtaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA+IG1heCkge1xuICAgICAgICAgICAgZW5kID0gbWF4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmQgLSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGlicmF0ZURyYXdpbmdWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpO1xufVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm94U2VyaWVzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSB7IHNlcmllczogW10gfTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZWRSZXNwb25kZXJzID0gW107XG4gICAgICAgIHRoaXMuaXNCYXIgPSB0cnVlO1xuICAgICAgICB0aGlzLnZhbHVlQXhpcyA9ICd4QXhpcyc7XG4gICAgICAgIHRoaXMubGFiZWxBeGlzID0gJ3lBeGlzJztcbiAgICAgICAgdGhpcy5hbmNob3JTaXplS2V5ID0gJ2hlaWdodCc7XG4gICAgICAgIHRoaXMub2Zmc2V0U2l6ZUtleSA9ICd3aWR0aCc7XG4gICAgICAgIHRoaXMuYmFzZVBvc2l0aW9uID0gMDtcbiAgICAgICAgdGhpcy5sZWZ0QmFzZVBvc2l0aW9uID0gMDtcbiAgICAgICAgdGhpcy5yaWdodEJhc2VQb3NpdGlvbiA9IDA7XG4gICAgICAgIHRoaXMuaXNSYW5nZURhdGEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vZmZzZXRLZXkgPSAneCc7XG4gICAgICAgIHRoaXMuZXZlbnREZXRlY3RUeXBlID0gJ3BvaW50JztcbiAgICAgICAgdGhpcy5vbk1vdXNlb3V0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzZXJpZXNQb2ludEhvdmVyZWQnLCB7IG1vZGVsczogW10sIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVySG92ZXJlZFNlcmllcycsIHtcbiAgICAgICAgICAgICAgICBtb2RlbHM6IFtdLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBldmVudERldGVjdFR5cGU6IHRoaXMuZXZlbnREZXRlY3RUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VsZWN0U2VyaWVzID0gKGluZm8pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5kZXgsIHNlcmllc0luZGV4IH0gPSBpbmZvO1xuICAgICAgICAgICAgaWYgKCFpc0F2YWlsYWJsZVNlbGVjdFNlcmllcyhpbmZvLCAnY29sdW1uJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMudG9vbHRpcFJlY3RNYXBbc2VyaWVzSW5kZXhdW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZS5TRUxFQ1RfU0VSSUVTX0FQSV9JTkRFWF9FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlclNlbGVjdGVkU2VyaWVzJywge1xuICAgICAgICAgICAgICAgIG1vZGVsczogdGhpcy5nZXRSZXNwb25kZXJzV2l0aFRoZW1lKFttb2RlbF0sICdzZWxlY3QnKSxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zaG93VG9vbHRpcCA9IChpbmZvKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGluZGV4LCBzZXJpZXNJbmRleCB9ID0gaW5mbztcbiAgICAgICAgICAgIGlmICghaXNBdmFpbGFibGVTaG93VG9vbHRpcEluZm8oaW5mbywgdGhpcy5ldmVudERldGVjdFR5cGUsICdjb2x1bW4nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vZGVscyA9IHRoaXMuZXZlbnREZXRlY3RUeXBlID09PSAnZ3JvdXBlZCdcbiAgICAgICAgICAgICAgICA/IHRoaXMuZ2V0R3JvdXBlZFJlY3QoW3RoaXMucmVzcG9uZGVyc1tpbmRleF1dLCAnaG92ZXInKVxuICAgICAgICAgICAgICAgIDogdGhpcy5nZXRSZXNwb25kZXJzV2l0aFRoZW1lKFt0aGlzLnRvb2x0aXBSZWN0TWFwW2luZGV4XVtzZXJpZXNJbmRleF1dLCAnaG92ZXInKTtcbiAgICAgICAgICAgIGlmICghbW9kZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVySG92ZXJlZFNlcmllcycsIHtcbiAgICAgICAgICAgICAgICBtb2RlbHMsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGV2ZW50RGV0ZWN0VHlwZTogdGhpcy5ldmVudERldGVjdFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudERldGVjdFR5cGUgPT09ICdncm91cGVkJyA/IHRoaXMudG9vbHRpcFJlY3RNYXBbaW5kZXhdIDogbW9kZWxzO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzZXJpZXNQb2ludEhvdmVyZWQnLCB7IG1vZGVsczogdGhpcy5hY3RpdmF0ZWRSZXNwb25kZXJzLCBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGluaXRpYWxpemUoeyBuYW1lLCBzdGFja0NoYXJ0IH0pIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplRmllbGRzKG5hbWUpO1xuICAgICAgICBpZiAoIXN0YWNrQ2hhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMub24oJ3NlbGVjdFNlcmllcycsIHRoaXMuc2VsZWN0U2VyaWVzKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMub24oJ3Nob3dUb29sdGlwJywgdGhpcy5zaG93VG9vbHRpcCk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLm9uKCdoaWRlVG9vbHRpcCcsIHRoaXMub25Nb3VzZW91dENvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdGlhbGl6ZUZpZWxkcyhuYW1lKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdzZXJpZXMnO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmlzQmFyID0gbmFtZSA9PT0gQk9YLkJBUjtcbiAgICAgICAgdGhpcy5vZmZzZXRLZXkgPSB0aGlzLmlzQmFyID8gJ3gnIDogJ3knO1xuICAgICAgICB0aGlzLnZhbHVlQXhpcyA9IHRoaXMuaXNCYXIgPyAneEF4aXMnIDogJ3lBeGlzJztcbiAgICAgICAgdGhpcy5sYWJlbEF4aXMgPSB0aGlzLmlzQmFyID8gJ3lBeGlzJyA6ICd4QXhpcyc7XG4gICAgICAgIHRoaXMuYW5jaG9yU2l6ZUtleSA9IHRoaXMuaXNCYXIgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICAgIHRoaXMub2Zmc2V0U2l6ZUtleSA9IHRoaXMuaXNCYXIgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgfVxuICAgIGluaXRVcGRhdGUoZGVsdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRyYXdNb2RlbHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1JhbmdlRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5pbml0VXBkYXRlUmFuZ2VEYXRhKGRlbHRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRVcGRhdGVDbGlwUmVjdChkZWx0YSk7XG4gICAgICAgIHRoaXMuaW5pdFVwZGF0ZUNvbm5lY3RvcihkZWx0YSk7XG4gICAgfVxuICAgIGluaXRVcGRhdGVSYW5nZURhdGEoZGVsdGEpIHtcbiAgICAgICAgY29uc3QgeyBzZXJpZXMgfSA9IHRoaXMuZHJhd01vZGVscztcbiAgICAgICAgdGhpcy5kcmF3TW9kZWxzLmNsaXBSZWN0ID0gdGhpcy5tb2RlbHMuY2xpcFJlY3Q7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMubW9kZWxzLnNlcmllcztcbiAgICAgICAgc2VyaWVzLmZvckVhY2goKGN1cnJlbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRNb2RlbCA9IHRhcmdldFtpbmRleF07XG4gICAgICAgICAgICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50W3RoaXMub2Zmc2V0U2l6ZUtleV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0U2l6ZSA9IGN1cnJlbnRbdGhpcy5vZmZzZXRTaXplS2V5XSArXG4gICAgICAgICAgICAgICAgKHRhcmdldE1vZGVsW3RoaXMub2Zmc2V0U2l6ZUtleV0gLSBjdXJyZW50W3RoaXMub2Zmc2V0U2l6ZUtleV0pICogZGVsdGE7XG4gICAgICAgICAgICBjdXJyZW50W3RoaXMub2Zmc2V0U2l6ZUtleV0gPSBvZmZzZXRTaXplO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQmFyKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFt0aGlzLm9mZnNldEtleV0gPVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRNb2RlbFt0aGlzLm9mZnNldEtleV0gKyB0YXJnZXRNb2RlbFt0aGlzLm9mZnNldFNpemVLZXldIC0gb2Zmc2V0U2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluaXRVcGRhdGVDbGlwUmVjdChkZWx0YSkge1xuICAgICAgICBjb25zdCB7IGNsaXBSZWN0IH0gPSB0aGlzLmRyYXdNb2RlbHM7XG4gICAgICAgIGlmICghY2xpcFJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50ID0gY2xpcFJlY3RbMF07XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMub2Zmc2V0U2l6ZUtleTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5tb2RlbHMuY2xpcFJlY3RbMF07XG4gICAgICAgIGNvbnN0IG9mZnNldFNpemUgPSBjdXJyZW50W2tleV0gKyAodGFyZ2V0W2tleV0gLSBjdXJyZW50W2tleV0pICogZGVsdGE7XG4gICAgICAgIGN1cnJlbnRba2V5XSA9IG9mZnNldFNpemU7XG4gICAgICAgIGN1cnJlbnRbdGhpcy5vZmZzZXRLZXldID0gTWF0aC5tYXgodGhpcy5iYXNlUG9zaXRpb24gLSAob2Zmc2V0U2l6ZSAqIHRoaXMuYmFzZVBvc2l0aW9uKSAvIHRhcmdldFtrZXldLCAwKTtcbiAgICB9XG4gICAgaW5pdFVwZGF0ZUNvbm5lY3RvcihkZWx0YSkge1xuICAgICAgICBjb25zdCB7IGNvbm5lY3RvciB9ID0gdGhpcy5kcmF3TW9kZWxzO1xuICAgICAgICBpZiAoIWNvbm5lY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMubW9kZWxzLmNvbm5lY3RvcjtcbiAgICAgICAgY29ubmVjdG9yLmZvckVhY2goKGN1cnJlbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhbHBoYSA9IGdldEFscGhhKHRhcmdldFtpbmRleF0uc3Ryb2tlU3R5bGUpICogZGVsdGE7XG4gICAgICAgICAgICBjdXJyZW50LnN0cm9rZVN0eWxlID0gZ2V0UkdCQShjdXJyZW50LnN0cm9rZVN0eWxlLCBhbHBoYSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRFdmVudERldGVjdFR5cGUoc2VyaWVzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChzZXJpZXMubGluZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudERldGVjdFR5cGUgPSAnZ3JvdXBlZCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChfYiA9IChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXJpZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ldmVudERldGVjdFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnREZXRlY3RUeXBlID0gb3B0aW9ucy5zZXJpZXMuZXZlbnREZXRlY3RUeXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE9wdGlvbnMoY2hhcnRPcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGNoYXJ0T3B0aW9ucyk7XG4gICAgICAgIGlmICgoKF9hID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlcmllcykgJiYgb3B0aW9ucy5zZXJpZXMuY29sdW1uKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNlcmllcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5zZXJpZXMpLCBvcHRpb25zLnNlcmllcy5jb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICByZW5kZXIoY2hhcnRTdGF0ZSwgY29tcHV0ZWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgeyBsYXlvdXQsIHNlcmllcywgYXhlcywgc3RhY2tTZXJpZXMsIGxlZ2VuZCwgdGhlbWUsIHNjYWxlIH0gPSBjaGFydFN0YXRlO1xuICAgICAgICB0aGlzLmlzU2hvdyA9ICEoc3RhY2tTZXJpZXMgJiYgc3RhY2tTZXJpZXNbdGhpcy5uYW1lXSk7XG4gICAgICAgIGlmICghdGhpcy5pc1Nob3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gKF9hID0gY2hhcnRTdGF0ZS5jYXRlZ29yaWVzLCAoX2EgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucyhjaGFydFN0YXRlLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNldEV2ZW50RGV0ZWN0VHlwZShzZXJpZXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWUuc2VyaWVzW3RoaXMubmFtZV07XG4gICAgICAgIHRoaXMucmVjdCA9IGxheW91dC5wbG90O1xuICAgICAgICB0aGlzLmFjdGl2ZVNlcmllc01hcCA9IGdldEFjdGl2ZVNlcmllc01hcChsZWdlbmQpO1xuICAgICAgICB0aGlzLnNlbGVjdGFibGUgPSB0aGlzLmdldFNlbGVjdGFibGVPcHRpb24ob3B0aW9ucyk7XG4gICAgICAgIHRoaXMudmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzTmFtZShvcHRpb25zLCB0aGlzLm5hbWUsIHRoaXMuaXNCYXIgPyAneEF4aXMnIDogJ3lBeGlzJyk7XG4gICAgICAgIGNvbnN0IHNlcmllc0RhdGEgPSBzZXJpZXNbdGhpcy5uYW1lXS5kYXRhLm1hcCgoc2VyaWVzRGF0dW0pID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlcmllc0RhdHVtKSwgeyBkYXRhOiBnZXREYXRhSW5SYW5nZShzZXJpZXNEYXR1bS5kYXRhLCBjb21wdXRlZC52aWV3UmFuZ2UpIH0pKSk7XG4gICAgICAgIGlmIChheGVzLmNlbnRlcllBeGlzKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQXhpcyA9ICdjZW50ZXJZQXhpcyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0aWNrRGlzdGFuY2UgfSA9IGF4ZXNbdGhpcy5sYWJlbEF4aXNdO1xuICAgICAgICBjb25zdCBkaXZlcmdpbmcgPSAhISgoX2IgPSBvcHRpb25zLnNlcmllcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpdmVyZ2luZyk7XG4gICAgICAgIGNvbnN0IHsgbGltaXQsIHN0ZXBTaXplIH0gPSB0aGlzLmdldFNjYWxlRGF0YShzY2FsZSk7XG4gICAgICAgIGNvbnN0IGxhYmVscyA9IG1ha2VMYWJlbHNGcm9tTGltaXQobGltaXQsIHN0ZXBTaXplKTtcbiAgICAgICAgY29uc3QgeyBtaW4sIG1heCB9ID0gZ2V0TGltaXRPbkF4aXMobGFiZWxzKTtcbiAgICAgICAgdGhpcy5iYXNlUG9zaXRpb24gPSB0aGlzLmdldEJhc2VQb3NpdGlvbihheGVzW3RoaXMudmFsdWVBeGlzXSk7XG4gICAgICAgIGxldCBvZmZzZXRTaXplID0gdGhpcy5nZXRPZmZzZXRTaXplKCk7XG4gICAgICAgIGNvbnN0IHsgY2VudGVyWUF4aXMgfSA9IGF4ZXM7XG4gICAgICAgIGlmIChkaXZlcmdpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldERpdmVyZ2luZ0Jhc2VQb3NpdGlvbihjZW50ZXJZQXhpcyk7XG4gICAgICAgICAgICB0aGlzLmJhc2VQb3NpdGlvbiA9IHRoaXMuZ2V0T2Zmc2V0U2l6ZSgpIC8gMjtcbiAgICAgICAgICAgIHRoaXMubGVmdEJhc2VQb3NpdGlvbiA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0QmFzZVBvc2l0aW9uID0gcmlnaHQ7XG4gICAgICAgICAgICBvZmZzZXRTaXplID0gdGhpcy5nZXRPZmZzZXRTaXplV2l0aERpdmVyZ2luZyhjZW50ZXJZQXhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVuZGVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgIG1heCxcbiAgICAgICAgICAgIHRpY2tEaXN0YW5jZSxcbiAgICAgICAgICAgIGRpdmVyZ2luZyxcbiAgICAgICAgICAgIHJhdGlvOiB0aGlzLmdldFZhbHVlUmF0aW8obWluLCBtYXgsIG9mZnNldFNpemUpLFxuICAgICAgICAgICAgaGFzTmVnYXRpdmVWYWx1ZTogaGFzTmVnYXRpdmUobGFiZWxzKSxcbiAgICAgICAgICAgIHNlcmllc0RpcmVjdGlvbjogdGhpcy5nZXRTZXJpZXNEaXJlY3Rpb24obGFiZWxzKSxcbiAgICAgICAgICAgIGRlZmF1bHRQYWRkaW5nOiBnZXRCb3hUeXBlU2VyaWVzUGFkZGluZyh0aWNrRGlzdGFuY2UpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXJpZXNNb2RlbHMgPSB0aGlzLnJlbmRlclNlcmllc01vZGVsKHNlcmllc0RhdGEsIHJlbmRlck9wdGlvbnMpO1xuICAgICAgICBjb25zdCB0b29sdGlwRGF0YSA9IHRoaXMubWFrZVRvb2x0aXBEYXRhKHNlcmllc0RhdGEsIHJlbmRlck9wdGlvbnMsIGNhdGVnb3JpZXMpO1xuICAgICAgICBjb25zdCBjbGlwUmVjdCA9IHRoaXMucmVuZGVyQ2xpcFJlY3RBcmVhTW9kZWwoKTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSB7XG4gICAgICAgICAgICBjbGlwUmVjdDogW2NsaXBSZWN0XSxcbiAgICAgICAgICAgIHNlcmllczogc2VyaWVzTW9kZWxzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXMuZHJhd01vZGVscykge1xuICAgICAgICAgICAgdGhpcy5kcmF3TW9kZWxzID0ge1xuICAgICAgICAgICAgICAgIGNsaXBSZWN0OiBbdGhpcy5pbml0Q2xpcFJlY3QoY2xpcFJlY3QpXSxcbiAgICAgICAgICAgICAgICBzZXJpZXM6IGRlZXBDb3B5QXJyYXkoc2VyaWVzTW9kZWxzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldERhdGFMYWJlbHNPcHRpb25zKG9wdGlvbnMsIHRoaXMubmFtZSkudmlzaWJsZSkge1xuICAgICAgICAgICAgY29uc3QgZGF0YUxhYmVsRGF0YSA9IHNlcmllc01vZGVscy5yZWR1Y2UoKGFjYywgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1JhbmdlVmFsdWUoZGF0YS52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgPyBbLi4uYWNjLCAuLi50aGlzLm1ha2VEYXRhTGFiZWxSYW5nZURhdGEoZGF0YSldXG4gICAgICAgICAgICAgICAgICAgIDogWy4uLmFjYywgdGhpcy5tYWtlRGF0YUxhYmVsKGRhdGEsIGNlbnRlcllBeGlzKV07XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckRhdGFMYWJlbHMoZGF0YUxhYmVsRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b29sdGlwUmVjdE1hcCA9IHRoaXMubWFrZVRvb2x0aXBSZWN0TWFwKHNlcmllc01vZGVscywgdG9vbHRpcERhdGEpO1xuICAgICAgICB0aGlzLnJlc3BvbmRlcnMgPSB0aGlzLmdldEJveFNlcmllc1Jlc3BvbmRlcnMoc2VyaWVzTW9kZWxzLCB0b29sdGlwRGF0YSwgYXhlcywgY2F0ZWdvcmllcyk7XG4gICAgfVxuICAgIGdldFNjYWxlRGF0YShzY2FsZSkge1xuICAgICAgICByZXR1cm4gc2NhbGVbdGhpcy52YWx1ZUF4aXMgPT09ICdjZW50ZXJZQXhpcycgPyAneEF4aXMnIDogdGhpcy52YWx1ZUF4aXNdO1xuICAgIH1cbiAgICBnZXRCb3hTZXJpZXNSZXNwb25kZXJzKHNlcmllc01vZGVscywgdG9vbHRpcERhdGEsIGF4ZXMsIGNhdGVnb3JpZXMpIHtcbiAgICAgICAgY29uc3QgaG92ZXJlZFNlcmllcyA9IHRoaXMucmVuZGVySG92ZXJlZFNlcmllc01vZGVsKHNlcmllc01vZGVscyk7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50RGV0ZWN0VHlwZSA9PT0gJ2dyb3VwZWQnXG4gICAgICAgICAgICA/IG1ha2VSZWN0UmVzcG9uZGVyTW9kZWwodGhpcy5yZWN0LCAodGhpcy5pc0JhciA/IGF4ZXMueUF4aXMgOiBheGVzLnhBeGlzKSwgY2F0ZWdvcmllcywgIXRoaXMuaXNCYXIpXG4gICAgICAgICAgICA6IGhvdmVyZWRTZXJpZXMubWFwKChtLCBpbmRleCkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbSksIHsgZGF0YTogdG9vbHRpcERhdGFbaW5kZXhdIH0pKSk7XG4gICAgfVxuICAgIG1ha2VUb29sdGlwUmVjdE1hcChzZXJpZXNNb2RlbHMsIHRvb2x0aXBEYXRhQXJyKSB7XG4gICAgICAgIHJldHVybiBzZXJpZXNNb2RlbHMucmVkdWNlKChhY2MsIGN1ciwgZGF0YUluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGN1ci5pbmRleDtcbiAgICAgICAgICAgIGNvbnN0IHRvb2x0aXBNb2RlbCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY3VyKSwgeyBkYXRhOiB0b29sdGlwRGF0YUFycltkYXRhSW5kZXhdIH0pO1xuICAgICAgICAgICAgaWYgKCFhY2NbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgYWNjW2luZGV4XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNjW2luZGV4XS5wdXNoKHRvb2x0aXBNb2RlbCk7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIHJlbmRlckNsaXBSZWN0QXJlYU1vZGVsKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2NsaXBSZWN0QXJlYScsXG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLnJlY3Qud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMucmVjdC5oZWlnaHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGluaXRDbGlwUmVjdChjbGlwUmVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2NsaXBSZWN0QXJlYScsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy5pc0JhciA/IDAgOiBjbGlwUmVjdC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5pc0JhciA/IGNsaXBSZWN0LmhlaWdodCA6IDAsXG4gICAgICAgICAgICB4OiB0aGlzLmlzQmFyID8gMCA6IGNsaXBSZWN0LngsXG4gICAgICAgICAgICB5OiB0aGlzLmlzQmFyID8gY2xpcFJlY3QueSA6IDAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlclNlcmllc01vZGVsKHNlcmllc0RhdGEsIHJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyB0aWNrRGlzdGFuY2UsIGRpdmVyZ2luZyB9ID0gcmVuZGVyT3B0aW9ucztcbiAgICAgICAgY29uc3Qgc2VyaWVzTGVuZ3RoID0gc2VyaWVzRGF0YS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHZhbGlkRGl2ZXJnaW5nID0gZGl2ZXJnaW5nICYmIHNlcmllc0RhdGEubGVuZ3RoID09PSAyO1xuICAgICAgICBjb25zdCBjb2x1bW5XaWR0aCA9IHRoaXMuZ2V0Q29sdW1uV2lkdGgocmVuZGVyT3B0aW9ucywgc2VyaWVzTGVuZ3RoLCB2YWxpZERpdmVyZ2luZyk7XG4gICAgICAgIGNvbnN0IHNlcmllc01vZGVscyA9IFtdO1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gKHRpY2tEaXN0YW5jZSAtIGNvbHVtbldpZHRoICogKHZhbGlkRGl2ZXJnaW5nID8gMSA6IHNlcmllc0xlbmd0aCkpIC8gMjtcbiAgICAgICAgc2VyaWVzRGF0YS5mb3JFYWNoKCh7IGRhdGEsIGNvbG9yOiBzZXJpZXNDb2xvciwgbmFtZSwgY29sb3JCeUNhdGVnb3JpZXMgfSwgc2VyaWVzSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlcmllc1BvcyA9IChkaXZlcmdpbmcgPyAwIDogc2VyaWVzSW5kZXgpICogY29sdW1uV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICAgICAgY29uc3QgaXNMQlNpZGVXaXRoRGl2ZXJnaW5nID0gZGl2ZXJnaW5nICYmIGlzTGVmdEJvdHRvbVNpZGUoc2VyaWVzSW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgY29sb3JMZW5ndGggPSBjb2xvckJ5Q2F0ZWdvcmllcyA/IHNlcmllc0NvbG9yLmxlbmd0aCA6IDE7XG4gICAgICAgICAgICB0aGlzLmlzUmFuZ2VEYXRhID0gaXNSYW5nZURhdGEoZGF0YSk7XG4gICAgICAgICAgICBkYXRhLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFTdGFydCA9IHNlcmllc1BvcyArIGluZGV4ICogdGlja0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhckxlbmd0aCA9IHRoaXMubWFrZUJhckxlbmd0aCh2YWx1ZSwgcmVuZGVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLmdldFNlcmllc0NvbG9yKG5hbWUsIGNvbG9yQnlDYXRlZ29yaWVzID8gc2VyaWVzQ29sb3JbaW5kZXggJSBjb2xvckxlbmd0aF0gOiBzZXJpZXNDb2xvcik7XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGJhckxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IHRoaXMuZ2V0U3RhcnRQb3NpdGlvbihiYXJMZW5ndGgsIHZhbHVlLCByZW5kZXJPcHRpb25zLCBpc0xCU2lkZVdpdGhEaXZlcmdpbmcpO1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbHMucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB0eXBlOiAncmVjdCcsIGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgfSwgdGhpcy5nZXRBZGp1c3RlZFJlY3QoZGF0YVN0YXJ0LCBzdGFydFBvc2l0aW9uLCBiYXJMZW5ndGgsIGNvbHVtbldpZHRoKSksIHsgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZXJpZXNNb2RlbHM7XG4gICAgfVxuICAgIHJlbmRlckhvdmVyZWRTZXJpZXNNb2RlbChzZXJpZXNNb2RlbCkge1xuICAgICAgICByZXR1cm4gc2VyaWVzTW9kZWwubWFwKChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlSG92ZXJlZFNlcmllc01vZGVsKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFrZUhvdmVyZWRTZXJpZXNNb2RlbChkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3IsIGluZGV4IH0gPSBkYXRhO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3JlY3QnLFxuICAgICAgICAgICAgY29sb3I6IGdldFJHQkEoY29sb3IsIDEpLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRSZWN0TW9kZWxzRnJvbVJlY3RSZXNwb25kZXJzKHJlc3BvbmRlcnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXJlc3BvbmRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9hID0gdGhpcy50b29sdGlwUmVjdE1hcFtyZXNwb25kZXJzWzBdLmluZGV4XSwgKF9hICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKTtcbiAgICB9XG4gICAgZ2V0R3JvdXBlZFJlY3QocmVzcG9uZGVycywgdHlwZSkge1xuICAgICAgICBjb25zdCByZWN0TW9kZWxzID0gdGhpcy5nZXRSZWN0TW9kZWxzRnJvbVJlY3RSZXNwb25kZXJzKHJlc3BvbmRlcnMpO1xuICAgICAgICBjb25zdCB7IGNvbG9yLCBvcGFjaXR5IH0gPSB0aGlzLnRoZW1lW3R5cGVdLmdyb3VwZWRSZWN0O1xuICAgICAgICByZXR1cm4gcmVjdE1vZGVscy5sZW5ndGhcbiAgICAgICAgICAgID8gcmVzcG9uZGVycy5tYXAoKG0pID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG0pLCB7IGNvbG9yOiBnZXRSR0JBKGNvbG9yLCBvcGFjaXR5KSB9KSkpXG4gICAgICAgICAgICA6IFtdO1xuICAgIH1cbiAgICBvbk1vdXNlbW92ZUdyb3VwZWRUeXBlKHJlc3BvbmRlcnMpIHtcbiAgICAgICAgY29uc3QgcmVjdE1vZGVscyA9IHRoaXMuZ2V0UmVjdE1vZGVsc0Zyb21SZWN0UmVzcG9uZGVycyhyZXNwb25kZXJzKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJIb3ZlcmVkU2VyaWVzJywge1xuICAgICAgICAgICAgbW9kZWxzOiB0aGlzLmdldEdyb3VwZWRSZWN0KHJlc3BvbmRlcnMsICdob3ZlcicpLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgZXZlbnREZXRlY3RUeXBlOiB0aGlzLmV2ZW50RGV0ZWN0VHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IHJlY3RNb2RlbHM7XG4gICAgfVxuICAgIG9uTW91c2Vtb3ZlKHsgcmVzcG9uZGVycyB9KSB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50RGV0ZWN0VHlwZSA9PT0gJ2dyb3VwZWQnKSB7XG4gICAgICAgICAgICB0aGlzLm9uTW91c2Vtb3ZlR3JvdXBlZFR5cGUocmVzcG9uZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlckhvdmVyZWRTZXJpZXMnLCB7XG4gICAgICAgICAgICAgICAgbW9kZWxzOiB0aGlzLmdldFJlc3BvbmRlcnNXaXRoVGhlbWUocmVzcG9uZGVycywgJ2hvdmVyJyksXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGV2ZW50RGV0ZWN0VHlwZTogdGhpcy5ldmVudERldGVjdFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IHJlc3BvbmRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzZXJpZXNQb2ludEhvdmVyZWQnLCB7IG1vZGVsczogdGhpcy5hY3RpdmF0ZWRSZXNwb25kZXJzLCBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICB9XG4gICAgbWFrZVRvb2x0aXBEYXRhKHNlcmllc0RhdGEsIHJlbmRlck9wdGlvbnMsIGNhdGVnb3JpZXMpIHtcbiAgICAgICAgY29uc3QgdG9vbHRpcERhdGEgPSBbXTtcbiAgICAgICAgc2VyaWVzRGF0YS5mb3JFYWNoKCh7IGRhdGEsIG5hbWUsIGNvbG9yLCBjb2xvckJ5Q2F0ZWdvcmllcyB9KSA9PiB7XG4gICAgICAgICAgICBkYXRhLmZvckVhY2goKHZhbHVlLCBkYXRhSW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFyTGVuZ3RoID0gdGhpcy5tYWtlQmFyTGVuZ3RoKHZhbHVlLCByZW5kZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGJhckxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXBEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvckJ5Q2F0ZWdvcmllcyA/IGNvbG9yW2RhdGFJbmRleF0gOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5nZXRUb29sdGlwVmFsdWUodmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBjYXRlZ29yaWVzLmxlbmd0aCA/IGNhdGVnb3JpZXNbZGF0YUluZGV4XSA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0b29sdGlwRGF0YTtcbiAgICB9XG4gICAgZ2V0VG9vbHRpcFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc1JhbmdlVmFsdWUodmFsdWUpID8gYCR7dmFsdWVbMF19IH4gJHt2YWx1ZVsxXX1gIDogdmFsdWU7XG4gICAgfVxuICAgIGdldEJhc2VQb3NpdGlvbih7IGxhYmVscywgdGlja0NvdW50LCB6ZXJvUG9zaXRpb24gfSkge1xuICAgICAgICBjb25zdCB2YWx1ZUxhYmVscyA9IHRoaXMuaXNCYXIgPyBsYWJlbHMgOiBbLi4ubGFiZWxzXS5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IHRpY2tQb3NpdGlvbnMgPSBtYWtlVGlja1BpeGVsUG9zaXRpb25zKHRoaXMuZ2V0T2Zmc2V0U2l6ZSgpLCB0aWNrQ291bnQpO1xuICAgICAgICBjb25zdCBzZXJpZXNEaXJlY3Rpb24gPSB0aGlzLmdldFNlcmllc0RpcmVjdGlvbih2YWx1ZUxhYmVscyk7XG4gICAgICAgIHJldHVybiB6ZXJvUG9zaXRpb25cbiAgICAgICAgICAgID8gemVyb1Bvc2l0aW9uXG4gICAgICAgICAgICA6IHRoaXMuZ2V0VGlja1Bvc2l0aW9uSWZOb3RaZXJvKHRpY2tQb3NpdGlvbnMsIHNlcmllc0RpcmVjdGlvbik7XG4gICAgfVxuICAgIGdldERpdmVyZ2luZ0Jhc2VQb3NpdGlvbihjZW50ZXJZQXhpcykge1xuICAgICAgICBsZXQgbGVmdFplcm9Qb3NpdGlvbiwgcmlnaHRaZXJvUG9zaXRpb247XG4gICAgICAgIGlmIChjZW50ZXJZQXhpcykge1xuICAgICAgICAgICAgbGVmdFplcm9Qb3NpdGlvbiA9IGNlbnRlcllBeGlzLnhBeGlzSGFsZlNpemU7XG4gICAgICAgICAgICByaWdodFplcm9Qb3NpdGlvbiA9IGNlbnRlcllBeGlzLnNlY29uZFN0YXJ0WDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRpdmVyZ2luZ1plcm9Qb3NpdGlvbiA9IHRoaXMuZ2V0T2Zmc2V0U2l6ZSgpIC8gMjtcbiAgICAgICAgICAgIGxlZnRaZXJvUG9zaXRpb24gPSByaWdodFplcm9Qb3NpdGlvbiA9IGRpdmVyZ2luZ1plcm9Qb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2xlZnRaZXJvUG9zaXRpb24sIHJpZ2h0WmVyb1Bvc2l0aW9uXTtcbiAgICB9XG4gICAgZ2V0T2Zmc2V0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjdFt0aGlzLm9mZnNldFNpemVLZXldO1xuICAgIH1cbiAgICBnZXRWYWx1ZVJhdGlvKG1pbiwgbWF4LCBzaXplKSB7XG4gICAgICAgIHJldHVybiBzaXplIC8gKG1heCAtIG1pbik7XG4gICAgfVxuICAgIG1ha2VCYXJMZW5ndGgodmFsdWUsIHJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzTnVsbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbWluLCBtYXgsIHJhdGlvIH0gPSByZW5kZXJPcHRpb25zO1xuICAgICAgICBjb25zdCBjYWxjdWxhdGVkVmFsdWUgPSBjYWxjdWxhdGVCYXJMZW5ndGgodmFsdWUsIG1pbiwgbWF4KTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuZ2V0QmFyTGVuZ3RoKGNhbGN1bGF0ZWRWYWx1ZSwgcmF0aW8pLCAyKTtcbiAgICB9XG4gICAgZ2V0QmFyTGVuZ3RoKHZhbHVlLCByYXRpbykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gTWF0aC5hYnModmFsdWUpICogcmF0aW8gOiB2YWx1ZSAqIHJhdGlvO1xuICAgIH1cbiAgICBnZXRTdGFydFBvc2l0aW9uV2l0aFJhbmdlVmFsdWUodmFsdWUsIGJhckxlbmd0aCwgcmVuZGVyT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IG1pbiwgcmF0aW8gfSA9IHJlbmRlck9wdGlvbnM7XG4gICAgICAgIGxldCBbc3RhcnRdID0gdmFsdWU7XG4gICAgICAgIGlmIChzdGFydCA8IG1pbikge1xuICAgICAgICAgICAgc3RhcnQgPSBtaW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IChzdGFydCAtIG1pbikgKiByYXRpbztcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNCYXIgPyBzdGFydFBvc2l0aW9uIDogdGhpcy5nZXRPZmZzZXRTaXplKCkgLSBzdGFydFBvc2l0aW9uIC0gYmFyTGVuZ3RoO1xuICAgIH1cbiAgICBnZXRTdGFydFBvc2l0aW9uKGJhckxlbmd0aCwgdmFsdWUsIHJlbmRlck9wdGlvbnMsIGlzTEJTaWRlV2l0aERpdmVyZ2luZykge1xuICAgICAgICBjb25zdCB7IGRpdmVyZ2luZywgc2VyaWVzRGlyZWN0aW9uIH0gPSByZW5kZXJPcHRpb25zO1xuICAgICAgICBsZXQgc3RhcnRQb3M7XG4gICAgICAgIGlmIChpc1JhbmdlVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICBzdGFydFBvcyA9IHRoaXMuZ2V0U3RhcnRQb3NpdGlvbldpdGhSYW5nZVZhbHVlKHZhbHVlLCBiYXJMZW5ndGgsIHJlbmRlck9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpdmVyZ2luZykge1xuICAgICAgICAgICAgc3RhcnRQb3MgPSBpc0xCU2lkZVdpdGhEaXZlcmdpbmdcbiAgICAgICAgICAgICAgICA/IHRoaXMuZ2V0U3RhcnRQb3NPbkxlZnRCb3R0b21TaWRlKGJhckxlbmd0aCwgZGl2ZXJnaW5nKVxuICAgICAgICAgICAgICAgIDogdGhpcy5nZXRTdGFydFBvc09uUmlnaHRUb3BTaWRlKGJhckxlbmd0aCwgZGl2ZXJnaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZXJpZXNEaXJlY3Rpb24gPT09IFNlcmllc0RpcmVjdGlvbi5QT1NJVElWRSkge1xuICAgICAgICAgICAgc3RhcnRQb3MgPSB0aGlzLmdldFN0YXJ0UG9zT25SaWdodFRvcFNpZGUoYmFyTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZXJpZXNEaXJlY3Rpb24gPT09IFNlcmllc0RpcmVjdGlvbi5ORUdBVElWRSkge1xuICAgICAgICAgICAgc3RhcnRQb3MgPSB0aGlzLmdldFN0YXJ0UG9zT25MZWZ0Qm90dG9tU2lkZShiYXJMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRQb3MgPVxuICAgICAgICAgICAgICAgIHZhbHVlIDwgMFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuZ2V0U3RhcnRQb3NPbkxlZnRCb3R0b21TaWRlKGJhckxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmdldFN0YXJ0UG9zT25SaWdodFRvcFNpZGUoYmFyTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnRQb3M7XG4gICAgfVxuICAgIGdldFN0YXJ0UG9zT25SaWdodFRvcFNpZGUoYmFyTGVuZ3RoLCBkaXZlcmdpbmcgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcG9zO1xuICAgICAgICBpZiAoZGl2ZXJnaW5nKSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLmlzQmFyID8gdGhpcy5yaWdodEJhc2VQb3NpdGlvbiA6IHRoaXMucmlnaHRCYXNlUG9zaXRpb24gLSBiYXJMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLmlzQmFyID8gdGhpcy5iYXNlUG9zaXRpb24gOiB0aGlzLmJhc2VQb3NpdGlvbiAtIGJhckxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBnZXRTdGFydFBvc09uTGVmdEJvdHRvbVNpZGUoYmFyTGVuZ3RoLCBkaXZlcmdpbmcgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcG9zO1xuICAgICAgICBpZiAoZGl2ZXJnaW5nKSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLmlzQmFyID8gdGhpcy5sZWZ0QmFzZVBvc2l0aW9uIC0gYmFyTGVuZ3RoIDogdGhpcy5sZWZ0QmFzZVBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5pc0JhciA/IHRoaXMuYmFzZVBvc2l0aW9uIC0gYmFyTGVuZ3RoIDogdGhpcy5iYXNlUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgZ2V0QWRqdXN0ZWRSZWN0KHNlcmllc1Bvc2l0aW9uLCBkYXRhUG9zaXRpb24sIGJhckxlbmd0aCwgY29sdW1uV2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHRoaXMuaXNCYXIgPyBkYXRhUG9zaXRpb24gOiBzZXJpZXNQb3NpdGlvbixcbiAgICAgICAgICAgIHk6IHRoaXMuaXNCYXIgPyBzZXJpZXNQb3NpdGlvbiA6IGRhdGFQb3NpdGlvbixcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLmlzQmFyID8gYmFyTGVuZ3RoIDogY29sdW1uV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaXNCYXIgPyBjb2x1bW5XaWR0aCA6IGJhckxlbmd0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0Q29sdW1uV2lkdGgocmVuZGVyT3B0aW9ucywgc2VyaWVzTGVuZ3RoLCB2YWxpZERpdmVyZ2luZyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHsgdGlja0Rpc3RhbmNlLCBkZWZhdWx0UGFkZGluZyB9ID0gcmVuZGVyT3B0aW9ucztcbiAgICAgICAgc2VyaWVzTGVuZ3RoID0gdmFsaWREaXZlcmdpbmcgPyAxIDogc2VyaWVzTGVuZ3RoO1xuICAgICAgICBjb25zdCB0aGVtZUJhcldpZHRoID0gdGhpcy50aGVtZS5iYXJXaWR0aDtcbiAgICAgICAgcmV0dXJuIHRoZW1lQmFyV2lkdGhcbiAgICAgICAgICAgID8gY2FsY3VsYXRlU2l6ZVdpdGhQZXJjZW50U3RyaW5nKHRpY2tEaXN0YW5jZSwgdGhlbWVCYXJXaWR0aClcbiAgICAgICAgICAgIDogKHRpY2tEaXN0YW5jZSAtIGRlZmF1bHRQYWRkaW5nICogMikgLyBzZXJpZXNMZW5ndGg7XG4gICAgfVxuICAgIGdldFNlcmllc0RpcmVjdGlvbihsYWJlbHMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFNlcmllc0RpcmVjdGlvbi5CT1RIO1xuICAgICAgICBpZiAoaGFzUG9zaXRpdmVPbmx5KGxhYmVscykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFNlcmllc0RpcmVjdGlvbi5QT1NJVElWRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNOZWdhdGl2ZU9ubHkobGFiZWxzKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gU2VyaWVzRGlyZWN0aW9uLk5FR0FUSVZFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldFRpY2tQb3NpdGlvbklmTm90WmVybyh0aWNrUG9zaXRpb25zLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgaWYgKCF0aWNrUG9zaXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RUaWNrUG9zaXRpb24gPSBOdW1iZXIoZmlyc3QodGlja1Bvc2l0aW9ucykpO1xuICAgICAgICBjb25zdCBsYXN0VGlja1Bvc2l0aW9uID0gTnVtYmVyKGxhc3QodGlja1Bvc2l0aW9ucykpO1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBTZXJpZXNEaXJlY3Rpb24uUE9TSVRJVkUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQmFyID8gZmlyc3RUaWNrUG9zaXRpb24gOiBsYXN0VGlja1Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IFNlcmllc0RpcmVjdGlvbi5ORUdBVElWRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNCYXIgPyBsYXN0VGlja1Bvc2l0aW9uIDogZmlyc3RUaWNrUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIG1ha2VEYXRhTGFiZWwocmVjdCwgY2VudGVyWUF4aXMpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhTGFiZWxzIH0gPSB0aGlzLnRoZW1lO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWN0KSwgeyBkaXJlY3Rpb246IHRoaXMuZ2V0RGF0YUxhYmVsRGlyZWN0aW9uKHJlY3QsIGNlbnRlcllBeGlzKSwgcGxvdDogeyB4OiAwLCB5OiAwLCBzaXplOiB0aGlzLmdldE9mZnNldFNpemUoKSB9LCB0aGVtZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbWl0KGRhdGFMYWJlbHMsICdzdGFja1RvdGFsJykpLCB7IGNvbG9yOiBkYXRhTGFiZWxzLnVzZVNlcmllc0NvbG9yID8gcmVjdC5jb2xvciA6IGRhdGFMYWJlbHMuY29sb3IgfSkgfSk7XG4gICAgfVxuICAgIG1ha2VEYXRhTGFiZWxSYW5nZURhdGEocmVjdCkge1xuICAgICAgICBjb25zdCB7IGRhdGFMYWJlbHMgfSA9IHRoaXMudGhlbWU7XG4gICAgICAgIHJldHVybiByZWN0LnZhbHVlLnJlZHVjZSgoYWNjLCB2YWx1ZSwgaW5kZXgpID0+IFtcbiAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVjdCksIHsgdmFsdWUsIGRpcmVjdGlvbjogdGhpcy5nZXREYXRhTGFiZWxSYW5nZURhdGFEaXJlY3Rpb24oaW5kZXggJSAyID09PSAwKSwgcGxvdDogeyB4OiAwLCB5OiAwLCBzaXplOiB0aGlzLmdldE9mZnNldFNpemUoKSB9LCB0aGVtZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbWl0KGRhdGFMYWJlbHMsICdzdGFja1RvdGFsJykpLCB7IGNvbG9yOiBkYXRhTGFiZWxzLnVzZVNlcmllc0NvbG9yID8gcmVjdC5jb2xvciA6IGRhdGFMYWJlbHMuY29sb3IgfSkgfSksXG4gICAgICAgIF0sIFtdKTtcbiAgICB9XG4gICAgZ2V0RGF0YUxhYmVsUmFuZ2VEYXRhRGlyZWN0aW9uKGlzRXZlbikge1xuICAgICAgICBsZXQgZGlyZWN0aW9uO1xuICAgICAgICBpZiAodGhpcy5pc0Jhcikge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gaXNFdmVuID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGlzRXZlbiA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgICB9XG4gICAgZ2V0RGF0YUxhYmVsRGlyZWN0aW9uKHJlY3QsIGNlbnRlcllBeGlzKSB7XG4gICAgICAgIGxldCBkaXJlY3Rpb247XG4gICAgICAgIGlmICh0aGlzLmlzQmFyKSB7XG4gICAgICAgICAgICBjb25zdCBiYXNlUG9zID0gY2VudGVyWUF4aXMgPyB0aGlzLmxlZnRCYXNlUG9zaXRpb24gOiB0aGlzLmJhc2VQb3NpdGlvbjtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IHJlY3QueCA8IGJhc2VQb3MgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gcmVjdC55ID49IHRoaXMuYmFzZVBvc2l0aW9uID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlyZWN0aW9uO1xuICAgIH1cbiAgICBnZXRPZmZzZXRTaXplV2l0aERpdmVyZ2luZyhjZW50ZXJZQXhpcykge1xuICAgICAgICByZXR1cm4gY2VudGVyWUF4aXMgPyBjZW50ZXJZQXhpcy54QXhpc0hhbGZTaXplIDogdGhpcy5nZXRPZmZzZXRTaXplKCkgLyAyO1xuICAgIH1cbiAgICBvbkNsaWNrKHsgcmVzcG9uZGVycyB9KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIGxldCBtb2RlbHM7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudERldGVjdFR5cGUgPT09ICdncm91cGVkJykge1xuICAgICAgICAgICAgICAgIG1vZGVscyA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5nZXRHcm91cGVkUmVjdChyZXNwb25kZXJzLCAnc2VsZWN0JyksXG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2V0UmVjdE1vZGVsc0Zyb21SZWN0UmVzcG9uZGVycyhyZXNwb25kZXJzKSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9kZWxzID0gdGhpcy5nZXRSZXNwb25kZXJzV2l0aFRoZW1lKHJlc3BvbmRlcnMsICdzZWxlY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVyU2VsZWN0ZWRTZXJpZXMnLCB7XG4gICAgICAgICAgICAgICAgbW9kZWxzLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBldmVudERldGVjdFR5cGU6IHRoaXMuZXZlbnREZXRlY3RUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmVzcG9uZGVyc1dpdGhUaGVtZShyZXNwb25kZXJzLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IHsgY29sb3IsIGJvcmRlckNvbG9yLCBib3JkZXJXaWR0aCwgc2hhZG93Qmx1ciwgc2hhZG93Q29sb3IsIHNoYWRvd09mZnNldFgsIHNoYWRvd09mZnNldFksIH0gPSB0aGlzLnRoZW1lW3R5cGVdO1xuICAgICAgICByZXR1cm4gcmVzcG9uZGVycy5tYXAoKG1vZGVsKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtb2RlbCksIHsgY29sb3I6IChjb2xvciAhPT0gbnVsbCAmJiBjb2xvciAhPT0gdm9pZCAwID8gY29sb3IgOiBtb2RlbC5jb2xvciksIHRoaWNrbmVzczogYm9yZGVyV2lkdGgsIGJvcmRlckNvbG9yLCBzdHlsZTogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93Qmx1cixcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd09mZnNldFgsXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd09mZnNldFksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0gfSkpKTtcbiAgICB9XG4gICAgZ2V0U2VyaWVzQ29sb3IobmFtZSwgY29sb3IpIHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3QsIGFyZWFPcGFjaXR5IH0gPSB0aGlzLnRoZW1lO1xuICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmFjdGl2ZVNlcmllc01hcFtuYW1lXTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBPYmplY3QudmFsdWVzKHRoaXMuYWN0aXZlU2VyaWVzTWFwKS5zb21lKChlbGVtKSA9PiAhZWxlbSk7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZFxuICAgICAgICAgICAgPyBnZXRSR0JBKGNvbG9yLCBhY3RpdmUgPyBzZWxlY3QuYXJlYU9wYWNpdHkgOiBzZWxlY3QucmVzdFNlcmllcy5hcmVhT3BhY2l0eSlcbiAgICAgICAgICAgIDogZ2V0UkdCQShjb2xvciwgYXJlYU9wYWNpdHkpO1xuICAgIH1cbn1cbiIsImltcG9ydCBCb3hTZXJpZXMsIHsgaXNMZWZ0Qm90dG9tU2lkZSwgU2VyaWVzRGlyZWN0aW9uIH0gZnJvbSBcIi4vYm94U2VyaWVzXCI7XG5pbXBvcnQgeyBkZWVwQ29weUFycmF5LCBpbmNsdWRlcywgaXNOdW1iZXIsIGhhc05lZ2F0aXZlLCBjYWxjdWxhdGVTaXplV2l0aFBlcmNlbnRTdHJpbmcsIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmltcG9ydCB7IGdldExpbWl0T25BeGlzIH0gZnJvbSBcIi4uL2hlbHBlcnMvYXhlc1wiO1xuaW1wb3J0IHsgaXNHcm91cFN0YWNrLCBpc1BlcmNlbnRTdGFjayB9IGZyb20gXCIuLi9zdG9yZS9zdGFja1Nlcmllc0RhdGFcIjtcbmltcG9ydCB7IGNhbGlicmF0ZUJveFN0YWNrRHJhd2luZ1ZhbHVlLCBzdW1WYWx1ZXNCZWZvcmVJbmRleCB9IGZyb20gXCIuLi9oZWxwZXJzL2JveFNlcmllc1wiO1xuaW1wb3J0IHsgZ2V0RGF0YUxhYmVsc09wdGlvbnMgfSBmcm9tIFwiLi4vaGVscGVycy9kYXRhTGFiZWxzXCI7XG5pbXBvcnQgeyBnZXRSR0JBIH0gZnJvbSBcIi4uL2hlbHBlcnMvY29sb3JcIjtcbmltcG9ydCB7IGdldEFjdGl2ZVNlcmllc01hcCB9IGZyb20gXCIuLi9oZWxwZXJzL2xlZ2VuZFwiO1xuaW1wb3J0IHsgZ2V0Qm94VHlwZVNlcmllc1BhZGRpbmcgfSBmcm9tIFwiLi4vaGVscGVycy9zdHlsZVwiO1xuaW1wb3J0IHsgZ2V0RGF0YUluUmFuZ2UgfSBmcm9tIFwiLi4vaGVscGVycy9yYW5nZVwiO1xuaW1wb3J0IHsgbWVzc2FnZSB9IGZyb20gXCIuLi9tZXNzYWdlXCI7XG5pbXBvcnQgeyBtYWtlTGFiZWxzRnJvbUxpbWl0IH0gZnJvbSBcIi4uL2hlbHBlcnMvY2FsY3VsYXRvclwiO1xuZnVuY3Rpb24gY2FsaWJyYXRlRHJhd2luZ1ZhbHVlKHZhbHVlcywgc2VyaWVzSW5kZXgsIHJlbmRlck9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHN0YWNrLCBtaW4sIG1heCB9ID0gcmVuZGVyT3B0aW9ucztcbiAgICByZXR1cm4gaXNQZXJjZW50U3RhY2soc3RhY2spXG4gICAgICAgID8gdmFsdWVzW3Nlcmllc0luZGV4XVxuICAgICAgICA6IGNhbGlicmF0ZUJveFN0YWNrRHJhd2luZ1ZhbHVlKHZhbHVlcywgc2VyaWVzSW5kZXgsIG1pbiwgbWF4KTtcbn1cbmZ1bmN0aW9uIGdldERpdmlzb3JGb3JQZXJjZW50KHRvdGFsLCBzY2FsZVR5cGUpIHtcbiAgICBjb25zdCB7IHBvc2l0aXZlLCBuZWdhdGl2ZSB9ID0gdG90YWw7XG4gICAgbGV0IGRpdmlzb3IgPSBwb3NpdGl2ZSArIE1hdGguYWJzKG5lZ2F0aXZlKTtcbiAgICBpZiAoaW5jbHVkZXMoWydkdWFsUGVyY2VudFN0YWNrJywgJ2RpdmVyZ2luZ1BlcmNlbnRTdGFjayddLCBzY2FsZVR5cGUpKSB7XG4gICAgICAgIGRpdmlzb3IgKj0gMjtcbiAgICB9XG4gICAgcmV0dXJuIGRpdmlzb3I7XG59XG5mdW5jdGlvbiBnZXREaXJlY3Rpb25LZXlzKHNlcmllc0RpcmVjdGlvbikge1xuICAgIGxldCByZXN1bHQgPSBbJ3Bvc2l0aXZlJywgJ25lZ2F0aXZlJ107XG4gICAgaWYgKHNlcmllc0RpcmVjdGlvbiA9PT0gU2VyaWVzRGlyZWN0aW9uLlBPU0lUSVZFKSB7XG4gICAgICAgIHJlc3VsdCA9IFsncG9zaXRpdmUnXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VyaWVzRGlyZWN0aW9uID09PSBTZXJpZXNEaXJlY3Rpb24uTkVHQVRJVkUpIHtcbiAgICAgICAgcmVzdWx0ID0gWyduZWdhdGl2ZSddO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0U3RhY2tTZXJpZXNEYXRhSW5WaWV3UmFuZ2Uoc3RhY2tTZXJpZXNEYXRhLCB2aWV3UmFuZ2UpIHtcbiAgICBpZiAoIXZpZXdSYW5nZSkge1xuICAgICAgICByZXR1cm4gc3RhY2tTZXJpZXNEYXRhO1xuICAgIH1cbiAgICBjb25zdCBzdGFja0RhdGEgPSBBcnJheS5pc0FycmF5KHN0YWNrU2VyaWVzRGF0YS5zdGFja0RhdGEpXG4gICAgICAgID8gZ2V0RGF0YUluUmFuZ2Uoc3RhY2tTZXJpZXNEYXRhLnN0YWNrRGF0YSwgdmlld1JhbmdlKVxuICAgICAgICA6IE9iamVjdC5hc3NpZ24oe30sIE9iamVjdC5rZXlzKHN0YWNrU2VyaWVzRGF0YS5zdGFja0RhdGEpLnJlZHVjZSgoYWNjLCBuYW1lKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2MpLCB7IFtuYW1lXTogZ2V0RGF0YUluUmFuZ2Uoc3RhY2tTZXJpZXNEYXRhLnN0YWNrRGF0YVtuYW1lXSwgdmlld1JhbmdlKSB9KSksIHt9KSk7XG4gICAgY29uc3QgZGF0YSA9IHN0YWNrU2VyaWVzRGF0YS5kYXRhLm1hcCgoc2VyaWVzRGF0dW0pID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlcmllc0RhdHVtKSwgeyBkYXRhOiBnZXREYXRhSW5SYW5nZShzZXJpZXNEYXR1bS5kYXRhLCB2aWV3UmFuZ2UpIH0pKSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhY2tTZXJpZXNEYXRhKSwgeyBkYXRhLCBzdGFja0RhdGEgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCb3hTdGFja1NlcmllcyBleHRlbmRzIEJveFNlcmllcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc2VsZWN0U2VyaWVzID0gKHsgaW5kZXgsIHNlcmllc0luZGV4LCBzdGF0ZSwgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc051bWJlcihpbmRleCkgfHwgIWlzTnVtYmVyKHNlcmllc0luZGV4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgc3RhY2tTZXJpZXMgfSA9IHN0YXRlO1xuICAgICAgICAgICAgY29uc3Qgc3RhY2tTZXJpZXNEYXRhID0gc3RhY2tTZXJpZXNbdGhpcy5uYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gc3RhY2tTZXJpZXNEYXRhLmRhdGFbc2VyaWVzSW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLnRvb2x0aXBSZWN0TWFwW2luZGV4XS5maW5kKCh7IG5hbWU6IHNlcmllc05hbWUgfSkgPT4gc2VyaWVzTmFtZSA9PT0gbmFtZSk7XG4gICAgICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UuU0VMRUNUX1NFUklFU19BUElfSU5ERVhfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJTZWxlY3RlZFNlcmllcycsIHtcbiAgICAgICAgICAgICAgICBtb2RlbHM6IHRoaXMuZ2V0UmVzcG9uZGVyc1dpdGhUaGVtZShbbW9kZWxdLCAnc2VsZWN0JyksXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGV2ZW50RGV0ZWN0VHlwZTogdGhpcy5ldmVudERldGVjdFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSh7IG5hbWUsIHN0YWNrQ2hhcnQgfSkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVGaWVsZHMobmFtZSk7XG4gICAgICAgIGlmIChzdGFja0NoYXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLm9uKCdzZWxlY3RTZXJpZXMnLCB0aGlzLnNlbGVjdFNlcmllcyk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLm9uKCdzaG93VG9vbHRpcCcsIHRoaXMuc2hvd1Rvb2x0aXApO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignaGlkZVRvb2x0aXAnLCB0aGlzLm9uTW91c2VvdXRDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcihjaGFydFN0YXRlLCBjb21wdXRlZCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB7IGxheW91dCwgc2VyaWVzOiBzZXJpZXNEYXRhLCBheGVzLCBzdGFja1NlcmllcywgbGVnZW5kLCB0aGVtZSwgc2NhbGUgfSA9IGNoYXJ0U3RhdGU7XG4gICAgICAgIGNvbnN0IHsgdmlld1JhbmdlIH0gPSBjb21wdXRlZDtcbiAgICAgICAgdGhpcy5pc1Nob3cgPSAhIXN0YWNrU2VyaWVzW3RoaXMubmFtZV07XG4gICAgICAgIGlmICghdGhpcy5pc1Nob3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gKF9hID0gY2hhcnRTdGF0ZS5jYXRlZ29yaWVzLCAoX2EgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucyhjaGFydFN0YXRlLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNldEV2ZW50RGV0ZWN0VHlwZShzZXJpZXNEYXRhLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50aGVtZSA9IHRoZW1lLnNlcmllc1t0aGlzLm5hbWVdO1xuICAgICAgICB0aGlzLnJlY3QgPSBsYXlvdXQucGxvdDtcbiAgICAgICAgdGhpcy5hY3RpdmVTZXJpZXNNYXAgPSBnZXRBY3RpdmVTZXJpZXNNYXAobGVnZW5kKTtcbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlID0gdGhpcy5nZXRTZWxlY3RhYmxlT3B0aW9uKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzdGFja1Nlcmllc0RhdGEgPSBnZXRTdGFja1Nlcmllc0RhdGFJblZpZXdSYW5nZShzdGFja1Nlcmllc1t0aGlzLm5hbWVdLCB2aWV3UmFuZ2UpO1xuICAgICAgICBjb25zdCB7IHRpY2tEaXN0YW5jZSB9ID0gYXhlc1t0aGlzLmxhYmVsQXhpc107XG4gICAgICAgIGNvbnN0IGRpdmVyZ2luZyA9ICEhKChfYiA9IG9wdGlvbnMuc2VyaWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGl2ZXJnaW5nKTtcbiAgICAgICAgY29uc3QgeyBsaW1pdCwgc3RlcFNpemUgfSA9IHRoaXMuZ2V0U2NhbGVEYXRhKHNjYWxlKTtcbiAgICAgICAgY29uc3QgbGFiZWxzID0gbWFrZUxhYmVsc0Zyb21MaW1pdChsaW1pdCwgc3RlcFNpemUpO1xuICAgICAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSBnZXRMaW1pdE9uQXhpcyhsYWJlbHMpO1xuICAgICAgICBjb25zdCB7IHN0YWNrLCBzY2FsZVR5cGUgfSA9IHN0YWNrU2VyaWVzRGF0YTtcbiAgICAgICAgdGhpcy5iYXNlUG9zaXRpb24gPSB0aGlzLmdldEJhc2VQb3NpdGlvbihheGVzW3RoaXMudmFsdWVBeGlzXSk7XG4gICAgICAgIGxldCBvZmZzZXRTaXplID0gdGhpcy5nZXRPZmZzZXRTaXplKCk7XG4gICAgICAgIGNvbnN0IHsgY2VudGVyWUF4aXMgfSA9IGF4ZXM7XG4gICAgICAgIGlmIChkaXZlcmdpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldERpdmVyZ2luZ0Jhc2VQb3NpdGlvbihjZW50ZXJZQXhpcyk7XG4gICAgICAgICAgICB0aGlzLmJhc2VQb3NpdGlvbiA9IHRoaXMuZ2V0T2Zmc2V0U2l6ZSgpIC8gMjtcbiAgICAgICAgICAgIHRoaXMubGVmdEJhc2VQb3NpdGlvbiA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0QmFzZVBvc2l0aW9uID0gcmlnaHQ7XG4gICAgICAgICAgICBvZmZzZXRTaXplID0gdGhpcy5nZXRPZmZzZXRTaXplV2l0aERpdmVyZ2luZyhjZW50ZXJZQXhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVuZGVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgICAgc2NhbGVUeXBlLFxuICAgICAgICAgICAgdGlja0Rpc3RhbmNlLFxuICAgICAgICAgICAgbWluLFxuICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgZGl2ZXJnaW5nLFxuICAgICAgICAgICAgaGFzTmVnYXRpdmVWYWx1ZTogaGFzTmVnYXRpdmUobGFiZWxzKSxcbiAgICAgICAgICAgIHNlcmllc0RpcmVjdGlvbjogdGhpcy5nZXRTZXJpZXNEaXJlY3Rpb24obGFiZWxzKSxcbiAgICAgICAgICAgIGRlZmF1bHRQYWRkaW5nOiBnZXRCb3hUeXBlU2VyaWVzUGFkZGluZyh0aWNrRGlzdGFuY2UpLFxuICAgICAgICAgICAgb2Zmc2V0U2l6ZSxcbiAgICAgICAgICAgIGNlbnRlcllBeGlzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IHNlcmllcywgY29ubmVjdG9yIH0gPSB0aGlzLnJlbmRlclN0YWNrU2VyaWVzTW9kZWwoc3RhY2tTZXJpZXNEYXRhLCByZW5kZXJPcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2xpcFJlY3QgPSB0aGlzLnJlbmRlckNsaXBSZWN0QXJlYU1vZGVsKCk7XG4gICAgICAgIGNvbnN0IHRvb2x0aXBEYXRhID0gdGhpcy5nZXRUb29sdGlwRGF0YShzdGFja1Nlcmllc0RhdGEsIGNhdGVnb3JpZXMpO1xuICAgICAgICB0aGlzLm1vZGVscyA9IHtcbiAgICAgICAgICAgIGNsaXBSZWN0OiBbY2xpcFJlY3RdLFxuICAgICAgICAgICAgc2VyaWVzLFxuICAgICAgICAgICAgY29ubmVjdG9yLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXMuZHJhd01vZGVscykge1xuICAgICAgICAgICAgdGhpcy5kcmF3TW9kZWxzID0ge1xuICAgICAgICAgICAgICAgIGNsaXBSZWN0OiBbdGhpcy5pbml0Q2xpcFJlY3QoY2xpcFJlY3QpXSxcbiAgICAgICAgICAgICAgICBzZXJpZXM6IGRlZXBDb3B5QXJyYXkoc2VyaWVzKSxcbiAgICAgICAgICAgICAgICBjb25uZWN0b3I6IGRlZXBDb3B5QXJyYXkoY29ubmVjdG9yKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldERhdGFMYWJlbHNPcHRpb25zKG9wdGlvbnMsIHRoaXMubmFtZSkudmlzaWJsZSkge1xuICAgICAgICAgICAgY29uc3QgZGF0YUxhYmVsRGF0YSA9IHRoaXMuZ2V0RGF0YUxhYmVscyhzZXJpZXMsIHJlbmRlck9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3Qgc3RhY2tUb3RhbERhdGEgPSB0aGlzLmdldFRvdGFsRGF0YUxhYmVscyhzdGFja1Nlcmllc0RhdGEsIHJlbmRlck9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJEYXRhTGFiZWxzKFsuLi5kYXRhTGFiZWxEYXRhLCAuLi5zdGFja1RvdGFsRGF0YV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9vbHRpcFJlY3RNYXAgPSB0aGlzLm1ha2VUb29sdGlwUmVjdE1hcChzZXJpZXMsIHRvb2x0aXBEYXRhKTtcbiAgICAgICAgdGhpcy5yZXNwb25kZXJzID0gdGhpcy5nZXRCb3hTZXJpZXNSZXNwb25kZXJzKHNlcmllcywgdG9vbHRpcERhdGEsIGF4ZXMsIGNhdGVnb3JpZXMpO1xuICAgIH1cbiAgICByZW5kZXJTdGFja1Nlcmllc01vZGVsKHNlcmllc0RhdGEsIHJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBzdGFja0RhdGEgfSA9IHNlcmllc0RhdGE7XG4gICAgICAgIHJldHVybiBpc0dyb3VwU3RhY2soc3RhY2tEYXRhKVxuICAgICAgICAgICAgPyB0aGlzLm1ha2VTdGFja0dyb3VwU2VyaWVzTW9kZWwoc2VyaWVzRGF0YSwgcmVuZGVyT3B0aW9ucylcbiAgICAgICAgICAgIDogdGhpcy5tYWtlU3RhY2tTZXJpZXNNb2RlbChzdGFja0RhdGEsIHJlbmRlck9wdGlvbnMsIHNlcmllc0RhdGEuZGF0YSk7XG4gICAgfVxuICAgIG1ha2VTdGFja1Nlcmllc01vZGVsKHN0YWNrRGF0YSwgcmVuZGVyT3B0aW9ucywgc2VyaWVzUmF3RGF0YSwgc3RhY2tHcm91cENvdW50ID0gMSwgc3RhY2tHcm91cEluZGV4ID0gMCkge1xuICAgICAgICBjb25zdCBzZXJpZXNNb2RlbHMgPSBbXTtcbiAgICAgICAgY29uc3QgY29sdW1uV2lkdGggPSB0aGlzLmdldFN0YWNrQ29sdW1uV2lkdGgocmVuZGVyT3B0aW9ucywgc3RhY2tHcm91cENvdW50KTtcbiAgICAgICAgY29uc3QgeyBkaXZlcmdpbmcgfSA9IHJlbmRlck9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGlzTEJTaWRlV2l0aERpdmVyZ2luZyA9IGRpdmVyZ2luZyAmJiBpc0xlZnRCb3R0b21TaWRlKHN0YWNrR3JvdXBJbmRleCk7XG4gICAgICAgIHN0YWNrRGF0YS5mb3JFYWNoKCh7IHZhbHVlcywgdG90YWwgfSwgZGF0YUluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzZXJpZXNQb3MgPSB0aGlzLmdldFNlcmllc1Bvc2l0aW9uKHJlbmRlck9wdGlvbnMsIGNvbHVtbldpZHRoLCBkYXRhSW5kZXgsIHN0YWNrR3JvdXBJbmRleCwgc3RhY2tHcm91cENvdW50KTtcbiAgICAgICAgICAgIGNvbnN0IHJhdGlvID0gdGhpcy5nZXRTdGFja1ZhbHVlUmF0aW8odG90YWwsIHJlbmRlck9wdGlvbnMpO1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlLCBzZXJpZXNJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYmFyTGVuZ3RoLCBkYXRhUG9zaXRpb24gfSA9IHRoaXMuZ2V0U3RhY2tSZWN0SW5mbyh2YWx1ZXMsIHNlcmllc0luZGV4LCByYXRpbywgcmVuZGVyT3B0aW9ucywgaXNMQlNpZGVXaXRoRGl2ZXJnaW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5hbWUsIGNvbG9yQnlDYXRlZ29yaWVzLCBjb2xvcjogcmF3Q29sb3IgfSA9IHNlcmllc1Jhd0RhdGFbc2VyaWVzSW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuYWN0aXZlU2VyaWVzTWFwW25hbWVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yTGVuZ3RoID0gcmF3Q29sb3IubGVuZ3RoIHx8IDE7XG4gICAgICAgICAgICAgICAgY29uc3QgaGV4Q29sb3IgPSBjb2xvckJ5Q2F0ZWdvcmllcyA/IHJhd0NvbG9yW2RhdGFJbmRleCAlIGNvbG9yTGVuZ3RoXSA6IHJhd0NvbG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gZ2V0UkdCQShoZXhDb2xvciwgYWN0aXZlID8gMSA6IDAuMik7XG4gICAgICAgICAgICAgICAgc2VyaWVzTW9kZWxzLnB1c2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdHlwZTogJ3JlY3QnLCBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgfSwgdGhpcy5nZXRBZGp1c3RlZFJlY3Qoc2VyaWVzUG9zLCBkYXRhUG9zaXRpb24sIChiYXJMZW5ndGggIT09IG51bGwgJiYgYmFyTGVuZ3RoICE9PSB2b2lkIDAgPyBiYXJMZW5ndGggOiAwKSwgY29sdW1uV2lkdGgpKSwgeyBpbmRleDogZGF0YUluZGV4IH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlcmllczogc2VyaWVzTW9kZWxzLFxuICAgICAgICAgICAgY29ubmVjdG9yOiB0aGlzLm1ha2VDb25uZWN0b3JTZXJpZXNNb2RlbChzdGFja0RhdGEsIHJlbmRlck9wdGlvbnMsIHN0YWNrR3JvdXBDb3VudCwgc3RhY2tHcm91cEluZGV4KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbWFrZVN0YWNrR3JvdXBTZXJpZXNNb2RlbChzdGFja1NlcmllcywgcmVuZGVyT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHN0YWNrIH0gPSByZW5kZXJPcHRpb25zO1xuICAgICAgICBjb25zdCBzdGFja0dyb3VwRGF0YSA9IHN0YWNrU2VyaWVzLnN0YWNrRGF0YTtcbiAgICAgICAgY29uc3Qgc2VyaWVzUmF3RGF0YSA9IHN0YWNrU2VyaWVzLmRhdGE7XG4gICAgICAgIGNvbnN0IHN0YWNrR3JvdXBJZHMgPSBPYmplY3Qua2V5cyhzdGFja0dyb3VwRGF0YSk7XG4gICAgICAgIGxldCBzZXJpZXNNb2RlbHMgPSBbXTtcbiAgICAgICAgbGV0IGNvbm5lY3Rvck1vZGVscyA9IFtdO1xuICAgICAgICBzdGFja0dyb3VwSWRzLmZvckVhY2goKGdyb3VwSWQsIGdyb3VwSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gc2VyaWVzUmF3RGF0YS5maWx0ZXIoKHsgc3RhY2tHcm91cCB9KSA9PiBzdGFja0dyb3VwID09PSBncm91cElkKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VyaWVzLCBjb25uZWN0b3IgfSA9IHRoaXMubWFrZVN0YWNrU2VyaWVzTW9kZWwoc3RhY2tHcm91cERhdGFbZ3JvdXBJZF0sIHJlbmRlck9wdGlvbnMsIGZpbHRlcmVkLCBzdGFja0dyb3VwSWRzLmxlbmd0aCwgZ3JvdXBJbmRleCk7XG4gICAgICAgICAgICBzZXJpZXNNb2RlbHMgPSBbLi4uc2VyaWVzTW9kZWxzLCAuLi5zZXJpZXNdO1xuICAgICAgICAgICAgaWYgKHN0YWNrLmNvbm5lY3Rvcikge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rvck1vZGVscyA9IFsuLi5jb25uZWN0b3JNb2RlbHMsIC4uLmNvbm5lY3Rvcl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXNNb2RlbHMsXG4gICAgICAgICAgICBjb25uZWN0b3I6IGNvbm5lY3Rvck1vZGVscyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbWFrZUNvbm5lY3RvclNlcmllc01vZGVsKHN0YWNrRGF0YSwgcmVuZGVyT3B0aW9ucywgc3RhY2tHcm91cENvdW50ID0gMSwgc3RhY2tHcm91cEluZGV4ID0gMCkge1xuICAgICAgICBjb25zdCB7IGRpdmVyZ2luZywgc3RhY2s6IHsgY29ubmVjdG9yIH0sIH0gPSByZW5kZXJPcHRpb25zO1xuICAgICAgICBpZiAoIWNvbm5lY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbHVtbldpZHRoID0gdGhpcy5nZXRTdGFja0NvbHVtbldpZHRoKHJlbmRlck9wdGlvbnMsIHN0YWNrR3JvdXBDb3VudCk7XG4gICAgICAgIGNvbnN0IGlzTEJTaWRlV2l0aERpdmVyZ2luZyA9IGRpdmVyZ2luZyAmJiBpc0xlZnRCb3R0b21TaWRlKHN0YWNrR3JvdXBJbmRleCk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RvclBvaW50cyA9IFtdO1xuICAgICAgICBzdGFja0RhdGEuZm9yRWFjaCgoeyB2YWx1ZXMsIHRvdGFsIH0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzZXJpZXNQb3MgPSB0aGlzLmdldFNlcmllc1Bvc2l0aW9uKHJlbmRlck9wdGlvbnMsIGNvbHVtbldpZHRoLCBpbmRleCwgc3RhY2tHcm91cEluZGV4LCBzdGFja0dyb3VwQ291bnQpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBjb25zdCByYXRpbyA9IHRoaXMuZ2V0U3RhY2tWYWx1ZVJhdGlvKHRvdGFsLCByZW5kZXJPcHRpb25zKTtcbiAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgc2VyaWVzSW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGJhckxlbmd0aCwgZGF0YVBvc2l0aW9uIH0gPSB0aGlzLmdldFN0YWNrUmVjdEluZm8odmFsdWVzLCBzZXJpZXNJbmRleCwgcmF0aW8sIHJlbmRlck9wdGlvbnMsIGlzTEJTaWRlV2l0aERpdmVyZ2luZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLmdldEFkanVzdGVkUmVjdChzZXJpZXNQb3MsIGRhdGFQb3NpdGlvbiwgYmFyTGVuZ3RoLCBjb2x1bW5XaWR0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeFBvcyA9ICFpc0xCU2lkZVdpdGhEaXZlcmdpbmcgJiYgdGhpcy5pc0JhciA/IHggKyBiYXJMZW5ndGggOiB4O1xuICAgICAgICAgICAgICAgIGNvbnN0IHlQb3MgPSBpc0xCU2lkZVdpdGhEaXZlcmdpbmcgJiYgIXRoaXMuaXNCYXIgPyB5ICsgYmFyTGVuZ3RoIDogeTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh7IHg6IHhQb3MsIHk6IHlQb3MgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbm5lY3RvclBvaW50cy5wdXNoKHBvaW50cyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5tYWtlQ29ubmVjdG9yTW9kZWwoY29ubmVjdG9yUG9pbnRzLCBjb25uZWN0b3IsIGNvbHVtbldpZHRoKTtcbiAgICB9XG4gICAgZ2V0VG9vbHRpcERhdGEoc2VyaWVzRGF0YSwgY2F0ZWdvcmllcykge1xuICAgICAgICBjb25zdCBzZXJpZXNSYXdEYXRhID0gc2VyaWVzRGF0YS5kYXRhO1xuICAgICAgICBjb25zdCB7IHN0YWNrRGF0YSB9ID0gc2VyaWVzRGF0YTtcbiAgICAgICAgY29uc3QgY29sb3JzID0gc2VyaWVzUmF3RGF0YS5tYXAoKHsgY29sb3IgfSkgPT4gY29sb3IpO1xuICAgICAgICByZXR1cm4gaXNHcm91cFN0YWNrKHN0YWNrRGF0YSlcbiAgICAgICAgICAgID8gdGhpcy5tYWtlR3JvdXBTdGFja1Rvb2x0aXBEYXRhKHNlcmllc1Jhd0RhdGEsIHN0YWNrRGF0YSwgY2F0ZWdvcmllcylcbiAgICAgICAgICAgIDogdGhpcy5tYWtlU3RhY2tUb29sdGlwRGF0YShzZXJpZXNSYXdEYXRhLCBzdGFja0RhdGEsIGNvbG9ycywgY2F0ZWdvcmllcyk7XG4gICAgfVxuICAgIG1ha2VHcm91cFN0YWNrVG9vbHRpcERhdGEoc2VyaWVzUmF3RGF0YSwgc3RhY2tEYXRhLCBjYXRlZ29yaWVzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzdGFja0RhdGEpLmZsYXRNYXAoKGdyb3VwSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJhd0RhdGFXaXRoU2FtZUdyb3VwSWQgPSBzZXJpZXNSYXdEYXRhLmZpbHRlcigoeyBzdGFja0dyb3VwIH0pID0+IHN0YWNrR3JvdXAgPT09IGdyb3VwSWQpO1xuICAgICAgICAgICAgY29uc3QgY29sb3JzID0gcmF3RGF0YVdpdGhTYW1lR3JvdXBJZC5tYXAoKHsgY29sb3IgfSkgPT4gY29sb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZVN0YWNrVG9vbHRpcERhdGEocmF3RGF0YVdpdGhTYW1lR3JvdXBJZCwgc3RhY2tEYXRhW2dyb3VwSWRdLCBjb2xvcnMsIGNhdGVnb3JpZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFrZVN0YWNrVG9vbHRpcERhdGEoc2VyaWVzUmF3RGF0YSwgc3RhY2tEYXRhLCBjb2xvcnMsIGNhdGVnb3JpZXMpIHtcbiAgICAgICAgY29uc3QgdG9vbHRpcERhdGEgPSBbXTtcbiAgICAgICAgc3RhY2tEYXRhLmZvckVhY2goKHsgdmFsdWVzIH0sIGRhdGFJbmRleCkgPT4ge1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlLCBzZXJpZXNJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsYWJlbDogc2VyaWVzUmF3RGF0YVtzZXJpZXNJbmRleF0ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yc1tzZXJpZXNJbmRleF0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeTogY2F0ZWdvcmllcy5sZW5ndGggPyBjYXRlZ29yaWVzW2RhdGFJbmRleF0gOiAnJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRvb2x0aXBEYXRhO1xuICAgIH1cbiAgICBtYWtlQ29ubmVjdG9yTW9kZWwocG9pbnRzRm9yQ29ubmVjdG9yLCBjb25uZWN0b3IsIGNvbHVtbldpZHRoKSB7XG4gICAgICAgIGlmICghY29ubmVjdG9yIHx8ICFwb2ludHNGb3JDb25uZWN0b3IubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjb2xvciwgbGluZVdpZHRoLCBkYXNoU2VnbWVudHMgfSA9IHRoaXMudGhlbWUuY29ubmVjdG9yO1xuICAgICAgICBjb25zdCBjb25uZWN0b3JNb2RlbHMgPSBbXTtcbiAgICAgICAgY29uc3Qgc2VyaWVzRGF0YUNvdW50ID0gcG9pbnRzRm9yQ29ubmVjdG9yLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc2VyaWVzQ291bnQgPSBwb2ludHNGb3JDb25uZWN0b3JbMF0ubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBzZXJpZXNJbmRleCA9IDA7IHNlcmllc0luZGV4IDwgc2VyaWVzQ291bnQ7IHNlcmllc0luZGV4ICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgZGF0YUluZGV4ID0gMDsgZGF0YUluZGV4IDwgc2VyaWVzRGF0YUNvdW50OyBkYXRhSW5kZXggKz0gMSkge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50c0ZvckNvbm5lY3RvcltkYXRhSW5kZXhdW3Nlcmllc0luZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludHMuZm9yRWFjaCgocG9pbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwb2ludDtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHg6IG5leHRYLCB5OiBuZXh0WSB9ID0gcG9pbnRzW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rvck1vZGVscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRoaXMuaXNCYXIgPyB4IDogeCArIGNvbHVtbldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdGhpcy5pc0JhciA/IHkgKyBjb2x1bW5XaWR0aCA6IHksXG4gICAgICAgICAgICAgICAgICAgICAgICB4MjogbmV4dFgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5MjogbmV4dFksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXNoU2VnbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25uZWN0b3JNb2RlbHM7XG4gICAgfVxuICAgIGdldFN0YWNrVmFsdWVSYXRpbyh0b3RhbCwgcmVuZGVyT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHN0YWNrOiB7IHR5cGU6IHN0YWNrVHlwZSB9LCBzY2FsZVR5cGUsIG1pbiwgbWF4LCBvZmZzZXRTaXplLCB9ID0gcmVuZGVyT3B0aW9ucztcbiAgICAgICAgaWYgKHN0YWNrVHlwZSA9PT0gJ3BlcmNlbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0U2l6ZSAvIGdldERpdmlzb3JGb3JQZXJjZW50KHRvdGFsLCBzY2FsZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlUmF0aW8obWluLCBtYXgsIG9mZnNldFNpemUpO1xuICAgIH1cbiAgICBnZXRTdGFja0Jhckxlbmd0aCh2YWx1ZXMsIHNlcmllc0luZGV4LCByYXRpbywgcmVuZGVyT3B0aW9ucykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNhbGlicmF0ZURyYXdpbmdWYWx1ZSh2YWx1ZXMsIHNlcmllc0luZGV4LCByZW5kZXJPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSA/IHRoaXMuZ2V0QmFyTGVuZ3RoKHZhbHVlLCByYXRpbykgOiBudWxsO1xuICAgIH1cbiAgICBnZXRTdGFja0NvbHVtbldpZHRoKHJlbmRlck9wdGlvbnMsIHN0YWNrR3JvdXBDb3VudCkge1xuICAgICAgICBjb25zdCB7IHRpY2tEaXN0YW5jZSwgZGl2ZXJnaW5nLCBkZWZhdWx0UGFkZGluZyB9ID0gcmVuZGVyT3B0aW9ucztcbiAgICAgICAgY29uc3QgZGl2aXNvciA9IGRpdmVyZ2luZyA/IDEgOiBzdGFja0dyb3VwQ291bnQ7XG4gICAgICAgIGNvbnN0IHRoZW1lQmFyV2lkdGggPSB0aGlzLnRoZW1lLmJhcldpZHRoO1xuICAgICAgICByZXR1cm4gdGhlbWVCYXJXaWR0aFxuICAgICAgICAgICAgPyBjYWxjdWxhdGVTaXplV2l0aFBlcmNlbnRTdHJpbmcodGlja0Rpc3RhbmNlLCB0aGVtZUJhcldpZHRoKVxuICAgICAgICAgICAgOiAodGlja0Rpc3RhbmNlIC0gZGVmYXVsdFBhZGRpbmcgKiAyKSAvIGRpdmlzb3I7XG4gICAgfVxuICAgIGdldFNlcmllc1Bvc2l0aW9uKHJlbmRlck9wdGlvbnMsIGNvbHVtbldpZHRoLCBkYXRhSW5kZXgsIHN0YWNrR3JvdXBJbmRleCwgc3RhY2tHcm91cENvdW50KSB7XG4gICAgICAgIGNvbnN0IHsgdGlja0Rpc3RhbmNlLCBkaXZlcmdpbmcgfSA9IHJlbmRlck9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGdyb3VwSW5kZXggPSBkaXZlcmdpbmcgPyAwIDogc3RhY2tHcm91cEluZGV4O1xuICAgICAgICBjb25zdCBncm91cENvdW50ID0gZGl2ZXJnaW5nID8gMSA6IHN0YWNrR3JvdXBDb3VudDtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9ICh0aWNrRGlzdGFuY2UgLSBjb2x1bW5XaWR0aCAqIGdyb3VwQ291bnQpIC8gMjtcbiAgICAgICAgcmV0dXJuIGRhdGFJbmRleCAqIHRpY2tEaXN0YW5jZSArIHBhZGRpbmcgKyBjb2x1bW5XaWR0aCAqIGdyb3VwSW5kZXg7XG4gICAgfVxuICAgIGdldFN0YWNrU3RhcnRQb3NpdGlvbih2YWx1ZXMsIGN1cnJlbnRJbmRleCwgcmF0aW8sIHJlbmRlck9wdGlvbnMsIGlzTEJTaWRlV2l0aERpdmVyZ2luZykge1xuICAgICAgICBjb25zdCB7IHN0YWNrLCBkaXZlcmdpbmcsIHNlcmllc0RpcmVjdGlvbiB9ID0gcmVuZGVyT3B0aW9ucztcbiAgICAgICAgbGV0IHN0YXJ0UG9zO1xuICAgICAgICBpZiAoZGl2ZXJnaW5nKSB7XG4gICAgICAgICAgICBzdGFydFBvcyA9IGlzTEJTaWRlV2l0aERpdmVyZ2luZ1xuICAgICAgICAgICAgICAgID8gdGhpcy5jYWxjU3RhcnRQb3NPbkxlZnRCb3R0b21TaWRlKHZhbHVlcywgY3VycmVudEluZGV4LCByZW5kZXJPcHRpb25zLCByYXRpbylcbiAgICAgICAgICAgICAgICA6IHRoaXMuY2FsY1N0YXJ0UG9zT25SaWdodFRvcFNpZGUodmFsdWVzLCBjdXJyZW50SW5kZXgsIHJlbmRlck9wdGlvbnMsIHJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BlcmNlbnRTdGFjayhzdGFjaykpIHtcbiAgICAgICAgICAgIHN0YXJ0UG9zID0gdGhpcy5jYWxjU3RhcnRQb3NpdGlvbldpdGhQZXJjZW50KHZhbHVlcywgY3VycmVudEluZGV4LCByYXRpbyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VyaWVzRGlyZWN0aW9uID09PSBTZXJpZXNEaXJlY3Rpb24uUE9TSVRJVkUpIHtcbiAgICAgICAgICAgIHN0YXJ0UG9zID0gdGhpcy5jYWxjU3RhcnRQb3NPblJpZ2h0VG9wU2lkZSh2YWx1ZXMsIGN1cnJlbnRJbmRleCwgcmVuZGVyT3B0aW9ucywgcmF0aW8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlcmllc0RpcmVjdGlvbiA9PT0gU2VyaWVzRGlyZWN0aW9uLk5FR0FUSVZFKSB7XG4gICAgICAgICAgICBzdGFydFBvcyA9IHRoaXMuY2FsY1N0YXJ0UG9zT25MZWZ0Qm90dG9tU2lkZSh2YWx1ZXMsIGN1cnJlbnRJbmRleCwgcmVuZGVyT3B0aW9ucywgcmF0aW8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRQb3MgPSB0aGlzLmNhbGNTdGFydFBvc2l0aW9uV2l0aFN0YWNrKHZhbHVlcywgY3VycmVudEluZGV4LCByZW5kZXJPcHRpb25zLCByYXRpbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0UG9zO1xuICAgIH1cbiAgICBjYWxjU3RhcnRQb3NPbkxlZnRCb3R0b21TaWRlKHZhbHVlcywgY3VycmVudEluZGV4LCByZW5kZXJPcHRpb25zLCByYXRpbykge1xuICAgICAgICBjb25zdCB7IG1pbiwgbWF4LCBkaXZlcmdpbmcgfSA9IHJlbmRlck9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGJhc2VQb3NpdGlvbiA9IGRpdmVyZ2luZyA/IHRoaXMubGVmdEJhc2VQb3NpdGlvbiA6IHRoaXMuYmFzZVBvc2l0aW9uO1xuICAgICAgICBjb25zdCB0b3RhbE9mSW5kZXhCZWZvcmUgPSBzdW1WYWx1ZXNCZWZvcmVJbmRleCh2YWx1ZXMsIGN1cnJlbnRJbmRleCwgZmFsc2UpO1xuICAgICAgICBjb25zdCB0b3RhbE9mVmFsdWVzID0gc3VtVmFsdWVzQmVmb3JlSW5kZXgodmFsdWVzLCBjdXJyZW50SW5kZXgsIHRydWUpO1xuICAgICAgICBjb25zdCBjb2xsaWRlRWRnZSA9IHRvdGFsT2ZWYWx1ZXMgPCBtaW47XG4gICAgICAgIGNvbnN0IHVzaW5nVmFsdWUgPSB0aGlzLmlzQmFyID8gdG90YWxPZlZhbHVlcyA6IHRvdGFsT2ZJbmRleEJlZm9yZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbWF4IDwgMCA/IE1hdGgubWluKHVzaW5nVmFsdWUgLSBtYXgsIDApIDogdXNpbmdWYWx1ZTtcbiAgICAgICAgbGV0IHBvcztcbiAgICAgICAgaWYgKHRoaXMuaXNCYXIpIHtcbiAgICAgICAgICAgIHBvcyA9IGNvbGxpZGVFZGdlID8gMCA6IGJhc2VQb3NpdGlvbiAtIE1hdGguYWJzKHJlc3VsdCkgKiByYXRpbztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvcyA9IGJhc2VQb3NpdGlvbiArIE1hdGguYWJzKHJlc3VsdCkgKiByYXRpbztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBjYWxjU3RhcnRQb3NPblJpZ2h0VG9wU2lkZSh2YWx1ZXMsIGN1cnJlbnRJbmRleCwgcmVuZGVyT3B0aW9ucywgcmF0aW8pIHtcbiAgICAgICAgY29uc3QgeyBtaW4sIG1heCwgZGl2ZXJnaW5nIH0gPSByZW5kZXJPcHRpb25zO1xuICAgICAgICBjb25zdCBiYXNlUG9zaXRpb24gPSBkaXZlcmdpbmcgPyB0aGlzLnJpZ2h0QmFzZVBvc2l0aW9uIDogdGhpcy5iYXNlUG9zaXRpb247XG4gICAgICAgIGNvbnN0IHRvdGFsT2ZJbmRleEJlZm9yZSA9IHN1bVZhbHVlc0JlZm9yZUluZGV4KHZhbHVlcywgY3VycmVudEluZGV4LCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHRvdGFsT2ZWYWx1ZXMgPSBzdW1WYWx1ZXNCZWZvcmVJbmRleCh2YWx1ZXMsIGN1cnJlbnRJbmRleCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGNvbGxpZGVFZGdlID0gdG90YWxPZlZhbHVlcyA+IG1heDtcbiAgICAgICAgY29uc3QgdXNpbmdWYWx1ZSA9IHRoaXMuaXNCYXIgPyB0b3RhbE9mSW5kZXhCZWZvcmUgOiB0b3RhbE9mVmFsdWVzO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBtaW4gPiAwID8gTWF0aC5tYXgodXNpbmdWYWx1ZSAtIG1pbiwgMCkgOiB1c2luZ1ZhbHVlO1xuICAgICAgICBjb25zdCBiYXJMZW5ndGggPSByZXN1bHQgKiByYXRpbztcbiAgICAgICAgbGV0IHBvcztcbiAgICAgICAgaWYgKHRoaXMuaXNCYXIpIHtcbiAgICAgICAgICAgIHBvcyA9IGJhc2VQb3NpdGlvbiArIGJhckxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvcyA9IGNvbGxpZGVFZGdlID8gMCA6IGJhc2VQb3NpdGlvbiAtIGJhckxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBjYWxjU3RhcnRQb3NpdGlvbldpdGhTdGFjayh2YWx1ZXMsIGN1cnJlbnRJbmRleCwgcmVuZGVyT3B0aW9ucywgcmF0aW8pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1tjdXJyZW50SW5kZXhdIDwgMFxuICAgICAgICAgICAgPyB0aGlzLmNhbGNTdGFydFBvc09uTGVmdEJvdHRvbVNpZGUodmFsdWVzLCBjdXJyZW50SW5kZXgsIHJlbmRlck9wdGlvbnMsIHJhdGlvKVxuICAgICAgICAgICAgOiB0aGlzLmNhbGNTdGFydFBvc09uUmlnaHRUb3BTaWRlKHZhbHVlcywgY3VycmVudEluZGV4LCByZW5kZXJPcHRpb25zLCByYXRpbyk7XG4gICAgfVxuICAgIGNhbGNTdGFydFBvc2l0aW9uV2l0aFBlcmNlbnQodmFsdWVzLCBjdXJyZW50SW5kZXgsIHJhdGlvKSB7XG4gICAgICAgIGNvbnN0IGJhc2VQb3NpdGlvbiA9IHRoaXMuYmFzZVBvc2l0aW9uO1xuICAgICAgICBjb25zdCB0b3RhbFByZXZWYWx1ZXMgPSBzdW1WYWx1ZXNCZWZvcmVJbmRleCh2YWx1ZXMsIGN1cnJlbnRJbmRleCwgdGhpcy5pc0JhciA/IHZhbHVlc1tjdXJyZW50SW5kZXhdIDwgMCA6IHZhbHVlc1tjdXJyZW50SW5kZXhdID4gMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQmFyXG4gICAgICAgICAgICA/IHRvdGFsUHJldlZhbHVlcyAqIHJhdGlvICsgYmFzZVBvc2l0aW9uXG4gICAgICAgICAgICA6IGJhc2VQb3NpdGlvbiAtIHRvdGFsUHJldlZhbHVlcyAqIHJhdGlvO1xuICAgIH1cbiAgICBnZXRTdGFja1JlY3RJbmZvKHZhbHVlcywgc2VyaWVzSW5kZXgsIHJhdGlvLCByZW5kZXJPcHRpb25zLCBpc0xCU2lkZVdpdGhEaXZlcmdpbmcpIHtcbiAgICAgICAgY29uc3QgYmFyTGVuZ3RoID0gdGhpcy5nZXRTdGFja0Jhckxlbmd0aCh2YWx1ZXMsIHNlcmllc0luZGV4LCByYXRpbywgcmVuZGVyT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFQb3NpdGlvbiA9IHRoaXMuZ2V0U3RhY2tTdGFydFBvc2l0aW9uKHZhbHVlcywgc2VyaWVzSW5kZXgsIHJhdGlvLCByZW5kZXJPcHRpb25zLCBpc0xCU2lkZVdpdGhEaXZlcmdpbmcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFyTGVuZ3RoLFxuICAgICAgICAgICAgZGF0YVBvc2l0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXREYXRhTGFiZWxzKHNlcmllc01vZGVscywgcmVuZGVyT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc2VyaWVzTW9kZWxzLm1hcCgoZGF0YSkgPT4gdGhpcy5tYWtlRGF0YUxhYmVsKGRhdGEsIHJlbmRlck9wdGlvbnMuY2VudGVyWUF4aXMpKTtcbiAgICB9XG4gICAgZ2V0VG90YWxEYXRhTGFiZWxzKHNlcmllc0RhdGEsIHJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBzdGFja0RhdGEsIHN0YWNrIH0gPSBzZXJpZXNEYXRhO1xuICAgICAgICBpZiAoaXNQZXJjZW50U3RhY2soc3RhY2spKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzR3JvdXBTdGFjayhzdGFja0RhdGEpXG4gICAgICAgICAgICA/IHRoaXMubWFrZUdyb3VwVG90YWxEYXRhTGFiZWxzKHNlcmllc0RhdGEsIHJlbmRlck9wdGlvbnMpXG4gICAgICAgICAgICA6IHRoaXMubWFrZVRvdGFsRGF0YUxhYmVscyhzdGFja0RhdGEsIHJlbmRlck9wdGlvbnMpO1xuICAgIH1cbiAgICBtYWtlR3JvdXBUb3RhbERhdGFMYWJlbHMoc3RhY2tTZXJpZXMsIHJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGRhdGFMYWJlbHMgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhY2tHcm91cERhdGEgPSBzdGFja1Nlcmllcy5zdGFja0RhdGE7XG4gICAgICAgIGNvbnN0IHN0YWNrR3JvdXBJZHMgPSBPYmplY3Qua2V5cyhzdGFja0dyb3VwRGF0YSk7XG4gICAgICAgIHN0YWNrR3JvdXBJZHMuZm9yRWFjaCgoZ3JvdXBJZCwgZ3JvdXBJbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdG90YWxEYXRhTGFiZWxzID0gdGhpcy5tYWtlVG90YWxEYXRhTGFiZWxzKHN0YWNrR3JvdXBEYXRhW2dyb3VwSWRdLCByZW5kZXJPcHRpb25zLCBzdGFja0dyb3VwSWRzLmxlbmd0aCwgZ3JvdXBJbmRleCk7XG4gICAgICAgICAgICBkYXRhTGFiZWxzID0gWy4uLmRhdGFMYWJlbHMsIC4uLnRvdGFsRGF0YUxhYmVsc107XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YUxhYmVscztcbiAgICB9XG4gICAgbWFrZVRvdGFsRGF0YUxhYmVscyhzdGFja0RhdGEsIHJlbmRlck9wdGlvbnMsIHN0YWNrR3JvdXBDb3VudCA9IDEsIHN0YWNrR3JvdXBJbmRleCA9IDApIHtcbiAgICAgICAgY29uc3QgZGF0YUxhYmVscyA9IFtdO1xuICAgICAgICBjb25zdCB7IG1pbiwgbWF4LCBzZXJpZXNEaXJlY3Rpb24sIGRpdmVyZ2luZywgY2VudGVyWUF4aXMgfSA9IHJlbmRlck9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGNvbHVtbldpZHRoID0gdGhpcy5nZXRTdGFja0NvbHVtbldpZHRoKHJlbmRlck9wdGlvbnMsIHN0YWNrR3JvdXBDb3VudCk7XG4gICAgICAgIHN0YWNrRGF0YS5mb3JFYWNoKChkYXRhLCBkYXRhSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdG90YWwgfSA9IGRhdGE7XG4gICAgICAgICAgICBjb25zdCBzZXJpZXNQb3MgPSB0aGlzLmdldFNlcmllc1Bvc2l0aW9uKHJlbmRlck9wdGlvbnMsIGNvbHVtbldpZHRoLCBkYXRhSW5kZXgsIHN0YWNrR3JvdXBJbmRleCwgc3RhY2tHcm91cENvdW50KTtcbiAgICAgICAgICAgIGNvbnN0IHJhdGlvID0gdGhpcy5nZXRTdGFja1ZhbHVlUmF0aW8odG90YWwsIHJlbmRlck9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uS2V5cyA9IGdldERpcmVjdGlvbktleXMoc2VyaWVzRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGRpcmVjdGlvbktleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0b3RhbFtrZXldO1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBiYXJMZW5ndGggPSB0aGlzLm1ha2VCYXJMZW5ndGgodmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAgbWluLFxuICAgICAgICAgICAgICAgICAgICBtYXgsXG4gICAgICAgICAgICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFQb3NpdGlvbiA9IHRoaXMuZ2V0U3RhcnRQb3NpdGlvbihiYXJMZW5ndGgsIHZhbHVlLCByZW5kZXJPcHRpb25zLCBkaXZlcmdpbmcgJiYgaXNMZWZ0Qm90dG9tU2lkZShzdGFja0dyb3VwSW5kZXgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFja1RvdGFsID0gT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdzdGFja1RvdGFsJywgdmFsdWUsIG5hbWU6IGB0b3RhbExhYmVsLSR7a2V5fWAsIHRoZW1lOiB0aGlzLnRoZW1lLmRhdGFMYWJlbHMuc3RhY2tUb3RhbCB9LCB0aGlzLmdldEFkanVzdGVkUmVjdChzZXJpZXNQb3MsIGRhdGFQb3NpdGlvbiwgYmFyTGVuZ3RoLCBjb2x1bW5XaWR0aCkpO1xuICAgICAgICAgICAgICAgIGRhdGFMYWJlbHMucHVzaCh0aGlzLm1ha2VUb3RhbERhdGFMYWJlbChzdGFja1RvdGFsLCBjZW50ZXJZQXhpcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YUxhYmVscztcbiAgICB9XG4gICAgbWFrZVRvdGFsRGF0YUxhYmVsKHRvdGFsTGFiZWwsIGNlbnRlcllBeGlzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRvdGFsTGFiZWwpLCB7IGRpcmVjdGlvbjogdGhpcy5nZXREYXRhTGFiZWxEaXJlY3Rpb24odG90YWxMYWJlbCwgY2VudGVyWUF4aXMpLCBwbG90OiB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIHNpemU6IHRoaXMuZ2V0T2Zmc2V0U2l6ZSgpLFxuICAgICAgICAgICAgfSB9KTtcbiAgICB9XG4gICAgb25Nb3VzZW1vdmVHcm91cGVkVHlwZShyZXNwb25kZXJzKSB7XG4gICAgICAgIGNvbnN0IHJlY3RNb2RlbHMgPSB0aGlzLmdldFJlY3RNb2RlbHNGcm9tUmVjdFJlc3BvbmRlcnMocmVzcG9uZGVycyk7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVySG92ZXJlZFNlcmllcycsIHtcbiAgICAgICAgICAgIG1vZGVsczogWy4uLnJlY3RNb2RlbHMsIC4uLnRoaXMuZ2V0R3JvdXBlZFJlY3QocmVzcG9uZGVycywgJ2hvdmVyJyldLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgZXZlbnREZXRlY3RUeXBlOiB0aGlzLmV2ZW50RGV0ZWN0VHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IHJlY3RNb2RlbHM7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgZ2V0Q29vcmRpbmF0ZVhWYWx1ZSwgZ2V0Q29vcmRpbmF0ZVlWYWx1ZSB9IGZyb20gXCIuLi9oZWxwZXJzL2Nvb3JkaW5hdGVcIjtcbmltcG9ydCB7IGdldFJHQkEgfSBmcm9tIFwiLi4vaGVscGVycy9jb2xvclwiO1xuaW1wb3J0IHsgZ2V0VmFsdWVSYXRpbyB9IGZyb20gXCIuLi9oZWxwZXJzL2NhbGN1bGF0b3JcIjtcbmltcG9ydCB7IGRlZXBDb3B5LCBkZWVwTWVyZ2VkQ29weSwgaXNOdWxsLCBpc051bWJlciwgaXNTdHJpbmcgfSBmcm9tIFwiLi4vaGVscGVycy91dGlsc1wiO1xuaW1wb3J0IHsgZ2V0QWN0aXZlU2VyaWVzTWFwIH0gZnJvbSBcIi4uL2hlbHBlcnMvbGVnZW5kXCI7XG5pbXBvcnQgeyBnZXROZWFyZXN0UmVzcG9uZGVyIH0gZnJvbSBcIi4uL2hlbHBlcnMvcmVzcG9uZGVyc1wiO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi9jb21wb25lbnRcIjtcbmltcG9ydCB7IG1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZVwiO1xuY29uc3QgTUlOSU1VTV9SQURJVVMgPSAwLjU7XG5jb25zdCBNSU5JTVVNX0RFVEVDVElOR19BUkVBX1JBRElVUyA9IDE7XG5leHBvcnQgZnVuY3Rpb24gZ2V0TWF4UmFkaXVzKGJ1YmJsZURhdGEpIHtcbiAgICByZXR1cm4gYnViYmxlRGF0YS5yZWR1Y2UoKGFjYywgY3VyKSA9PiB7XG4gICAgICAgIGNvbnN0IE5vbk51bGxEYXRhID0gY3VyLmRhdGEuZmlsdGVyKChkYXR1bSkgPT4gIWlzTnVsbChkYXR1bSkpO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoYWNjLCAuLi5Ob25OdWxsRGF0YS5tYXAoKHsgciB9KSA9PiByKSk7XG4gICAgfSwgMCk7XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWJibGVTZXJpZXMgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1vZGVscyA9IHsgc2VyaWVzOiBbXSB9O1xuICAgICAgICB0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYXhSYWRpdXMgPSAtMTtcbiAgICAgICAgdGhpcy5tYXhWYWx1ZSA9IC0xO1xuICAgICAgICB0aGlzLm9uTW91c2VvdXRDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nlcmllc1BvaW50SG92ZXJlZCcsIHsgbW9kZWxzOiBbXSwgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJIb3ZlcmVkU2VyaWVzJywge1xuICAgICAgICAgICAgICAgIG1vZGVsczogW10sXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VsZWN0U2VyaWVzID0gKHsgaW5kZXgsIHNlcmllc0luZGV4LCBzdGF0ZSB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzTnVtYmVyKGluZGV4KSB8fCAhaXNOdW1iZXIoc2VyaWVzSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBuYW1lIH0gPSBzdGF0ZS5zZXJpZXMuYnViYmxlLmRhdGFbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLnJlc3BvbmRlcnMuZmlsdGVyKCh7IG5hbWU6IGRhdGFOYW1lIH0pID0+IGRhdGFOYW1lID09PSBuYW1lKVtzZXJpZXNJbmRleF07XG4gICAgICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UuU0VMRUNUX1NFUklFU19BUElfSU5ERVhfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW9kZWxzID0gdGhpcy5nZXRSZXNwb25kZXJBcHBsaWVkVGhlbWUoW21vZGVsXSwgJ3NlbGVjdCcpO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJTZWxlY3RlZFNlcmllcycsIHsgbW9kZWxzLCBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2hvd1Rvb2x0aXAgPSAoaW5mbykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpbmRleCwgc2VyaWVzSW5kZXgsIHN0YXRlIH0gPSBpbmZvO1xuICAgICAgICAgICAgaWYgKCFpc051bWJlcihpbmRleCkgfHwgIWlzTnVtYmVyKHNlcmllc0luZGV4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gc3RhdGUuc2VyaWVzLmJ1YmJsZS5kYXRhW3Nlcmllc0luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVscyA9IFt0aGlzLnJlc3BvbmRlcnMuZmlsdGVyKCh7IG5hbWU6IGRhdGFOYW1lIH0pID0+IGRhdGFOYW1lID09PSBuYW1lKVtpbmRleF1dO1xuICAgICAgICAgICAgaWYgKCFtb2RlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJIb3ZlcmVkU2VyaWVzJywgeyBtb2RlbHMsIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IG1vZGVscztcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnc2VyaWVzUG9pbnRIb3ZlcmVkJywgeyBtb2RlbHM6IHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycywgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCduZWVkRHJhdycpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnc2VyaWVzJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ2J1YmJsZSc7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMub24oJ3NlbGVjdFNlcmllcycsIHRoaXMuc2VsZWN0U2VyaWVzKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignc2hvd1Rvb2x0aXAnLCB0aGlzLnNob3dUb29sdGlwKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignaGlkZVRvb2x0aXAnLCB0aGlzLm9uTW91c2VvdXRDb21wb25lbnQpO1xuICAgIH1cbiAgICBpbml0VXBkYXRlKGRlbHRhKSB7XG4gICAgICAgIHRoaXMuZHJhd01vZGVscy5zZXJpZXMuZm9yRWFjaCgobW9kZWwsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBtb2RlbC5yYWRpdXMgPSB0aGlzLm1vZGVscy5zZXJpZXNbaW5kZXhdLnJhZGl1cyAqIGRlbHRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVuZGVyKGNoYXJ0U3RhdGUpIHtcbiAgICAgICAgY29uc3QgeyBsYXlvdXQsIHNlcmllcywgc2NhbGUsIGF4ZXMsIGNpcmNsZUxlZ2VuZCwgbGVnZW5kLCBvcHRpb25zLCB0aGVtZSB9ID0gY2hhcnRTdGF0ZTtcbiAgICAgICAgY29uc3QgeyBwbG90IH0gPSBsYXlvdXQ7XG4gICAgICAgIGlmICghc2VyaWVzLmJ1YmJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2Uubm9EYXRhRXJyb3IodGhpcy5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB4QXhpcywgeUF4aXMgfSA9IGF4ZXM7XG4gICAgICAgIGNvbnN0IGJ1YmJsZURhdGEgPSBzZXJpZXMuYnViYmxlLmRhdGE7XG4gICAgICAgIHRoaXMudGhlbWUgPSB0aGVtZS5zZXJpZXMuYnViYmxlO1xuICAgICAgICB0aGlzLnJlY3QgPSBwbG90O1xuICAgICAgICB0aGlzLmFjdGl2ZVNlcmllc01hcCA9IGdldEFjdGl2ZVNlcmllc01hcChsZWdlbmQpO1xuICAgICAgICB0aGlzLnNlbGVjdGFibGUgPSB0aGlzLmdldFNlbGVjdGFibGVPcHRpb24ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHhBeGlzVGlja1NpemUgPSB0aGlzLnJlY3Qud2lkdGggLyB4QXhpcy50aWNrQ291bnQ7XG4gICAgICAgIGNvbnN0IHlBeGlzVGlja1NpemUgPSB0aGlzLnJlY3QuaGVpZ2h0IC8geUF4aXMudGlja0NvdW50O1xuICAgICAgICB0aGlzLm1heFJhZGl1cyA9IGNpcmNsZUxlZ2VuZC5yYWRpdXNcbiAgICAgICAgICAgID8gY2lyY2xlTGVnZW5kLnJhZGl1c1xuICAgICAgICAgICAgOiBNYXRoLm1pbih4QXhpc1RpY2tTaXplLCB5QXhpc1RpY2tTaXplKTtcbiAgICAgICAgdGhpcy5tYXhWYWx1ZSA9IGdldE1heFJhZGl1cyhidWJibGVEYXRhKTtcbiAgICAgICAgY29uc3Qgc2VyaWVzTW9kZWwgPSB0aGlzLnJlbmRlckJ1YmJsZVBvaW50c01vZGVsKGJ1YmJsZURhdGEsIHNjYWxlKTtcbiAgICAgICAgY29uc3QgdG9vbHRpcE1vZGVsID0gdGhpcy5tYWtlVG9vbHRpcE1vZGVsKGJ1YmJsZURhdGEpO1xuICAgICAgICB0aGlzLm1vZGVscy5zZXJpZXMgPSBzZXJpZXNNb2RlbDtcbiAgICAgICAgaWYgKCF0aGlzLmRyYXdNb2RlbHMpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd01vZGVscyA9IGRlZXBDb3B5KHRoaXMubW9kZWxzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc3BvbmRlcnMgPSBzZXJpZXNNb2RlbC5tYXAoKG0sIGluZGV4KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyB0eXBlOiAnY2lyY2xlJywgZGV0ZWN0aW9uU2l6ZTogMCwgcmFkaXVzOiBtLnJhZGl1cyArIE1JTklNVU1fREVURUNUSU5HX0FSRUFfUkFESVVTLCBjb2xvcjogZ2V0UkdCQShtLmNvbG9yLCAwLjg1KSwgZGF0YTogdG9vbHRpcE1vZGVsW2luZGV4XSwgaW5kZXggfSkpKTtcbiAgICB9XG4gICAgcmVuZGVyQnViYmxlUG9pbnRzTW9kZWwoc2VyaWVzUmF3RGF0YSwgc2NhbGUpIHtcbiAgICAgICAgY29uc3QgeEF4aXNMaW1pdCA9IHNjYWxlLnhBeGlzLmxpbWl0O1xuICAgICAgICBjb25zdCB5QXhpc0xpbWl0ID0gc2NhbGUueUF4aXMubGltaXQ7XG4gICAgICAgIGNvbnN0IHsgYm9yZGVyV2lkdGgsIGJvcmRlckNvbG9yIH0gPSB0aGlzLnRoZW1lO1xuICAgICAgICByZXR1cm4gc2VyaWVzUmF3RGF0YS5mbGF0TWFwKCh7IGRhdGEsIG5hbWUsIGNvbG9yOiBzZXJpZXNDb2xvciB9LCBzZXJpZXNJbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2lyY2xlTW9kZWxzID0gW107XG4gICAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmFjdGl2ZVNlcmllc01hcFtuYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gZ2V0UkdCQShzZXJpZXNDb2xvciwgYWN0aXZlID8gMC44IDogMC4xKTtcbiAgICAgICAgICAgIGNvbnN0IG5vbk51bGxEYXRhID0gZGF0YS5maWx0ZXIoKGRhdHVtKSA9PiAhaXNOdWxsKGRhdHVtKSk7XG4gICAgICAgICAgICBub25OdWxsRGF0YS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhd1hWYWx1ZSA9IGdldENvb3JkaW5hdGVYVmFsdWUoZGF0dW0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHhWYWx1ZSA9IGlzU3RyaW5nKHJhd1hWYWx1ZSkgPyBOdW1iZXIobmV3IERhdGUocmF3WFZhbHVlKSkgOiBOdW1iZXIocmF3WFZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5VmFsdWUgPSBnZXRDb29yZGluYXRlWVZhbHVlKGRhdHVtKTtcbiAgICAgICAgICAgICAgICBjb25zdCB4VmFsdWVSYXRpbyA9IGdldFZhbHVlUmF0aW8oeFZhbHVlLCB4QXhpc0xpbWl0KTtcbiAgICAgICAgICAgICAgICBjb25zdCB5VmFsdWVSYXRpbyA9IGdldFZhbHVlUmF0aW8oeVZhbHVlLCB5QXhpc0xpbWl0KTtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0geFZhbHVlUmF0aW8gKiB0aGlzLnJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9ICgxIC0geVZhbHVlUmF0aW8pICogdGhpcy5yZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCByYWRpdXMgPSBNYXRoLm1heChNSU5JTVVNX1JBRElVUywgKGRhdHVtLnIgLyB0aGlzLm1heFZhbHVlKSAqIHRoaXMubWF4UmFkaXVzKTtcbiAgICAgICAgICAgICAgICBjaXJjbGVNb2RlbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjaXJjbGUnLFxuICAgICAgICAgICAgICAgICAgICByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogWydkZWZhdWx0J10sXG4gICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjaXJjbGVNb2RlbHM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYWtlVG9vbHRpcE1vZGVsKGNpcmNsZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5jaXJjbGVEYXRhXS5mbGF0TWFwKCh7IGRhdGEsIG5hbWUsIGNvbG9yIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2x0aXBEYXRhID0gW107XG4gICAgICAgICAgICBjb25zdCBub25OdWxsRGF0YSA9IGRhdGEuZmlsdGVyKChkYXR1bSkgPT4gIWlzTnVsbChkYXR1bSkpO1xuICAgICAgICAgICAgbm9uTnVsbERhdGEuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIGxhYmVsIH0gPSBkYXR1bTtcbiAgICAgICAgICAgICAgICB0b29sdGlwRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGAke25hbWV9LyR7bGFiZWx9YCxcbiAgICAgICAgICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBnZXRDb29yZGluYXRlWFZhbHVlKGRhdHVtKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGdldENvb3JkaW5hdGVZVmFsdWUoZGF0dW0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRvb2x0aXBEYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UmVzcG9uZGVyQXBwbGllZFRoZW1lKHJlc3BvbmRlcnMsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbmRlcnMubWFwKChyZXNwb25kZXIpID0+IGRlZXBNZXJnZWRDb3B5KHJlc3BvbmRlciwgdGhpcy50aGVtZVt0eXBlXSkpO1xuICAgIH1cbiAgICBvbk1vdXNlbW92ZSh7IHJlc3BvbmRlcnMsIG1vdXNlUG9zaXRpb24gfSkge1xuICAgICAgICBjb25zdCBjbG9zZXN0UmVzcG9uZGVyID0gZ2V0TmVhcmVzdFJlc3BvbmRlcihyZXNwb25kZXJzLCBtb3VzZVBvc2l0aW9uLCB0aGlzLnJlY3QpO1xuICAgICAgICBjb25zdCByZXNwb25kZXJXaXRoVGhlbWUgPSB0aGlzLmdldFJlc3BvbmRlckFwcGxpZWRUaGVtZShjbG9zZXN0UmVzcG9uZGVyLCAnaG92ZXInKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJIb3ZlcmVkU2VyaWVzJywgeyBtb2RlbHM6IHJlc3BvbmRlcldpdGhUaGVtZSwgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICB0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMgPSBjbG9zZXN0UmVzcG9uZGVyO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nlcmllc1BvaW50SG92ZXJlZCcsIHsgbW9kZWxzOiB0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMsIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCduZWVkRHJhdycpO1xuICAgIH1cbiAgICBvbkNsaWNrKHsgcmVzcG9uZGVycywgbW91c2VQb3NpdGlvbiB9KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RSZXNwb25kZXIgPSBnZXROZWFyZXN0UmVzcG9uZGVyKHJlc3BvbmRlcnMsIG1vdXNlUG9zaXRpb24sIHRoaXMucmVjdCk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25kZXJXaXRoVGhlbWUgPSB0aGlzLmdldFJlc3BvbmRlckFwcGxpZWRUaGVtZShjbG9zZXN0UmVzcG9uZGVyLCAnc2VsZWN0Jyk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlclNlbGVjdGVkU2VyaWVzJywge1xuICAgICAgICAgICAgICAgIG1vZGVsczogcmVzcG9uZGVyV2l0aFRoZW1lLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCduZWVkRHJhdycpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi9jb21wb25lbnRcIjtcbmltcG9ydCB7IGdldEFjdGl2ZVNlcmllc01hcCB9IGZyb20gXCIuLi9oZWxwZXJzL2xlZ2VuZFwiO1xuaW1wb3J0IHsgZ2V0UkdCQSwgZ2V0QWxwaGEgfSBmcm9tIFwiLi4vaGVscGVycy9jb2xvclwiO1xuaW1wb3J0IHsgaXNMYWJlbEF4aXNPbllBeGlzLCBnZXRBeGlzTmFtZSwgZ2V0U2l6ZUtleSB9IGZyb20gXCIuLi9oZWxwZXJzL2F4ZXNcIjtcbmltcG9ydCB7IGdldERhdGFMYWJlbHNPcHRpb25zIH0gZnJvbSBcIi4uL2hlbHBlcnMvZGF0YUxhYmVsc1wiO1xuaW1wb3J0IHsgREVGQVVMVF9CVUxMRVRfUkFOR0VfT1BBQ0lUWSB9IGZyb20gXCIuLi9oZWxwZXJzL3RoZW1lXCI7XG5pbXBvcnQgeyBpc051bWJlciwgb21pdCwgY2FsY3VsYXRlU2l6ZVdpdGhQZXJjZW50U3RyaW5nLCBwaWNrLCBpc051bGwsIGRlZXBDb3B5QXJyYXksIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmltcG9ydCB7IG1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZVwiO1xuaW1wb3J0IHsgbWFrZVJlY3RSZXNwb25kZXJNb2RlbCB9IGZyb20gXCIuLi9oZWxwZXJzL3Jlc3BvbmRlcnNcIjtcbmNvbnN0IERFRkFVTFRfV0lEVEhfUkFUSU8gPSAwLjY7XG5jb25zdCBNQVJLRVJfTElORV9ERVRFQ1RJT05fU0laRSA9IDU7XG5mdW5jdGlvbiBnZXRSZWN0U2l6ZSh2ZXJ0aWNhbCwgYmFyV2lkdGgsIGJhckxlbmd0aCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB2ZXJ0aWNhbCA/IGJhcldpZHRoIDogYmFyTGVuZ3RoLFxuICAgICAgICBoZWlnaHQ6IHZlcnRpY2FsID8gYmFyTGVuZ3RoIDogYmFyV2lkdGgsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFN0YXJ0WChzZXJpZXNJbmRleCwgdGlja0Rpc3RhbmNlLCBiYXJXaWR0aCkge1xuICAgIHJldHVybiBzZXJpZXNJbmRleCAqIHRpY2tEaXN0YW5jZSArICh0aWNrRGlzdGFuY2UgLSBiYXJXaWR0aCkgLyAyO1xufVxuZnVuY3Rpb24gbWFrZUJ1bGxldFJlc3BvbmRlck1vZGVsKG1vZGVscywgdG9vbHRpcERhdGEpIHtcbiAgICBjb25zdCB7IHJhbmdlLCBtYXJrZXIsIGJ1bGxldCB9ID0gbW9kZWxzO1xuICAgIGNvbnN0IHsgcmFuZ2U6IHRvb2x0aXBSYW5nZSwgbWFya2VyOiB0b29sdGlwTWFya2VyLCBidWxsZXQ6IHRvb2x0aXBCdWxsZXQgfSA9IHRvb2x0aXBEYXRhO1xuICAgIHJldHVybiBbXG4gICAgICAgIC4uLnJhbmdlLm1hcCgobSwgaW5kZXgpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG0pLCB7IGRhdGE6IHRvb2x0aXBSYW5nZVtpbmRleF0gfSkpKSxcbiAgICAgICAgLi4uYnVsbGV0Lm1hcCgobSwgaW5kZXgpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG0pLCB7IGRhdGE6IHRvb2x0aXBCdWxsZXRbaW5kZXhdIH0pKSksXG4gICAgICAgIC4uLm1hcmtlci5tYXAoKG0sIGluZGV4KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyBkZXRlY3Rpb25TaXplOiBNQVJLRVJfTElORV9ERVRFQ1RJT05fU0laRSwgZGF0YTogdG9vbHRpcE1hcmtlcltpbmRleF0gfSkpKSxcbiAgICBdO1xufVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnVsbGV0U2VyaWVzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSB7IHJhbmdlOiBbXSwgYnVsbGV0OiBbXSwgbWFya2VyOiBbXSB9O1xuICAgICAgICB0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudERldGVjdFR5cGUgPSAncG9pbnQnO1xuICAgICAgICB0aGlzLnZlcnRpY2FsID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25Nb3VzZW91dENvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnc2VyaWVzUG9pbnRIb3ZlcmVkJywgeyBtb2RlbHM6IFtdLCBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlckhvdmVyZWRTZXJpZXMnLCB7XG4gICAgICAgICAgICAgICAgbW9kZWxzOiBbXSxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZWxlY3RTZXJpZXMgPSAoeyBzZXJpZXNJbmRleCwgc3RhdGUgfSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKCFpc051bWJlcihzZXJpZXNJbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUgfSA9IChfYSA9IHN0YXRlLnNlcmllcy5idWxsZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtzZXJpZXNJbmRleF07XG4gICAgICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuZmlsdGVyQnVsbGV0UmVzcG9uZGVyKHRoaXMucmVzcG9uZGVycykuZmlsdGVyKCh7IG5hbWU6IGRhdGFOYW1lIH0pID0+IGRhdGFOYW1lID09PSBuYW1lKTtcbiAgICAgICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZS5TRUxFQ1RfU0VSSUVTX0FQSV9JTkRFWF9FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlclNlbGVjdGVkU2VyaWVzJywge1xuICAgICAgICAgICAgICAgIG1vZGVsczogdGhpcy5nZXRSZXNwb25kZXJzV2l0aFRoZW1lKG1vZGVsLCAnc2VsZWN0JyksXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2hvd1Rvb2x0aXAgPSAoeyBzZXJpZXNJbmRleCwgc3RhdGUgfSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKCFpc051bWJlcihzZXJpZXNJbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUgfSA9IChfYSA9IHN0YXRlLnNlcmllcy5idWxsZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtzZXJpZXNJbmRleF07XG4gICAgICAgICAgICBjb25zdCBtb2RlbHMgPSB0aGlzLmZpbHRlckJ1bGxldFJlc3BvbmRlcih0aGlzLnJlc3BvbmRlcnMpLmZpbHRlcigoeyBuYW1lOiBkYXRhTmFtZSB9KSA9PiBkYXRhTmFtZSA9PT0gbmFtZSk7XG4gICAgICAgICAgICBpZiAoIW1vZGVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uTW91c2Vtb3ZlKHsgcmVzcG9uZGVyczogbW9kZWxzIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnc2VyaWVzJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ2J1bGxldCc7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMub24oJ3NlbGVjdFNlcmllcycsIHRoaXMuc2VsZWN0U2VyaWVzKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignc2hvd1Rvb2x0aXAnLCB0aGlzLnNob3dUb29sdGlwKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignaGlkZVRvb2x0aXAnLCB0aGlzLm9uTW91c2VvdXRDb21wb25lbnQpO1xuICAgIH1cbiAgICBpbml0VXBkYXRlKGRlbHRhKSB7XG4gICAgICAgIGlmICghdGhpcy5kcmF3TW9kZWxzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjbGlwUmVjdCB9ID0gdGhpcy5kcmF3TW9kZWxzO1xuICAgICAgICBpZiAoIWNsaXBSZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2Zmc2V0S2V5ID0gdGhpcy52ZXJ0aWNhbCA/ICd5JyA6ICd4JztcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy52ZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGNsaXBSZWN0WzBdO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLm1vZGVscy5jbGlwUmVjdFswXTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0U2l6ZSA9IGN1cnJlbnRba2V5XSArICh0YXJnZXRba2V5XSAtIGN1cnJlbnRba2V5XSkgKiBkZWx0YTtcbiAgICAgICAgY3VycmVudFtrZXldID0gb2Zmc2V0U2l6ZTtcbiAgICAgICAgY3VycmVudFtvZmZzZXRLZXldID0gTWF0aC5tYXgodGhpcy5iYXNlUG9zaXRpb24gLSAob2Zmc2V0U2l6ZSAqIHRoaXMuYmFzZVBvc2l0aW9uKSAvIHRhcmdldFtrZXldLCAwKTtcbiAgICB9XG4gICAgcmVuZGVyKHN0YXRlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHsgbGF5b3V0LCBheGVzLCBzZXJpZXMsIHNjYWxlLCBsZWdlbmQsIG9wdGlvbnMsIHRoZW1lLCBjYXRlZ29yaWVzIH0gPSBzdGF0ZTtcbiAgICAgICAgaWYgKCFzZXJpZXMuYnVsbGV0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZS5ub0RhdGFFcnJvcih0aGlzLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEV2ZW50RGV0ZWN0VHlwZShzZXJpZXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWUuc2VyaWVzLmJ1bGxldDtcbiAgICAgICAgdGhpcy5yZWN0ID0gbGF5b3V0LnBsb3Q7XG4gICAgICAgIHRoaXMuYWN0aXZlU2VyaWVzTWFwID0gZ2V0QWN0aXZlU2VyaWVzTWFwKGxlZ2VuZCk7XG4gICAgICAgIHRoaXMuc2VsZWN0YWJsZSA9IHRoaXMuZ2V0U2VsZWN0YWJsZU9wdGlvbihvcHRpb25zKTtcbiAgICAgICAgdGhpcy52ZXJ0aWNhbCA9ICEhKChfYiA9IChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXJpZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi52ZXJ0aWNhbCk7XG4gICAgICAgIGNvbnN0IGxhYmVsQXhpc09uWUF4aXMgPSBpc0xhYmVsQXhpc09uWUF4aXMoeyBzZXJpZXMsIG9wdGlvbnMgfSk7XG4gICAgICAgIGNvbnN0IHsgbGFiZWxBeGlzTmFtZSwgdmFsdWVBeGlzTmFtZSB9ID0gZ2V0QXhpc05hbWUobGFiZWxBeGlzT25ZQXhpcywgc2VyaWVzKTtcbiAgICAgICAgY29uc3QgeyB2YWx1ZVNpemVLZXkgfSA9IGdldFNpemVLZXkobGFiZWxBeGlzT25ZQXhpcyk7XG4gICAgICAgIGNvbnN0IHsgdGlja0Rpc3RhbmNlIH0gPSBheGVzW2xhYmVsQXhpc05hbWVdO1xuICAgICAgICBjb25zdCB7IHplcm9Qb3NpdGlvbiB9ID0gYXhlc1t2YWx1ZUF4aXNOYW1lXTtcbiAgICAgICAgY29uc3QgeyBtaW4sIG1heCB9ID0gc2NhbGVbdmFsdWVBeGlzTmFtZV0ubGltaXQ7XG4gICAgICAgIGNvbnN0IGJ1bGxldERhdGEgPSBzZXJpZXMuYnVsbGV0LmRhdGE7XG4gICAgICAgIHRoaXMuYmFzZVBvc2l0aW9uID0gKHplcm9Qb3NpdGlvbiAhPT0gbnVsbCAmJiB6ZXJvUG9zaXRpb24gIT09IHZvaWQgMCA/IHplcm9Qb3NpdGlvbiA6IDApO1xuICAgICAgICBjb25zdCByZW5kZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHJhdGlvOiB0aGlzLnJlY3RbdmFsdWVTaXplS2V5XSAvIChtYXggLSBtaW4pLCB0aWNrRGlzdGFuY2UsXG4gICAgICAgICAgICB6ZXJvUG9zaXRpb24gfSwgdGhpcy5nZXRCdWxsZXRCYXJXaWR0aHModGlja0Rpc3RhbmNlKSk7XG4gICAgICAgIGNvbnN0IHJhbmdlTW9kZWxzID0gdGhpcy5yZW5kZXJSYW5nZXMoYnVsbGV0RGF0YSwgcmVuZGVyT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGJ1bGxldE1vZGVscyA9IHRoaXMucmVuZGVyQnVsbGV0KGJ1bGxldERhdGEsIHJlbmRlck9wdGlvbnMpO1xuICAgICAgICBjb25zdCBtYXJrZXJNb2RlbHMgPSB0aGlzLnJlbmRlck1hcmtlcnMoYnVsbGV0RGF0YSwgcmVuZGVyT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNsaXBSZWN0ID0gdGhpcy5yZW5kZXJDbGlwUmVjdEFyZWEoKTtcbiAgICAgICAgdGhpcy5tb2RlbHMuY2xpcFJlY3QgPSBbY2xpcFJlY3RdO1xuICAgICAgICB0aGlzLm1vZGVscy5yYW5nZSA9IHJhbmdlTW9kZWxzO1xuICAgICAgICB0aGlzLm1vZGVscy5idWxsZXQgPSBidWxsZXRNb2RlbHM7XG4gICAgICAgIHRoaXMubW9kZWxzLm1hcmtlciA9IG1hcmtlck1vZGVscztcbiAgICAgICAgaWYgKCF0aGlzLmRyYXdNb2RlbHMpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd01vZGVscyA9IHtcbiAgICAgICAgICAgICAgICBjbGlwUmVjdDogW3RoaXMubWFrZUluaXRpYWxDbGlwUmVjdE1vZGVsKGNsaXBSZWN0KV0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGRlZXBDb3B5QXJyYXkocmFuZ2VNb2RlbHMpLFxuICAgICAgICAgICAgICAgIGJ1bGxldDogZGVlcENvcHlBcnJheShidWxsZXRNb2RlbHMpLFxuICAgICAgICAgICAgICAgIG1hcmtlcjogZGVlcENvcHlBcnJheShtYXJrZXJNb2RlbHMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbHMgPSB7XG4gICAgICAgICAgICByYW5nZTogcmFuZ2VNb2RlbHMsXG4gICAgICAgICAgICBidWxsZXQ6IGJ1bGxldE1vZGVscyxcbiAgICAgICAgICAgIG1hcmtlcjogbWFya2VyTW9kZWxzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b29sdGlwRGF0YSA9IHRoaXMubWFrZVRvb2x0aXBNb2RlbChtb2RlbHMpO1xuICAgICAgICB0aGlzLnRvb2x0aXBSZWN0TWFwID0gdGhpcy5tYWtlVG9vbHRpcFJlY3RNYXAobW9kZWxzLCB0b29sdGlwRGF0YSk7XG4gICAgICAgIHRoaXMucmVzcG9uZGVycyA9IHRoaXMuZ2V0QnVsbGV0U2VyaWVzUmVzcG9uZGVycyhtb2RlbHMsIHRvb2x0aXBEYXRhLCBheGVzLCBjYXRlZ29yaWVzKTtcbiAgICAgICAgaWYgKGdldERhdGFMYWJlbHNPcHRpb25zKG9wdGlvbnMsIHRoaXMubmFtZSkudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJEYXRhTGFiZWxzKHRoaXMuZ2V0RGF0YUxhYmVscyhbLi4ucmFuZ2VNb2RlbHMsIC4uLmJ1bGxldE1vZGVscywgLi4ubWFya2VyTW9kZWxzXSwgdGhpcy52ZXJ0aWNhbCwgdGhpcy5yZWN0W3ZhbHVlU2l6ZUtleV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJDbGlwUmVjdEFyZWEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnY2xpcFJlY3RBcmVhJyxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMucmVjdC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5yZWN0LmhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbWFrZUluaXRpYWxDbGlwUmVjdE1vZGVsKGNsaXBSZWN0KSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy52ZXJ0aWNhbCA/IGNsaXBSZWN0LndpZHRoIDogMDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy52ZXJ0aWNhbCA/IDAgOiBjbGlwUmVjdC5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLnZlcnRpY2FsID8gY2xpcFJlY3QueCA6IDA7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLnZlcnRpY2FsID8gMCA6IGNsaXBSZWN0Lnk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdjbGlwUmVjdEFyZWEnLCB3aWR0aCwgaGVpZ2h0LCB4LCB5IH07XG4gICAgfVxuICAgIGdldERhdGFMYWJlbHMoc2VyaWVzTW9kZWxzLCB2ZXJ0aWNhbCwgc2l6ZSkge1xuICAgICAgICBjb25zdCB7IGRhdGFMYWJlbHM6IGRhdGFMYWJlbFRoZW1lIH0gPSB0aGlzLnRoZW1lO1xuICAgICAgICBjb25zdCBidWxsZXRMYWJlbFRoZW1lID0gb21pdChkYXRhTGFiZWxUaGVtZSwgJ21hcmtlcicpO1xuICAgICAgICBjb25zdCB7IHVzZVNlcmllc0NvbG9yLCBjb2xvciB9ID0gYnVsbGV0TGFiZWxUaGVtZTtcbiAgICAgICAgY29uc3QgeyBtYXJrZXIgfSA9IGRhdGFMYWJlbFRoZW1lO1xuICAgICAgICByZXR1cm4gc2VyaWVzTW9kZWxzXG4gICAgICAgICAgICAuZmlsdGVyKChtKSA9PiBtLnR5cGUgPT09ICdsaW5lJyB8fCBtLm1vZGVsVHlwZSAhPT0gJ3JhbmdlJylcbiAgICAgICAgICAgIC5tYXAoKG0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChtLnR5cGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG0pLCB7IHg6IHZlcnRpY2FsID8gKG0ueCArIG0ueDIpIC8gMiA6IG0ueCwgdGhlbWU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWFya2VyKSwgeyBjb2xvcjogbWFya2VyLnVzZVNlcmllc0NvbG9yID8gbS5zdHJva2VTdHlsZSA6IG1hcmtlci5jb2xvciB9KSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzVmFsdWVOZWdhdGl2ZSA9IGlzTnVtYmVyKG0udmFsdWUpICYmICgoX2EgPSBtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWUpIDwgMDtcbiAgICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSB2ZXJ0aWNhbCA/ICd0b3AnIDogJ3JpZ2h0JztcbiAgICAgICAgICAgIGlmIChpc1ZhbHVlTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSB2ZXJ0aWNhbCA/ICdib3R0b20nIDogJ2xlZnQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbSksIHsgZGlyZWN0aW9uLCBwbG90OiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgICAgfSwgdGhlbWU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVsbGV0TGFiZWxUaGVtZSksIHsgY29sb3I6IHVzZVNlcmllc0NvbG9yID8gbS5jb2xvciA6IGNvbG9yIH0pIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0RXZlbnREZXRlY3RUeXBlKHNlcmllcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoKF9iID0gKF9hID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlcmllcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmV2ZW50RGV0ZWN0VHlwZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudERldGVjdFR5cGUgPSBvcHRpb25zLnNlcmllcy5ldmVudERldGVjdFR5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0QnVsbGV0U2VyaWVzUmVzcG9uZGVycyhtb2RlbHMsIHRvb2x0aXBEYXRhLCBheGVzLCBjYXRlZ29yaWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50RGV0ZWN0VHlwZSA9PT0gJ2dyb3VwZWQnXG4gICAgICAgICAgICA/IG1ha2VSZWN0UmVzcG9uZGVyTW9kZWwodGhpcy5yZWN0LCAodGhpcy52ZXJ0aWNhbCA/IGF4ZXMueEF4aXMgOiBheGVzLnlBeGlzKSwgY2F0ZWdvcmllcywgdGhpcy52ZXJ0aWNhbClcbiAgICAgICAgICAgIDogbWFrZUJ1bGxldFJlc3BvbmRlck1vZGVsKG1vZGVscywgdG9vbHRpcERhdGEpO1xuICAgIH1cbiAgICBtYWtlVG9vbHRpcFJlY3RNYXAobW9kZWxzLCB0b29sdGlwRGF0YSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMobW9kZWxzKS5mb3JFYWNoKChzZXJpZXNUeXBlKSA9PiB7XG4gICAgICAgICAgICBtb2RlbHNbc2VyaWVzVHlwZV0uZm9yRWFjaCgobSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IG0ubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdFtsYWJlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2xhYmVsXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0b29sdGlwTW9kZWwgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG0pLCB7IGRhdGE6IHRvb2x0aXBEYXRhW3Nlcmllc1R5cGVdW2luZGV4XSB9KTtcbiAgICAgICAgICAgICAgICByZXN1bHRbbGFiZWxdLnB1c2godG9vbHRpcE1vZGVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0QnVsbGV0U2VyaWVzTW9kZWxzRnJvbVJlY3RSZXNwb25kZXJzKHJlc3BvbmRlcnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXJlc3BvbmRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9hID0gdGhpcy50b29sdGlwUmVjdE1hcFtyZXNwb25kZXJzWzBdLmxhYmVsXSwgKF9hICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKTtcbiAgICB9XG4gICAgZ2V0R3JvdXBlZFJlY3QocmVzcG9uZGVycywgdHlwZSkge1xuICAgICAgICBjb25zdCBidWxsZXRTZXJpZXNNb2RlbHMgPSB0aGlzLmdldEJ1bGxldFNlcmllc01vZGVsc0Zyb21SZWN0UmVzcG9uZGVycyhyZXNwb25kZXJzKTtcbiAgICAgICAgY29uc3QgeyBjb2xvciwgb3BhY2l0eSB9ID0gdGhpcy50aGVtZVt0eXBlXS5ncm91cGVkUmVjdDtcbiAgICAgICAgcmV0dXJuIGJ1bGxldFNlcmllc01vZGVscy5sZW5ndGhcbiAgICAgICAgICAgID8gcmVzcG9uZGVycy5tYXAoKG0pID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG0pLCB7IGNvbG9yOiBnZXRSR0JBKGNvbG9yLCBvcGFjaXR5KSB9KSkpXG4gICAgICAgICAgICA6IFtdO1xuICAgIH1cbiAgICBvbk1vdXNlbW92ZUdyb3VwZWRUeXBlKHJlc3BvbmRlcnMpIHtcbiAgICAgICAgY29uc3QgYnVsbGV0U2VyaWVzTW9kZWxzID0gdGhpcy5nZXRCdWxsZXRTZXJpZXNNb2RlbHNGcm9tUmVjdFJlc3BvbmRlcnMocmVzcG9uZGVycyk7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVySG92ZXJlZFNlcmllcycsIHtcbiAgICAgICAgICAgIG1vZGVsczogW1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2V0R3JvdXBlZFJlY3QocmVzcG9uZGVycywgJ2hvdmVyJyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5nZXRSZXNwb25kZXJzV2l0aFRoZW1lKGJ1bGxldFNlcmllc01vZGVscywgJ2hvdmVyJyksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgZXZlbnREZXRlY3RUeXBlOiB0aGlzLmV2ZW50RGV0ZWN0VHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IGJ1bGxldFNlcmllc01vZGVscztcbiAgICB9XG4gICAgb25Nb3VzZW1vdmUoeyByZXNwb25kZXJzIH0pIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnREZXRlY3RUeXBlID09PSAnZ3JvdXBlZCcpIHtcbiAgICAgICAgICAgIHRoaXMub25Nb3VzZW1vdmVHcm91cGVkVHlwZShyZXNwb25kZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVySG92ZXJlZFNlcmllcycsIHtcbiAgICAgICAgICAgICAgICBtb2RlbHM6IHRoaXMuZ2V0UmVzcG9uZGVyc1dpdGhUaGVtZShyZXNwb25kZXJzLCAnaG92ZXInKSxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IHJlc3BvbmRlcnMubGVuZ3RoID8gW3Jlc3BvbmRlcnNbcmVzcG9uZGVycy5sZW5ndGggLSAxXV0gOiBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nlcmllc1BvaW50SG92ZXJlZCcsIHtcbiAgICAgICAgICAgIG1vZGVsczogdGhpcy5hY3RpdmF0ZWRSZXNwb25kZXJzLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCduZWVkRHJhdycpO1xuICAgIH1cbiAgICBvbkNsaWNrKHsgcmVzcG9uZGVycyB9KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVscyA9IHRoaXMuZXZlbnREZXRlY3RUeXBlID09PSAnZ3JvdXBlZCdcbiAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5nZXRHcm91cGVkUmVjdChyZXNwb25kZXJzLCAnc2VsZWN0JyksXG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2V0UmVzcG9uZGVyc1dpdGhUaGVtZSh0aGlzLmdldEJ1bGxldFNlcmllc01vZGVsc0Zyb21SZWN0UmVzcG9uZGVycyhyZXNwb25kZXJzKSwgJ3NlbGVjdCcpLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICA6IHRoaXMuZ2V0UmVzcG9uZGVyc1dpdGhUaGVtZShyZXNwb25kZXJzLCAnc2VsZWN0Jyk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlclNlbGVjdGVkU2VyaWVzJywge1xuICAgICAgICAgICAgICAgIG1vZGVscyxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgZXZlbnREZXRlY3RUeXBlOiB0aGlzLmV2ZW50RGV0ZWN0VHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCduZWVkRHJhdycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbHRlckJ1bGxldFJlc3BvbmRlcihyZXNwb25kZXJzKSB7XG4gICAgICAgIHJldHVybiByZXNwb25kZXJzLmZpbHRlcigobW9kZWwpID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IG1vZGVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW9kZWxUeXBlKSA9PT0gJ2J1bGxldCc7IH0pO1xuICAgIH1cbiAgICByZW5kZXJSYW5nZXMoYnVsbGV0RGF0YSwgeyB0aWNrRGlzdGFuY2UsIHJhdGlvLCB6ZXJvUG9zaXRpb24sIHJhbmdlV2lkdGggfSkge1xuICAgICAgICBjb25zdCByYW5nZU1vZGVscyA9IFtdO1xuICAgICAgICBidWxsZXREYXRhLmZvckVhY2goKHsgcmFuZ2VzLCBjb2xvciwgbmFtZSB9LCBzZXJpZXNJbmRleCkgPT4ge1xuICAgICAgICAgICAgKChyYW5nZXMgIT09IG51bGwgJiYgcmFuZ2VzICE9PSB2b2lkIDAgPyByYW5nZXMgOiBbXSkpLmZvckVhY2goKHJhbmdlLCByYW5nZUluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwocmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXJMZW5ndGggPSAoZW5kIC0gc3RhcnQpICogcmF0aW87XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlU3RhcnRYID0gZ2V0U3RhcnRYKHNlcmllc0luZGV4LCB0aWNrRGlzdGFuY2UsIHJhbmdlV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZU1vZGVscy5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdyZWN0JywgbmFtZSwgY29sb3I6IHRoaXMuZ2V0UmFuZ2VDb2xvcihnZXRSR0JBKGNvbG9yLCB0aGlzLmdldFNlcmllc09wYWNpdHkobmFtZSkpLCByYW5nZUluZGV4LCBuYW1lKSwgeDogdGhpcy52ZXJ0aWNhbCA/IHJhbmdlU3RhcnRYIDogc3RhcnQgKiByYXRpbyArIHplcm9Qb3NpdGlvbiwgeTogdGhpcy52ZXJ0aWNhbCA/IHplcm9Qb3NpdGlvbiAtIGVuZCAqIHJhdGlvIDogcmFuZ2VTdGFydFggfSwgZ2V0UmVjdFNpemUodGhpcy52ZXJ0aWNhbCwgcmFuZ2VXaWR0aCwgYmFyTGVuZ3RoKSksIHsgbW9kZWxUeXBlOiAncmFuZ2UnLCBzZXJpZXNDb2xvcjogY29sb3IsIHRvb2x0aXBDb2xvcjogdGhpcy5nZXRSYW5nZUNvbG9yKGNvbG9yLCByYW5nZUluZGV4LCBuYW1lLCB0cnVlKSwgdmFsdWU6IHJhbmdlIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByYW5nZU1vZGVscztcbiAgICB9XG4gICAgcmVuZGVyQnVsbGV0KGJ1bGxldERhdGEsIHsgdGlja0Rpc3RhbmNlLCByYXRpbywgemVyb1Bvc2l0aW9uLCBidWxsZXRXaWR0aCB9KSB7XG4gICAgICAgIGNvbnN0IHsgYm9yZGVyQ29sb3IsIGJvcmRlcldpZHRoOiB0aGlja25lc3MgfSA9IHRoaXMudGhlbWU7XG4gICAgICAgIHJldHVybiBidWxsZXREYXRhLnJlZHVjZSgoYWNjLCB7IGRhdGEsIGNvbG9yLCBuYW1lIH0sIHNlcmllc0luZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNOdWxsKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5hY2NdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYnVsbGV0TGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5hYnMoZGF0YSAqIHJhdGlvKSwgMik7XG4gICAgICAgICAgICBjb25zdCBidWxsZXRTdGFydFggPSBnZXRTdGFydFgoc2VyaWVzSW5kZXgsIHRpY2tEaXN0YW5jZSwgYnVsbGV0V2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMudmVydGljYWwgPyBidWxsZXRTdGFydFggOiB6ZXJvUG9zaXRpb24gLSAoZGF0YSA8IDAgPyBidWxsZXRMZW5ndGggOiAwKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLnZlcnRpY2FsXG4gICAgICAgICAgICAgICAgPyB6ZXJvUG9zaXRpb24gLSBidWxsZXRMZW5ndGggKyAoZGF0YSA8IDAgPyBidWxsZXRMZW5ndGggOiAwKVxuICAgICAgICAgICAgICAgIDogYnVsbGV0U3RhcnRYO1xuICAgICAgICAgICAgY29uc3QgYnVsbGV0ID0gT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdyZWN0JywgbmFtZSwgY29sb3I6IGdldFJHQkEoY29sb3IsIHRoaXMuZ2V0U2VyaWVzT3BhY2l0eShuYW1lKSksIHgsXG4gICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICB0aGlja25lc3MsXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3IsIG1vZGVsVHlwZTogJ2J1bGxldCcsIHNlcmllc0NvbG9yOiBjb2xvciwgdG9vbHRpcENvbG9yOiBjb2xvciwgdmFsdWU6IGRhdGEgfSwgZ2V0UmVjdFNpemUodGhpcy52ZXJ0aWNhbCwgYnVsbGV0V2lkdGgsIGJ1bGxldExlbmd0aCkpO1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5hY2MsIGJ1bGxldF07XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgcmVuZGVyTWFya2VycyhidWxsZXREYXRhLCB7IHRpY2tEaXN0YW5jZSwgcmF0aW8sIHplcm9Qb3NpdGlvbiwgbWFya2VyV2lkdGggfSkge1xuICAgICAgICBjb25zdCB7IG1hcmtlckxpbmVXaWR0aCB9ID0gdGhpcy50aGVtZTtcbiAgICAgICAgY29uc3QgbWFya2VyTW9kZWxzID0gW107XG4gICAgICAgIGJ1bGxldERhdGEuZm9yRWFjaCgoeyBtYXJrZXJzLCBjb2xvciwgbmFtZSB9LCBzZXJpZXNJbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWFya2VyU3RhcnRYID0gZ2V0U3RhcnRYKHNlcmllc0luZGV4LCB0aWNrRGlzdGFuY2UsIG1hcmtlcldpZHRoKTtcbiAgICAgICAgICAgICgobWFya2VycyAhPT0gbnVsbCAmJiBtYXJrZXJzICE9PSB2b2lkIDAgPyBtYXJrZXJzIDogW10pKS5mb3JFYWNoKChtYXJrZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChtYXJrZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFQb3NpdGlvbiA9IG1hcmtlciAqIHJhdGlvO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4ID0gdGhpcy52ZXJ0aWNhbCA/IG1hcmtlclN0YXJ0WCA6IGRhdGFQb3NpdGlvbiArIHplcm9Qb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMudmVydGljYWwgPyB6ZXJvUG9zaXRpb24gLSBkYXRhUG9zaXRpb24gOiBtYXJrZXJTdGFydFg7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlck1vZGVscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyOiB0aGlzLnZlcnRpY2FsID8geCArIG1hcmtlcldpZHRoIDogeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyOiB0aGlzLnZlcnRpY2FsID8geSA6IHkgKyBtYXJrZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBnZXRSR0JBKGNvbG9yLCB0aGlzLmdldFNlcmllc09wYWNpdHkobmFtZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiBtYXJrZXJMaW5lV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNDb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwQ29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWFya2VyTW9kZWxzO1xuICAgIH1cbiAgICBtYWtlVG9vbHRpcE1vZGVsKHNlcmllc01vZGVscykge1xuICAgICAgICBjb25zdCB7IHJhbmdlLCBidWxsZXQsIG1hcmtlciB9ID0gc2VyaWVzTW9kZWxzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFuZ2U6IHRoaXMubWFrZVRvb2x0aXBEYXRhKHJhbmdlLCAnUmFuZ2UnKSxcbiAgICAgICAgICAgIGJ1bGxldDogdGhpcy5tYWtlVG9vbHRpcERhdGEoYnVsbGV0LCAnQWN0dWFsJyksXG4gICAgICAgICAgICBtYXJrZXI6IHRoaXMubWFrZVRvb2x0aXBEYXRhKG1hcmtlciwgJ01hcmtlcicpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBtYWtlVG9vbHRpcERhdGEoZGF0YSwgdGl0bGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEubWFwKChtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIHNlcmllc0NvbG9yLCB0b29sdGlwQ29sb3IsIHZhbHVlIH0gPSBtO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogbmFtZSxcbiAgICAgICAgICAgICAgICBjb2xvcjogZ2V0UkdCQShzZXJpZXNDb2xvciwgMSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IFt7IHRpdGxlLCB2YWx1ZSwgY29sb3I6IHRvb2x0aXBDb2xvciB9XSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVR5cGU6ICdidWxsZXQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEJ1bGxldEJhcldpZHRocyh0aWNrRGlzdGFuY2UpIHtcbiAgICAgICAgY29uc3QgeyBiYXJXaWR0aDogYmFyVGhlbWVXaWR0aCwgYmFyV2lkdGhSYXRpb3MgfSA9IHRoaXMudGhlbWU7XG4gICAgICAgIGNvbnN0IHsgcmFuZ2VSYXRpbywgYnVsbGV0UmF0aW8sIG1hcmtlclJhdGlvIH0gPSBiYXJXaWR0aFJhdGlvcztcbiAgICAgICAgY29uc3QgYmFyV2lkdGggPSBiYXJUaGVtZVdpZHRoXG4gICAgICAgICAgICA/IGNhbGN1bGF0ZVNpemVXaXRoUGVyY2VudFN0cmluZyh0aWNrRGlzdGFuY2UsIGJhclRoZW1lV2lkdGgpXG4gICAgICAgICAgICA6IHRpY2tEaXN0YW5jZSAqIERFRkFVTFRfV0lEVEhfUkFUSU87XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYW5nZVdpZHRoOiBiYXJXaWR0aCAqIHJhbmdlUmF0aW8sXG4gICAgICAgICAgICBidWxsZXRXaWR0aDogYmFyV2lkdGggKiBidWxsZXRSYXRpbyxcbiAgICAgICAgICAgIG1hcmtlcldpZHRoOiBiYXJXaWR0aCAqIG1hcmtlclJhdGlvLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRSYW5nZUNvbG9yKHNlcmllc0NvbG9yLCByYW5nZUluZGV4LCBzZXJpZXNOYW1lLCBpZ25vcmVSZXN0U2VyaWVzT3BhY2l0eSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHsgcmFuZ2VDb2xvcnMgfSA9IHRoaXMudGhlbWU7XG4gICAgICAgIGNvbnN0IGhhc1RoZW1lUmFuZ2VDb2xvciA9IEFycmF5LmlzQXJyYXkocmFuZ2VDb2xvcnMpICYmIHJhbmdlQ29sb3JzW3JhbmdlSW5kZXhdO1xuICAgICAgICBjb25zdCBjb2xvciA9IGhhc1RoZW1lUmFuZ2VDb2xvciA/IHJhbmdlQ29sb3JzW3JhbmdlSW5kZXhdIDogc2VyaWVzQ29sb3I7XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSBoYXNUaGVtZVJhbmdlQ29sb3JcbiAgICAgICAgICAgID8gZ2V0QWxwaGEocmFuZ2VDb2xvcnNbcmFuZ2VJbmRleF0pXG4gICAgICAgICAgICA6IERFRkFVTFRfQlVMTEVUX1JBTkdFX09QQUNJVFlbcmFuZ2VJbmRleF07XG4gICAgICAgIHJldHVybiBnZXRSR0JBKGNvbG9yLCBvcGFjaXR5ICogdGhpcy5nZXRTZXJpZXNPcGFjaXR5KHNlcmllc05hbWUsIGlnbm9yZVJlc3RTZXJpZXNPcGFjaXR5KSk7XG4gICAgfVxuICAgIGdldFNlcmllc09wYWNpdHkoc2VyaWVzTmFtZSwgaWdub3JlUmVzdFNlcmllc09wYWNpdHkgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB7IHNlbGVjdCwgYXJlYU9wYWNpdHkgfSA9IHRoaXMudGhlbWU7XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuYWN0aXZlU2VyaWVzTWFwW3Nlcmllc05hbWVdO1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IE9iamVjdC52YWx1ZXModGhpcy5hY3RpdmVTZXJpZXNNYXApLnNvbWUoKGVsZW0pID0+ICFlbGVtKTtcbiAgICAgICAgY29uc3QgcmVzdE9wYWNpdHkgPSBpZ25vcmVSZXN0U2VyaWVzT3BhY2l0eSA/IGFyZWFPcGFjaXR5IDogc2VsZWN0LnJlc3RTZXJpZXMuYXJlYU9wYWNpdHk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkT3BhY2l0eSA9IGFjdGl2ZSA/IHNlbGVjdC5hcmVhT3BhY2l0eSA6IHJlc3RPcGFjaXR5O1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQgPyBzZWxlY3RlZE9wYWNpdHkgOiBhcmVhT3BhY2l0eTtcbiAgICB9XG4gICAgZ2V0UmVzcG9uZGVyc1dpdGhUaGVtZShyZXNwb25kZXJzLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IHsgY29sb3IsIGJvcmRlckNvbG9yLCBib3JkZXJXaWR0aDogdGhpY2tuZXNzIH0gPSB0aGlzLnRoZW1lW3R5cGVdO1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJCdWxsZXRSZXNwb25kZXIocmVzcG9uZGVycykubWFwKChtb2RlbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbW9kZWwpLCB7IGNvbG9yOiAoY29sb3IgIT09IG51bGwgJiYgY29sb3IgIT09IHZvaWQgMCA/IGNvbG9yIDogbW9kZWwudG9vbHRpcENvbG9yKSwgdGhpY2tuZXNzLFxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yLCBzdHlsZTogW1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBwaWNrKHRoaXMudGhlbWVbdHlwZV0sICdzaGFkb3dCbHVyJywgJ3NoYWRvd0NvbG9yJywgJ3NoYWRvd09mZnNldFgnLCAnc2hhZG93T2Zmc2V0WScpKSxcbiAgICAgICAgICAgICAgICBdIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuL2NvbXBvbmVudFwiO1xuaW1wb3J0IHsgZ2V0TWF4UmFkaXVzIH0gZnJvbSBcIi4vYnViYmxlU2VyaWVzXCI7XG5pbXBvcnQgeyBtZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2VcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENpcmNsZUxlZ2VuZCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubW9kZWxzID0geyBjaXJjbGVMZWdlbmQ6IFtdIH07XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdjaXJjbGVMZWdlbmQnO1xuICAgIH1cbiAgICByZW5kZXIoeyBsYXlvdXQsIHNlcmllcywgY2lyY2xlTGVnZW5kIH0pIHtcbiAgICAgICAgaWYgKCFzZXJpZXMuYnViYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZS5DSVJDTEVfTEVHRU5EX1JFTkRFUl9FUlJPUik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1Nob3cgPSBjaXJjbGVMZWdlbmQudmlzaWJsZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzU2hvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1YmJsZURhdGEgPSBzZXJpZXMuYnViYmxlLmRhdGE7XG4gICAgICAgIHRoaXMucmVjdCA9IGxheW91dC5jaXJjbGVMZWdlbmQ7XG4gICAgICAgIHRoaXMucmVuZGVyQ2lyY2xlTGVnZW5kKGJ1YmJsZURhdGEsIGNpcmNsZUxlZ2VuZCk7XG4gICAgfVxuICAgIHJlbmRlckNpcmNsZUxlZ2VuZChidWJibGVEYXRhLCBjaXJjbGVMZWdlbmQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRNYXhSYWRpdXMoYnViYmxlRGF0YSk7XG4gICAgICAgIGNvbnN0IHsgcmFkaXVzIH0gPSBjaXJjbGVMZWdlbmQ7XG4gICAgICAgIHRoaXMubW9kZWxzLmNpcmNsZUxlZ2VuZCA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY2lyY2xlTGVnZW5kJyxcbiAgICAgICAgICAgICAgICByYWRpdXMsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgeDogcmFkaXVzLFxuICAgICAgICAgICAgICAgIHk6IHRoaXMucmVjdC5oZWlnaHQgLSByYWRpdXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGdldEZpcnN0VmFsaWRWYWx1ZSwgaW5jbHVkZXMsIGlzTnVtYmVyIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmltcG9ydCB7IHNldFNwbGluZUNvbnRyb2xQb2ludCB9IGZyb20gXCIuLi9oZWxwZXJzL2NhbGN1bGF0b3JcIjtcbmltcG9ydCB7IGlzU2FtZUFycmF5IH0gZnJvbSBcIi4uL2hlbHBlcnMvYXJyYXlVdGlsXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHsgc3RvcmUsIGV2ZW50QnVzIH0pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0NvbXBvbmVudCc7XG4gICAgICAgIHRoaXMudHlwZSA9ICdjb21wb25lbnQnO1xuICAgICAgICB0aGlzLnJlY3QgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzU2hvdyA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICAgIH1cbiAgICB1cGRhdGUoZGVsdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRyYXdNb2RlbHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1vZGVscykpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTW9kZWxzKHRoaXMuZHJhd01vZGVscywgdGhpcy5tb2RlbHMsIGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMubW9kZWxzKS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudE1vZGVscyA9IHRoaXMuZHJhd01vZGVsc1t0eXBlXTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRNb2RlbHMgPSB0aGlzLm1vZGVsc1t0eXBlXTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1vZGVscyhjdXJyZW50TW9kZWxzLCB0YXJnZXRNb2RlbHMsIGRlbHRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRVcGRhdGUoZGVsdGEpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoZGVsdGEpO1xuICAgIH1cbiAgICB1cGRhdGVNb2RlbHMoY3VycmVudE1vZGVscywgdGFyZ2V0TW9kZWxzLCBkZWx0YSkge1xuICAgICAgICBjdXJyZW50TW9kZWxzLmZvckVhY2goKGN1cnJlbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRNb2RlbHNbaW5kZXhdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoY3VycmVudCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudCB8fCAhdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleVswXSAhPT0gJ18nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihjdXJyZW50W2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50W2tleV0gPSBjdXJyZW50W2tleV0gKyAodGFyZ2V0W2tleV0gLSBjdXJyZW50W2tleV0pICogZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAncG9pbnRzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZE1vZGVsID0gdGhpcy5nZXRDdXJyZW50TW9kZWxUb01hdGNoVGFyZ2V0TW9kZWwoY3VycmVudFtrZXldLCBjdXJyZW50W2tleV0sIHRhcmdldFtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BvaW50cyA9IG1hdGNoZWRNb2RlbC5tYXAoKGN1clBvaW50LCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gdGFyZ2V0W2tleV1baWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyUG9pbnQgJiYgbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGN1clBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHg6IG5leHRYLCB5OiBuZXh0WSB9ID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbmV4dCksIHsgeDogeCArIChuZXh0WCAtIHgpICogZGVsdGEsIHk6IHkgKyAobmV4dFkgLSB5KSAqIGRlbHRhIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMuc3RvcmUuc3RhdGUub3B0aW9ucy5zZXJpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTcGxpbmVDb250cm9sUG9pbnQobmV3UG9pbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRba2V5XSA9IG5ld1BvaW50cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRba2V5XSA9IHRhcmdldFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzeW5jKCkge1xuICAgICAgICBpZiAoIXRoaXMuZHJhd01vZGVscykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMubW9kZWxzKSkge1xuICAgICAgICAgICAgdGhpcy5zeW5jTW9kZWxzKHRoaXMuZHJhd01vZGVscywgdGhpcy5tb2RlbHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFPYmplY3Qua2V5cyh0aGlzLm1vZGVscykubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdNb2RlbHMgPSB0aGlzLm1vZGVscztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMubW9kZWxzKS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudE1vZGVscyA9IHRoaXMuZHJhd01vZGVsc1t0eXBlXTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRNb2RlbHMgPSB0aGlzLm1vZGVsc1t0eXBlXTtcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNNb2RlbHMoY3VycmVudE1vZGVscywgdGFyZ2V0TW9kZWxzLCB0eXBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEN1cnJlbnRNb2RlbFRvTWF0Y2hUYXJnZXRNb2RlbChtb2RlbHMsIGN1cnJlbnRNb2RlbHMsIHRhcmdldE1vZGVscykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghbW9kZWxzIHx8ICFjdXJyZW50TW9kZWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnRhcmdldE1vZGVsc107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChfYSA9IGdldEZpcnN0VmFsaWRWYWx1ZSh0YXJnZXRNb2RlbHMpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxOYW1lcyA9IFsuLi5uZXcgU2V0KG1vZGVscy5tYXAoKHsgbmFtZSB9KSA9PiBuYW1lKSldO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0TmFtZXMgPSBbLi4ubmV3IFNldCh0YXJnZXRNb2RlbHMubWFwKCh7IG5hbWUgfSkgPT4gbmFtZSkpXTtcbiAgICAgICAgICAgIGNvbnN0IHNhbWUgPSBpc1NhbWVBcnJheShtb2RlbE5hbWVzLCB0YXJnZXROYW1lcyk7XG4gICAgICAgICAgICBpZiAoIXNhbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50TW9kZWxXaXRoRGlmZmVyZW50TW9kZWwobW9kZWxzLCBjdXJyZW50TW9kZWxzLCB0YXJnZXRNb2RlbHMsIG1vZGVsTmFtZXMsIHRhcmdldE5hbWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50TGVuZ3RoID0gY3VycmVudE1vZGVscy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHRhcmdldExlbmd0aCA9IHRhcmdldE1vZGVscy5sZW5ndGg7XG4gICAgICAgIGlmIChjdXJyZW50TGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLmN1cnJlbnRNb2RlbHMsIC4uLnRhcmdldE1vZGVscy5zbGljZShjdXJyZW50TGVuZ3RoLCB0YXJnZXRMZW5ndGgpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudExlbmd0aCA+IHRhcmdldExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRNb2RlbHMuc2xpY2UoMCwgdGFyZ2V0TGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kZWxzO1xuICAgIH1cbiAgICBnZXRDdXJyZW50TW9kZWxXaXRoRGlmZmVyZW50TW9kZWwobW9kZWxzLCBjdXJyZW50TW9kZWxzLCB0YXJnZXRNb2RlbHMsIG1vZGVsTmFtZXMsIHRhcmdldE5hbWVzKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRMZW5ndGggPSBjdXJyZW50TW9kZWxzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgdGFyZ2V0TGVuZ3RoID0gdGFyZ2V0TW9kZWxzLmxlbmd0aDtcbiAgICAgICAgaWYgKGN1cnJlbnRMZW5ndGggPiB0YXJnZXRMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld01vZGVscyA9IG1vZGVscy5maWx0ZXIoKHsgbmFtZSB9KSA9PiBpbmNsdWRlcyh0YXJnZXROYW1lcywgbmFtZSkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld01vZGVscy5sZW5ndGggIT09IHRhcmdldE1vZGVscy5sZW5ndGggPyB0YXJnZXRNb2RlbHMgOiBuZXdNb2RlbHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRMZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdEluY2x1ZGVkTW9kZWxzID0gdGFyZ2V0TW9kZWxzLnJlZHVjZSgoYWNjLCBjdXIsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdEluY2x1ZGVkID0gIWluY2x1ZGVzKG1vZGVsTmFtZXMsIGN1ci5uYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90SW5jbHVkZWRcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbHM6IFsuLi5hY2MubW9kZWxzLCBjdXJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxJZHg6IFsuLi5hY2MubW9kZWxJZHgsIGlkeF0sXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBhY2M7XG4gICAgICAgICAgICB9LCB7IG1vZGVsczogW10sIG1vZGVsSWR4OiBbXSB9KTtcbiAgICAgICAgICAgIGlmIChtb2RlbHMubGVuZ3RoICsgbm90SW5jbHVkZWRNb2RlbHMubW9kZWxzLmxlbmd0aCA9PT0gdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TW9kZWxzID0gWy4uLm1vZGVsc107XG4gICAgICAgICAgICAgICAgbm90SW5jbHVkZWRNb2RlbHMubW9kZWxzLmZvckVhY2goKG1vZGVsLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3TW9kZWxzLnNwbGljZShub3RJbmNsdWRlZE1vZGVscy5tb2RlbElkeFtpZHhdLCAwLCBtb2RlbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld01vZGVscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRNb2RlbHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGVscztcbiAgICB9XG4gICAgc3luY01vZGVscyhjdXJyZW50TW9kZWxzLCB0YXJnZXRNb2RlbHMsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgZHJhd01vZGVscyA9IHR5cGUgPyB0aGlzLmRyYXdNb2RlbHNbdHlwZV0gOiB0aGlzLmRyYXdNb2RlbHM7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5nZXRDdXJyZW50TW9kZWxUb01hdGNoVGFyZ2V0TW9kZWwoZHJhd01vZGVscywgY3VycmVudE1vZGVscywgdGFyZ2V0TW9kZWxzKTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd01vZGVsc1t0eXBlXSA9IG1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmF3TW9kZWxzID0gbW9kZWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2VsZWN0YWJsZU9wdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4gX2MgPSAoX2IgPSAoX2EgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VyaWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2VsZWN0YWJsZSwgKF9jICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZhbHNlKTtcbiAgICB9XG4gICAgcmVuZGVyRGF0YUxhYmVscyhkYXRhLCBuYW1lKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJEYXRhTGFiZWxzJywgeyBkYXRhLCBuYW1lOiAobmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogdGhpcy5uYW1lKSB9KTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIGRyYXcocGFpbnRlcikge1xuICAgICAgICBjb25zdCBtb2RlbHMgPSB0aGlzLmRyYXdNb2RlbHMgPyB0aGlzLmRyYXdNb2RlbHMgOiB0aGlzLm1vZGVscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobW9kZWxzKSkge1xuICAgICAgICAgICAgcGFpbnRlci5wYWludEZvckVhY2gobW9kZWxzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2RlbHMpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG1vZGVscykuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHBhaW50ZXIucGFpbnRGb3JFYWNoKG1vZGVsc1tpdGVtXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IGRlYm91bmNlIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBvbmVudE1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHsgc3RvcmUsIGV2ZW50QnVzIH0pIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gW107XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICAgIH1cbiAgICBhZGQoQ29tcG9uZW50Q3RvciwgaW5pdGlhbFBhcmFtKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnRDdG9yKHtcbiAgICAgICAgICAgIHN0b3JlOiB0aGlzLnN0b3JlLFxuICAgICAgICAgICAgZXZlbnRCdXM6IHRoaXMuZXZlbnRCdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY29tcG9uZW50LmluaXRpYWxpemUpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5pbml0aWFsaXplKGluaXRpYWxQYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByb2MgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgY29tcG9uZW50LnJlbmRlcihhcmdzWzBdLCBhcmdzWzFdKTsgLy8gcmVzdOyTsOuptCDsl5Drn6zrgqhcbiAgICAgICAgICAgIGNvbXBvbmVudC5zeW5jKCk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWRMb29wJyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RvcmUub2JzZXJ2ZSgoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgcHJvYyguLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2MgPSBkZWJvdW5jZShwcm9jKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICB9XG4gICAgcmVtb3ZlKENvbXBvbmVudEN0b3IpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzLmZpbHRlcigoY29tcG9uZW50KSA9PiAhKGNvbXBvbmVudCBpbnN0YW5jZW9mIENvbXBvbmVudEN0b3IpKTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgfVxuICAgIGludm9rZShtZXRob2QsIHBhcmFtcykge1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuZm9yRWFjaCgoY29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmbiA9IGNvbXBvbmVudFttZXRob2RdO1xuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChjb21wb25lbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3JFYWNoKGl0ZXJhdGVlKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKGl0ZXJhdGVlKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuL2NvbXBvbmVudFwiO1xuaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tIFwiLi4vaGVscGVycy91dGlsc1wiO1xuaW1wb3J0IHsgaXNNb2RlbEV4aXN0aW5nSW5SZWN0IH0gZnJvbSBcIi4uL2hlbHBlcnMvY29vcmRpbmF0ZVwiO1xuaW1wb3J0IHsgZ2V0RGF0YUxhYmVsc09wdGlvbnMsIGdldERlZmF1bHREYXRhTGFiZWxzT3B0aW9ucywgbWFrZVBvaW50TGFiZWxJbmZvLCBtYWtlU2VjdG9yTGFiZWxJbmZvLCBtYWtlUGllU2VyaWVzTmFtZUxhYmVsSW5mbywgbWFrZVJlY3RMYWJlbEluZm8sIG1ha2VMaW5lTGFiZWxJbmZvLCBtYWtlU2VjdG9yQmFyTGFiZWxJbmZvLCB9IGZyb20gXCIuLi9oZWxwZXJzL2RhdGFMYWJlbHNcIjtcbmltcG9ydCB7IHBpY2tTdGFja09wdGlvbiB9IGZyb20gXCIuLi9zdG9yZS9zdGFja1Nlcmllc0RhdGFcIjtcbmZ1bmN0aW9uIGdldExhYmVsSW5mbyhtb2RlbCwgbGFiZWxPcHRpb25zLCByZWN0LCBuYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gbW9kZWw7XG4gICAgY29uc3QgZGF0YUxhYmVsID0gW107XG4gICAgaWYgKHR5cGUgPT09ICdwb2ludCcpIHtcbiAgICAgICAgZGF0YUxhYmVsLnB1c2gobWFrZVBvaW50TGFiZWxJbmZvKG1vZGVsLCBsYWJlbE9wdGlvbnMsIHJlY3QpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ3NlY3RvcicpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdyYWRpYWxCYXInKSB7XG4gICAgICAgICAgICBkYXRhTGFiZWwucHVzaChtYWtlU2VjdG9yQmFyTGFiZWxJbmZvKG1vZGVsLCBsYWJlbE9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbC5wdXNoKG1ha2VTZWN0b3JMYWJlbEluZm8obW9kZWwsIGxhYmVsT3B0aW9ucykpO1xuICAgICAgICAgICAgaWYgKChfYSA9IGxhYmVsT3B0aW9ucy5waWVTZXJpZXNOYW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmllc05hbWVMYWJlbCA9IG1ha2VQaWVTZXJpZXNOYW1lTGFiZWxJbmZvKG1vZGVsLCBsYWJlbE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGRhdGFMYWJlbC5wdXNoKHNlcmllc05hbWVMYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgIGRhdGFMYWJlbC5wdXNoKG1ha2VMaW5lTGFiZWxJbmZvKG1vZGVsLCBsYWJlbE9wdGlvbnMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGFMYWJlbC5wdXNoKG1ha2VSZWN0TGFiZWxJbmZvKG1vZGVsLCBsYWJlbE9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFMYWJlbDtcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGFMYWJlbHMgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmRhdGFMYWJlbHNNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZW5kZXJTZXJpZXNEYXRhTGFiZWxzID0gKHNlcmllc0RhdGFMYWJlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmREYXRhTGFiZWxzKHNlcmllc0RhdGFMYWJlbCk7XG4gICAgICAgICAgICB0aGlzLm1vZGVscyA9IHRoaXMucmVuZGVyTGFiZWxNb2RlbCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRyYXdNb2RlbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdNb2RlbHMgPSB0aGlzLmdldERyYXdNb2RlbHNBcHBsaWVkT3BhY2l0eSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3luYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnZGF0YUxhYmVscyc7XG4gICAgICAgIHRoaXMubmFtZSA9ICdkYXRhTGFiZWxzJztcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbigncmVuZGVyRGF0YUxhYmVscycsIHRoaXMucmVuZGVyU2VyaWVzRGF0YUxhYmVscyk7XG4gICAgfVxuICAgIGluaXRVcGRhdGUoZGVsdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRyYXdNb2RlbHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYXdNb2RlbHMgPSB0aGlzLmdldERyYXdNb2RlbHNBcHBsaWVkT3BhY2l0eShkZWx0YSk7XG4gICAgfVxuICAgIHJlbmRlcih7IGxheW91dCwgb3B0aW9ucywgc2VyaWVzLCBuZXN0ZWRQaWVTZXJpZXMgfSkge1xuICAgICAgICB0aGlzLnJlY3QgPSBsYXlvdXQucGxvdDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pc1Nob3cgPSB0aGlzLnZpc2libGVEYXRhTGFiZWxzKHNlcmllcywgbmVzdGVkUGllU2VyaWVzKTtcbiAgICB9XG4gICAgdmlzaWJsZURhdGFMYWJlbHMoc2VyaWVzLCBuZXN0ZWRQaWVTZXJpZXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgdmlzaWJsZUNvbW1vblNlcmllc0RhdGFMYWJlbHMgPSAhISgoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuc2VyaWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0YUxhYmVscykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnZpc2libGUpO1xuICAgICAgICBjb25zdCB2aXNpYmxlQ29tYm9TZXJpZXNEYXRhTGFiZWxzID0gT2JqZWN0LmtleXMoc2VyaWVzKS5zb21lKChzZXJpZXNOYW1lKSA9PiB7IHZhciBfYSwgX2IsIF9jOyByZXR1cm4gISEoKF9jID0gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLnNlcmllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3Nlcmllc05hbWVdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGF0YUxhYmVscykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnZpc2libGUpOyB9KTtcbiAgICAgICAgY29uc3QgdmlzaWJsZU5lc3RlZFBpZVNlcmllc0RhdGFMYWJlbHMgPSAhIShuZXN0ZWRQaWVTZXJpZXMgJiZcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG5lc3RlZFBpZVNlcmllcykuc29tZSgoYWxpYXMpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICByZXR1cm4gISEoKF9jID0gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLnNlcmllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2FsaWFzXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRhdGFMYWJlbHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy52aXNpYmxlKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuICh2aXNpYmxlQ29tbW9uU2VyaWVzRGF0YUxhYmVscyB8fFxuICAgICAgICAgICAgdmlzaWJsZUNvbWJvU2VyaWVzRGF0YUxhYmVscyB8fFxuICAgICAgICAgICAgdmlzaWJsZU5lc3RlZFBpZVNlcmllc0RhdGFMYWJlbHMpO1xuICAgIH1cbiAgICBhcHBlbmREYXRhTGFiZWxzKHsgbmFtZSwgZGF0YSB9KSB7XG4gICAgICAgIGNvbnN0IGRhdGFMYWJlbE9wdGlvbnMgPSBnZXREYXRhTGFiZWxzT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG5hbWUpO1xuICAgICAgICBjb25zdCB3aXRoU3RhY2sgPSAhIXBpY2tTdGFja09wdGlvbih0aGlzLm9wdGlvbnMpO1xuICAgICAgICBjb25zdCBsYWJlbHMgPSBbXTtcbiAgICAgICAgZGF0YS5mb3JFYWNoKChtb2RlbCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gbW9kZWw7XG4gICAgICAgICAgICBjb25zdCBsYWJlbE9wdGlvbnMgPSBnZXREZWZhdWx0RGF0YUxhYmVsc09wdGlvbnMoZGF0YUxhYmVsT3B0aW9ucywgdHlwZSwgd2l0aFN0YWNrKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc2FibGVTdGFja1RvdGFsID0gdHlwZSA9PT0gJ3N0YWNrVG90YWwnICYmICEoKF9hID0gbGFiZWxPcHRpb25zLnN0YWNrVG90YWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52aXNpYmxlKTtcbiAgICAgICAgICAgIGlmIChkaXNhYmxlU3RhY2tUb3RhbCB8fCBpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYWJlbHMuc3BsaWNlKGxhYmVscy5sZW5ndGgsIDAsIC4uLmdldExhYmVsSW5mbyhtb2RlbCwgbGFiZWxPcHRpb25zLCB0aGlzLnJlY3QsIG5hbWUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGF0YUxhYmVsc01hcFtuYW1lXSA9IHsgZGF0YTogbGFiZWxzLCBvcHRpb25zOiBkYXRhTGFiZWxPcHRpb25zIH07XG4gICAgfVxuICAgIGdldERyYXdNb2RlbHNBcHBsaWVkT3BhY2l0eShvcGFjaXR5KSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLm1vZGVscykucmVkdWNlKChhY2MsIGtleSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjKSwgeyBba2V5XTogdGhpcy5tb2RlbHNba2V5XS5tYXAoKG0pID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG0pLCB7IG9wYWNpdHkgfSkpKSB9KSksIHsgc2VyaWVzOiBbXSwgdG90YWw6IFtdIH0pO1xuICAgIH1cbiAgICByZW5kZXJMYWJlbE1vZGVsKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5kYXRhTGFiZWxzTWFwKVxuICAgICAgICAgICAgLm1hcCgoc2VyaWVzTmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhIH0gPSB0aGlzLmRhdGFMYWJlbHNNYXBbc2VyaWVzTmFtZV07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlTGFiZWxNb2RlbChkYXRhKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgY3VyKSA9PiAoe1xuICAgICAgICAgICAgc2VyaWVzOiBbLi4uYWNjLnNlcmllcywgLi4uY3VyLnNlcmllc10sXG4gICAgICAgICAgICB0b3RhbDogWy4uLmFjYy50b3RhbCwgLi4uY3VyLnRvdGFsXSxcbiAgICAgICAgfSksIHsgc2VyaWVzOiBbXSwgdG90YWw6IFtdIH0pO1xuICAgIH1cbiAgICBtYWtlTGFiZWxNb2RlbChkYXRhTGFiZWxzKSB7XG4gICAgICAgIHJldHVybiBkYXRhTGFiZWxzLnJlZHVjZSgoYWNjLCBkYXRhTGFiZWwpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSwgeCwgeSwgdGV4dCwgdGV4dEFsaWduLCB0ZXh0QmFzZWxpbmUsIG5hbWUsIGNhbGxvdXQsIHRoZW1lLCByYWRpYW4sIH0gPSBkYXRhTGFiZWw7XG4gICAgICAgICAgICBpZiAoIWlzTW9kZWxFeGlzdGluZ0luUmVjdCh0aGlzLnJlY3QsIHsgeCwgeSB9KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2RlbE5hbWUgPSB0eXBlID09PSAnc3RhY2tUb3RhbCcgPyAndG90YWwnIDogJ3Nlcmllcyc7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2MpLCB7IFttb2RlbE5hbWVdOiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLihfYSA9IGFjY1ttb2RlbE5hbWVdLCAoX2EgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pKSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RhdGFMYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhTGFiZWxUeXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpYW4sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSB9KTtcbiAgICAgICAgfSwgeyBzZXJpZXM6IFtdLCB0b3RhbDogW10gfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi9jb21wb25lbnRcIjtcbmltcG9ydCB7IGlzRXhwb3J0TWVudVZpc2libGUsIHBhZGRpbmcgfSBmcm9tIFwiLi4vc3RvcmUvbGF5b3V0XCI7XG5pbXBvcnQgeyBleGVjRG93bmxvYWQsIGRvd25sb2FkU3ByZWFkU2hlZXQgfSBmcm9tIFwiLi4vaGVscGVycy9kb3dubG9hZGVyXCI7XG5pbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXRGb250U3R5bGVTdHJpbmcsIGdldFRyYW5zbGF0ZVN0cmluZyB9IGZyb20gXCIuLi9oZWxwZXJzL3N0eWxlXCI7XG5jb25zdCBFWFBPUlRfTUVOVV9XSURUSCA9IDE0MDtcbmNvbnN0IGV4cG9ydEV4dGVuc2lvbnMgPSB7XG4gICAgSU1BR0VTOiBbJ3BuZycsICdqcGVnJ10sXG4gICAgU1BSRUFEX1NIRUVUUzogWyd4bHMnLCAnY3N2J10sXG59O1xuZXhwb3J0IGNvbnN0IEJVVFRPTl9SRUNUX1NJWkUgPSAyNDtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV4cG9ydE1lbnUgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1vZGVscyA9IHsgZXhwb3J0TWVudUJ1dHRvbjogW10gfTtcbiAgICAgICAgdGhpcy5vcGVuZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGFydFdpZHRoID0gMDtcbiAgICAgICAgdGhpcy50b2dnbGVFeHBvcnRNZW51ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vcGVuZWQgPSAhdGhpcy5vcGVuZWQ7XG4gICAgICAgICAgICB0aGlzLm1vZGVscy5leHBvcnRNZW51QnV0dG9uWzBdLm9wZW5lZCA9IHRoaXMub3BlbmVkO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCduZWVkRHJhdycpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVBhbmVsV3JhcHBlclN0eWxlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFydEVsLmFwcGVuZENoaWxkKHRoaXMuZXhwb3J0TWVudUVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhcnRFbC5yZW1vdmVDaGlsZCh0aGlzLmV4cG9ydE1lbnVFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q2FudmFzRXhwb3J0QnRuUmVtb3ZlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2hhcnRFbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJylbMF07XG4gICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSwgaGVpZ2h0OiBoLCB3aWR0aDogdyB9ID0gdGhpcy5yZWN0O1xuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNoYXJ0QmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkNsaWNrRXhwb3J0QnV0dG9uID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGlkIH0gPSBldi50YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBpc0ltYWdlRXh0ZW5zaW9uID0gZXhwb3J0RXh0ZW5zaW9ucy5JTUFHRVMuaW5jbHVkZXMoaWQpO1xuICAgICAgICAgICAgY29uc3QgaXNTcHJlYWRTaGVldEV4dGVuc2lvbiA9IGV4cG9ydEV4dGVuc2lvbnMuU1BSRUFEX1NIRUVUUy5pbmNsdWRlcyhpZCk7XG4gICAgICAgICAgICBpZiAoaXNJbWFnZUV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzRXhwb3J0QnRuUmVtb3ZlZCgpO1xuICAgICAgICAgICAgICAgIGV4ZWNEb3dubG9hZCh0aGlzLmZpbGVOYW1lLCBpZCwgY2FudmFzLnRvRGF0YVVSTChgaW1hZ2UvJHtpZH1gLCAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1NwcmVhZFNoZWV0RXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgZG93bmxvYWRTcHJlYWRTaGVldCh0aGlzLmZpbGVOYW1lLCBpZCwgdGhpcy5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0ltYWdlRXh0ZW5zaW9uIHx8IGlzU3ByZWFkU2hlZXRFeHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZUV4cG9ydE1lbnUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXBwbHlFeHBvcnRCdXR0b25QYW5lbFN0eWxlKCkge1xuICAgICAgICBjb25zdCBleHBvcnRNZW51VGl0bGUgPSB0aGlzLmV4cG9ydE1lbnVFbC5xdWVyeVNlbGVjdG9yKCcudG9hc3R1aS1jaGFydC1leHBvcnQtbWVudS10aXRsZScpO1xuICAgICAgICBjb25zdCBtZW51QnRuV3JhcHBlciA9IHRoaXMuZXhwb3J0TWVudUVsLnF1ZXJ5U2VsZWN0b3IoJy50b2FzdHVpLWNoYXJ0LWV4cG9ydC1tZW51LWJ0bi13cmFwcGVyJyk7XG4gICAgICAgIGV4cG9ydE1lbnVUaXRsZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgdGhpcy5tYWtlUGFuZWxTdHlsZSgnaGVhZGVyJykpO1xuICAgICAgICBtZW51QnRuV3JhcHBlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgdGhpcy5tYWtlUGFuZWxTdHlsZSgnYm9keScpKTtcbiAgICB9XG4gICAgbWFrZUV4cG9ydE1lbnVCdXR0b24oKSB7XG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGVsLm9uY2xpY2sgPSB0aGlzLm9uQ2xpY2tFeHBvcnRCdXR0b247XG4gICAgICAgIGVsLmlubmVySFRNTCA9IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cInRvYXN0dWktY2hhcnQtZXhwb3J0LW1lbnVcIj5cbiAgICAgICAgICA8cCBjbGFzcz1cInRvYXN0dWktY2hhcnQtZXhwb3J0LW1lbnUtdGl0bGVcIj5FeHBvcnQgdG88L3A+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInRvYXN0dWktY2hhcnQtZXhwb3J0LW1lbnUtYnRuLXdyYXBwZXJcIj5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJ0b2FzdHVpLWNoYXJ0LWV4cG9ydC1tZW51LWJ0blwiIGlkPVwieGxzXCI+eGxzPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwidG9hc3R1aS1jaGFydC1leHBvcnQtbWVudS1idG5cIiBpZD1cImNzdlwiPmNzdjwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInRvYXN0dWktY2hhcnQtZXhwb3J0LW1lbnUtYnRuXCIgaWQ9XCJwbmdcIj5wbmc8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJ0b2FzdHVpLWNoYXJ0LWV4cG9ydC1tZW51LWJ0blwiIGlkPVwianBlZ1wiPmpwZWc8L2J1dHRvbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICBgO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfVxuICAgIGluaXRpYWxpemUoeyBjaGFydEVsIH0pIHtcbiAgICAgICAgdGhpcy5jaGFydEVsID0gY2hhcnRFbDtcbiAgICAgICAgdGhpcy50eXBlID0gJ2V4cG9ydE1lbnUnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnZXhwb3J0TWVudSc7XG4gICAgICAgIHRoaXMuZXhwb3J0TWVudUVsID0gdGhpcy5tYWtlRXhwb3J0TWVudUJ1dHRvbigpO1xuICAgIH1cbiAgICBvbkNsaWNrKHsgcmVzcG9uZGVycyB9KSB7XG4gICAgICAgIGlmIChyZXNwb25kZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVFeHBvcnRNZW51KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RmlsZU5hbWUodGl0bGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHRpdGxlKSA/IHRpdGxlIDogKF9iID0gKF9hID0gdGl0bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZXh0LCAoX2IgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3RvYXN0LXVpLWNoYXJ0JykpO1xuICAgIH1cbiAgICByZW5kZXIoeyBvcHRpb25zLCBsYXlvdXQsIGNoYXJ0LCBzZXJpZXMsIHJhd0NhdGVnb3JpZXMsIHRoZW1lIH0pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5pc1Nob3cgPSBpc0V4cG9ydE1lbnVWaXNpYmxlKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNoYXJ0V2lkdGggPSBjaGFydC53aWR0aDtcbiAgICAgICAgaWYgKCF0aGlzLmlzU2hvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhcnRCYWNrZ3JvdW5kQ29sb3IgPSB0aGVtZS5jaGFydC5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIHRoaXMudGhlbWUgPSB0aGVtZS5leHBvcnRNZW51O1xuICAgICAgICB0aGlzLmRhdGEgPSB7IHNlcmllcywgY2F0ZWdvcmllczogcmF3Q2F0ZWdvcmllcyB9O1xuICAgICAgICB0aGlzLmZpbGVOYW1lID0gdGhpcy5nZXRGaWxlTmFtZSgoKF9iID0gKF9hID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV4cG9ydE1lbnUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5maWxlbmFtZSkgfHwgY2hhcnQudGl0bGUpO1xuICAgICAgICB0aGlzLmFwcGx5RXhwb3J0QnV0dG9uUGFuZWxTdHlsZSgpO1xuICAgICAgICB0aGlzLnJlY3QgPSBsYXlvdXQuZXhwb3J0TWVudTtcbiAgICAgICAgdGhpcy5tb2RlbHMuZXhwb3J0TWVudUJ1dHRvbiA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXhwb3J0TWVudUJ1dHRvbicsXG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIG9wZW5lZDogdGhpcy5vcGVuZWQsXG4gICAgICAgICAgICAgICAgdGhlbWU6IHRoaXMudGhlbWUuYnV0dG9uLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5yZXNwb25kZXJzID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdyZWN0JyxcbiAgICAgICAgICAgICAgICB3aWR0aDogQlVUVE9OX1JFQ1RfU0laRSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IEJVVFRPTl9SRUNUX1NJWkUsXG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgYXBwbHlQYW5lbFdyYXBwZXJTdHlsZSgpIHtcbiAgICAgICAgY29uc3QgZXhwb3J0TWVudSA9IHRoaXMuZXhwb3J0TWVudUVsLnF1ZXJ5U2VsZWN0b3IoJy50b2FzdHVpLWNoYXJ0LWV4cG9ydC1tZW51Jyk7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLmNoYXJ0V2lkdGggLSBFWFBPUlRfTUVOVV9XSURUSCAtIHBhZGRpbmcuWDtcbiAgICAgICAgY29uc3QgeSA9IHBhZGRpbmcuWSArIEJVVFRPTl9SRUNUX1NJWkUgKyA1O1xuICAgICAgICBjb25zdCB7IGJvcmRlclJhZGl1cywgYm9yZGVyV2lkdGgsIGJvcmRlckNvbG9yIH0gPSB0aGlzLnRoZW1lLnBhbmVsO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGBcbiAgICAgIHRyYW5zZm9ybTogJHtnZXRUcmFuc2xhdGVTdHJpbmcoeCwgeSl9O1xuICAgICAgYm9yZGVyOiAke2JvcmRlcldpZHRofXB4IHNvbGlkICR7Ym9yZGVyQ29sb3J9O1xuICAgICAgYm9yZGVyLXJhZGl1czogJHtib3JkZXJSYWRpdXN9cHg7YDtcbiAgICAgICAgZXhwb3J0TWVudS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgc3R5bGUpO1xuICAgIH1cbiAgICBtYWtlUGFuZWxTdHlsZSh0eXBlKSB7XG4gICAgICAgIGNvbnN0IHNlY3Rpb25UaGVtZSA9IHRoaXMudGhlbWUucGFuZWxbdHlwZV07XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHR5cGUgPT09ICdoZWFkZXInID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgICAgY29uc3QgeyBib3JkZXJSYWRpdXMsIGJvcmRlcldpZHRoIH0gPSB0aGlzLnRoZW1lLnBhbmVsO1xuICAgICAgICBjb25zdCBib3JkZXJSYWRpdXNQeCA9IGAke2JvcmRlclJhZGl1cyAtIGJvcmRlcldpZHRofXB4YDtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGAke2dldEZvbnRTdHlsZVN0cmluZyhzZWN0aW9uVGhlbWUpfWAsXG4gICAgICAgICAgICBgYm9yZGVyLSR7ZGlyZWN0aW9ufS1sZWZ0LXJhZGl1czogJHtib3JkZXJSYWRpdXNQeH07YCxcbiAgICAgICAgICAgIGBib3JkZXItJHtkaXJlY3Rpb259LXJpZ2h0LXJhZGl1czogJHtib3JkZXJSYWRpdXNQeH07YCxcbiAgICAgICAgICAgIGBiYWNrZ3JvdW5kLWNvbG9yOiAke3NlY3Rpb25UaGVtZS5iYWNrZ3JvdW5kQ29sb3J9O2AsXG4gICAgICAgIF0uam9pbignJyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi9jb21wb25lbnRcIjtcbmltcG9ydCB7IGlzTnVtYmVyLCBwaWNrLCBpc051bGwsIGlzU3RyaW5nLCBjYWxjdWxhdGVTaXplV2l0aFBlcmNlbnRTdHJpbmcsIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmltcG9ydCB7IG1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZVwiO1xuaW1wb3J0IHsgZ2V0UmFkaWFsUG9zaXRpb24sIGNhbGN1bGF0ZURlZ3JlZVRvUmFkaWFuLCBjYWxjdWxhdGVWYWxpZEFuZ2xlLCB3aXRoaW5SYWRpYW4sIERFR1JFRV9ORUdBVElWRV85MCwgREVHUkVFXzM2MCwgREVHUkVFXzkwLCB9IGZyb20gXCIuLi9oZWxwZXJzL3NlY3RvclwiO1xuaW1wb3J0IHsgZ2V0QWN0aXZlU2VyaWVzTWFwIH0gZnJvbSBcIi4uL2hlbHBlcnMvbGVnZW5kXCI7XG5pbXBvcnQgeyBnZXRSR0JBIH0gZnJvbSBcIi4uL2hlbHBlcnMvY29sb3JcIjtcbmltcG9ydCB7IGdldFRvdGFsQW5nbGUgfSBmcm9tIFwiLi4vaGVscGVycy9waWVTZXJpZXNcIjtcbmltcG9ydCB7IGlzTGFiZWxBeGlzT25ZQXhpcyB9IGZyb20gXCIuLi9oZWxwZXJzL2F4ZXNcIjtcbmltcG9ydCB7IGdldFNjYWxlTWF4TGltaXRWYWx1ZSB9IGZyb20gXCIuL3JhZGlhbFBsb3RcIjtcbmltcG9ydCB7IGdldERhdGFMYWJlbHNPcHRpb25zIH0gZnJvbSBcIi4uL2hlbHBlcnMvZGF0YUxhYmVsc1wiO1xuaW1wb3J0IHsgREFUQV9MQUJFTF9NQVJHSU4gfSBmcm9tIFwiLi4vc3RvcmUvZ2F1Z2VBeGVzXCI7XG5jb25zdCBERVRFQ1RJT05fU0laRV9NQVJHSU4gPSAzO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2F1Z2VTZXJpZXMgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1vZGVscyA9IHsgY2xvY2tIYW5kOiBbXSwgc29saWQ6IFtdLCBiYWNrZ3JvdW5kU29saWQ6IFtdIH07XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IFtdO1xuICAgICAgICB0aGlzLm9uTW91c2VvdXRDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nlcmllc1BvaW50SG92ZXJlZCcsIHsgbW9kZWxzOiBbXSwgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJIb3ZlcmVkU2VyaWVzJywgeyBtb2RlbHM6IFtdLCBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VsZWN0U2VyaWVzID0gKGluZm8pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5kZXggfSA9IGluZm87XG4gICAgICAgICAgICBpZiAoIWlzTnVtYmVyKGluZGV4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gKF9hID0gdGhpcy50b29sdGlwTWFwLmNsb2NrSGFuZFtpbmRleF0sIChfYSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnRvb2x0aXBNYXAuc29saWRbaW5kZXhdKSk7XG4gICAgICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW9kZWxzID0gdGhpcy5nZXRSZXNwb25kZXJNb2RlbHNXaXRoVGhlbWUodGhpcy5nZXRSZXNwb25kZXJNb2RlbHMoW21vZGVsXSksICdzZWxlY3QnKTtcbiAgICAgICAgICAgIGlmICghbW9kZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlLlNFTEVDVF9TRVJJRVNfQVBJX0lOREVYX0VSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVyU2VsZWN0ZWRTZXJpZXMnLCB7XG4gICAgICAgICAgICAgICAgbW9kZWxzOiBtb2RlbHMsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2hvd1Rvb2x0aXAgPSAoaW5mbykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpbmRleCB9ID0gaW5mbztcbiAgICAgICAgICAgIGNvbnN0IG1vZGVscyA9IHRoaXMuZ2V0UmVzcG9uZGVyTW9kZWxzV2l0aFRoZW1lKFt0aGlzLnRvb2x0aXBNYXAuY2xvY2tIYW5kW2luZGV4XV0sICdob3ZlcicpO1xuICAgICAgICAgICAgaWYgKCFtb2RlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJIb3ZlcmVkU2VyaWVzJywge1xuICAgICAgICAgICAgICAgIG1vZGVscyxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IG1vZGVscztcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnc2VyaWVzUG9pbnRIb3ZlcmVkJywgeyBtb2RlbHM6IHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycywgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCduZWVkRHJhdycpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnc2VyaWVzJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ2dhdWdlJztcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignc2VsZWN0U2VyaWVzJywgdGhpcy5zZWxlY3RTZXJpZXMpO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLm9uKCdzaG93VG9vbHRpcCcsIHRoaXMuc2hvd1Rvb2x0aXApO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLm9uKCdoaWRlVG9vbHRpcCcsIHRoaXMub25Nb3VzZW91dENvbXBvbmVudCk7XG4gICAgfVxuICAgIGluaXRVcGRhdGUoZGVsdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRyYXdNb2RlbHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFuZ2xlOiB7IHN0YXJ0OiBzdGFydEFuZ2xlLCB0b3RhbDogdG90YWxBbmdsZSB9LCBjbG9ja3dpc2UsIH0gPSB0aGlzLmNpcmN1bGFyQXhpcztcbiAgICAgICAgY29uc3QgY3VycmVudERlZ3JlZSA9IGNsb2Nrd2lzZVxuICAgICAgICAgICAgPyBzdGFydEFuZ2xlICsgdG90YWxBbmdsZSAqIGRlbHRhXG4gICAgICAgICAgICA6IHN0YXJ0QW5nbGUgLSB0b3RhbEFuZ2xlICogZGVsdGE7XG4gICAgICAgIHRoaXMubW9kZWxzLmNsb2NrSGFuZC5mb3JFYWNoKChtb2RlbCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSwgYW5pbWF0aW9uRGVncmVlLCBoYW5kU2l6ZSB9ID0gbW9kZWw7XG4gICAgICAgICAgICBpZiAoKGNsb2Nrd2lzZSAmJiBhbmltYXRpb25EZWdyZWUgPCBjdXJyZW50RGVncmVlKSB8fFxuICAgICAgICAgICAgICAgICghY2xvY2t3aXNlICYmIGFuaW1hdGlvbkRlZ3JlZSA+IGN1cnJlbnREZWdyZWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zeW5jRW5kQW5nbGUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSBnZXRSYWRpYWxQb3NpdGlvbih4LCB5LCBoYW5kU2l6ZSwgY2FsY3VsYXRlRGVncmVlVG9SYWRpYW4oY2FsY3VsYXRlVmFsaWRBbmdsZShjdXJyZW50RGVncmVlKSkpO1xuICAgICAgICAgICAgdGhpcy5kcmF3TW9kZWxzLmNsb2NrSGFuZFtpbmRleF0ueDIgPSB4MjtcbiAgICAgICAgICAgIHRoaXMuZHJhd01vZGVscy5jbG9ja0hhbmRbaW5kZXhdLnkyID0geTI7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vZGVscy5zb2xpZC5mb3JFYWNoKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tb2RlbHMuc29saWQuZmluZEluZGV4KCh7IGFuaW1hdGlvbkRlZ3JlZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBhbmltYXRpb25EZWdyZWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhpblJhZGlhbihjbG9ja3dpc2UsIHN0YXJ0LCBlbmQsIGN1cnJlbnREZWdyZWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnN5bmNTZWN0b3JFbmRBbmdsZShpbmRleCA8IDAgPyB0aGlzLm1vZGVscy5zb2xpZC5sZW5ndGggOiBpbmRleCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TW9kZWxzLnNvbGlkW2luZGV4XS5kZWdyZWUuZW5kID0gY2FsY3VsYXRlVmFsaWRBbmdsZShjdXJyZW50RGVncmVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZU1vZGVscyhjdXJyZW50LCB0YXJnZXQsIGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IHsgYW5nbGU6IHsgdG90YWwgfSwgfSA9IHRoaXMuY2lyY3VsYXJBeGlzO1xuICAgICAgICBPYmplY3Qua2V5cyhjdXJyZW50KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghY3VycmVudCB8fCAhdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleVswXSAhPT0gJ18nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGN1cnJlbnRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFtrZXldID0gY3VycmVudFtrZXldICsgKHRhcmdldFtrZXldIC0gY3VycmVudFtrZXldKSAqIGRlbHRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdkZWdyZWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbCA8IERFR1JFRV8zNjAgJiYgY3VycmVudC5kZWdyZWUuZW5kIDwgREVHUkVFXzkwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50W2tleV0uZW5kID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBERUdSRUVfMzYwICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFtrZXldLmVuZCAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChERUdSRUVfMzYwIC0gdGFyZ2V0W2tleV0uZW5kICsgY3VycmVudFtrZXldLmVuZCkgKiBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRba2V5XS5lbmQgPSBjdXJyZW50W2tleV0uZW5kICsgKHRhcmdldFtrZXldLmVuZCAtIGN1cnJlbnRba2V5XS5lbmQpICogZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRba2V5XSA9IHRhcmdldFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZShkZWx0YSkge1xuICAgICAgICB0aGlzLm1vZGVscy5jbG9ja0hhbmQuZm9yRWFjaCgobW9kZWwsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1vZGVscyh0aGlzLmRyYXdNb2RlbHMuY2xvY2tIYW5kW2luZGV4XSwgbW9kZWwsIGRlbHRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZWxzLnNvbGlkLmZvckVhY2goKG1vZGVsLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNb2RlbHModGhpcy5kcmF3TW9kZWxzLnNvbGlkW2luZGV4XSwgbW9kZWwsIGRlbHRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN5bmNFbmRBbmdsZShpbmRleCkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMubW9kZWxzLmNsb2NrSGFuZFtpbmRleF07XG4gICAgICAgIGNvbnN0IGRyYXdNb2RlbCA9IHRoaXMuZHJhd01vZGVscy5jbG9ja0hhbmRbaW5kZXhdO1xuICAgICAgICBpZiAobW9kZWwueDIgIT09IGRyYXdNb2RlbC54MiB8fCBtb2RlbC55MiAhPT0gZHJhd01vZGVsLnkyKSB7XG4gICAgICAgICAgICBkcmF3TW9kZWwueDIgPSBtb2RlbC54MjtcbiAgICAgICAgICAgIGRyYXdNb2RlbC55MiA9IG1vZGVsLnkyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN5bmNTZWN0b3JFbmRBbmdsZShpbmRleCkge1xuICAgICAgICBpZiAoIWluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2VGFyZ2V0RW5kRGVncmVlID0gdGhpcy5tb2RlbHMuc29saWRbaV0uZGVncmVlLmVuZDtcbiAgICAgICAgICAgIGlmICh0aGlzLmRyYXdNb2RlbHMuc29saWRbaV0uZGVncmVlLmVuZCAhPT0gcHJldlRhcmdldEVuZERlZ3JlZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd01vZGVscy5zb2xpZFtpXS5kZWdyZWUuZW5kID0gcHJldlRhcmdldEVuZERlZ3JlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoY2hhcnRTdGF0ZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB7IGxheW91dCwgc2VyaWVzLCBsZWdlbmQsIG9wdGlvbnMsIHRoZW1lLCBzY2FsZSwgcmFkaWFsQXhlcyB9ID0gY2hhcnRTdGF0ZTtcbiAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IChfYSA9IGNoYXJ0U3RhdGUuY2F0ZWdvcmllcywgKF9hICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSk7XG4gICAgICAgIGlmICghc2VyaWVzLmdhdWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZS5ub0RhdGFFcnJvcih0aGlzLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWUuc2VyaWVzLmdhdWdlO1xuICAgICAgICB0aGlzLnJlY3QgPSBsYXlvdXQucGxvdDtcbiAgICAgICAgdGhpcy5jaXJjdWxhckF4aXMgPSByYWRpYWxBeGVzLmNpcmN1bGFyQXhpcztcbiAgICAgICAgdGhpcy5hY3RpdmVTZXJpZXNNYXAgPSBnZXRBY3RpdmVTZXJpZXNNYXAobGVnZW5kKTtcbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlID0gdGhpcy5nZXRTZWxlY3RhYmxlT3B0aW9uKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzZXJpZXNEYXRhID0gc2VyaWVzLmdhdWdlLmRhdGE7XG4gICAgICAgIGNvbnN0IGhhc0NhdGVnb3J5QXhpcyA9ICFpc0xhYmVsQXhpc09uWUF4aXMoeyBzZXJpZXMsIGNhdGVnb3JpZXMgfSk7XG4gICAgICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSB0aGlzLm1ha2VSZW5kZXJPcHRpb25zKGhhc0NhdGVnb3J5QXhpcywgY2F0ZWdvcmllcywgc2NhbGUsIChfYiA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZXJpZXMpO1xuICAgICAgICBjb25zdCBjbG9ja0hhbmRNb2RlbHMgPSB0aGlzLnJlbmRlckNsb2NrSGFuZHMoc2VyaWVzRGF0YSwgcmVuZGVyT3B0aW9ucyk7XG4gICAgICAgIHRoaXMubW9kZWxzLmNsb2NrSGFuZCA9IHJlbmRlck9wdGlvbnMudXNlQ2xvY2tIYW5kID8gY2xvY2tIYW5kTW9kZWxzIDogW107XG4gICAgICAgIGNvbnN0IHNvbGlkTW9kZWxzID0gdGhpcy5yZW5kZXJTb2xpZE1vZGVscyhzZXJpZXNEYXRhLCBjbG9ja0hhbmRNb2RlbHMsIHJlbmRlck9wdGlvbnMpO1xuICAgICAgICBjb25zdCB0b29sdGlwRGF0YSA9IHRoaXMubWFrZVRvb2x0aXBEYXRhKGNsb2NrSGFuZE1vZGVscyk7XG4gICAgICAgIGlmICghdGhpcy5kcmF3TW9kZWxzKSB7XG4gICAgICAgICAgICB0aGlzLmluaXREcmF3TW9kZWxzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldERhdGFMYWJlbHNPcHRpb25zKG9wdGlvbnMsIHRoaXMubmFtZSkudmlzaWJsZSkge1xuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgbmFtZSwgeCwgeSwgc2VyaWVzRGF0YTogZGF0YSB9ID0gY2xvY2tIYW5kTW9kZWxzWzBdO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJEYXRhTGFiZWxzKFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb2ludCcsXG4gICAgICAgICAgICAgICAgICAgIHRoZW1lOiB0aGlzLnRoZW1lLmRhdGFMYWJlbHMsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICB5OiB5ICsgREFUQV9MQUJFTF9NQVJHSU4sXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9vbHRpcE1hcCA9IHRoaXMubWFrZVRvb2x0aXBNYXAodG9vbHRpcERhdGEsIHJlbmRlck9wdGlvbnMpO1xuICAgICAgICB0aGlzLnJlc3BvbmRlcnMgPSB0aGlzLmdldFJlc3BvbmRlcnMoY2xvY2tIYW5kTW9kZWxzLCBzb2xpZE1vZGVscywgdG9vbHRpcERhdGEsIHJlbmRlck9wdGlvbnMudXNlQ2xvY2tIYW5kKTtcbiAgICB9XG4gICAgcmVuZGVyU29saWRNb2RlbHMoc2VyaWVzRGF0YSwgY2xvY2tIYW5kTW9kZWxzLCByZW5kZXJPcHRpb25zKSB7XG4gICAgICAgIGxldCBzb2xpZE1vZGVscyA9IFtdO1xuICAgICAgICB0aGlzLm1vZGVscy5jbG9ja0hhbmQgPSByZW5kZXJPcHRpb25zLnVzZUNsb2NrSGFuZCA/IGNsb2NrSGFuZE1vZGVscyA6IFtdO1xuICAgICAgICBpZiAocmVuZGVyT3B0aW9ucy5zb2xpZERhdGEudmlzaWJsZSkge1xuICAgICAgICAgICAgc29saWRNb2RlbHMgPSB0aGlzLnJlbmRlclNlY3RvcnMoc2VyaWVzRGF0YSwgcmVuZGVyT3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLm1vZGVscy5iYWNrZ3JvdW5kU29saWQgPSB0aGlzLnJlbmRlckJhY2tncm91bmRTb2xpZChyZW5kZXJPcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWxzLnNvbGlkID0gc29saWRNb2RlbHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvbGlkTW9kZWxzO1xuICAgIH1cbiAgICBpbml0RHJhd01vZGVscygpIHtcbiAgICAgICAgY29uc3QgeyBhbmdsZTogeyBzdGFydCB9LCB9ID0gdGhpcy5jaXJjdWxhckF4aXM7XG4gICAgICAgIHRoaXMuZHJhd01vZGVscyA9IHtcbiAgICAgICAgICAgIGNsb2NrSGFuZDogdGhpcy5tb2RlbHMuY2xvY2tIYW5kLm1hcCgobSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSBnZXRSYWRpYWxQb3NpdGlvbihtLngsIG0ueSwgbS5oYW5kU2l6ZSwgY2FsY3VsYXRlRGVncmVlVG9SYWRpYW4oc3RhcnQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyB4MiwgeTIsIHRlc3REZWdyZWU6IDAgfSk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGJhY2tncm91bmRTb2xpZDogdGhpcy5tb2RlbHMuYmFja2dyb3VuZFNvbGlkLFxuICAgICAgICAgICAgc29saWQ6IHRoaXMubW9kZWxzLnNvbGlkLm1hcCgobSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbSksIHsgZGVncmVlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG0uZGVncmVlKSwgeyBlbmQ6IG0uZGVncmVlLnN0YXJ0IH0pIH0pKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFJlc3BvbmRlcnMoY2xvY2tIYW5kTW9kZWxzLCBzZWN0b3JNb2RlbHMsIHRvb2x0aXBEYXRhLCB1c2VDbG9ja0hhbmQgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGNsb2NrSGFuZFJlc3BvbmRlcnMgPSAhdXNlQ2xvY2tIYW5kXG4gICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICA6IGNsb2NrSGFuZE1vZGVscy5tYXAoKG0sIGluZGV4KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyBkZXRlY3Rpb25TaXplOiBtLmJhc2VMaW5lICsgREVURUNUSU9OX1NJWkVfTUFSR0lOLCBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCB0b29sdGlwRGF0YVtpbmRleF0pIH0pKSk7XG4gICAgICAgIHJldHVybiBzZWN0b3JNb2RlbHMubGVuZ3RoXG4gICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAuLi5zZWN0b3JNb2RlbHMubWFwKChtLCBpbmRleCkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbSksIHsgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgdG9vbHRpcERhdGFbaW5kZXhdKSB9KSkpLFxuICAgICAgICAgICAgICAgIC4uLmNsb2NrSGFuZFJlc3BvbmRlcnMsXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICA6IGNsb2NrSGFuZFJlc3BvbmRlcnM7XG4gICAgfVxuICAgIGdldEhhbmRTaXplKHNpemUsIGluZGV4ID0gMCkge1xuICAgICAgICBjb25zdCBtYXhDbG9ja0hhbmRTaXplID0gdGhpcy5jaXJjdWxhckF4aXMubWF4Q2xvY2tIYW5kU2l6ZTtcbiAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHNpemUpXG4gICAgICAgICAgICAgICAgPyBjYWxjdWxhdGVTaXplV2l0aFBlcmNlbnRTdHJpbmcobWF4Q2xvY2tIYW5kU2l6ZSwgc2l6ZVtpbmRleF0pXG4gICAgICAgICAgICAgICAgOiBjYWxjdWxhdGVTaXplV2l0aFBlcmNlbnRTdHJpbmcobWF4Q2xvY2tIYW5kU2l6ZSwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heENsb2NrSGFuZFNpemU7XG4gICAgfVxuICAgIHJlbmRlckNsb2NrSGFuZHMoc2VyaWVzRGF0YSwgcmVuZGVyT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGNlbnRlclgsIGNlbnRlclksIHRvdGFsQW5nbGUsIGNsb2Nrd2lzZSwgc2NhbGVNYXhMaW1pdFZhbHVlLCBjYXRlZ29yaWVzLCBkcmF3aW5nU3RhcnRBbmdsZSwgfSA9IHJlbmRlck9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHNlcmllc01vZGVscyA9IFtdO1xuICAgICAgICBjb25zdCB7IHNpemUsIGJhc2VMaW5lLCBjb2xvcjogY2xvY2tIYW5kQ29sb3IgfSA9IHRoaXMudGhlbWUuY2xvY2tIYW5kO1xuICAgICAgICBjb25zdCB7IHJhZGl1cywgY29sb3I6IHBpbkNvbG9yLCBib3JkZXJXaWR0aCwgYm9yZGVyQ29sb3IgfSA9IHRoaXMudGhlbWUucGluO1xuICAgICAgICBzZXJpZXNEYXRhLmZvckVhY2goKHsgbmFtZSwgZGF0YSwgY29sb3IgfSwgc2VyaWVzSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlcmllc0NvbG9yID0gdGhpcy5nZXRTZXJpZXNDb2xvcihuYW1lLCBjb2xvcik7XG4gICAgICAgICAgICBkYXRhLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGlzU3RyaW5nKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA/IGNhdGVnb3JpZXMuZmluZEluZGV4KChjYXRlZ29yeSkgPT4gY2F0ZWdvcnkgPT09IHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA6IHZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZ3JlZSA9IGRyYXdpbmdTdGFydEFuZ2xlICsgKHZhbCAvIHNjYWxlTWF4TGltaXRWYWx1ZSkgKiB0b3RhbEFuZ2xlICogKGNsb2Nrd2lzZSA/IDEgOiAtMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWREZWdyZWUgPSBjYWxjdWxhdGVWYWxpZEFuZ2xlKGRlZ3JlZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZFNpemUgPSB0aGlzLmdldEhhbmRTaXplKHNpemUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gZ2V0UmFkaWFsUG9zaXRpb24oY2VudGVyWCwgY2VudGVyWSwgaGFuZFNpemUsIGNhbGN1bGF0ZURlZ3JlZVRvUmFkaWFuKHZhbGlkRGVncmVlKSk7XG4gICAgICAgICAgICAgICAgc2VyaWVzTW9kZWxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2xvY2tIYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IChjbG9ja0hhbmRDb2xvciAhPT0gbnVsbCAmJiBjbG9ja0hhbmRDb2xvciAhPT0gdm9pZCAwID8gY2xvY2tIYW5kQ29sb3IgOiBzZXJpZXNDb2xvciksXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB4OiBjZW50ZXJYLFxuICAgICAgICAgICAgICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICB4MixcbiAgICAgICAgICAgICAgICAgICAgeTIsXG4gICAgICAgICAgICAgICAgICAgIHBpbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogKHBpbkNvbG9yICE9PSBudWxsICYmIHBpbkNvbG9yICE9PSB2b2lkIDAgPyBwaW5Db2xvciA6IHNlcmllc0NvbG9yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogKGJvcmRlckNvbG9yICE9PSBudWxsICYmIGJvcmRlckNvbG9yICE9PSB2b2lkIDAgPyBib3JkZXJDb2xvciA6IGdldFJHQkEoc2VyaWVzQ29sb3IsIDAuMSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IGJvcmRlcldpZHRoID8gYm9yZGVyV2lkdGggKyByYWRpdXMgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWdyZWU6IHZhbGlkRGVncmVlLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25EZWdyZWU6IGRlZ3JlZSxcbiAgICAgICAgICAgICAgICAgICAgYmFzZUxpbmU6IGJhc2VMaW5lLFxuICAgICAgICAgICAgICAgICAgICBoYW5kU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzRGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VyaWVzTW9kZWxzO1xuICAgIH1cbiAgICByZW5kZXJCYWNrZ3JvdW5kU29saWQocmVuZGVyT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGNlbnRlclgsIGNlbnRlclksIHN0YXJ0QW5nbGUsIHRvdGFsQW5nbGUsIGNsb2Nrd2lzZSwgc29saWREYXRhIH0gPSByZW5kZXJPcHRpb25zO1xuICAgICAgICBjb25zdCB7IGNvbG9yIH0gPSB0aGlzLnRoZW1lLnNvbGlkLmJhY2tncm91bmRTb2xpZDtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc2VjdG9yJyxcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgIGNsb2Nrd2lzZSxcbiAgICAgICAgICAgICAgICBkZWdyZWU6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0QW5nbGUsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogc3RhcnRBbmdsZSArIHRvdGFsQW5nbGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByYWRpdXM6IHNvbGlkRGF0YS5yYWRpdXNSYW5nZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJlbmRlclNlY3RvcnMoc2VyaWVzRGF0YSwgcmVuZGVyT3B0aW9ucykge1xuICAgICAgICBjb25zdCBzZWN0b3JzID0gW107XG4gICAgICAgIGNvbnN0IHsgY2VudGVyWCwgY2VudGVyWSwgY2xvY2t3aXNlLCB0b3RhbEFuZ2xlLCBzY2FsZU1heExpbWl0VmFsdWUsIHN0YXJ0QW5nbGUsIGNhdGVnb3JpZXMsIHNvbGlkRGF0YSwgfSA9IHJlbmRlck9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgcmFkaXVzUmFuZ2UgfSA9IHNvbGlkRGF0YTtcbiAgICAgICAgY29uc3QgeyBsaW5lV2lkdGgsIHN0cm9rZVN0eWxlIH0gPSB0aGlzLnRoZW1lLnNvbGlkO1xuICAgICAgICBzZXJpZXNEYXRhLmZvckVhY2goKHsgbmFtZSwgZGF0YSwgY29sb3IgfSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlcmllc0NvbG9yID0gdGhpcy5nZXRTZXJpZXNDb2xvcihuYW1lLCBjb2xvcik7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFbMF07XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBpc1N0cmluZyh2YWx1ZSkgPyBjYXRlZ29yaWVzLmZpbmRJbmRleCgoY2F0ZWdvcnkpID0+IGNhdGVnb3J5ID09PSB2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGRlZ3JlZSA9ICh2YWwgLyBzY2FsZU1heExpbWl0VmFsdWUpICogdG90YWxBbmdsZSAqIChjbG9ja3dpc2UgPyAxIDogLTEpO1xuICAgICAgICAgICAgY29uc3QgdmFsaWREZWdyZWUgPSBjYWxjdWxhdGVWYWxpZEFuZ2xlKGRlZ3JlZSk7XG4gICAgICAgICAgICBjb25zdCBzdGFydERlZ3JlZSA9IHN0YXJ0QW5nbGU7XG4gICAgICAgICAgICBjb25zdCBlbmREZWdyZWUgPSBzdGFydERlZ3JlZSArIGRlZ3JlZTtcbiAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvblN0YXJ0RGVncmVlID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbkVuZERlZ3JlZSA9IGFuaW1hdGlvblN0YXJ0RGVncmVlICsgdmFsaWREZWdyZWU7XG4gICAgICAgICAgICBzZWN0b3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzZWN0b3InLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBzZXJpZXNDb2xvcixcbiAgICAgICAgICAgICAgICB4OiBjZW50ZXJYLFxuICAgICAgICAgICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgICAgICAgICAgY2xvY2t3aXNlLFxuICAgICAgICAgICAgICAgIGRlZ3JlZToge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnREZWdyZWUsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZW5kRGVncmVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXNSYW5nZSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25EZWdyZWU6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGFuaW1hdGlvblN0YXJ0RGVncmVlLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGFuaW1hdGlvbkVuZERlZ3JlZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRyYXdpbmdTdGFydEFuZ2xlOiBERUdSRUVfTkVHQVRJVkVfOTAsXG4gICAgICAgICAgICAgICAgc3R5bGU6IFt7IHN0cm9rZVN0eWxlIH1dLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aCxcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlY3RvcnM7XG4gICAgfVxuICAgIG1ha2VUb29sdGlwTWFwKHRvb2x0aXBEYXRhLCByZW5kZXJPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgY2xvY2tIYW5kLCBzb2xpZCB9ID0gdGhpcy5tb2RlbHM7XG4gICAgICAgIGNvbnN0IHsgdXNlQ2xvY2tIYW5kIH0gPSByZW5kZXJPcHRpb25zO1xuICAgICAgICByZXR1cm4gdG9vbHRpcERhdGEucmVkdWNlKChhY2MsIGRhdGEsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAodXNlQ2xvY2tIYW5kKSB7XG4gICAgICAgICAgICAgICAgYWNjLmNsb2NrSGFuZC5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2xvY2tIYW5kW2luZGV4XSksIHsgZGV0ZWN0aW9uU2l6ZTogY2xvY2tIYW5kW2luZGV4XS5iYXNlTGluZSArIDMsIGRhdGEgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvbGlkW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIGFjYy5zb2xpZC5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc29saWRbaW5kZXhdKSwgeyBkYXRhIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHsgc29saWQ6IFtdLCBjbG9ja0hhbmQ6IFtdIH0pO1xuICAgIH1cbiAgICBtYWtlUmVuZGVyT3B0aW9ucyhoYXNDYXRlZ29yeUF4aXMsIGNhdGVnb3JpZXMsIHNjYWxlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHsgY2VudGVyWCwgY2VudGVyWSwgc29saWREYXRhLCBhbmdsZTogeyBzdGFydCwgZW5kLCBkcmF3aW5nU3RhcnQgfSwgcmFkaXVzOiB7IG91dGVyIH0sIH0gPSB0aGlzLmNpcmN1bGFyQXhpcztcbiAgICAgICAgY29uc3Qgc29saWQgPSB0aGlzLmNpcmN1bGFyQXhpcy5zb2xpZERhdGE7XG4gICAgICAgIGNvbnN0IGNsb2Nrd2lzZSA9IChfYiA9IChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9ja3dpc2UsIChfYiAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlKSk7XG4gICAgICAgIGNvbnN0IHRvdGFsQW5nbGUgPSBnZXRUb3RhbEFuZ2xlKGNsb2Nrd2lzZSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbG9ja3dpc2UsXG4gICAgICAgICAgICBjZW50ZXJYLFxuICAgICAgICAgICAgY2VudGVyWSxcbiAgICAgICAgICAgIGFuZ2xlUmFuZ2U6IHsgc3RhcnQsIGVuZCB9LFxuICAgICAgICAgICAgdG90YWxBbmdsZSxcbiAgICAgICAgICAgIHNjYWxlTWF4TGltaXRWYWx1ZTogaGFzQ2F0ZWdvcnlBeGlzXG4gICAgICAgICAgICAgICAgPyBjYXRlZ29yaWVzLmxlbmd0aFxuICAgICAgICAgICAgICAgIDogZ2V0U2NhbGVNYXhMaW1pdFZhbHVlKHNjYWxlLmNpcmN1bGFyQXhpcywgdG90YWxBbmdsZSksXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydCxcbiAgICAgICAgICAgIGNhdGVnb3JpZXMsXG4gICAgICAgICAgICBkcmF3aW5nU3RhcnRBbmdsZTogZHJhd2luZ1N0YXJ0LFxuICAgICAgICAgICAgb3V0ZXJSYWRpdXM6IG91dGVyLFxuICAgICAgICAgICAgdXNlQ2xvY2tIYW5kOiBzb2xpZC52aXNpYmxlID8gc29saWQuY2xvY2tIYW5kIDogdHJ1ZSxcbiAgICAgICAgICAgIHNvbGlkRGF0YTogc29saWREYXRhLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRTZXJpZXNDb2xvcihuYW1lLCBjb2xvcikge1xuICAgICAgICBjb25zdCB7IHNlbGVjdCwgYXJlYU9wYWNpdHkgfSA9IHRoaXMudGhlbWU7XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuYWN0aXZlU2VyaWVzTWFwW25hbWVdO1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IE9iamVjdC52YWx1ZXModGhpcy5hY3RpdmVTZXJpZXNNYXApLnNvbWUoKGVsZW0pID0+ICFlbGVtKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkXG4gICAgICAgICAgICA/IGdldFJHQkEoY29sb3IsIGFjdGl2ZSA/IHNlbGVjdC5hcmVhT3BhY2l0eSA6IHNlbGVjdC5yZXN0U2VyaWVzLmFyZWFPcGFjaXR5KVxuICAgICAgICAgICAgOiBnZXRSR0JBKGNvbG9yLCBhcmVhT3BhY2l0eSk7XG4gICAgfVxuICAgIG1ha2VUb29sdGlwRGF0YShzZXJpZXNNb2RlbHMpIHtcbiAgICAgICAgcmV0dXJuIHNlcmllc01vZGVscy5yZWR1Y2UoKGFjYywgeyBjb2xvciwgbmFtZSwgdmFsdWUsIGluZGV4LCBzZXJpZXNJbmRleCB9KSA9PiBpc051bGwodmFsdWUpID8gYWNjIDogWy4uLmFjYywgeyBsYWJlbDogbmFtZSwgY29sb3IsIHZhbHVlOiB2YWx1ZSwgaW5kZXgsIHNlcmllc0luZGV4IH1dLCBbXSk7XG4gICAgfVxuICAgIG9uTW91c2Vtb3ZlKHsgcmVzcG9uZGVycyB9KSB7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVySG92ZXJlZFNlcmllcycsIHtcbiAgICAgICAgICAgIG1vZGVsczogdGhpcy5nZXRSZXNwb25kZXJNb2RlbHNXaXRoVGhlbWUodGhpcy5nZXRSZXNwb25kZXJNb2RlbHMocmVzcG9uZGVycyksICdob3ZlcicpLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZWRSZXNwb25kZXJzID0gcmVzcG9uZGVycy5tYXAoKHJlc3BvbmRlcikgPT4gKE9iamVjdC5hc3NpZ24oe30sIHJlc3BvbmRlcikpKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzZXJpZXNQb2ludEhvdmVyZWQnLCB7XG4gICAgICAgICAgICBtb2RlbHM6IHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICB9XG4gICAgZ2V0UmVzcG9uZGVyTW9kZWxzKHJlc3BvbmRlcnMpIHtcbiAgICAgICAgY29uc3QgeyBjbG9ja0hhbmQsIHNvbGlkIH0gPSB0aGlzLnRvb2x0aXBNYXA7XG4gICAgICAgIHJldHVybiByZXNwb25kZXJzLnJlZHVjZSgoYWNjLCByZXNwb25kZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcmVzcG9uZGVyLmluZGV4O1xuICAgICAgICAgICAgY29uc3QgY2xvY2tIYW5kTW9kZWwgPSBjbG9ja0hhbmRbaW5kZXhdID8gW2Nsb2NrSGFuZFtpbmRleF1dIDogW107XG4gICAgICAgICAgICBjb25zdCBzb2xpZE1vZGVsID0gc29saWRbaW5kZXhdID8gW3NvbGlkW2luZGV4XV0gOiBbXTtcbiAgICAgICAgICAgIHJldHVybiBbLi4uYWNjLCAuLi5jbG9ja0hhbmRNb2RlbCwgLi4uc29saWRNb2RlbF07XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgb25DbGljayh7IHJlc3BvbmRlcnMgfSkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICBjb25zdCBtb2RlbHMgPSB0aGlzLmdldFJlc3BvbmRlck1vZGVsc1dpdGhUaGVtZSh0aGlzLmdldFJlc3BvbmRlck1vZGVscyhyZXNwb25kZXJzKSwgJ3NlbGVjdCcpO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJTZWxlY3RlZFNlcmllcycsIHtcbiAgICAgICAgICAgICAgICBtb2RlbHMsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmVzcG9uZGVyTW9kZWxzV2l0aFNvbGlkVGhlbWUocmVzcG9uZGVyLCB0eXBlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgc29saWRUaGVtZSA9IHRoaXMudGhlbWVbdHlwZV0uc29saWQ7XG4gICAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IHNvbGlkVGhlbWUubGluZVdpZHRoO1xuICAgICAgICBjb25zdCBpc1NhbWVMaW5lV2lkdGggPSB0aGlzLnRoZW1lLnNvbGlkID09PSBsaW5lV2lkdGg7XG4gICAgICAgIGNvbnN0IHRoaWNrbmVzcyA9IGlzU2FtZUxpbmVXaWR0aCA/IDAgOiBsaW5lV2lkdGggKiAwLjU7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3BvbmRlciksIHsgY29sb3I6IChfYSA9IHNvbGlkVGhlbWUuY29sb3IsIChfYSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiByZXNwb25kZXIuY29sb3IpKSwgbGluZVdpZHRoLCBzdHlsZTogW1xuICAgICAgICAgICAgICAgIHBpY2soc29saWRUaGVtZSwgJ3N0cm9rZVN0eWxlJywgJ3NoYWRvd0JsdXInLCAnc2hhZG93Q29sb3InLCAnc2hhZG93T2Zmc2V0WCcsICdzaGFkb3dPZmZzZXRZJyksXG4gICAgICAgICAgICBdLCByYWRpdXM6IHtcbiAgICAgICAgICAgICAgICBpbm5lcjogTWF0aC5tYXgocmVzcG9uZGVyLnJhZGl1cy5pbm5lciAtIHRoaWNrbmVzcywgMCksXG4gICAgICAgICAgICAgICAgb3V0ZXI6IHJlc3BvbmRlci5yYWRpdXMub3V0ZXIgKyB0aGlja25lc3MsXG4gICAgICAgICAgICB9IH0pO1xuICAgIH1cbiAgICBnZXRSZXNwb25kZXJXaXRoQ2xvY2tIYW5kVGhlbWUocmVzcG9uZGVyLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IHsgY2xvY2tIYW5kLCBwaW4gfSA9IHRoaXMudGhlbWVbdHlwZV07XG4gICAgICAgIGNvbnN0IHsgc2l6ZSwgYmFzZUxpbmUsIGNvbG9yOiBjbG9ja0hhbmRDb2xvciB9ID0gY2xvY2tIYW5kO1xuICAgICAgICBjb25zdCB7IHJhZGl1cywgY29sb3I6IHBpbkNvbG9yLCBib3JkZXJXaWR0aCwgYm9yZGVyQ29sb3IgfSA9IHBpbjtcbiAgICAgICAgY29uc3QgcGluUmFkaXVzID0gKHJhZGl1cyAhPT0gbnVsbCAmJiByYWRpdXMgIT09IHZvaWQgMCA/IHJhZGl1cyA6IHJlc3BvbmRlci5waW4ucmFkaXVzKTtcbiAgICAgICAgY29uc3QgcGluU3R5bGUgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IChib3JkZXJDb2xvciAhPT0gbnVsbCAmJiBib3JkZXJDb2xvciAhPT0gdm9pZCAwID8gYm9yZGVyQ29sb3IgOiBnZXRSR0JBKHJlc3BvbmRlci5waW4uc3R5bGVbMF0uc3Ryb2tlU3R5bGUsIDAuMykpLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogYm9yZGVyV2lkdGggPyBib3JkZXJXaWR0aCArIHBpblJhZGl1cyA6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXNwb25kZXIpLCB7IGNvbG9yOiAoY2xvY2tIYW5kQ29sb3IgIT09IG51bGwgJiYgY2xvY2tIYW5kQ29sb3IgIT09IHZvaWQgMCA/IGNsb2NrSGFuZENvbG9yIDogcmVzcG9uZGVyLmNvbG9yKSwgcGluOiB7XG4gICAgICAgICAgICAgICAgcmFkaXVzOiBwaW5SYWRpdXMsXG4gICAgICAgICAgICAgICAgY29sb3I6IChwaW5Db2xvciAhPT0gbnVsbCAmJiBwaW5Db2xvciAhPT0gdm9pZCAwID8gcGluQ29sb3IgOiByZXNwb25kZXIucGluLmNvbG9yKSxcbiAgICAgICAgICAgICAgICBzdHlsZTogcGluU3R5bGUsXG4gICAgICAgICAgICB9LCBiYXNlTGluZTogKGJhc2VMaW5lICE9PSBudWxsICYmIGJhc2VMaW5lICE9PSB2b2lkIDAgPyBiYXNlTGluZSA6IHJlc3BvbmRlci5iYXNlTGluZSksIGhhbmRTaXplOiBzaXplID8gdGhpcy5nZXRIYW5kU2l6ZShzaXplLCByZXNwb25kZXIuaW5kZXgpIDogcmVzcG9uZGVyLmhhbmRTaXplIH0pO1xuICAgIH1cbiAgICBnZXRSZXNwb25kZXJNb2RlbHNXaXRoVGhlbWUocmVzcG9uZGVycywgdHlwZSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uZGVycy5tYXAoKG0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAoKF9hID0gbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSAnc2VjdG9yJ1xuICAgICAgICAgICAgICAgID8gdGhpcy5nZXRSZXNwb25kZXJNb2RlbHNXaXRoU29saWRUaGVtZShtLCB0eXBlKVxuICAgICAgICAgICAgICAgIDogdGhpcy5nZXRSZXNwb25kZXJXaXRoQ2xvY2tIYW5kVGhlbWUobSwgdHlwZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIi4vY29tcG9uZW50XCI7XG5pbXBvcnQgeyBoZXhUb1JHQiB9IGZyb20gXCIuLi9oZWxwZXJzL2NvbG9yXCI7XG5pbXBvcnQgeyBnZXREYXRhTGFiZWxzT3B0aW9ucyB9IGZyb20gXCIuLi9oZWxwZXJzL2RhdGFMYWJlbHNcIjtcbmltcG9ydCB7IGdldENvbG9yUmF0aW8sIGdldFNwZWN0cnVtQ29sb3IsIG1ha2VEaXN0YW5jZXMgfSBmcm9tIFwiLi4vaGVscGVycy9jb2xvclNwZWN0cnVtXCI7XG5pbXBvcnQgeyBkZWVwTWVyZ2VkQ29weSwgaXNOdWxsLCBpc051bWJlciB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBib3hEZWZhdWx0IH0gZnJvbSBcIi4uL2hlbHBlcnMvdGhlbWVcIjtcbmltcG9ydCB7IG1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZVwiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVhdG1hcFNlcmllcyBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IFtdO1xuICAgICAgICB0aGlzLm9uTW91c2VvdXRDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXRNb3VzZUV2ZW50KFtdKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZWxlY3RTZXJpZXMgPSAoeyBpbmRleCwgc2VyaWVzSW5kZXgsIHN0YXRlLCB9KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIWlzTnVtYmVyKGluZGV4KSB8fCAhaXNOdW1iZXIoc2VyaWVzSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YVNpemUgPSAoX2EgPSBzdGF0ZS5zZXJpZXMuaGVhdG1hcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdLmRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uZGVySW5kZXggPSBzZXJpZXNJbmRleCAqIGRhdGFTaXplICsgaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMucmVzcG9uZGVyc1tyZXNwb25kZXJJbmRleF07XG4gICAgICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UuU0VMRUNUX1NFUklFU19BUElfSU5ERVhfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJTZWxlY3RlZFNlcmllcycsIHtcbiAgICAgICAgICAgICAgICBtb2RlbHM6IHRoaXMuZ2V0UmVzcG9uZGVyc1dpdGhUaGVtZShbbW9kZWxdLCAnc2VsZWN0JyksXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2hvd1Rvb2x0aXAgPSAoeyBpbmRleCwgc2VyaWVzSW5kZXgsIHN0YXRlIH0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghaXNOdW1iZXIoaW5kZXgpIHx8ICFpc051bWJlcihzZXJpZXNJbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhU2l6ZSA9IChfYSA9IHN0YXRlLnNlcmllcy5oZWF0bWFwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0uZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCByZXNwb25kZXJJbmRleCA9IHNlcmllc0luZGV4ICogZGF0YVNpemUgKyBpbmRleDtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5yZXNwb25kZXJzW3Jlc3BvbmRlckluZGV4XTtcbiAgICAgICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdE1vdXNlRXZlbnQoW21vZGVsXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdzZXJpZXMnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnaGVhdG1hcCc7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMub24oJ3NlbGVjdFNlcmllcycsIHRoaXMuc2VsZWN0U2VyaWVzKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignc2hvd1Rvb2x0aXAnLCB0aGlzLnNob3dUb29sdGlwKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignaGlkZVRvb2x0aXAnLCB0aGlzLm9uTW91c2VvdXRDb21wb25lbnQpO1xuICAgIH1cbiAgICByZW5kZXIoY2hhcnRTdGF0ZSkge1xuICAgICAgICBjb25zdCB7IGxheW91dCwgaGVhdG1hcFNlcmllcywgYXhlcywgdGhlbWUsIGNvbG9yVmFsdWVTY2FsZSwgb3B0aW9ucyB9ID0gY2hhcnRTdGF0ZTtcbiAgICAgICAgaWYgKCFoZWF0bWFwU2VyaWVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZS5ub0RhdGFFcnJvcih0aGlzLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWUuc2VyaWVzLmhlYXRtYXA7XG4gICAgICAgIHRoaXMuc2VsZWN0YWJsZSA9IHRoaXMuZ2V0U2VsZWN0YWJsZU9wdGlvbihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5yZWN0ID0gbGF5b3V0LnBsb3Q7XG4gICAgICAgIGNvbnN0IGNlbGxTaXplID0ge1xuICAgICAgICAgICAgaGVpZ2h0OiBheGVzLnlBeGlzLnRpY2tEaXN0YW5jZSxcbiAgICAgICAgICAgIHdpZHRoOiBheGVzLnhBeGlzLnRpY2tEaXN0YW5jZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSB7XG4gICAgICAgICAgICBzZXJpZXM6IHRoaXMucmVuZGVySGVhdG1hcFNlcmllcyhoZWF0bWFwU2VyaWVzLCBjZWxsU2l6ZSwgY29sb3JWYWx1ZVNjYWxlKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGdldERhdGFMYWJlbHNPcHRpb25zKG9wdGlvbnMsIHRoaXMubmFtZSkudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJEYXRhTGFiZWxzKHRoaXMubWFrZURhdGFMYWJlbHMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNwb25kZXJzID0gdGhpcy5tYWtlSGVhdG1hcFNlcmllc1Jlc3BvbmRlcigpO1xuICAgIH1cbiAgICBtYWtlRGF0YUxhYmVscygpIHtcbiAgICAgICAgY29uc3QgZGF0YUxhYmVsVGhlbWUgPSB0aGlzLnRoZW1lLmRhdGFMYWJlbHM7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVscy5zZXJpZXMucmVkdWNlKChhY2MsIG0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpc051bGwobS5jb2xvclZhbHVlKVxuICAgICAgICAgICAgICAgID8gYWNjXG4gICAgICAgICAgICAgICAgOiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyB0eXBlOiAndHJlZW1hcFNlcmllc05hbWUnLCB2YWx1ZTogbS5jb2xvclZhbHVlLCBkaXJlY3Rpb246ICdsZWZ0JywgcGxvdDogeyB4OiAwLCB5OiAwLCBzaXplOiAwIH0sIHRoZW1lOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGFMYWJlbFRoZW1lKSwgeyBjb2xvcjogZGF0YUxhYmVsVGhlbWUudXNlU2VyaWVzQ29sb3IgPyBtLmNvbG9yIDogZGF0YUxhYmVsVGhlbWUuY29sb3IgfSkgfSksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICBtYWtlSGVhdG1hcFNlcmllc1Jlc3BvbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxzLnNlcmllcy5yZWR1Y2UoKGFjYywgbW9kZWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpc051bGwobW9kZWwuY29sb3JWYWx1ZSlcbiAgICAgICAgICAgICAgICA/IGFjY1xuICAgICAgICAgICAgICAgIDogW1xuICAgICAgICAgICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbW9kZWwpLCB7IGRhdGE6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbW9kZWwpLCB7IGxhYmVsOiBtb2RlbC5uYW1lLCB2YWx1ZTogbW9kZWwuY29sb3JWYWx1ZSwgdGVtcGxhdGVUeXBlOiAnaGVhdG1hcCcgfSksIHRoaWNrbmVzczogYm94RGVmYXVsdC5IT1ZFUl9USElDS05FU1MsIHN0eWxlOiBbJ3NoYWRvdyddIH0pLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgcmVuZGVySGVhdG1hcFNlcmllcyhzZXJpZXNEYXRhLCBjZWxsU2l6ZSwgY29sb3JWYWx1ZVNjYWxlKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnRDb2xvciwgZW5kQ29sb3IsIGJvcmRlckNvbG9yLCBib3JkZXJXaWR0aCB9ID0gdGhpcy50aGVtZTtcbiAgICAgICAgY29uc3Qgc3RhcnRSR0IgPSBoZXhUb1JHQihzdGFydENvbG9yKTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VzID0gbWFrZURpc3RhbmNlcyhzdGFydFJHQiwgaGV4VG9SR0IoZW5kQ29sb3IpKTtcbiAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBjZWxsU2l6ZTtcbiAgICAgICAgcmV0dXJuIHNlcmllc0RhdGEuZmxhdE1hcCgoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuZmxhdE1hcCgoZGF0dW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGluZGV4ZXMsIGNvbG9yVmFsdWUsIGNhdGVnb3J5IH0gPSBkYXR1bTtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYCR7Y2F0ZWdvcnkueH0sICR7Y2F0ZWdvcnkueX1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4SW5kZXgsIHlJbmRleF0gPSBpbmRleGVzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yUmF0aW8gPSBnZXRDb2xvclJhdGlvKGNvbG9yVmFsdWVTY2FsZS5saW1pdCwgY29sb3JWYWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBpc051bGwoY29sb3JWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgPyAncmdiYSgwLCAwLCAwLCAwKSdcbiAgICAgICAgICAgICAgICAgICAgOiBnZXRTcGVjdHJ1bUNvbG9yKGNvbG9yUmF0aW8sIGRpc3RhbmNlcywgc3RhcnRSR0IpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRoaWNrbmVzcyA9IGJvcmRlcldpZHRoO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdyZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoIC0gdGhpY2tuZXNzICogMixcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgLSB0aGlja25lc3MgKiAyLFxuICAgICAgICAgICAgICAgICAgICB4OiB3aWR0aCAqIHhJbmRleCArIHRoaWNrbmVzcyxcbiAgICAgICAgICAgICAgICAgICAgeTogaGVpZ2h0ICogeUluZGV4ICsgdGhpY2tuZXNzLFxuICAgICAgICAgICAgICAgICAgICBjb2xvclZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBjb2xvclJhdGlvLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgdGhpY2tuZXNzLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRSZXNwb25kZXJzV2l0aFRoZW1lKHJlc3BvbmRlcnMsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbmRlcnMubWFwKChyZXNwb25kZXIpID0+IGRlZXBNZXJnZWRDb3B5KHJlc3BvbmRlciwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnRoZW1lW3R5cGVdKSwgeyBzdHlsZTogWydzaGFkb3cnXSB9KSkpO1xuICAgIH1cbiAgICBvbkNsaWNrKHsgcmVzcG9uZGVycyB9KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVyU2VsZWN0ZWRTZXJpZXMnLCB7XG4gICAgICAgICAgICAgICAgbW9kZWxzOiB0aGlzLmdldFJlc3BvbmRlcnNXaXRoVGhlbWUocmVzcG9uZGVycywgJ3NlbGVjdCcpLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCduZWVkRHJhdycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uTW91c2Vtb3ZlKHsgcmVzcG9uZGVycyB9KSB7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IHJlc3BvbmRlcnM7XG4gICAgICAgIHRoaXMuZW1pdE1vdXNlRXZlbnQocmVzcG9uZGVycyk7XG4gICAgfVxuICAgIGVtaXRNb3VzZUV2ZW50KHJlc3BvbmRlcnMpIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJIb3ZlcmVkU2VyaWVzJywge1xuICAgICAgICAgICAgbW9kZWxzOiB0aGlzLmdldFJlc3BvbmRlcnNXaXRoVGhlbWUocmVzcG9uZGVycywgJ2hvdmVyJyksXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nlcmllc1BvaW50SG92ZXJlZCcsIHtcbiAgICAgICAgICAgIG1vZGVsczogcmVzcG9uZGVycyxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVyU3BlY3RydW1Ub29sdGlwJywgcmVzcG9uZGVycyk7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICB9XG59XG4iLCJ2YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuL2NvbXBvbmVudFwiO1xuaW1wb3J0IHsgY3Jpc3BQaXhlbCB9IGZyb20gXCIuLi9oZWxwZXJzL2NhbGN1bGF0b3JcIjtcbmltcG9ydCB7IGlzVW5kZWZpbmVkLCBpbmNsdWRlcyB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBpc1NhbWVTZXJpZXNSZXNwb25kZXIgfSBmcm9tIFwiLi4vaGVscGVycy9yZXNwb25kZXJzXCI7XG5pbXBvcnQgeyBtYWtlT2JzZXJ2YWJsZU9iamVjdFRvTm9ybWFsIH0gZnJvbSBcIi4uL3N0b3JlL3JlYWN0aXZlXCI7XG5jb25zdCBndWlkZUxpbmVUeXBlID0ge1xuICAgIGxpbmU6ICdjaXJjbGUnLFxuICAgIGFyZWE6ICdjaXJjbGUnLFxuICAgIGJveFBsb3Q6ICdib3hQbG90Jyxcbn07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIb3ZlcmVkU2VyaWVzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSB7IGd1aWRlTGluZTogW10gfTtcbiAgICAgICAgdGhpcy5pc1Nob3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW5kZXJIb3ZlcmVkU2VyaWVzID0gKHsgbW9kZWxzLCBuYW1lLCBldmVudERldGVjdFR5cGUsIH0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCBwcmV2TW9kZWxzID0gdGhpcy5nZXRTZXJpZXNNb2RlbHMobmFtZSk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsc1tuYW1lXSA9IFsuLi5tb2RlbHNdO1xuICAgICAgICAgICAgdGhpcy5pc1Nob3cgPSAhIXRoaXMuZ2V0U2VyaWVzTW9kZWxzKCkubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaXNTYW1lID0gISEoKF9hID0gcHJldk1vZGVscykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgJiZcbiAgICAgICAgICAgICAgICAhIW1vZGVscy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBpc1NhbWVTZXJpZXNSZXNwb25kZXIoeyBtb2RlbHMsIGNvbXBhcmlzb25Nb2RlbDogcHJldk1vZGVscywgZXZlbnREZXRlY3RUeXBlLCBuYW1lIH0pO1xuICAgICAgICAgICAgaWYgKCgoX2IgPSBwcmV2TW9kZWxzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSAmJiAhbW9kZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgndW5ob3ZlclNlcmllcycsIG1ha2VPYnNlcnZhYmxlT2JqZWN0VG9Ob3JtYWwocHJldk1vZGVscykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZWxzLmxlbmd0aCAmJiAhaXNTYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdob3ZlclNlcmllcycsIG1ha2VPYnNlcnZhYmxlT2JqZWN0VG9Ob3JtYWwobW9kZWxzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1vZGVsRm9yR3VpZGVMaW5lID0gdGhpcy5nZXRNb2RlbEZvckd1aWRlTGluZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChldmVudERldGVjdFR5cGUgPT09ICdncm91cGVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyR3JvdXBlZE1vZGVscyhuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXNldEhvdmVyZWRTZXJpZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1vZGVscyA9IHsgZ3VpZGVMaW5lOiBbXSB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRTZXJpZXNNb2RlbHModHlwZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IF9iID0gdGhpcy5tb2RlbHMsIHsgZ3VpZGVMaW5lIH0gPSBfYiwgbW9kZWxzID0gX19yZXN0KF9iLCBbXCJndWlkZUxpbmVcIl0pO1xuICAgICAgICByZXR1cm4gKF9hID0gKHR5cGUgPyBtb2RlbHNbdHlwZV0gOiBPYmplY3QudmFsdWVzKG1vZGVscykpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmxhdE1hcCgodmFsKSA9PiB2YWwpO1xuICAgIH1cbiAgICBoYXNHdWlkZUxpbmUoKSB7XG4gICAgICAgIGNvbnN0IFtyZWN0TW9kZWxdID0gdGhpcy5nZXRTZXJpZXNNb2RlbHMoKS5maWx0ZXIoKHsgdHlwZSB9KSA9PiB0eXBlID09PSAncmVjdCcpO1xuICAgICAgICByZXR1cm4gIWlzVW5kZWZpbmVkKHRoaXMubW9kZWxGb3JHdWlkZUxpbmUpICYmIGlzVW5kZWZpbmVkKHJlY3RNb2RlbCk7XG4gICAgfVxuICAgIGdldE1vZGVsRm9yR3VpZGVMaW5lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VyaWVzTW9kZWxzKCkuZmlsdGVyKCh7IHR5cGUgfSkgPT4gdHlwZSA9PT0gZ3VpZGVMaW5lVHlwZVtuYW1lXSlbMF07XG4gICAgfVxuICAgIHJlbmRlckdyb3VwZWRNb2RlbHMobmFtZSkge1xuICAgICAgICBpZiAoaW5jbHVkZXMoT2JqZWN0LmtleXMoZ3VpZGVMaW5lVHlwZSksIG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1Nob3cgJiYgdGhpcy5oYXNHdWlkZUxpbmUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWxzLmd1aWRlTGluZSA9IFt0aGlzLnJlbmRlckd1aWRlTGluZU1vZGVsKHRoaXMubW9kZWxGb3JHdWlkZUxpbmUpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWxzLmd1aWRlTGluZSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlckd1aWRlTGluZU1vZGVsKG1vZGVsKSB7XG4gICAgICAgIGNvbnN0IHggPSBjcmlzcFBpeGVsKG1vZGVsLnR5cGUgPT09ICdib3hQbG90JyAmJiBtb2RlbC5ib3hQbG90RGV0ZWN0aW9uXG4gICAgICAgICAgICA/IG1vZGVsLmJveFBsb3REZXRlY3Rpb24ueCArIG1vZGVsLmJveFBsb3REZXRlY3Rpb24ud2lkdGggLyAyXG4gICAgICAgICAgICA6IG1vZGVsLngpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB4MjogeCxcbiAgICAgICAgICAgIHkyOiB0aGlzLnJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGU6ICcjZGRkJyxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ2hvdmVyZWRTZXJpZXMnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnaG92ZXJlZFNlcmllcyc7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMub24oJ3JlbmRlckhvdmVyZWRTZXJpZXMnLCB0aGlzLnJlbmRlckhvdmVyZWRTZXJpZXMpO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLm9uKCdyZXNldEhvdmVyZWRTZXJpZXMnLCB0aGlzLnJlc2V0SG92ZXJlZFNlcmllcyk7XG4gICAgfVxuICAgIHJlbmRlcih7IGxheW91dCB9KSB7XG4gICAgICAgIHRoaXMucmVjdCA9IGxheW91dC5wbG90O1xuICAgIH1cbn1cbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIi4vY29tcG9uZW50XCI7XG5pbXBvcnQgeyBnZXRMZWdlbmRJdGVtSGVpZ2h0LCBMRUdFTkRfQ0hFQ0tCT1hfU0laRSwgTEVHRU5EX0lDT05fU0laRSwgTEVHRU5EX0lURU1fTUFSR0lOX1gsIExFR0VORF9NQVJHSU5fWCwgfSBmcm9tIFwiLi4vYnJ1c2hlcy9sZWdlbmRcIjtcbmltcG9ydCB7IGdldFRleHRXaWR0aCB9IGZyb20gXCIuLi9oZWxwZXJzL2NhbGN1bGF0b3JcIjtcbmltcG9ydCB7IGlzVmVydGljYWxBbGlnbiwgcGFkZGluZyB9IGZyb20gXCIuLi9zdG9yZS9sYXlvdXRcIjtcbmltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmltcG9ydCB7IGdldFRpdGxlRm9udFN0cmluZyB9IGZyb20gXCIuLi9oZWxwZXJzL3N0eWxlXCI7XG5pbXBvcnQgeyBtYWtlT2JzZXJ2YWJsZU9iamVjdFRvTm9ybWFsIH0gZnJvbSBcIi4uL3N0b3JlL3JlYWN0aXZlXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZWdlbmQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5zZXJpZXNDb2xvck1hcCA9IHt9O1xuICAgICAgICB0aGlzLnNlcmllc0ljb25UeXBlTWFwID0ge307XG4gICAgICAgIHRoaXMub25DbGlja0NoZWNrYm94ID0gKHJlc3BvbmRlcnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbGFiZWwsIGNoZWNrZWQgfSA9IHJlc3BvbmRlcnNbMF07XG4gICAgICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdzZXRBbGxMZWdlbmRBY3RpdmVTdGF0ZScsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgnc2V0TGVnZW5kQ2hlY2tlZFN0YXRlJywgeyBuYW1lOiBsYWJlbCwgY2hlY2tlZDogIWNoZWNrZWQgfSk7XG4gICAgICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ2Rpc2FibGVTZXJpZXMnLCBsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdlbmFibGVTZXJpZXMnLCBsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25DbGlja0xhYmVsID0gKHJlc3BvbmRlcnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbGFiZWwgfSA9IHJlc3BvbmRlcnNbMF07XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Jlc2V0U2VsZWN0ZWRTZXJpZXMnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMubGVuZ3RoICYmIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVyc1swXS5sYWJlbCA9PT0gbGFiZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdzZXRBbGxMZWdlbmRBY3RpdmVTdGF0ZScsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgnc2V0QWxsTGVnZW5kQWN0aXZlU3RhdGUnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgnc2V0TGVnZW5kQWN0aXZlU3RhdGUnLCB7IG5hbWU6IGxhYmVsLCBhY3RpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZWRSZXNwb25kZXJzID0gcmVzcG9uZGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgb25DbGljayh7IHJlc3BvbmRlcnMgfSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChyZXNwb25kZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhIH0gPSByZXNwb25kZXJzWzBdO1xuICAgICAgICAgICAgaWYgKCgoX2EgPSBkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ2NsaWNrTGVnZW5kQ2hlY2tib3gnLCBtYWtlT2JzZXJ2YWJsZU9iamVjdFRvTm9ybWFsKHJlc3BvbmRlcnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnY2xpY2tMZWdlbmRMYWJlbCcsIG1ha2VPYnNlcnZhYmxlT2JqZWN0VG9Ob3JtYWwocmVzcG9uZGVycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdsZWdlbmQnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnbGVnZW5kJztcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignY2xpY2tMZWdlbmRDaGVja2JveCcsIHRoaXMub25DbGlja0NoZWNrYm94KTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignY2xpY2tMZWdlbmRMYWJlbCcsIHRoaXMub25DbGlja0xhYmVsKTtcbiAgICB9XG4gICAgaW5pdENvbG9yQW5kSWNvblR5cGVNYXAobGVnZW5kRGF0YSkge1xuICAgICAgICB0aGlzLnNlcmllc0NvbG9yTWFwID0ge307XG4gICAgICAgIHRoaXMuc2VyaWVzSWNvblR5cGVNYXAgPSB7fTtcbiAgICAgICAgbGVnZW5kRGF0YS5mb3JFYWNoKCh7IGxhYmVsLCBjb2xvciwgaWNvblR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXJpZXNDb2xvck1hcFtsYWJlbF0gPSBjb2xvcjtcbiAgICAgICAgICAgIHRoaXMuc2VyaWVzSWNvblR5cGVNYXBbbGFiZWxdID0gaWNvblR5cGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRYUG9zaXRpb25XaGVuVmVydGljYWxBbGlnbihkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0LCByb3dXaWR0aHMgfSA9IGRhdGEucmVkdWNlKChhY2MsIGRhdHVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHJvd0luZGV4LCBjb2x1bW5JbmRleCwgd2lkdGggfSA9IGRhdHVtO1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGFjYy5yb3dXaWR0aHNbcm93SW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGFjYy5yb3dXaWR0aHNbcm93SW5kZXhdID0gMDtcbiAgICAgICAgICAgICAgICBhY2Mub2Zmc2V0W3Jvd0luZGV4XSA9IFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjYy5yb3dXaWR0aHNbcm93SW5kZXhdICs9IHdpZHRoICsgKGNvbHVtbkluZGV4ID8gTEVHRU5EX0lURU1fTUFSR0lOX1ggOiAwKTtcbiAgICAgICAgICAgIGFjYy5vZmZzZXRbcm93SW5kZXhdW2NvbHVtbkluZGV4ICsgMV0gPVxuICAgICAgICAgICAgICAgIGFjYy5vZmZzZXRbcm93SW5kZXhdW2NvbHVtbkluZGV4XSArIExFR0VORF9JVEVNX01BUkdJTl9YICsgd2lkdGg7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7IG9mZnNldDogW10sIHJvd1dpZHRoczogW10gfSk7XG4gICAgICAgIGNvbnN0IHsgd2lkdGggfSA9IHRoaXMucmVjdDtcbiAgICAgICAgcm93V2lkdGhzLmZvckVhY2goKHJvd1dpZHRoLCByb3dJbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeE1hcmdpbiA9ICh3aWR0aCAtIHJvd1dpZHRoKSAvIDI7XG4gICAgICAgICAgICBvZmZzZXRbcm93SW5kZXhdID0gb2Zmc2V0W3Jvd0luZGV4XS5tYXAoKHhPZmZzZXQpID0+IHhPZmZzZXQgKyB4TWFyZ2luKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIGdldFhQb3NpdGlvbldoZW5Ib3Jpem9udGFsQWxpZ24oZGF0YSkge1xuICAgICAgICBjb25zdCBtYXhXaWR0aHMgPSBkYXRhLnJlZHVjZSgoYWNjLCBkYXR1bSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjb2x1bW5JbmRleCwgd2lkdGggfSA9IGRhdHVtO1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGFjY1tjb2x1bW5JbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgYWNjW2NvbHVtbkluZGV4XSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2NbY29sdW1uSW5kZXhdID0gTWF0aC5tYXgoYWNjW2NvbHVtbkluZGV4XSwgd2lkdGgpO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gZGF0YS5yZWR1Y2UoKGFjYywgZGF0dW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcm93SW5kZXgsIGNvbHVtbkluZGV4IH0gPSBkYXR1bTtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChhY2Nbcm93SW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGFjY1tyb3dJbmRleF0gPSBbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2Nbcm93SW5kZXhdW2NvbHVtbkluZGV4ICsgMV0gPVxuICAgICAgICAgICAgICAgIGFjY1tyb3dJbmRleF1bY29sdW1uSW5kZXhdICsgTEVHRU5EX0lURU1fTUFSR0lOX1ggKyBtYXhXaWR0aHNbY29sdW1uSW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICByZW5kZXJMZWdlbmRNb2RlbChsZWdlbmQpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBzaG93Q2hlY2tib3gsIGFsaWduLCB1c2VTY2F0dGVyQ2hhcnRJY29uIH0gPSBsZWdlbmQ7XG4gICAgICAgIGNvbnN0IHZlcnRpY2FsQWxpZ24gPSBpc1ZlcnRpY2FsQWxpZ24oYWxpZ24pO1xuICAgICAgICBjb25zdCBpdGVtSGVpZ2h0ID0gZ2V0TGVnZW5kSXRlbUhlaWdodCh0aGlzLnRoZW1lLmxhYmVsLmZvbnRTaXplKTtcbiAgICAgICAgY29uc3QgeFBvc2l0aW9uID0gdmVydGljYWxBbGlnblxuICAgICAgICAgICAgPyB0aGlzLmdldFhQb3NpdGlvbldoZW5WZXJ0aWNhbEFsaWduKGRhdGEpXG4gICAgICAgICAgICA6IHRoaXMuZ2V0WFBvc2l0aW9uV2hlbkhvcml6b250YWxBbGlnbihkYXRhKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oeyB0eXBlOiAnbGVnZW5kJywgYWxpZ24sXG4gICAgICAgICAgICAgICAgc2hvd0NoZWNrYm94LCBkYXRhOiBkYXRhLm1hcCgoZGF0dW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGxhYmVsLCBpY29uVHlwZSwgcm93SW5kZXgsIGNvbHVtbkluZGV4IH0gPSBkYXR1bTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0dW0pLCB7IGljb25UeXBlOiAoX2EgPSB0aGlzLnNlcmllc0ljb25UeXBlTWFwW2xhYmVsXSwgKF9hICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGljb25UeXBlKSksIGNvbG9yOiB0aGlzLnNlcmllc0NvbG9yTWFwW2xhYmVsXSwgeDogeFBvc2l0aW9uW3Jvd0luZGV4XVtjb2x1bW5JbmRleF0sIHk6IHBhZGRpbmcuWSArIGl0ZW1IZWlnaHQgKiByb3dJbmRleCwgdXNlU2NhdHRlckNoYXJ0SWNvbiB9KTtcbiAgICAgICAgICAgICAgICB9KSB9LCB0aGlzLnRoZW1lLmxhYmVsKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgbWFrZUNoZWNrYm94UmVzcG9uZGVyKGRhdGEsIHNob3dDaGVja2JveCkge1xuICAgICAgICByZXR1cm4gc2hvd0NoZWNrYm94XG4gICAgICAgICAgICA/IGRhdGEubWFwKChtKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyB0eXBlOiAncmVjdCcsIHg6IG0ueCwgeTogbS55LCB3aWR0aDogTEVHRU5EX0NIRUNLQk9YX1NJWkUsIGhlaWdodDogTEVHRU5EX0NIRUNLQk9YX1NJWkUsIGRhdGE6IHsgbmFtZTogJ2NoZWNrYm94JyB9IH0pKSlcbiAgICAgICAgICAgIDogW107XG4gICAgfVxuICAgIG1ha2VMYWJlbFJlc3BvbmRlcihkYXRhLCBzaG93Q2hlY2tib3gpIHtcbiAgICAgICAgY29uc3QgZm9udCA9IGdldFRpdGxlRm9udFN0cmluZyh0aGlzLnRoZW1lLmxhYmVsKTtcbiAgICAgICAgcmV0dXJuIGRhdGEubWFwKChtKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyB0eXBlOiAncmVjdCcsIHg6IG0ueCArXG4gICAgICAgICAgICAgICAgKHNob3dDaGVja2JveCA/IExFR0VORF9DSEVDS0JPWF9TSVpFICsgTEVHRU5EX01BUkdJTl9YIDogMCkgK1xuICAgICAgICAgICAgICAgIExFR0VORF9JQ09OX1NJWkUgK1xuICAgICAgICAgICAgICAgIExFR0VORF9NQVJHSU5fWCwgeTogbS55LCB3aWR0aDogZ2V0VGV4dFdpZHRoKG0ubGFiZWwsIGZvbnQpLCBkYXRhOiB7IG5hbWU6ICdsYWJlbCcgfSwgaGVpZ2h0OiBMRUdFTkRfQ0hFQ0tCT1hfU0laRSB9KSkpO1xuICAgIH1cbiAgICByZW5kZXIoeyBsYXlvdXQsIGxlZ2VuZCwgdGhlbWUgfSkge1xuICAgICAgICB0aGlzLmlzU2hvdyA9IGxlZ2VuZC52aXNpYmxlICYmICEhbGVnZW5kLmRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAoIXRoaXMuaXNTaG93KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IHN0YWNrIOydvCDrloQg652867KoIOyInOyEnCDsl63siJzsnLzroZwo7Iqk7YOd7J20IOyMk+yduCDsiJzshJzrjIDroZwpIOuQmOyWtOyVvFxuICAgICAgICBjb25zdCB7IHNob3dDaGVja2JveCwgZGF0YTogbGVnZW5kRGF0YSB9ID0gbGVnZW5kO1xuICAgICAgICB0aGlzLnJlY3QgPSBsYXlvdXQubGVnZW5kO1xuICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWUubGVnZW5kO1xuICAgICAgICB0aGlzLmluaXRDb2xvckFuZEljb25UeXBlTWFwKGxlZ2VuZERhdGEpO1xuICAgICAgICB0aGlzLm1vZGVscyA9IHRoaXMucmVuZGVyTGVnZW5kTW9kZWwobGVnZW5kKTtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSB0aGlzLm1vZGVsc1swXTtcbiAgICAgICAgY29uc3QgY2hlY2tib3hSZXNwb25kZXIgPSB0aGlzLm1ha2VDaGVja2JveFJlc3BvbmRlcihkYXRhLCBzaG93Q2hlY2tib3gpO1xuICAgICAgICBjb25zdCBsYWJlbFJlc3BvbmRlciA9IHRoaXMubWFrZUxhYmVsUmVzcG9uZGVyKGRhdGEsIHNob3dDaGVja2JveCk7XG4gICAgICAgIHRoaXMucmVzcG9uZGVycyA9IFsuLi5jaGVja2JveFJlc3BvbmRlciwgLi4ubGFiZWxSZXNwb25kZXJdO1xuICAgIH1cbn1cbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIi4vY29tcG9uZW50XCI7XG5pbXBvcnQgeyBnZXRWYWx1ZVJhdGlvLCBzZXRTcGxpbmVDb250cm9sUG9pbnQsIGdldFhQb3NpdGlvbiB9IGZyb20gXCIuLi9oZWxwZXJzL2NhbGN1bGF0b3JcIjtcbmltcG9ydCB7IGdldENvb3JkaW5hdGVEYXRhSW5kZXgsIGdldENvb3JkaW5hdGVYVmFsdWUsIGdldENvb3JkaW5hdGVZVmFsdWUsIGlzQ29vcmRpbmF0ZVNlcmllcywgfSBmcm9tIFwiLi4vaGVscGVycy9jb29yZGluYXRlXCI7XG5pbXBvcnQgeyBnZXRSR0JBIH0gZnJvbSBcIi4uL2hlbHBlcnMvY29sb3JcIjtcbmltcG9ydCB7IGluY2x1ZGVzLCBpc051bGwgfSBmcm9tIFwiLi4vaGVscGVycy91dGlsc1wiO1xuaW1wb3J0IHsgZ2V0QWN0aXZlU2VyaWVzTWFwIH0gZnJvbSBcIi4uL2hlbHBlcnMvbGVnZW5kXCI7XG5pbXBvcnQgeyBnZXROZWFyZXN0UmVzcG9uZGVyLCBtYWtlUmVjdFJlc3BvbmRlck1vZGVsLCBtYWtlUmVjdFJlc3BvbmRlck1vZGVsRm9yQ29vcmRpbmF0ZVR5cGUsIG1ha2VUb29sdGlwQ2lyY2xlTWFwLCB9IGZyb20gXCIuLi9oZWxwZXJzL3Jlc3BvbmRlcnNcIjtcbmltcG9ydCB7IGdldFZhbHVlQXhpc05hbWUgfSBmcm9tIFwiLi4vaGVscGVycy9heGVzXCI7XG5pbXBvcnQgeyBnZXREYXRhTGFiZWxzT3B0aW9ucyB9IGZyb20gXCIuLi9oZWxwZXJzL2RhdGFMYWJlbHNcIjtcbmltcG9ydCB7IG1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZVwiO1xuaW1wb3J0IHsgaXNBdmFpbGFibGVTZWxlY3RTZXJpZXMsIGlzQXZhaWxhYmxlU2hvd1Rvb2x0aXBJbmZvIH0gZnJvbSBcIi4uL2hlbHBlcnMvdmFsaWRhdGlvblwiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZVNlcmllcyBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubW9kZWxzID0geyByZWN0OiBbXSwgc2VyaWVzOiBbXSwgZG90OiBbXSB9O1xuICAgICAgICB0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudERldGVjdFR5cGUgPSAnbmVhcmVzdCc7XG4gICAgICAgIHRoaXMueUF4aXNOYW1lID0gJ3lBeGlzJztcbiAgICAgICAgdGhpcy5vbk1vdXNlb3V0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzZXJpZXNQb2ludEhvdmVyZWQnLCB7IG1vZGVsczogW10sIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVySG92ZXJlZFNlcmllcycsIHtcbiAgICAgICAgICAgICAgICBtb2RlbHM6IFtdLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBldmVudERldGVjdFR5cGU6IHRoaXMuZXZlbnREZXRlY3RUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VsZWN0U2VyaWVzID0gKGluZm8pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5kZXgsIHNlcmllc0luZGV4IH0gPSBpbmZvO1xuICAgICAgICAgICAgaWYgKCFpc0F2YWlsYWJsZVNlbGVjdFNlcmllcyhpbmZvLCAnbGluZScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSB0aGlzLmdldFJlc3BvbmRlckNhdGVnb3J5QnlJbmRleChpbmRleCk7XG4gICAgICAgICAgICBpZiAoIWNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UuU0VMRUNUX1NFUklFU19BUElfSU5ERVhfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLnRvb2x0aXBDaXJjbGVNYXBbY2F0ZWdvcnldW3Nlcmllc0luZGV4XTtcbiAgICAgICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZS5TRUxFQ1RfU0VSSUVTX0FQSV9JTkRFWF9FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2RlbHMgPSB0aGlzLmdldFJlc3BvbmRlclNlcmllc1dpdGhUaGVtZShbbW9kZWxdLCAnc2VsZWN0Jyk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlclNlbGVjdGVkU2VyaWVzJywgeyBtb2RlbHMsIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zaG93VG9vbHRpcCA9IChpbmZvKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IGluZGV4LCBzZXJpZXNJbmRleCB9ID0gaW5mbztcbiAgICAgICAgICAgIGlmICghaXNBdmFpbGFibGVTaG93VG9vbHRpcEluZm8oaW5mbywgdGhpcy5ldmVudERldGVjdFR5cGUsICdsaW5lJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IHRoaXMuZ2V0UmVzcG9uZGVyQ2F0ZWdvcnlCeUluZGV4KGluZGV4KTtcbiAgICAgICAgICAgIGlmICghY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2RlbHMgPSB0aGlzLmV2ZW50RGV0ZWN0VHlwZSA9PT0gJ2dyb3VwZWQnXG4gICAgICAgICAgICAgICAgPyB0aGlzLnRvb2x0aXBDaXJjbGVNYXBbY2F0ZWdvcnldXG4gICAgICAgICAgICAgICAgOiBbdGhpcy50b29sdGlwQ2lyY2xlTWFwW2NhdGVnb3J5XVtzZXJpZXNJbmRleF1dO1xuICAgICAgICAgICAgaWYgKCEoKF9hID0gbW9kZWxzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25Nb3VzZW1vdmVOZWFyVHlwZShtb2RlbHMpO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzZXJpZXNQb2ludEhvdmVyZWQnLCB7IG1vZGVsczogdGhpcy5hY3RpdmF0ZWRSZXNwb25kZXJzLCBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdzZXJpZXMnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnbGluZSc7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMub24oJ3NlbGVjdFNlcmllcycsIHRoaXMuc2VsZWN0U2VyaWVzKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignc2hvd1Rvb2x0aXAnLCB0aGlzLnNob3dUb29sdGlwKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignaGlkZVRvb2x0aXAnLCB0aGlzLm9uTW91c2VvdXRDb21wb25lbnQpO1xuICAgIH1cbiAgICBpbml0VXBkYXRlKGRlbHRhKSB7XG4gICAgICAgIHRoaXMuZHJhd01vZGVscy5yZWN0WzBdLndpZHRoID0gdGhpcy5tb2RlbHMucmVjdFswXS53aWR0aCAqIGRlbHRhO1xuICAgIH1cbiAgICBzZXRFdmVudERldGVjdFR5cGUoc2VyaWVzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChzZXJpZXMuYXJlYSB8fCBzZXJpZXMuY29sdW1uKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGV0ZWN0VHlwZSA9ICdncm91cGVkJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9iID0gKF9hID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlcmllcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmV2ZW50RGV0ZWN0VHlwZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudERldGVjdFR5cGUgPSBvcHRpb25zLnNlcmllcy5ldmVudERldGVjdFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcmllcy5zY2F0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGV0ZWN0VHlwZSA9ICduZWFyJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoY2hhcnRTdGF0ZSwgY29tcHV0ZWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGNvbnN0IHsgdmlld1JhbmdlIH0gPSBjb21wdXRlZDtcbiAgICAgICAgY29uc3QgeyBsYXlvdXQsIHNlcmllcywgc2NhbGUsIGF4ZXMsIGxlZ2VuZCwgdGhlbWUgfSA9IGNoYXJ0U3RhdGU7XG4gICAgICAgIGlmICghc2VyaWVzLmxpbmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlLm5vRGF0YUVycm9yKHRoaXMubmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSAoX2EgPSBjaGFydFN0YXRlLmNhdGVnb3JpZXMsIChfYSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkpO1xuICAgICAgICBjb25zdCByYXdDYXRlZ29yaWVzID0gKF9iID0gY2hhcnRTdGF0ZS5yYXdDYXRlZ29yaWVzLCAoX2IgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGNoYXJ0U3RhdGUub3B0aW9ucyk7XG4gICAgICAgIGlmICgoKF9jID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNlcmllcykgJiYgJ2xpbmUnIGluIG9wdGlvbnMuc2VyaWVzKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNlcmllcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5zZXJpZXMpLCBvcHRpb25zLnNlcmllcy5saW5lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEV2ZW50RGV0ZWN0VHlwZShzZXJpZXMsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBsYWJlbEF4aXNEYXRhID0gYXhlcy54QXhpcztcbiAgICAgICAgY29uc3Qgc2VyaWVzT3B0aW9ucyA9IChfZCA9IG9wdGlvbnMuc2VyaWVzLCAoX2QgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDoge30pKTtcbiAgICAgICAgY29uc3QgbGluZVNlcmllc0RhdGEgPSBzZXJpZXMubGluZS5kYXRhO1xuICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWUuc2VyaWVzLmxpbmU7XG4gICAgICAgIHRoaXMucmVjdCA9IGxheW91dC5wbG90O1xuICAgICAgICB0aGlzLmFjdGl2ZVNlcmllc01hcCA9IGdldEFjdGl2ZVNlcmllc01hcChsZWdlbmQpO1xuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSAoX2YgPSAoX2UgPSB2aWV3UmFuZ2UpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSwgKF9mICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IDApKTtcbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlID0gdGhpcy5nZXRTZWxlY3RhYmxlT3B0aW9uKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnlBeGlzTmFtZSA9IGdldFZhbHVlQXhpc05hbWUob3B0aW9ucywgdGhpcy5uYW1lLCAneUF4aXMnKTtcbiAgICAgICAgY29uc3QgbGluZVNlcmllc01vZGVsID0gdGhpcy5yZW5kZXJMaW5lUG9pbnRzTW9kZWwobGluZVNlcmllc0RhdGEsIHNjYWxlLCBsYWJlbEF4aXNEYXRhLCBzZXJpZXNPcHRpb25zLCBjYXRlZ29yaWVzKTtcbiAgICAgICAgY29uc3QgeyBkb3RTZXJpZXNNb2RlbCwgcmVzcG9uZGVyTW9kZWwgfSA9IHRoaXMucmVuZGVyQ2lyY2xlTW9kZWwobGluZVNlcmllc01vZGVsLCBzZXJpZXNPcHRpb25zKTtcbiAgICAgICAgY29uc3QgdG9vbHRpcERhdGFBcnIgPSB0aGlzLm1ha2VUb29sdGlwRGF0YShsaW5lU2VyaWVzRGF0YSwgY2F0ZWdvcmllcyk7XG4gICAgICAgIHRoaXMudG9vbHRpcENpcmNsZU1hcCA9IG1ha2VUb29sdGlwQ2lyY2xlTWFwKHJlc3BvbmRlck1vZGVsLCB0b29sdGlwRGF0YUFycik7XG4gICAgICAgIHRoaXMubW9kZWxzID0ge1xuICAgICAgICAgICAgcmVjdDogW3RoaXMucmVuZGVyQ2xpcFJlY3RBcmVhTW9kZWwoKV0sXG4gICAgICAgICAgICBzZXJpZXM6IGxpbmVTZXJpZXNNb2RlbCxcbiAgICAgICAgICAgIGRvdDogZG90U2VyaWVzTW9kZWwsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5kcmF3TW9kZWxzKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdNb2RlbHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubW9kZWxzKSwgeyByZWN0OiBbdGhpcy5yZW5kZXJDbGlwUmVjdEFyZWFNb2RlbCh0cnVlKV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldERhdGFMYWJlbHNPcHRpb25zKG9wdGlvbnMsIHRoaXMubmFtZSkudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJEYXRhTGFiZWxzKHRoaXMuZ2V0RGF0YUxhYmVscyhsaW5lU2VyaWVzTW9kZWwpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb29yZGluYXRlVHlwZSA9IGlzQ29vcmRpbmF0ZVNlcmllcyhzZXJpZXMpO1xuICAgICAgICB0aGlzLnJlc3BvbmRlcnMgPSB0aGlzLmdldFJlc3BvbmRlcnMoe1xuICAgICAgICAgICAgbGFiZWxBeGlzRGF0YSxcbiAgICAgICAgICAgIHJlc3BvbmRlck1vZGVsLFxuICAgICAgICAgICAgdG9vbHRpcERhdGFBcnIsXG4gICAgICAgICAgICBjYXRlZ29yaWVzLFxuICAgICAgICAgICAgcmF3Q2F0ZWdvcmllcyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVUeXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UmVzcG9uZGVycyh7IGxhYmVsQXhpc0RhdGEsIHJlc3BvbmRlck1vZGVsLCB0b29sdGlwRGF0YUFyciwgY2F0ZWdvcmllcywgcmF3Q2F0ZWdvcmllcywgY29vcmRpbmF0ZVR5cGUsIH0pIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnREZXRlY3RUeXBlID09PSAnbmVhcicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VOZWFyVHlwZVJlc3BvbmRlck1vZGVsKHJlc3BvbmRlck1vZGVsLCB0b29sdGlwRGF0YUFyciwgcmF3Q2F0ZWdvcmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXZlbnREZXRlY3RUeXBlID09PSAncG9pbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlTmVhclR5cGVSZXNwb25kZXJNb2RlbChyZXNwb25kZXJNb2RlbCwgdG9vbHRpcERhdGFBcnIsIHJhd0NhdGVnb3JpZXMsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb29yZGluYXRlVHlwZSkge1xuICAgICAgICAgICAgY29uc3QgcmVjdFJlc3BvbmRlckluZm8gPSB0aGlzLmdldFJlY3RSZXNwb25kZXJJbmZvRm9yQ29vcmRpbmF0ZVR5cGUocmVzcG9uZGVyTW9kZWwsIHJhd0NhdGVnb3JpZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VSZWN0UmVzcG9uZGVyTW9kZWxGb3JDb29yZGluYXRlVHlwZShyZWN0UmVzcG9uZGVySW5mbywgdGhpcy5yZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZVJlY3RSZXNwb25kZXJNb2RlbCh0aGlzLnJlY3QsIGxhYmVsQXhpc0RhdGEsIGNhdGVnb3JpZXMpO1xuICAgIH1cbiAgICBtYWtlTmVhclR5cGVSZXNwb25kZXJNb2RlbChzZXJpZXNDaXJjbGVNb2RlbCwgdG9vbHRpcERhdGFBcnIsIGNhdGVnb3JpZXMsIGRldGVjdGlvblNpemUpIHtcbiAgICAgICAgcmV0dXJuIHNlcmllc0NpcmNsZU1vZGVsLm1hcCgobSwgaW5kZXgpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG0pLCB7IGRhdGE6IHRvb2x0aXBEYXRhQXJyW2luZGV4XSwgZGV0ZWN0aW9uU2l6ZSwgbGFiZWw6IGNhdGVnb3JpZXNbbS5pbmRleF0gfSkpKTtcbiAgICB9XG4gICAgbWFrZVRvb2x0aXBEYXRhKGxpbmVTZXJpZXNEYXRhLCBjYXRlZ29yaWVzKSB7XG4gICAgICAgIHJldHVybiBsaW5lU2VyaWVzRGF0YS5mbGF0TWFwKCh7IHJhd0RhdGEsIG5hbWUsIGNvbG9yIH0sIHNlcmllc0luZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmF3RGF0YS5tYXAoKGRhdHVtLCBpbmRleCkgPT4gaXNOdWxsKGRhdHVtKVxuICAgICAgICAgICAgICAgID8ge31cbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0Q29vcmRpbmF0ZVlWYWx1ZShkYXR1bSksXG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBjYXRlZ29yaWVzW2dldENvb3JkaW5hdGVEYXRhSW5kZXgoZGF0dW0sIGNhdGVnb3JpZXMsIGluZGV4LCB0aGlzLnN0YXJ0SW5kZXgpXSxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVuZGVyQ2xpcFJlY3RBcmVhTW9kZWwoaXNEcmF3TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdjbGlwUmVjdEFyZWEnLFxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3aWR0aDogaXNEcmF3TW9kZWwgPyAwIDogdGhpcy5yZWN0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnJlY3QuaGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXJMaW5lUG9pbnRzTW9kZWwoc2VyaWVzUmF3RGF0YSwgc2NhbGUsIGF4aXNEYXRhLCBvcHRpb25zLCBjYXRlZ29yaWVzKSB7XG4gICAgICAgIGNvbnN0IHsgc3BsaW5lIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCB5QXhpc0xpbWl0ID0gc2NhbGVbdGhpcy55QXhpc05hbWVdLmxpbWl0O1xuICAgICAgICBjb25zdCB7IGxpbmVXaWR0aCwgZGFzaFNlZ21lbnRzIH0gPSB0aGlzLnRoZW1lO1xuICAgICAgICByZXR1cm4gc2VyaWVzUmF3RGF0YS5tYXAoKHsgcmF3RGF0YSwgbmFtZSwgY29sb3I6IHNlcmllc0NvbG9yIH0sIHNlcmllc0luZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuYWN0aXZlU2VyaWVzTWFwW25hbWVdO1xuICAgICAgICAgICAgcmF3RGF0YS5mb3JFYWNoKChkYXR1bSwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChkYXR1bSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldENvb3JkaW5hdGVZVmFsdWUoZGF0dW0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHlWYWx1ZVJhdGlvID0gZ2V0VmFsdWVSYXRpbyh2YWx1ZSwgeUF4aXNMaW1pdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9ICgxIC0geVZhbHVlUmF0aW8pICogdGhpcy5yZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gZ2V0WFBvc2l0aW9uKGF4aXNEYXRhLCB0aGlzLnJlY3Qud2lkdGgsIGdldENvb3JkaW5hdGVYVmFsdWUoZGF0dW0pLCBnZXRDb29yZGluYXRlRGF0YUluZGV4KGRhdHVtLCBjYXRlZ29yaWVzLCBpZHgsIHRoaXMuc3RhcnRJbmRleCkpO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHsgeCwgeSwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzcGxpbmUpIHtcbiAgICAgICAgICAgICAgICBzZXRTcGxpbmVDb250cm9sUG9pbnQocG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmVQb2ludHMnLFxuICAgICAgICAgICAgICAgIHBvaW50cyxcbiAgICAgICAgICAgICAgICBzZXJpZXNJbmRleCxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBnZXRSR0JBKHNlcmllc0NvbG9yLCBhY3RpdmUgPyAxIDogMC4zKSxcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGgsXG4gICAgICAgICAgICAgICAgZGFzaFNlZ21lbnRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFJlY3RSZXNwb25kZXJJbmZvRm9yQ29vcmRpbmF0ZVR5cGUoY2lyY2xlTW9kZWwsIGNhdGVnb3JpZXMpIHtcbiAgICAgICAgY29uc3QgZHVwbGljYXRlQ2hlY2tNYXAgPSB7fTtcbiAgICAgICAgY29uc3QgbW9kZWxJblJhbmdlID0gY2lyY2xlTW9kZWwuZmlsdGVyKCh7IHggfSkgPT4geCA+PSAwICYmIHggPD0gdGhpcy5yZWN0LndpZHRoKTtcbiAgICAgICAgcmV0dXJuIG1vZGVsSW5SYW5nZS5yZWR1Y2UoKGFjYywgbW9kZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5kZXgsIHggfSA9IG1vZGVsO1xuICAgICAgICAgICAgaWYgKCFkdXBsaWNhdGVDaGVja01hcFt4XSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gY2F0ZWdvcmllc1tpbmRleF07XG4gICAgICAgICAgICAgICAgZHVwbGljYXRlQ2hlY2tNYXBbeF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFjYy5wdXNoKHsgeCwgbGFiZWwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIHJlbmRlckNpcmNsZU1vZGVsKGxpbmVTZXJpZXNNb2RlbCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkb3RTZXJpZXNNb2RlbCA9IFtdO1xuICAgICAgICBjb25zdCByZXNwb25kZXJNb2RlbCA9IFtdO1xuICAgICAgICBjb25zdCBzaG93RG90ID0gISFvcHRpb25zLnNob3dEb3Q7XG4gICAgICAgIGNvbnN0IHsgaG92ZXIsIGRvdDogZG90VGhlbWUgfSA9IHRoaXMudGhlbWU7XG4gICAgICAgIGNvbnN0IGhvdmVyRG90VGhlbWUgPSBob3Zlci5kb3Q7XG4gICAgICAgIGxpbmVTZXJpZXNNb2RlbC5mb3JFYWNoKCh7IGNvbG9yLCBuYW1lLCBwb2ludHMgfSwgc2VyaWVzSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuYWN0aXZlU2VyaWVzTWFwW25hbWVdO1xuICAgICAgICAgICAgcG9pbnRzLmZvckVhY2goKHBvaW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChwb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0geyB0eXBlOiAnY2lyY2xlJywgeCwgeSwgc2VyaWVzSW5kZXgsIG5hbWUsIGluZGV4IH07XG4gICAgICAgICAgICAgICAgaWYgKHNob3dEb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZG90U2VyaWVzTW9kZWwucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1vZGVsKSwgeyByYWRpdXM6IGRvdFRoZW1lLnJhZGl1cywgY29sb3I6IGdldFJHQkEoY29sb3IsIGFjdGl2ZSA/IDEgOiAwLjMpLCBzdHlsZTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbGluZVdpZHRoOiBkb3RUaGVtZS5ib3JkZXJXaWR0aCwgc3Ryb2tlU3R5bGU6IChfYSA9IGRvdFRoZW1lLmJvcmRlckNvbG9yLCAoX2EgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29sb3IpKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbmRlck1vZGVsLnB1c2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtb2RlbCksIHsgcmFkaXVzOiBob3ZlckRvdFRoZW1lLnJhZGl1cywgY29sb3I6IChfYiA9IGhvdmVyRG90VGhlbWUuY29sb3IsIChfYiAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBnZXRSR0JBKGNvbG9yLCAxKSkpLCBzdHlsZTogWydkZWZhdWx0J10gfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBkb3RTZXJpZXNNb2RlbCwgcmVzcG9uZGVyTW9kZWwgfTtcbiAgICB9XG4gICAgZ2V0Q2lyY2xlTW9kZWxzRnJvbVJlY3RSZXNwb25kZXJzKHJlc3BvbmRlcnMsIG1vdXNlUG9zaXRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghcmVzcG9uZGVycy5sZW5ndGggfHwgIXJlc3BvbmRlcnNbMF0ubGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbHMgPSAoX2IgPSB0aGlzLnRvb2x0aXBDaXJjbGVNYXBbKF9hID0gcmVzcG9uZGVyc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhYmVsXSwgKF9iICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50RGV0ZWN0VHlwZSA9PT0gJ2dyb3VwZWQnXG4gICAgICAgICAgICA/IG1vZGVsc1xuICAgICAgICAgICAgOiBnZXROZWFyZXN0UmVzcG9uZGVyKG1vZGVscywgbW91c2VQb3NpdGlvbnMsIHRoaXMucmVjdCk7XG4gICAgfVxuICAgIG9uTW91c2Vtb3ZlTmVhclR5cGUocmVzcG9uZGVycykge1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlckhvdmVyZWRTZXJpZXMnLCB7XG4gICAgICAgICAgICBtb2RlbHM6IHRoaXMuZ2V0UmVzcG9uZGVyU2VyaWVzV2l0aFRoZW1lKHJlc3BvbmRlcnMsICdob3ZlcicpLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgZXZlbnREZXRlY3RUeXBlOiB0aGlzLmV2ZW50RGV0ZWN0VHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IHJlc3BvbmRlcnM7XG4gICAgfVxuICAgIG9uTW91c2Vtb3ZlTmVhcmVzdFR5cGUocmVzcG9uZGVycywgbW91c2VQb3NpdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2lyY2xlTW9kZWxzID0gdGhpcy5nZXRDaXJjbGVNb2RlbHNGcm9tUmVjdFJlc3BvbmRlcnMocmVzcG9uZGVycywgbW91c2VQb3NpdGlvbnMpO1xuICAgICAgICB0aGlzLm9uTW91c2Vtb3ZlTmVhclR5cGUoY2lyY2xlTW9kZWxzKTtcbiAgICB9XG4gICAgb25Nb3VzZW1vdmVHcm91cGVkVHlwZShyZXNwb25kZXJzKSB7XG4gICAgICAgIGNvbnN0IGNpcmNsZU1vZGVscyA9IHRoaXMuZ2V0Q2lyY2xlTW9kZWxzRnJvbVJlY3RSZXNwb25kZXJzKHJlc3BvbmRlcnMpO1xuICAgICAgICB0aGlzLm9uTW91c2Vtb3ZlTmVhclR5cGUoY2lyY2xlTW9kZWxzKTtcbiAgICB9XG4gICAgb25Nb3VzZW1vdmUoeyByZXNwb25kZXJzLCBtb3VzZVBvc2l0aW9uIH0pIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnREZXRlY3RUeXBlID09PSAnbmVhcmVzdCcpIHtcbiAgICAgICAgICAgIHRoaXMub25Nb3VzZW1vdmVOZWFyZXN0VHlwZShyZXNwb25kZXJzLCBtb3VzZVBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmNsdWRlcyhbJ25lYXInLCAncG9pbnQnXSwgdGhpcy5ldmVudERldGVjdFR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLm9uTW91c2Vtb3ZlTmVhclR5cGUocmVzcG9uZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uTW91c2Vtb3ZlR3JvdXBlZFR5cGUocmVzcG9uZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzZXJpZXNQb2ludEhvdmVyZWQnLCB7IG1vZGVsczogdGhpcy5hY3RpdmF0ZWRSZXNwb25kZXJzLCBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICB9XG4gICAgZ2V0RGF0YUxhYmVscyhzZXJpZXNNb2RlbHMpIHtcbiAgICAgICAgY29uc3QgZGF0YUxhYmVsVGhlbWUgPSB0aGlzLnRoZW1lLmRhdGFMYWJlbHM7XG4gICAgICAgIHJldHVybiBzZXJpZXNNb2RlbHMuZmxhdE1hcCgoeyBwb2ludHMsIG5hbWUsIGNvbG9yIH0pID0+IHBvaW50cy5tYXAoKHBvaW50KSA9PiBpc051bGwocG9pbnQpXG4gICAgICAgICAgICA/IHt9XG4gICAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdwb2ludCcgfSwgcG9pbnQpLCB7IG5hbWUsIHRoZW1lOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGFMYWJlbFRoZW1lKSwgeyBjb2xvcjogZGF0YUxhYmVsVGhlbWUudXNlU2VyaWVzQ29sb3IgPyBjb2xvciA6IGRhdGFMYWJlbFRoZW1lLmNvbG9yIH0pIH0pKSk7XG4gICAgfVxuICAgIGdldFJlc3BvbmRlclNlcmllc1dpdGhUaGVtZShtb2RlbHMsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgeyByYWRpdXMsIGNvbG9yLCBib3JkZXJXaWR0aCwgYm9yZGVyQ29sb3IgfSA9IHRoaXMudGhlbWVbdHlwZV0uZG90O1xuICAgICAgICByZXR1cm4gbW9kZWxzLm1hcCgobW9kZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsQ29sb3IgPSAoY29sb3IgIT09IG51bGwgJiYgY29sb3IgIT09IHZvaWQgMCA/IGNvbG9yIDogbW9kZWwuY29sb3IpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbW9kZWwpLCB7IHJhZGl1cywgY29sb3I6IG1vZGVsQ29sb3IsIHN0eWxlOiBbeyBsaW5lV2lkdGg6IGJvcmRlcldpZHRoLCBzdHJva2VTdHlsZTogKGJvcmRlckNvbG9yICE9PSBudWxsICYmIGJvcmRlckNvbG9yICE9PSB2b2lkIDAgPyBib3JkZXJDb2xvciA6IGdldFJHQkEobW9kZWxDb2xvciwgMC41KSkgfV0gfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbkNsaWNrKHsgcmVzcG9uZGVycywgbW91c2VQb3NpdGlvbiB9KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIGxldCBtb2RlbHM7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudERldGVjdFR5cGUgPT09ICduZWFyJykge1xuICAgICAgICAgICAgICAgIG1vZGVscyA9IHJlc3BvbmRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb2RlbHMgPSB0aGlzLmdldENpcmNsZU1vZGVsc0Zyb21SZWN0UmVzcG9uZGVycyhyZXNwb25kZXJzLCBtb3VzZVBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVyU2VsZWN0ZWRTZXJpZXMnLCB7XG4gICAgICAgICAgICAgICAgbW9kZWxzOiB0aGlzLmdldFJlc3BvbmRlclNlcmllc1dpdGhUaGVtZShtb2RlbHMsICdzZWxlY3QnKSxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSZXNwb25kZXJDYXRlZ29yeUJ5SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgcmVzcG9uZGVyID0gT2JqZWN0LnZhbHVlcyh0aGlzLnRvb2x0aXBDaXJjbGVNYXApXG4gICAgICAgICAgICAuZmxhdE1hcCgodmFsKSA9PiB2YWwpXG4gICAgICAgICAgICAuZmluZCgobW9kZWwpID0+IG1vZGVsLmluZGV4ID09PSBpbmRleCk7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSByZXNwb25kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2F0ZWdvcnk7XG4gICAgfVxufVxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi9jb21wb25lbnRcIjtcbmltcG9ydCB7IGdldFRleHRIZWlnaHQsIGdldFRleHRXaWR0aCB9IGZyb20gXCIuLi9oZWxwZXJzL2NhbGN1bGF0b3JcIjtcbmltcG9ydCB7IGdldFRpdGxlRm9udFN0cmluZyB9IGZyb20gXCIuLi9oZWxwZXJzL3N0eWxlXCI7XG5pbXBvcnQgeyBpc05vRGF0YSB9IGZyb20gXCIuLi9oZWxwZXJzL3ZhbGlkYXRpb25cIjtcbmNvbnN0IERFRkFVTFRfTk9fREFUQV9URVhUID0gJ05vIGRhdGEgdG8gZGlzcGxheSc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb0RhdGFUZXh0IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnbm9EYXRhVGV4dCc7XG4gICAgICAgIHRoaXMubmFtZSA9ICdub0RhdGFUZXh0JztcbiAgICB9XG4gICAgZ2V0Q2VudGVyUG9zaXRpb24odGV4dCwgZm9udCkge1xuICAgICAgICBjb25zdCB0ZXh0V2lkdGggPSBnZXRUZXh0V2lkdGgodGV4dCwgZm9udCk7XG4gICAgICAgIGNvbnN0IHRleHRIZWlnaHQgPSBnZXRUZXh0SGVpZ2h0KHRleHQsIGZvbnQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogKHRoaXMucmVjdC53aWR0aCAtIHRleHRXaWR0aCkgLyAyLFxuICAgICAgICAgICAgeTogKHRoaXMucmVjdC5oZWlnaHQgLSB0ZXh0SGVpZ2h0KSAvIDIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcih7IGxheW91dCwgc2VyaWVzLCBvcHRpb25zLCB0aGVtZSB9KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCB0ZXh0ID0gKF9jID0gKF9iID0gKF9hID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhbmcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ub0RhdGEsIChfYyAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBERUZBVUxUX05PX0RBVEFfVEVYVCkpO1xuICAgICAgICBjb25zdCBsYWJlbFRoZW1lID0gdGhlbWUubm9EYXRhO1xuICAgICAgICBjb25zdCBmb250ID0gZ2V0VGl0bGVGb250U3RyaW5nKGxhYmVsVGhlbWUpO1xuICAgICAgICBjb25zdCBmaWxsU3R5bGUgPSBsYWJlbFRoZW1lLmNvbG9yO1xuICAgICAgICB0aGlzLmlzU2hvdyA9IGlzTm9EYXRhKHNlcmllcyk7XG4gICAgICAgIHRoaXMucmVjdCA9IGxheW91dC5wbG90O1xuICAgICAgICB0aGlzLm1vZGVscyA9IFtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdsYWJlbCcgfSwgdGhpcy5nZXRDZW50ZXJQb3NpdGlvbih0ZXh0LCBmb250KSksIHsgdGV4dCwgc3R5bGU6IFt7IGZvbnQsIGZpbGxTdHlsZSB9XSB9KSxcbiAgICAgICAgXTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuL2NvbXBvbmVudFwiO1xuaW1wb3J0IHsgZ2V0UkdCQSB9IGZyb20gXCIuLi9oZWxwZXJzL2NvbG9yXCI7XG5pbXBvcnQgeyBnZXRSYWRpYWxBbmNob3JQb3NpdGlvbiwgbWFrZUFuY2hvclBvc2l0aW9uUGFyYW0sIHdpdGhpblJhZGlhbiwgZ2V0RGVmYXVsdFJhZGl1cywgREVHUkVFXzM2MCwgREVHUkVFXzAsIERFR1JFRV85MCwgfSBmcm9tIFwiLi4vaGVscGVycy9zZWN0b3JcIjtcbmltcG9ydCB7IGdldEFjdGl2ZVNlcmllc01hcCB9IGZyb20gXCIuLi9oZWxwZXJzL2xlZ2VuZFwiO1xuaW1wb3J0IHsgZ2V0RGF0YUxhYmVsc09wdGlvbnMsIFJBRElVU19QQURESU5HIH0gZnJvbSBcIi4uL2hlbHBlcnMvZGF0YUxhYmVsc1wiO1xuaW1wb3J0IHsgZ2V0VG90YWxBbmdsZSwgaXNTZW1pQ2lyY2xlLCBnZXRTZW1pQ2lyY2xlQ2VudGVyWSwgbWFrZVBpZVRvb2x0aXBEYXRhLCBwaWVUb29sdGlwTGFiZWxGb3JtYXR0ZXIsIH0gZnJvbSBcIi4uL2hlbHBlcnMvcGllU2VyaWVzXCI7XG5pbXBvcnQgeyBjYWxjdWxhdGVTaXplV2l0aFBlcmNlbnRTdHJpbmcsIGlzTnVtYmVyLCBpc1VuZGVmaW5lZCwgbGFzdCwgfSBmcm9tIFwiLi4vaGVscGVycy91dGlsc1wiO1xuaW1wb3J0IHsgcGljayB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBtZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2VcIjtcbmltcG9ydCB7IGdldE1heExhYmVsU2l6ZSB9IGZyb20gXCIuLi9oZWxwZXJzL2F4ZXNcIjtcbmltcG9ydCB7IGdldEZvbnQgfSBmcm9tIFwiLi4vaGVscGVycy9zdHlsZVwiO1xuZnVuY3Rpb24gZ2V0Q2FsY3VsYXRlZFJhZGl1c1JhbmdlKHsgYWxpYXMsIHJlbmRlck9wdGlvbnMsIHJhZGl1c1JhbmdlTWFwLCBwaWVJbmRleCwgcmFkaXVzUmFuZ2VzLCB0b3RhbFBpZUFsaWFzQ291bnQsIH0pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGNvbnN0IHJhZGl1c1JhbmdlTGVuZ3RoID0gT2JqZWN0LmtleXMocmFkaXVzUmFuZ2VNYXApLmxlbmd0aDtcbiAgICBjb25zdCB7IGRlZmF1bHRSYWRpdXMgPSAwIH0gPSByZW5kZXJPcHRpb25zO1xuICAgIGxldCB7IGlubmVyLCBvdXRlciB9ID0gcmVuZGVyT3B0aW9ucy5yYWRpdXNSYW5nZTtcbiAgICBpZiAoIXJhZGl1c1JhbmdlTWFwW2FsaWFzXSkge1xuICAgICAgICBpZiAoIXJhZGl1c1JhbmdlTGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCByYWRpdXMgPSBkZWZhdWx0UmFkaXVzIC8gdG90YWxQaWVBbGlhc0NvdW50O1xuICAgICAgICAgICAgaW5uZXIgPSBwaWVJbmRleCAqIHJhZGl1cztcbiAgICAgICAgICAgIG91dGVyID0gKHBpZUluZGV4ICsgMSkgKiByYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocGllSW5kZXggJiYgcmFkaXVzUmFuZ2VzW3BpZUluZGV4IC0gMV0ub3V0ZXIpIHtcbiAgICAgICAgICAgICAgICBpbm5lciA9IHJhZGl1c1Jhbmdlc1twaWVJbmRleCAtIDFdLm91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChfYSA9IHJhZGl1c1Jhbmdlc1twaWVJbmRleCArIDFdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5uZXIpIHtcbiAgICAgICAgICAgICAgICBvdXRlciA9IHJhZGl1c1Jhbmdlc1twaWVJbmRleCArIDFdLmlubmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGllSW5kZXggPT09IHRvdGFsUGllQWxpYXNDb3VudCAtIDEpIHtcbiAgICAgICAgICAgICAgICBvdXRlciA9IGRlZmF1bHRSYWRpdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYWRpdXMgPSAoZGVmYXVsdFJhZGl1cyAtXG4gICAgICAgICAgICAgICAgICAgIChfYyA9IChfYiA9IHJhZGl1c1Jhbmdlc1twaWVJbmRleCAtIDFdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3V0ZXIsIChfYyAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwKSkgLVxuICAgICAgICAgICAgICAgICAgICAoX2UgPSAoX2QgPSByYWRpdXNSYW5nZXNbcGllSW5kZXggKyAxXSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmlubmVyLCAoX2UgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogMCkpKSAvXG4gICAgICAgICAgICAgICAgICAgICh0b3RhbFBpZUFsaWFzQ291bnQgLSByYWRpdXNSYW5nZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgb3V0ZXIgPSBpbm5lciArIHJhZGl1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBpbm5lciwgb3V0ZXIgfTtcbn1cbmZ1bmN0aW9uIGdldFBpZVNlcmllc09wYWNpdHlCeURlcHRoKG9yaWdpbkFscGhhLCBkZXB0aCwgaW5kZXhPZkdyb3VwLCBicmlnaHRuZXNzID0gMC44NSkge1xuICAgIGNvbnN0IGRlcHRoQWxwaGEgPSBOdW1iZXIoKG9yaWdpbkFscGhhICogTWF0aC5wb3coYnJpZ2h0bmVzcywgZGVwdGgpKS50b0ZpeGVkKDIpKTtcbiAgICByZXR1cm4gTnVtYmVyKChNYXRoLnBvdyhkZXB0aEFscGhhLCAoaW5kZXhPZkdyb3VwICsgMSkpKS50b0ZpeGVkKDIpKTtcbn1cbmZ1bmN0aW9uIGdldE1heERhdGFMYWJlbFNpemUoc2VyaWVzTmFtZUxhYmVscywgb3B0aW9ucywgZGF0YUxhYmVsVGhlbWUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IG91dGVyTGFiZWxzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBoYXNPdXRlckxhYmVsOiBvcHRpb25zLnZpc2libGUgJiYgb3B0aW9ucy5hbmNob3IgPT09ICdvdXRlcicsXG4gICAgICAgICAgICBsYWJlbHM6IFsnMDAuMDAlJ10sXG4gICAgICAgICAgICB0aGVtZTogZGF0YUxhYmVsVGhlbWUsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGhhc091dGVyTGFiZWw6ICgoX2EgPSBvcHRpb25zLnBpZVNlcmllc05hbWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52aXNpYmxlKSAmJiAoKF9iID0gb3B0aW9ucy5waWVTZXJpZXNOYW1lKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYW5jaG9yKSA9PT0gJ291dGVyJyxcbiAgICAgICAgICAgIGxhYmVsczogc2VyaWVzTmFtZUxhYmVscyxcbiAgICAgICAgICAgIHRoZW1lOiBkYXRhTGFiZWxUaGVtZS5waWVTZXJpZXNOYW1lLFxuICAgICAgICB9LFxuICAgIF07XG4gICAgcmV0dXJuIG91dGVyTGFiZWxzLnJlZHVjZSgoYWNjLCBjdXIpID0+IHtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBhY2M7XG4gICAgICAgIGNvbnN0IHsgaGFzT3V0ZXJMYWJlbCwgbGFiZWxzLCB0aGVtZSB9ID0gY3VyO1xuICAgICAgICBpZiAoaGFzT3V0ZXJMYWJlbCkge1xuICAgICAgICAgICAgY29uc3QgeyBtYXhMYWJlbFdpZHRoLCBtYXhMYWJlbEhlaWdodCB9ID0gZ2V0TWF4TGFiZWxTaXplKGxhYmVscywgMCwgZ2V0Rm9udCh0aGVtZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogTWF0aC5tYXgobWF4TGFiZWxXaWR0aCArIFJBRElVU19QQURESU5HLCB3aWR0aCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChtYXhMYWJlbEhlaWdodCArIFJBRElVU19QQURESU5HLCBoZWlnaHQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHsgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBpZVNlcmllcyBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubW9kZWxzID0geyBzZXJpZXM6IFtdIH07XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IFtdO1xuICAgICAgICB0aGlzLm9uTW91c2VvdXRDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nlcmllc1BvaW50SG92ZXJlZCcsIHsgbW9kZWxzOiBbXSwgbmFtZTogdGhpcy5hbGlhcyB8fCB0aGlzLm5hbWUgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlckhvdmVyZWRTZXJpZXMnLCB7IG1vZGVsczogW10sIG5hbWU6IHRoaXMuYWxpYXMgfHwgdGhpcy5uYW1lIH0pO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCduZWVkRHJhdycpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlbGVjdFNlcmllcyA9ICh7IHNlcmllc0luZGV4LCBuYW1lIH0pID0+IHtcbiAgICAgICAgICAgIGlmICghaXNOdW1iZXIoc2VyaWVzSW5kZXgpIHx8ICghaXNVbmRlZmluZWQobmFtZSkgJiYgbmFtZSAhPT0gdGhpcy5hbGlhcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMucmVzcG9uZGVyc1tzZXJpZXNJbmRleF07XG4gICAgICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UuU0VMRUNUX1NFUklFU19BUElfSU5ERVhfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJTZWxlY3RlZFNlcmllcycsIHtcbiAgICAgICAgICAgICAgICBtb2RlbHM6IHRoaXMuZ2V0UmVzcG9uZGVyTW9kZWxzV2l0aFRoZW1lKFttb2RlbF0sICdzZWxlY3QnKSxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgYWxpYXM6IHRoaXMuYWxpYXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zaG93VG9vbHRpcCA9ICh7IHNlcmllc0luZGV4LCBuYW1lIH0pID0+IHtcbiAgICAgICAgICAgIGlmICghaXNOdW1iZXIoc2VyaWVzSW5kZXgpIHx8ICghaXNVbmRlZmluZWQobmFtZSkgJiYgbmFtZSAhPT0gdGhpcy5hbGlhcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2RlbHMgPSBbdGhpcy5yZXNwb25kZXJzW3Nlcmllc0luZGV4XV07XG4gICAgICAgICAgICBpZiAoIW1vZGVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlckhvdmVyZWRTZXJpZXMnLCB7XG4gICAgICAgICAgICAgICAgbW9kZWxzOiB0aGlzLmdldFJlc3BvbmRlck1vZGVsc1dpdGhUaGVtZShtb2RlbHMsICdob3ZlcicpLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBhbGlhczogdGhpcy5hbGlhcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZWRSZXNwb25kZXJzID0gdGhpcy5tYWtlVG9vbHRpcFJlc3BvbmRlcihtb2RlbHMpO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzZXJpZXNQb2ludEhvdmVyZWQnLCB7XG4gICAgICAgICAgICAgICAgbW9kZWxzOiB0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5hbGlhcyB8fCB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaW5pdFVwZGF0ZShkZWx0YSkge1xuICAgICAgICBpZiAoIXRoaXMuZHJhd01vZGVscykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50RGVncmVlO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMubW9kZWxzLnNlcmllcy5maW5kSW5kZXgoKHsgY2xvY2t3aXNlLCBkZWdyZWU6IHsgc3RhcnQsIGVuZCB9LCB0b3RhbEFuZ2xlIH0pID0+IHtcbiAgICAgICAgICAgIGN1cnJlbnREZWdyZWUgPSBjbG9ja3dpc2UgPyB0b3RhbEFuZ2xlICogZGVsdGEgOiBERUdSRUVfMzYwIC0gdG90YWxBbmdsZSAqIGRlbHRhO1xuICAgICAgICAgICAgcmV0dXJuIHdpdGhpblJhZGlhbihjbG9ja3dpc2UsIHN0YXJ0LCBlbmQsIGN1cnJlbnREZWdyZWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zeW5jRW5kQW5nbGUoaW5kZXggPCAwID8gdGhpcy5tb2RlbHMuc2VyaWVzLmxlbmd0aCA6IGluZGV4KTtcbiAgICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3TW9kZWxzLnNlcmllc1tpbmRleF0uZGVncmVlLmVuZCA9IGN1cnJlbnREZWdyZWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3luY0VuZEFuZ2xlKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZUYXJnZXRFbmREZWdyZWUgPSB0aGlzLm1vZGVscy5zZXJpZXNbaV0uZGVncmVlLmVuZDtcbiAgICAgICAgICAgIGlmICh0aGlzLmRyYXdNb2RlbHMuc2VyaWVzW2ldLmRlZ3JlZS5lbmQgIT09IHByZXZUYXJnZXRFbmREZWdyZWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdNb2RlbHMuc2VyaWVzW2ldLmRlZ3JlZS5lbmQgPSBwcmV2VGFyZ2V0RW5kRGVncmVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRpYWxpemUocGFyYW0pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy50eXBlID0gJ3Nlcmllcyc7XG4gICAgICAgIHRoaXMubmFtZSA9ICdwaWUnO1xuICAgICAgICB0aGlzLmFsaWFzID0gKF9iID0gKF9hID0gcGFyYW0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hbGlhcywgKF9iICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnKSk7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMub24oJ3NlbGVjdFNlcmllcycsIHRoaXMuc2VsZWN0U2VyaWVzKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignc2hvd1Rvb2x0aXAnLCB0aGlzLnNob3dUb29sdGlwKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignaGlkZVRvb2x0aXAnLCB0aGlzLm9uTW91c2VvdXRDb21wb25lbnQpO1xuICAgIH1cbiAgICByZW5kZXIoY2hhcnRTdGF0ZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IHsgbGF5b3V0LCBzZXJpZXMsIGxlZ2VuZCwgb3B0aW9ucywgbmVzdGVkUGllU2VyaWVzLCB0aGVtZSB9ID0gY2hhcnRTdGF0ZTtcbiAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IChfYSA9IGNoYXJ0U3RhdGUuY2F0ZWdvcmllcywgKF9hICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSk7XG4gICAgICAgIGlmICghc2VyaWVzLnBpZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2Uubm9EYXRhRXJyb3IodGhpcy5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGllVGhlbWUgPSB0aGVtZS5zZXJpZXMucGllO1xuICAgICAgICB0aGlzLnRoZW1lID0gdGhpcy5hbGlhcyA/IHBpZVRoZW1lW3RoaXMuYWxpYXNdIDogcGllVGhlbWU7XG4gICAgICAgIHRoaXMucmVjdCA9IGxheW91dC5wbG90O1xuICAgICAgICB0aGlzLmFjdGl2ZVNlcmllc01hcCA9IGdldEFjdGl2ZVNlcmllc01hcChsZWdlbmQpO1xuICAgICAgICB0aGlzLnNlbGVjdGFibGUgPSB0aGlzLmdldFNlbGVjdGFibGVPcHRpb24ob3B0aW9ucyk7XG4gICAgICAgIGxldCBzZXJpZXNNb2RlbCwgdG9vbHRpcERhdGFNb2RlbDtcbiAgICAgICAgY29uc3QgZGF0YUxhYmVsc09wdGlvbnMgPSBnZXREYXRhTGFiZWxzT3B0aW9ucyhvcHRpb25zLCB0aGlzLmFsaWFzKTtcbiAgICAgICAgaWYgKG5lc3RlZFBpZVNlcmllcykge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBuZXN0ZWRQaWVTZXJpZXNbdGhpcy5hbGlhc107XG4gICAgICAgICAgICBjb25zdCBwaWVBbGlhcyA9IE9iamVjdC5rZXlzKG5lc3RlZFBpZVNlcmllcyk7XG4gICAgICAgICAgICBjb25zdCBwaWVJbmRleCA9IHBpZUFsaWFzLmZpbmRJbmRleCgoYWxpYXMpID0+IGFsaWFzID09PSB0aGlzLmFsaWFzKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBkYXRhIGxhYmVsIG9mIHRoZSBsYXN0IFBpZSBzZXJpZXNcbiAgICAgICAgICAgIGNvbnN0IGxhc3RBbGlhcyA9IGxhc3QocGllQWxpYXMpO1xuICAgICAgICAgICAgY29uc3QgbGFzdFNlcmllcyA9IG5lc3RlZFBpZVNlcmllc1tsYXN0QWxpYXNdO1xuICAgICAgICAgICAgY29uc3QgbWF4UGllRGF0YUxhYmVsU2l6ZSA9IGdldE1heERhdGFMYWJlbFNpemUobGFzdFNlcmllcy5kYXRhLm1hcCgoeyBuYW1lIH0pID0+IG5hbWUpLCBnZXREYXRhTGFiZWxzT3B0aW9ucyhvcHRpb25zLCBsYXN0QWxpYXMpLCB0aGlzLnRoZW1lLmRhdGFMYWJlbHMpO1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyT3B0aW9uc01hcCA9IHRoaXMuZ2V0UmVuZGVyT3B0aW9uc01hcChvcHRpb25zLCBwaWVBbGlhcywgbWF4UGllRGF0YUxhYmVsU2l6ZSk7XG4gICAgICAgICAgICBzZXJpZXNNb2RlbCA9IHRoaXMucmVuZGVyUGllTW9kZWwoZGF0YSwgcmVuZGVyT3B0aW9uc01hcFt0aGlzLmFsaWFzXSwgcGllSW5kZXgpO1xuICAgICAgICAgICAgdG9vbHRpcERhdGFNb2RlbCA9IG1ha2VQaWVUb29sdGlwRGF0YShkYXRhLCAoX2IgPSBjYXRlZ29yaWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbcGllSW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBpZURhdGEgPSAoX2MgPSBzZXJpZXMucGllKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0TWF4RGF0YUxhYmVsU2l6ZShwaWVEYXRhLm1hcCgoeyBuYW1lIH0pID0+IG5hbWUpLCBkYXRhTGFiZWxzT3B0aW9ucywgdGhpcy50aGVtZS5kYXRhTGFiZWxzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSB0aGlzLm1ha2VSZW5kZXJPcHRpb25zKG9wdGlvbnMsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgc2VyaWVzTW9kZWwgPSB0aGlzLnJlbmRlclBpZU1vZGVsKHBpZURhdGEsIHJlbmRlck9wdGlvbnMpO1xuICAgICAgICAgICAgdG9vbHRpcERhdGFNb2RlbCA9IG1ha2VQaWVUb29sdGlwRGF0YShwaWVEYXRhLCAoX2QgPSBjYXRlZ29yaWVzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWxzLnNlcmllcyA9IHNlcmllc01vZGVsO1xuICAgICAgICBpZiAoIXRoaXMuZHJhd01vZGVscykge1xuICAgICAgICAgICAgdGhpcy5kcmF3TW9kZWxzID0ge1xuICAgICAgICAgICAgICAgIHNlcmllczogdGhpcy5tb2RlbHMuc2VyaWVzLm1hcCgobSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbSksIHsgZGVncmVlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG0uZGVncmVlKSwgeyBlbmQ6IG0uZGVncmVlLnN0YXJ0IH0pIH0pKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhTGFiZWxzT3B0aW9ucy52aXNpYmxlKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhTGFiZWxEYXRhID0gc2VyaWVzTW9kZWwubWFwKChtKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyB2YWx1ZTogYCR7cGllVG9vbHRpcExhYmVsRm9ybWF0dGVyKG0ucGVyY2VudFZhbHVlKX1gLCB0aGVtZTogdGhpcy50aGVtZS5kYXRhTGFiZWxzIH0pKSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckRhdGFMYWJlbHMoZGF0YUxhYmVsRGF0YSwgdGhpcy5hbGlhcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNwb25kZXJzID0gc2VyaWVzTW9kZWwubWFwKChtLCBpbmRleCkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbSksIHsgdHlwZTogJ3NlY3RvcicsIHJhZGl1czogbS5yYWRpdXMsIHNlcmllc0luZGV4OiBpbmRleCwgZGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0b29sdGlwRGF0YU1vZGVsW2luZGV4XSksIHsgcGVyY2VudFZhbHVlOiBtLnBlcmNlbnRWYWx1ZSB9KSwgY29sb3I6IGdldFJHQkEobS5jb2xvciwgMSkgfSkpKTtcbiAgICB9XG4gICAgZ2V0UmFkaXVzUmFuZ2VNYXAob3B0aW9ucywgcGllQWxpYXMpIHtcbiAgICAgICAgcmV0dXJuIHBpZUFsaWFzLnJlZHVjZSgoYWNjLCBhbGlhcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IHNlcmllc09wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMob3B0aW9ucywgYWxpYXMpLnNlcmllcztcbiAgICAgICAgICAgIGlmICgoX2EgPSBzZXJpZXNPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmFkaXVzUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBhY2NbYWxpYXNdID0gKF9iID0gc2VyaWVzT3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJhZGl1c1JhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICBnZXRSZW5kZXJPcHRpb25zTWFwKG9wdGlvbnMsIHBpZUFsaWFzLCBtYXhQaWVEYXRhTGFiZWxTaXplKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlck9wdGlvbnNNYXAgPSB0aGlzLmluaXRSZW5kZXJPcHRpb25zTWFwKG9wdGlvbnMsIHBpZUFsaWFzLCBtYXhQaWVEYXRhTGFiZWxTaXplKTtcbiAgICAgICAgY29uc3QgcmFkaXVzUmFuZ2VNYXAgPSB0aGlzLmdldFJhZGl1c1JhbmdlTWFwKG9wdGlvbnMsIHBpZUFsaWFzKTtcbiAgICAgICAgcGllQWxpYXMuZm9yRWFjaCgoYWxpYXMsIHBpZUluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByYWRpdXNSYW5nZXMgPSBPYmplY3QudmFsdWVzKHJlbmRlck9wdGlvbnNNYXApLm1hcCgoeyByYWRpdXNSYW5nZSB9KSA9PiByYWRpdXNSYW5nZSk7XG4gICAgICAgICAgICByZW5kZXJPcHRpb25zTWFwW2FsaWFzXS5yYWRpdXNSYW5nZSA9IGdldENhbGN1bGF0ZWRSYWRpdXNSYW5nZSh7XG4gICAgICAgICAgICAgICAgYWxpYXMsXG4gICAgICAgICAgICAgICAgcmVuZGVyT3B0aW9uczogcmVuZGVyT3B0aW9uc01hcFthbGlhc10sXG4gICAgICAgICAgICAgICAgcmFkaXVzUmFuZ2VNYXAsXG4gICAgICAgICAgICAgICAgcGllSW5kZXgsXG4gICAgICAgICAgICAgICAgcmFkaXVzUmFuZ2VzLFxuICAgICAgICAgICAgICAgIHRvdGFsUGllQWxpYXNDb3VudDogcGllQWxpYXMubGVuZ3RoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVuZGVyT3B0aW9uc01hcDtcbiAgICB9XG4gICAgaW5pdFJlbmRlck9wdGlvbnNNYXAob3B0aW9ucywgcGllQWxpYXMsIHsgd2lkdGgsIGhlaWdodCB9KSB7XG4gICAgICAgIHJldHVybiBwaWVBbGlhcy5yZWR1Y2UoKGFjYywgYWxpYXMpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHsgW2FsaWFzXTogdGhpcy5tYWtlUmVuZGVyT3B0aW9ucyh0aGlzLmdldE9wdGlvbnMob3B0aW9ucywgYWxpYXMpLCB3aWR0aCwgaGVpZ2h0KSB9KSksIHt9KTtcbiAgICB9XG4gICAgZ2V0T3B0aW9ucyhjaGFydE9wdGlvbnMsIGFsaWFzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGNoYXJ0T3B0aW9ucyk7XG4gICAgICAgIGlmICgoKF9hID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlcmllcykgJiYgYWxpYXMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2VyaWVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnNlcmllcyksIG9wdGlvbnMuc2VyaWVzW2FsaWFzXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIG1ha2VSZW5kZXJPcHRpb25zKG9wdGlvbnMsIG1heERhdGFMYWJlbFdpZHRoID0gMCwgbWF4RGF0YUxhYmVsSGVpZ2h0ID0gMCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wO1xuICAgICAgICBjb25zdCBzZXJpZXNPcHRpb25zID0gb3B0aW9ucy5zZXJpZXM7XG4gICAgICAgIGNvbnN0IGNsb2Nrd2lzZSA9IChfYiA9IChfYSA9IHNlcmllc09wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9ja3dpc2UsIChfYiAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlKSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSAoX2UgPSAoX2QgPSAoX2MgPSBzZXJpZXNPcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYW5nbGVSYW5nZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnN0YXJ0LCAoX2UgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogREVHUkVFXzApKTtcbiAgICAgICAgY29uc3QgZW5kQW5nbGUgPSAoX2ggPSAoX2cgPSAoX2YgPSBzZXJpZXNPcHRpb25zKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuYW5nbGVSYW5nZSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmVuZCwgKF9oICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IERFR1JFRV8zNjApKTtcbiAgICAgICAgY29uc3QgdG90YWxBbmdsZSA9IGdldFRvdGFsQW5nbGUoY2xvY2t3aXNlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgICAgIGNvbnN0IGlzU2VtaUNpcmN1bGFyID0gaXNTZW1pQ2lyY2xlKGNsb2Nrd2lzZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMucmVjdDtcbiAgICAgICAgY29uc3QgZGVmYXVsdFJhZGl1cyA9IGdldERlZmF1bHRSYWRpdXModGhpcy5yZWN0LCBpc1NlbWlDaXJjdWxhciwgbWF4RGF0YUxhYmVsV2lkdGgsIG1heERhdGFMYWJlbEhlaWdodCk7XG4gICAgICAgIGNvbnN0IGlubmVyUmFkaXVzID0gY2FsY3VsYXRlU2l6ZVdpdGhQZXJjZW50U3RyaW5nKGRlZmF1bHRSYWRpdXMsIChfbCA9IChfayA9IChfaiA9IHNlcmllc09wdGlvbnMpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5yYWRpdXNSYW5nZSkgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLmlubmVyLCAoX2wgIT09IG51bGwgJiYgX2wgIT09IHZvaWQgMCA/IF9sIDogMCkpKTtcbiAgICAgICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBjYWxjdWxhdGVTaXplV2l0aFBlcmNlbnRTdHJpbmcoZGVmYXVsdFJhZGl1cywgKF9wID0gKF9vID0gKF9tID0gc2VyaWVzT3B0aW9ucykgPT09IG51bGwgfHwgX20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tLnJhZGl1c1JhbmdlKSA9PT0gbnVsbCB8fCBfbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX28ub3V0ZXIsIChfcCAhPT0gbnVsbCAmJiBfcCAhPT0gdm9pZCAwID8gX3AgOiAodGhpcy5hbGlhcyA/IDAgOiBkZWZhdWx0UmFkaXVzKSkpKTtcbiAgICAgICAgY29uc3QgY3ggPSB3aWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IGN5ID0gaXNTZW1pQ2lyY3VsYXIgPyBnZXRTZW1pQ2lyY2xlQ2VudGVyWSh0aGlzLnJlY3QuaGVpZ2h0LCBjbG9ja3dpc2UpIDogaGVpZ2h0IC8gMjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsb2Nrd2lzZSxcbiAgICAgICAgICAgIGN4LFxuICAgICAgICAgICAgY3ksXG4gICAgICAgICAgICBkcmF3aW5nU3RhcnRBbmdsZTogc3RhcnRBbmdsZSAtIERFR1JFRV85MCxcbiAgICAgICAgICAgIHJhZGl1c1JhbmdlOiB7XG4gICAgICAgICAgICAgICAgaW5uZXI6IGlubmVyUmFkaXVzLFxuICAgICAgICAgICAgICAgIG91dGVyOiBvdXRlclJhZGl1cyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbmdsZVJhbmdlOiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0QW5nbGUsXG4gICAgICAgICAgICAgICAgZW5kOiBlbmRBbmdsZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b3RhbEFuZ2xlLFxuICAgICAgICAgICAgZGVmYXVsdFJhZGl1cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyUGllTW9kZWwoc2VyaWVzUmF3RGF0YSwgcmVuZGVyT3B0aW9ucywgcGllSW5kZXgpIHtcbiAgICAgICAgY29uc3Qgc2VjdG9yTW9kZWxzID0gW107XG4gICAgICAgIGNvbnN0IHRvdGFsID0gc2VyaWVzUmF3RGF0YS5yZWR1Y2UoKHN1bSwgeyBkYXRhIH0pID0+IHN1bSArICgoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB2b2lkIDAgPyBkYXRhIDogMCkpLCAwKTtcbiAgICAgICAgY29uc3QgeyBjbG9ja3dpc2UsIGN4LCBjeSwgZHJhd2luZ1N0YXJ0QW5nbGUsIHJhZGl1c1JhbmdlOiB7IGlubmVyLCBvdXRlciB9LCB0b3RhbEFuZ2xlLCB9ID0gcmVuZGVyT3B0aW9ucztcbiAgICAgICAgY29uc3QgZGVmYXVsdFN0YXJ0RGVncmVlID0gY2xvY2t3aXNlID8gREVHUkVFXzAgOiBERUdSRUVfMzYwO1xuICAgICAgICBjb25zdCB7IGxpbmVXaWR0aCwgc3Ryb2tlU3R5bGUgfSA9IHRoaXMudGhlbWU7XG4gICAgICAgIHNlcmllc1Jhd0RhdGEuZm9yRWFjaCgocmF3RGF0YSwgc2VyaWVzSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5hbGlhc1xuICAgICAgICAgICAgICAgID8gdGhpcy5nZXRBbGlhc1Nlcmllc0NvbG9yKHJhd0RhdGEsIHNlcmllc1Jhd0RhdGEsIHBpZUluZGV4KVxuICAgICAgICAgICAgICAgIDogdGhpcy5nZXRTZXJpZXNDb2xvcihyYXdEYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgbmFtZSB9ID0gcmF3RGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVncmVlID0gTWF0aC5tYXgoKGRhdGEgLyB0b3RhbCkgKiB0b3RhbEFuZ2xlLCAxKSAqIChjbG9ja3dpc2UgPyAxIDogLTEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlcmNlbnRWYWx1ZSA9IChkYXRhIC8gdG90YWwpICogMTAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZNb2RlbCA9IHNlY3Rvck1vZGVsc1tzZWN0b3JNb2RlbHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnREZWdyZWUgPSBzZXJpZXNJbmRleCAmJiBwcmV2TW9kZWwgPyBwcmV2TW9kZWwuZGVncmVlLmVuZCA6IGRlZmF1bHRTdGFydERlZ3JlZTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmREZWdyZWUgPSBjbG9ja3dpc2VcbiAgICAgICAgICAgICAgICAgICAgPyBNYXRoLm1pbihzdGFydERlZ3JlZSArIGRlZ3JlZSwgREVHUkVFXzM2MClcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1heChzdGFydERlZ3JlZSArIGRlZ3JlZSwgREVHUkVFXzApO1xuICAgICAgICAgICAgICAgIHNlY3Rvck1vZGVscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NlY3RvcicsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICB4OiBjeCxcbiAgICAgICAgICAgICAgICAgICAgeTogY3ksXG4gICAgICAgICAgICAgICAgICAgIGRlZ3JlZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0RGVncmVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmREZWdyZWUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlcixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBbeyBzdHJva2VTdHlsZSB9XSxcbiAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBjbG9ja3dpc2UsXG4gICAgICAgICAgICAgICAgICAgIGRyYXdpbmdTdGFydEFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICB0b3RhbEFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50VmFsdWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VjdG9yTW9kZWxzO1xuICAgIH1cbiAgICBtYWtlVG9vbHRpcFJlc3BvbmRlcihyZXNwb25kZXJzKSB7XG4gICAgICAgIHJldHVybiByZXNwb25kZXJzLm1hcCgocmVzcG9uZGVyKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXNwb25kZXIpLCBnZXRSYWRpYWxBbmNob3JQb3NpdGlvbihtYWtlQW5jaG9yUG9zaXRpb25QYXJhbSgnY2VudGVyJywgdGhpcy5tb2RlbHMuc2VyaWVzW3Jlc3BvbmRlci5zZXJpZXNJbmRleF0pKSkpKTtcbiAgICB9XG4gICAgb25Nb3VzZW1vdmUoeyByZXNwb25kZXJzIH0pIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJIb3ZlcmVkU2VyaWVzJywge1xuICAgICAgICAgICAgbW9kZWxzOiB0aGlzLmdldFJlc3BvbmRlck1vZGVsc1dpdGhUaGVtZShyZXNwb25kZXJzLCAnaG92ZXInKSxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuYWxpYXMgfHwgdGhpcy5uYW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZWRSZXNwb25kZXJzID0gdGhpcy5tYWtlVG9vbHRpcFJlc3BvbmRlcihyZXNwb25kZXJzKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzZXJpZXNQb2ludEhvdmVyZWQnLCB7XG4gICAgICAgICAgICBtb2RlbHM6IHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuYWxpYXMgfHwgdGhpcy5uYW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCduZWVkRHJhdycpO1xuICAgIH1cbiAgICBvbkNsaWNrKHsgcmVzcG9uZGVycyB9KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVyU2VsZWN0ZWRTZXJpZXMnLCB7XG4gICAgICAgICAgICAgICAgbW9kZWxzOiB0aGlzLmdldFJlc3BvbmRlck1vZGVsc1dpdGhUaGVtZShyZXNwb25kZXJzLCAnc2VsZWN0JyksXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGFsaWFzOiB0aGlzLmFsaWFzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmVzcG9uZGVyTW9kZWxzV2l0aFRoZW1lKHJlc3BvbmRlcnMsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgdGhlbWUgPSB0aGlzLnRoZW1lW3R5cGVdO1xuICAgICAgICBjb25zdCBsaW5lV2lkdGggPSB0aGVtZS5saW5lV2lkdGg7XG4gICAgICAgIGNvbnN0IGlzU2FtZUxpbmVXaWR0aCA9IHRoaXMudGhlbWUubGluZVdpZHRoID09PSBsaW5lV2lkdGg7XG4gICAgICAgIGNvbnN0IHRoaWNrbmVzcyA9IGlzU2FtZUxpbmVXaWR0aCA/IDAgOiBsaW5lV2lkdGggKiAwLjU7XG4gICAgICAgIHJldHVybiByZXNwb25kZXJzLm1hcCgobSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyBjb2xvcjogKF9iID0gKF9hID0gdGhlbWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2xvciwgKF9iICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG0uY29sb3IpKSwgbGluZVdpZHRoLCBzdHlsZTogW1xuICAgICAgICAgICAgICAgICAgICBwaWNrKHRoZW1lLCAnc3Ryb2tlU3R5bGUnLCAnc2hhZG93Qmx1cicsICdzaGFkb3dDb2xvcicsICdzaGFkb3dPZmZzZXRYJywgJ3NoYWRvd09mZnNldFknKSxcbiAgICAgICAgICAgICAgICBdLCByYWRpdXM6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXI6IE1hdGgubWF4KG0ucmFkaXVzLmlubmVyIC0gdGhpY2tuZXNzLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXI6IG0ucmFkaXVzLm91dGVyICsgdGhpY2tuZXNzLFxuICAgICAgICAgICAgICAgIH0gfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0T3BhY2l0eShhY3RpdmUsIHNlbGVjdGVkU3RhdGUpIHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3QsIGFyZWFPcGFjaXR5IH0gPSB0aGlzLnRoZW1lO1xuICAgICAgICBjb25zdCB7IGFyZWFPcGFjaXR5OiBzZWxlY3RlZEFyZWFPcGFjaXR5LCByZXN0U2VyaWVzOiB7IGFyZWFPcGFjaXR5OiByZXN0QXJlYU9wYWNpdHkgfSwgfSA9IHNlbGVjdDtcbiAgICAgICAgY29uc3Qgc2VsZWN0VGhlbWVPcGFjaXR5ID0gYWN0aXZlID8gc2VsZWN0ZWRBcmVhT3BhY2l0eSA6IHJlc3RBcmVhT3BhY2l0eTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkU3RhdGUgPyBzZWxlY3RUaGVtZU9wYWNpdHkgOiBhcmVhT3BhY2l0eTtcbiAgICB9XG4gICAgZ2V0SW5kZXhPZkdyb3VwKHNlcmllc1Jhd0RhdGEsIHBhcmVudE5hbWUsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHNlcmllc1Jhd0RhdGFcbiAgICAgICAgICAgIC5maWx0ZXIoKGRhdHVtKSA9PiBwYXJlbnROYW1lID09PSBkYXR1bS5wYXJlbnROYW1lKVxuICAgICAgICAgICAgLmZpbmRJbmRleCgoZGF0dW0pID0+IG5hbWUgPT09IGRhdHVtLm5hbWUpO1xuICAgIH1cbiAgICBnZXRTZXJpZXNDb2xvcihyYXdEYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgY29sb3IsIG5hbWUgfSA9IHJhd0RhdGE7XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuYWN0aXZlU2VyaWVzTWFwW25hbWVdO1xuICAgICAgICBjb25zdCBvcGFjaXR5ID0gdGhpcy5nZXRPcGFjaXR5KGFjdGl2ZSwgdGhpcy5oYXNBY3RpdmVTZXJpZXMoKSk7XG4gICAgICAgIHJldHVybiBnZXRSR0JBKGNvbG9yLCBvcGFjaXR5KTtcbiAgICB9XG4gICAgZ2V0QWxpYXNTZXJpZXNDb2xvcihyYXdEYXRhLCBzZXJpZXNSYXdEYXRhLCBwaWVJbmRleCkge1xuICAgICAgICBjb25zdCB7IGNvbG9yLCBuYW1lIH0gPSByYXdEYXRhO1xuICAgICAgICBjb25zdCB7IHNlbGVjdDogeyBjb2xvcjogc2VsZWN0ZWRDb2xvciB9LCB9ID0gdGhpcy50aGVtZTtcbiAgICAgICAgY29uc3QgeyByb290UGFyZW50TmFtZSwgcGFyZW50TmFtZSB9ID0gcmF3RGF0YTtcbiAgICAgICAgY29uc3QgaW5kZXhPZkdyb3VwID0gdGhpcy5nZXRJbmRleE9mR3JvdXAoc2VyaWVzUmF3RGF0YSwgcGFyZW50TmFtZSwgbmFtZSk7XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSB0aGlzLmdldEFsaWFzU2VyaWVzT3BhY2l0eShyb290UGFyZW50TmFtZSwgcGFyZW50TmFtZSwgcGllSW5kZXgsIGluZGV4T2ZHcm91cCwgbmFtZSk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuYWN0aXZlU2VyaWVzTWFwWyhyb290UGFyZW50TmFtZSAhPT0gbnVsbCAmJiByb290UGFyZW50TmFtZSAhPT0gdm9pZCAwID8gcm9vdFBhcmVudE5hbWUgOiBuYW1lKV07XG4gICAgICAgIGNvbnN0IHNlcmllc0NvbG9yID0gYWN0aXZlID8gKHNlbGVjdGVkQ29sb3IgIT09IG51bGwgJiYgc2VsZWN0ZWRDb2xvciAhPT0gdm9pZCAwID8gc2VsZWN0ZWRDb2xvciA6IGNvbG9yKSA6IGNvbG9yO1xuICAgICAgICByZXR1cm4gZ2V0UkdCQShzZXJpZXNDb2xvciwgb3BhY2l0eSk7XG4gICAgfVxuICAgIGdldEFsaWFzU2VyaWVzT3BhY2l0eShyb290UGFyZW50TmFtZSwgcGFyZW50TmFtZSwgcGllSW5kZXgsIGluZGV4T2ZHcm91cCwgbmFtZSkge1xuICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmFjdGl2ZVNlcmllc01hcFsocm9vdFBhcmVudE5hbWUgIT09IG51bGwgJiYgcm9vdFBhcmVudE5hbWUgIT09IHZvaWQgMCA/IHJvb3RQYXJlbnROYW1lIDogbmFtZSldO1xuICAgICAgICBjb25zdCBvcGFjaXR5ID0gdGhpcy5nZXRPcGFjaXR5KGFjdGl2ZSwgdGhpcy5oYXNBY3RpdmVTZXJpZXMoKSk7XG4gICAgICAgIHJldHVybiBwaWVJbmRleCAmJiBwYXJlbnROYW1lXG4gICAgICAgICAgICA/IGdldFBpZVNlcmllc09wYWNpdHlCeURlcHRoKG9wYWNpdHksIHBpZUluZGV4LCBpbmRleE9mR3JvdXApXG4gICAgICAgICAgICA6IG9wYWNpdHk7XG4gICAgfVxuICAgIGhhc0FjdGl2ZVNlcmllcygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5hY3RpdmVTZXJpZXNNYXApLnNvbWUoKGVsZW0pID0+ICFlbGVtKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuL2NvbXBvbmVudFwiO1xuaW1wb3J0IHsgY3Jpc3BQaXhlbCwgbWFrZVRpY2tQaXhlbFBvc2l0aW9ucywgZ2V0WFBvc2l0aW9uIH0gZnJvbSBcIi4uL2hlbHBlcnMvY2FsY3VsYXRvclwiO1xuaW1wb3J0IHsgcGljayB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5mdW5jdGlvbiBnZXRWYWxpZEluZGV4KGluZGV4LCBzdGFydEluZGV4ID0gMCkge1xuICAgIHJldHVybiB+fmluZGV4ID8gaW5kZXggLSBzdGFydEluZGV4IDogaW5kZXg7XG59XG5mdW5jdGlvbiB2YWxpZFhQb3NpdGlvbih7IGF4aXNEYXRhLCBvZmZzZXRTaXplLCB2YWx1ZSwgc3RhcnRJbmRleCA9IDAgfSkge1xuICAgIGNvbnN0IGRhdGFJbmRleCA9IGdldFZhbGlkSW5kZXgodmFsdWUsIHN0YXJ0SW5kZXgpO1xuICAgIGNvbnN0IHggPSBnZXRYUG9zaXRpb24oYXhpc0RhdGEsIG9mZnNldFNpemUsIHZhbHVlLCBkYXRhSW5kZXgpO1xuICAgIHJldHVybiB4ID4gMCA/IE1hdGgubWluKG9mZnNldFNpemUsIHgpIDogMDtcbn1cbmZ1bmN0aW9uIGdldFBsb3RBeGlzRGF0YSh2ZXJ0aWNhbCwgYXhlcykge1xuICAgIHJldHVybiB2ZXJ0aWNhbCA/IGF4ZXMueEF4aXMgOiBheGVzLnlBeGlzO1xufVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxvdCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubW9kZWxzID0geyBwbG90OiBbXSwgbGluZTogW10sIGJhbmQ6IFtdIH07XG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IDA7XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdwbG90JztcbiAgICB9XG4gICAgZ2V0UGxvdEF4aXNTaXplKHZlcnRpY2FsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvZmZzZXRTaXplOiB2ZXJ0aWNhbCA/IHRoaXMucmVjdC53aWR0aCA6IHRoaXMucmVjdC5oZWlnaHQsXG4gICAgICAgICAgICBhbmNob3JTaXplOiB2ZXJ0aWNhbCA/IHRoaXMucmVjdC5oZWlnaHQgOiB0aGlzLnJlY3Qud2lkdGgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlckxpbmVzKGF4ZXMsIGNhdGVnb3JpZXMsIGxpbmVzID0gW10pIHtcbiAgICAgICAgcmV0dXJuIGxpbmVzLm1hcCgoeyB2YWx1ZSwgY29sb3IgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvZmZzZXRTaXplIH0gPSB0aGlzLmdldFBsb3RBeGlzU2l6ZSh0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdmFsaWRYUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgIGF4aXNEYXRhOiBnZXRQbG90QXhpc0RhdGEodHJ1ZSwgYXhlcyksXG4gICAgICAgICAgICAgICAgb2Zmc2V0U2l6ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBjYXRlZ29yaWVzLFxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXg6IHRoaXMuc3RhcnRJbmRleCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZUxpbmVNb2RlbCh0cnVlLCBwb3NpdGlvbiwgeyBjb2xvciB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbmRlckJhbmRzKGF4ZXMsIGNhdGVnb3JpZXMsIGJhbmRzID0gW10pIHtcbiAgICAgICAgY29uc3QgeyBvZmZzZXRTaXplLCBhbmNob3JTaXplIH0gPSB0aGlzLmdldFBsb3RBeGlzU2l6ZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuIGJhbmRzLm1hcCgoeyByYW5nZSwgY29sb3IgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gcmFuZ2UubWFwKCh2YWx1ZSkgPT4gdmFsaWRYUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgIGF4aXNEYXRhOiBnZXRQbG90QXhpc0RhdGEodHJ1ZSwgYXhlcyksXG4gICAgICAgICAgICAgICAgb2Zmc2V0U2l6ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBjYXRlZ29yaWVzLFxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXg6IHRoaXMuc3RhcnRJbmRleCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3JlY3QnLFxuICAgICAgICAgICAgICAgIHg6IGNyaXNwUGl4ZWwoc3RhcnQpLFxuICAgICAgICAgICAgICAgIHk6IGNyaXNwUGl4ZWwoMCksXG4gICAgICAgICAgICAgICAgd2lkdGg6IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGhlaWdodDogYW5jaG9yU2l6ZSxcbiAgICAgICAgICAgICAgICBjb2xvcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kZXJQbG90TGluZU1vZGVscyhyZWxhdGl2ZVBvc2l0aW9ucywgdmVydGljYWwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgeyBzaXplLCBzdGFydFBvc2l0aW9uLCBheGVzIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCB7IGxpbmVDb2xvcjogY29sb3IsIGxpbmVXaWR0aCwgZGFzaFNlZ21lbnRzIH0gPSB0aGlzLnRoZW1lW3ZlcnRpY2FsID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJ107XG4gICAgICAgIGNvbnN0IHRpY2tJbnRlcnZhbCA9ICgoX2MgPSAodmVydGljYWwgPyAoX2EgPSBheGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EueEF4aXMgOiAoX2IgPSBheGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IueUF4aXMpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudGlja0ludGVydmFsKSB8fCAxO1xuICAgICAgICByZXR1cm4gcmVsYXRpdmVQb3NpdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoKF8sIGlkeCkgPT4gIShpZHggJSB0aWNrSW50ZXJ2YWwpKVxuICAgICAgICAgICAgLm1hcCgocG9zaXRpb24pID0+IHRoaXMubWFrZUxpbmVNb2RlbCh2ZXJ0aWNhbCwgcG9zaXRpb24sIHsgY29sb3IsIGxpbmVXaWR0aCwgZGFzaFNlZ21lbnRzIH0sIChzaXplICE9PSBudWxsICYmIHNpemUgIT09IHZvaWQgMCA/IHNpemUgOiB0aGlzLnJlY3Qud2lkdGgpLCAoc3RhcnRQb3NpdGlvbiAhPT0gbnVsbCAmJiBzdGFydFBvc2l0aW9uICE9PSB2b2lkIDAgPyBzdGFydFBvc2l0aW9uIDogMCkpKTtcbiAgICB9XG4gICAgcmVuZGVyUGxvdHNGb3JDZW50ZXJZQXhpcyhheGVzKSB7XG4gICAgICAgIGNvbnN0IHsgeEF4aXNIYWxmU2l6ZSwgc2Vjb25kU3RhcnRYLCB5QXhpc0hlaWdodCB9ID0gYXhlcy5jZW50ZXJZQXhpcztcbiAgICAgICAgLy8gdmVydGljYWxcbiAgICAgICAgY29uc3QgeEF4aXNUaWNrQ291bnQgPSBheGVzLnhBeGlzLnRpY2tDb3VudDtcbiAgICAgICAgY29uc3QgdmVydGljYWxMaW5lcyA9IFtcbiAgICAgICAgICAgIC4uLnRoaXMucmVuZGVyUGxvdExpbmVNb2RlbHMobWFrZVRpY2tQaXhlbFBvc2l0aW9ucyh4QXhpc0hhbGZTaXplLCB4QXhpc1RpY2tDb3VudCksIHRydWUpLFxuICAgICAgICAgICAgLi4udGhpcy5yZW5kZXJQbG90TGluZU1vZGVscyhtYWtlVGlja1BpeGVsUG9zaXRpb25zKHhBeGlzSGFsZlNpemUsIHhBeGlzVGlja0NvdW50LCBzZWNvbmRTdGFydFgpLCB0cnVlKSxcbiAgICAgICAgXTtcbiAgICAgICAgLy8gaG9yaXpvbnRhbFxuICAgICAgICBjb25zdCB5QXhpc1RpY2tDb3VudCA9IGF4ZXMueUF4aXMudGlja0NvdW50O1xuICAgICAgICBjb25zdCB5QXhpc1RpY2tQaXhlbFBvc2l0aW9ucyA9IG1ha2VUaWNrUGl4ZWxQb3NpdGlvbnMoeUF4aXNIZWlnaHQsIHlBeGlzVGlja0NvdW50KTtcbiAgICAgICAgY29uc3QgaG9yaXpvbnRhbExpbmVzID0gW1xuICAgICAgICAgICAgLi4udGhpcy5yZW5kZXJQbG90TGluZU1vZGVscyh5QXhpc1RpY2tQaXhlbFBvc2l0aW9ucywgZmFsc2UsIHsgc2l6ZTogeEF4aXNIYWxmU2l6ZSB9KSxcbiAgICAgICAgICAgIC4uLnRoaXMucmVuZGVyUGxvdExpbmVNb2RlbHMoeUF4aXNUaWNrUGl4ZWxQb3NpdGlvbnMsIGZhbHNlLCB7XG4gICAgICAgICAgICAgICAgc2l6ZTogeEF4aXNIYWxmU2l6ZSxcbiAgICAgICAgICAgICAgICBzdGFydFBvc2l0aW9uOiBzZWNvbmRTdGFydFgsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFsuLi52ZXJ0aWNhbExpbmVzLCAuLi5ob3Jpem9udGFsTGluZXNdO1xuICAgIH1cbiAgICByZW5kZXJQbG90cyhheGVzLCBzY2FsZSkge1xuICAgICAgICBjb25zdCB2ZXJ0aWNhbCA9IHRydWU7XG4gICAgICAgIHJldHVybiBheGVzLmNlbnRlcllBeGlzXG4gICAgICAgICAgICA/IHRoaXMucmVuZGVyUGxvdHNGb3JDZW50ZXJZQXhpcyhheGVzKVxuICAgICAgICAgICAgOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5yZW5kZXJQbG90TGluZU1vZGVscyh0aGlzLmdldEhvcml6b250YWxUaWNrUGl4ZWxQb3NpdGlvbnMoYXhlcyksICF2ZXJ0aWNhbCwge1xuICAgICAgICAgICAgICAgICAgICBheGVzLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMucmVuZGVyUGxvdExpbmVNb2RlbHModGhpcy5nZXRWZXJ0aWNhbFRpY2tQaXhlbFBvc2l0aW9ucyhheGVzLCBzY2FsZSksIHZlcnRpY2FsLCB7XG4gICAgICAgICAgICAgICAgICAgIGF4ZXMsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdO1xuICAgIH1cbiAgICBnZXRWZXJ0aWNhbFRpY2tQaXhlbFBvc2l0aW9ucyhheGVzLCBzY2FsZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0U2l6ZSB9ID0gdGhpcy5nZXRQbG90QXhpc1NpemUodHJ1ZSk7XG4gICAgICAgIGNvbnN0IGF4aXNEYXRhID0gZ2V0UGxvdEF4aXNEYXRhKHRydWUsIGF4ZXMpO1xuICAgICAgICBpZiAoKF9hID0gYXhpc0RhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYWJlbFJhbmdlKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplUmF0aW8gPSAoX2QgPSAoX2MgPSAoX2IgPSBzY2FsZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnhBeGlzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc2l6ZVJhdGlvLCAoX2QgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMSkpO1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25SYXRpbyA9IChfZyA9IChfZiA9IChfZSA9IHNjYWxlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UueEF4aXMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5wb3NpdGlvblJhdGlvLCAoX2cgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogMCkpO1xuICAgICAgICAgICAgY29uc3QgYXhpc1NpemVBcHBsaWVkUmF0aW8gPSBvZmZzZXRTaXplICogc2l6ZVJhdGlvO1xuICAgICAgICAgICAgY29uc3QgYWRkaXRpb25hbCA9IG9mZnNldFNpemUgKiBwb3NpdGlvblJhdGlvO1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VUaWNrUGl4ZWxQb3NpdGlvbnMoYXhpc1NpemVBcHBsaWVkUmF0aW8sIGF4aXNEYXRhLnRpY2tDb3VudCwgYWRkaXRpb25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ha2VUaWNrUGl4ZWxQb3NpdGlvbnMob2Zmc2V0U2l6ZSwgYXhpc0RhdGEudGlja0NvdW50KTtcbiAgICB9XG4gICAgZ2V0SG9yaXpvbnRhbFRpY2tQaXhlbFBvc2l0aW9ucyhheGVzKSB7XG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0U2l6ZSB9ID0gdGhpcy5nZXRQbG90QXhpc1NpemUoZmFsc2UpO1xuICAgICAgICBjb25zdCBheGlzRGF0YSA9IGdldFBsb3RBeGlzRGF0YShmYWxzZSwgYXhlcyk7XG4gICAgICAgIHJldHVybiBtYWtlVGlja1BpeGVsUG9zaXRpb25zKG9mZnNldFNpemUsIGF4aXNEYXRhLnRpY2tDb3VudCk7XG4gICAgfVxuICAgIHJlbmRlclBsb3RCYWNrZ3JvdW5kUmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdyZWN0JywgeDogMCwgeTogMCB9LCBwaWNrKHRoaXMucmVjdCwgJ3dpZHRoJywgJ2hlaWdodCcpKSwgeyBjb2xvcjogdGhpcy50aGVtZS5iYWNrZ3JvdW5kQ29sb3IgfSk7XG4gICAgfVxuICAgIHJlbmRlcihzdGF0ZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgeyBsYXlvdXQsIGF4ZXMsIHBsb3QsIHpvb21SYW5nZSwgdGhlbWUsIHNjYWxlIH0gPSBzdGF0ZTtcbiAgICAgICAgaWYgKCFwbG90KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWN0ID0gbGF5b3V0LnBsb3Q7XG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IChfYiA9IChfYSA9IHpvb21SYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdLCAoX2IgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkpO1xuICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWUucGxvdDtcbiAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IChfYyA9IHN0YXRlLmNhdGVnb3JpZXMsIChfYyAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXSkpO1xuICAgICAgICBjb25zdCB7IGxpbmVzLCBiYW5kcywgdmlzaWJsZSB9ID0gcGxvdDtcbiAgICAgICAgdGhpcy5tb2RlbHMubGluZSA9IHRoaXMucmVuZGVyTGluZXMoYXhlcywgY2F0ZWdvcmllcywgbGluZXMpO1xuICAgICAgICB0aGlzLm1vZGVscy5iYW5kID0gdGhpcy5yZW5kZXJCYW5kcyhheGVzLCBjYXRlZ29yaWVzLCBiYW5kcyk7XG4gICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVscy5wbG90ID0gW3RoaXMucmVuZGVyUGxvdEJhY2tncm91bmRSZWN0KCksIC4uLnRoaXMucmVuZGVyUGxvdHMoYXhlcywgc2NhbGUpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYWtlTGluZU1vZGVsKHZlcnRpY2FsLCBwb3NpdGlvbiwgeyBjb2xvciwgZGFzaFNlZ21lbnRzID0gW10sIGxpbmVXaWR0aCA9IDEsIH0sIHNpemVXaWR0aCwgeFBvcyA9IDApIHtcbiAgICAgICAgY29uc3QgeCA9IHZlcnRpY2FsID8gY3Jpc3BQaXhlbChwb3NpdGlvbikgOiBjcmlzcFBpeGVsKHhQb3MpO1xuICAgICAgICBjb25zdCB5ID0gdmVydGljYWwgPyBjcmlzcFBpeGVsKDApIDogY3Jpc3BQaXhlbChwb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdmVydGljYWwgPyAwIDogKHNpemVXaWR0aCAhPT0gbnVsbCAmJiBzaXplV2lkdGggIT09IHZvaWQgMCA/IHNpemVXaWR0aCA6IHRoaXMucmVjdC53aWR0aCk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHZlcnRpY2FsID8gdGhpcy5yZWN0LmhlaWdodCA6IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIHgyOiB4ICsgd2lkdGgsXG4gICAgICAgICAgICB5MjogeSArIGhlaWdodCxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBjb2xvcixcbiAgICAgICAgICAgIGxpbmVXaWR0aCxcbiAgICAgICAgICAgIGRhc2hTZWdtZW50cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYmVmb3JlRHJhdyhwYWludGVyKSB7XG4gICAgICAgIHBhaW50ZXIuY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwgMCwgMCwgMC4wNSknO1xuICAgICAgICBwYWludGVyLmN0eC5saW5lV2lkdGggPSAxO1xuICAgIH1cbn1cbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIi4vY29tcG9uZW50XCI7XG5pbXBvcnQgeyBnZXRBY3RpdmVTZXJpZXNNYXAgfSBmcm9tIFwiLi4vaGVscGVycy9sZWdlbmRcIjtcbmltcG9ydCB7IGdldFJhZGlhbFBvc2l0aW9uLCBjYWxjdWxhdGVEZWdyZWVUb1JhZGlhbiwgREVHUkVFXzM2MCB9IGZyb20gXCIuLi9oZWxwZXJzL3NlY3RvclwiO1xuaW1wb3J0IHsgZ2V0UkdCQSB9IGZyb20gXCIuLi9oZWxwZXJzL2NvbG9yXCI7XG5pbXBvcnQgeyBnZXRMaW1pdE9uQXhpcyB9IGZyb20gXCIuLi9oZWxwZXJzL2F4ZXNcIjtcbmltcG9ydCB7IHJhZGFyRGVmYXVsdCB9IGZyb20gXCIuLi9oZWxwZXJzL3RoZW1lXCI7XG5pbXBvcnQgeyBpc051bWJlciwgaXNOdWxsIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmltcG9ydCB7IG1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZVwiO1xuaW1wb3J0IHsgbWFrZUxhYmVsc0Zyb21MaW1pdCB9IGZyb20gXCIuLi9oZWxwZXJzL2NhbGN1bGF0b3JcIjtcbmNvbnN0IE5PTkVfQVJFQV9PUEFDSVRZID0gMDtcbmNvbnN0IHNlcmllc09wYWNpdHkgPSB7XG4gICAgSU5BQ1RJVkU6IDAuMixcbiAgICBBQ1RJVkU6IDEsXG59O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkYXJTZXJpZXMgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1vZGVscyA9IHsgYXJlYTogW10sIGxpbmU6IFtdLCBkb3Q6IFtdIH07XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IFtdO1xuICAgICAgICB0aGlzLm9uTW91c2VvdXRDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nlcmllc1BvaW50SG92ZXJlZCcsIHsgbW9kZWxzOiBbXSwgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJIb3ZlcmVkU2VyaWVzJywge1xuICAgICAgICAgICAgICAgIG1vZGVsczogW10sXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VsZWN0U2VyaWVzID0gKHsgaW5kZXgsIHNlcmllc0luZGV4LCBzdGF0ZSB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzTnVtYmVyKGluZGV4KSB8fCAhaXNOdW1iZXIoc2VyaWVzSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBuYW1lIH0gPSBzdGF0ZS5zZXJpZXMucmFkYXIuZGF0YVtzZXJpZXNJbmRleF07XG4gICAgICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMucmVzcG9uZGVycy5maWx0ZXIoKHsgbmFtZTogZGF0YU5hbWUgfSkgPT4gZGF0YU5hbWUgPT09IG5hbWUpW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZS5TRUxFQ1RfU0VSSUVTX0FQSV9JTkRFWF9FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlclNlbGVjdGVkU2VyaWVzJywge1xuICAgICAgICAgICAgICAgIG1vZGVsczogdGhpcy5nZXRSZXNwb25kZXJzV2l0aFRoZW1lKFttb2RlbF0sICdzZWxlY3QnKSxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zaG93VG9vbHRpcCA9ICh7IGluZGV4LCBzZXJpZXNJbmRleCwgc3RhdGUgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc051bWJlcihpbmRleCkgfHwgIWlzTnVtYmVyKHNlcmllc0luZGV4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gc3RhdGUuc2VyaWVzLnJhZGFyLmRhdGFbc2VyaWVzSW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgbW9kZWxzID0gW3RoaXMucmVzcG9uZGVycy5maWx0ZXIoKHsgbmFtZTogZGF0YU5hbWUgfSkgPT4gZGF0YU5hbWUgPT09IG5hbWUpW2luZGV4XV07XG4gICAgICAgICAgICBpZiAoIW1vZGVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlckhvdmVyZWRTZXJpZXMnLCB7XG4gICAgICAgICAgICAgICAgbW9kZWxzOiB0aGlzLmdldFJlc3BvbmRlcnNXaXRoVGhlbWUobW9kZWxzLCAnaG92ZXInKSxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IG1vZGVscztcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnc2VyaWVzUG9pbnRIb3ZlcmVkJywgeyBtb2RlbHM6IHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycywgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCduZWVkRHJhdycpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnc2VyaWVzJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ3JhZGFyJztcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignc2VsZWN0U2VyaWVzJywgdGhpcy5zZWxlY3RTZXJpZXMpO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLm9uKCdzaG93VG9vbHRpcCcsIHRoaXMuc2hvd1Rvb2x0aXApO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLm9uKCdoaWRlVG9vbHRpcCcsIHRoaXMub25Nb3VzZW91dENvbXBvbmVudCk7XG4gICAgfVxuICAgIHJlbmRlcihzdGF0ZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICBjb25zdCB7IGxheW91dCwgcmFkaWFsQXhlcywgc2VyaWVzLCBsZWdlbmQsIG9wdGlvbnMsIHRoZW1lLCBzY2FsZSB9ID0gc3RhdGU7XG4gICAgICAgIGlmICghc2VyaWVzLnJhZGFyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZS5ub0RhdGFFcnJvcih0aGlzLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWUuc2VyaWVzLnJhZGFyO1xuICAgICAgICB0aGlzLnJlY3QgPSBsYXlvdXQucGxvdDtcbiAgICAgICAgdGhpcy5hY3RpdmVTZXJpZXNNYXAgPSBnZXRBY3RpdmVTZXJpZXNNYXAobGVnZW5kKTtcbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlID0gdGhpcy5nZXRTZWxlY3RhYmxlT3B0aW9uKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gc3RhdGUuY2F0ZWdvcmllcztcbiAgICAgICAgY29uc3QgeyBheGlzU2l6ZSwgY2VudGVyWCwgY2VudGVyWSB9ID0gcmFkaWFsQXhlcy52ZXJ0aWNhbEF4aXM7XG4gICAgICAgIGNvbnN0IHsgbGltaXQsIHN0ZXBTaXplIH0gPSBzY2FsZS52ZXJ0aWNhbEF4aXM7XG4gICAgICAgIGNvbnN0IGxhYmVscyA9IG1ha2VMYWJlbHNGcm9tTGltaXQobGltaXQsIHN0ZXBTaXplKTtcbiAgICAgICAgY29uc3QgeyBtaW4sIG1heCB9ID0gZ2V0TGltaXRPbkF4aXMobGFiZWxzKTtcbiAgICAgICAgY29uc3QgcmVuZGVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXMsXG4gICAgICAgICAgICBkZWdyZWU6IERFR1JFRV8zNjAgLyBjYXRlZ29yaWVzLmxlbmd0aCxcbiAgICAgICAgICAgIGNlbnRlclgsXG4gICAgICAgICAgICBjZW50ZXJZLFxuICAgICAgICAgICAgc2hvd0FyZWE6IChfYyA9IChfYiA9IChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXJpZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zaG93QXJlYSwgKF9jICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZhbHNlKSksXG4gICAgICAgICAgICByYXRpbzogYXhpc1NpemUgLyAobWF4IC0gbWluKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmFkYXJEYXRhID0gKF9kID0gc2VyaWVzLnJhZGFyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZGF0YTtcbiAgICAgICAgY29uc3QgcmFkYXJQb2ludHNEYXRhID0gdGhpcy5tYWtlUmFkYXJQb2ludHNEYXRhKHJhZGFyRGF0YSwgcmVuZGVyT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNpcmNsZU1vZGVsID0gdGhpcy5yZW5kZXJEb3RNb2RlbHMocmFkYXJQb2ludHNEYXRhKTtcbiAgICAgICAgdGhpcy5tb2RlbHMuYXJlYSA9ICgoX2YgPSAoX2UgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Uuc2VyaWVzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc2hvd0FyZWEpID8gdGhpcy5yZW5kZXJBcmVhTW9kZWxzKHJhZGFyUG9pbnRzRGF0YSkgOiBbXTtcbiAgICAgICAgdGhpcy5tb2RlbHMubGluZSA9IHRoaXMucmVuZGVyTGluZU1vZGVscyhyYWRhclBvaW50c0RhdGEpO1xuICAgICAgICB0aGlzLm1vZGVscy5kb3QgPSAoKF9oID0gKF9nID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnNlcmllcykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLnNob3dEb3QpID8gY2lyY2xlTW9kZWwgOiBbXTtcbiAgICAgICAgaWYgKCF0aGlzLmRyYXdNb2RlbHMpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd01vZGVscyA9IHtcbiAgICAgICAgICAgICAgICBhcmVhOiB0aGlzLmluaXREcmF3TW9kZWxzKCdhcmVhJywgY2VudGVyWCwgY2VudGVyWSksXG4gICAgICAgICAgICAgICAgbGluZTogdGhpcy5pbml0RHJhd01vZGVscygnbGluZScsIGNlbnRlclgsIGNlbnRlclkpLFxuICAgICAgICAgICAgICAgIGRvdDogdGhpcy5tb2RlbHMuZG90Lm1hcCgobSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbSksIHsgeDogY2VudGVyWCwgeTogY2VudGVyWSB9KSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b29sdGlwRGF0YUFyciA9IHRoaXMubWFrZVRvb2x0aXBNb2RlbChjaXJjbGVNb2RlbCwgY2F0ZWdvcmllcyk7XG4gICAgICAgIHRoaXMucmVzcG9uZGVycyA9IGNpcmNsZU1vZGVsLm1hcCgobSwgaW5kZXgpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG0pLCB7IGRhdGE6IHRvb2x0aXBEYXRhQXJyW2luZGV4XSwgY29sb3I6IGdldFJHQkEobS5jb2xvciwgMSkgfSkpKTtcbiAgICB9XG4gICAgaW5pdERyYXdNb2RlbHMobW9kZWxOYW1lLCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsc1ttb2RlbE5hbWVdLm1hcCgobSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG0pLCB7IGRpc3RhbmNlczogKF9hID0gbS5kaXN0YW5jZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKCkgPT4gMCksIHBvaW50czogbS5wb2ludHMubWFwKCgpID0+ICh7IHg6IGNlbnRlclgsIHk6IGNlbnRlclkgfSkpIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1ha2VUb29sdGlwTW9kZWwoY2lyY2xlTW9kZWwsIGNhdGVnb3JpZXMpIHtcbiAgICAgICAgcmV0dXJuIGNpcmNsZU1vZGVsLm1hcCgoeyBuYW1lLCBjb2xvciwgdmFsdWUsIGluZGV4IH0pID0+ICh7XG4gICAgICAgICAgICBsYWJlbDogbmFtZSxcbiAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXRlZ29yeTogY2F0ZWdvcmllc1tpbmRleF0sXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZ2V0UmVzcG9uZGVyc1dpdGhUaGVtZShyZXNwb25kZXJzLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IHsgcmFkaXVzLCBib3JkZXJXaWR0aCwgYm9yZGVyQ29sb3IsIGNvbG9yIH0gPSB0aGlzLnRoZW1lW3R5cGVdLmRvdDtcbiAgICAgICAgcmV0dXJuIHJlc3BvbmRlcnMubWFwKChyZXNwb25kZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsQ29sb3IgPSAoY29sb3IgIT09IG51bGwgJiYgY29sb3IgIT09IHZvaWQgMCA/IGNvbG9yIDogcmVzcG9uZGVyLmNvbG9yKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3BvbmRlciksIHsgcmFkaXVzLCBjb2xvcjogbW9kZWxDb2xvciwgYm9yZGVyQ29sb3I6IChib3JkZXJDb2xvciAhPT0gbnVsbCAmJiBib3JkZXJDb2xvciAhPT0gdm9pZCAwID8gYm9yZGVyQ29sb3IgOiBnZXRSR0JBKG1vZGVsQ29sb3IsIDAuNSkpLCBib3JkZXJXaWR0aCB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uQ2xpY2soeyByZXNwb25kZXJzIH0pIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJTZWxlY3RlZFNlcmllcycsIHtcbiAgICAgICAgICAgICAgICBtb2RlbHM6IHRoaXMuZ2V0UmVzcG9uZGVyc1dpdGhUaGVtZShyZXNwb25kZXJzLCAnc2VsZWN0JyksXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25Nb3VzZW1vdmUoeyByZXNwb25kZXJzIH0pIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJIb3ZlcmVkU2VyaWVzJywge1xuICAgICAgICAgICAgbW9kZWxzOiB0aGlzLmdldFJlc3BvbmRlcnNXaXRoVGhlbWUocmVzcG9uZGVycywgJ2hvdmVyJyksXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMgPSByZXNwb25kZXJzO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nlcmllc1BvaW50SG92ZXJlZCcsIHsgbW9kZWxzOiB0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMsIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCduZWVkRHJhdycpO1xuICAgIH1cbiAgICBtYWtlUmFkYXJQb2ludHNEYXRhKHNlcmllc0RhdGEsIHJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBjZW50ZXJYLCBjZW50ZXJZLCBkZWdyZWUsIHJhdGlvLCBzaG93QXJlYSB9ID0gcmVuZGVyT3B0aW9ucztcbiAgICAgICAgcmV0dXJuIHNlcmllc0RhdGEubWFwKCh7IGRhdGEsIGNvbG9yOiBzZXJpZXNDb2xvciwgbmFtZSB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByYWRhclBvaW50cyA9IGRhdGEucmVkdWNlKChhY2MsIHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc051bGwodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZXM6IFsuLi5hY2MuZGlzdGFuY2VzLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVQb2ludHM6IFsuLi5hY2MubGluZVBvaW50cywgbnVsbF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmVhUG9pbnRzOiBbLi4uYWNjLmFyZWFQb2ludHMsIHsgeDogY2VudGVyWCwgeTogY2VudGVyWSB9XSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB2YWx1ZSAqIHJhdGlvO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gZ2V0UmFkaWFsUG9zaXRpb24oY2VudGVyWCwgY2VudGVyWSwgZGlzdGFuY2UsIGNhbGN1bGF0ZURlZ3JlZVRvUmFkaWFuKGRlZ3JlZSAqIGluZGV4KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VzOiBbLi4uYWNjLmRpc3RhbmNlcywgZGlzdGFuY2VdLFxuICAgICAgICAgICAgICAgICAgICBsaW5lUG9pbnRzOiBbLi4uYWNjLmxpbmVQb2ludHMsIHBvaW50XSxcbiAgICAgICAgICAgICAgICAgICAgYXJlYVBvaW50czogWy4uLmFjYy5hcmVhUG9pbnRzLCBwb2ludF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sIHsgbGluZVBvaW50czogW10sIGRpc3RhbmNlczogW10sIGFyZWFQb2ludHM6IFtdIH0pO1xuICAgICAgICAgICAgaWYgKCFpc051bGwoZGF0YVswXSkgJiYgIWlzTnVsbChkYXRhW2RhdGEubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgcmFkYXJQb2ludHMubGluZVBvaW50cy5wdXNoKHJhZGFyUG9pbnRzLmxpbmVQb2ludHNbMF0pO1xuICAgICAgICAgICAgICAgIHJhZGFyUG9pbnRzLmFyZWFQb2ludHMucHVzaChyYWRhclBvaW50cy5hcmVhUG9pbnRzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBuYW1lLFxuICAgICAgICAgICAgICAgIHNlcmllc0NvbG9yLFxuICAgICAgICAgICAgICAgIGRhdGEgfSwgcmFkYXJQb2ludHMpLCB0aGlzLmdldFNlcmllc0NvbG9yKHNob3dBcmVhLCBzZXJpZXNDb2xvciwgbmFtZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVuZGVyQXJlYU1vZGVscyhyYWRhclBvaW50c0RhdGEpIHtcbiAgICAgICAgcmV0dXJuIHJhZGFyUG9pbnRzRGF0YS5tYXAoKHsgZGlzdGFuY2VzLCBhcmVhUG9pbnRzLCBuYW1lLCBmaWxsQ29sb3IsIHNlcmllc0NvbG9yIH0pID0+ICh7XG4gICAgICAgICAgICB0eXBlOiAnYXJlYVBvaW50cycsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGlzdGFuY2VzLFxuICAgICAgICAgICAgcG9pbnRzOiBhcmVhUG9pbnRzLFxuICAgICAgICAgICAgZmlsbENvbG9yLFxuICAgICAgICAgICAgY29sb3I6IGdldFJHQkEoc2VyaWVzQ29sb3IsIDApLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAwLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJlbmRlckxpbmVNb2RlbHMocmFkYXJQb2ludHNEYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgbGluZVdpZHRoLCBkYXNoU2VnbWVudHMgfSA9IHRoaXMudGhlbWU7XG4gICAgICAgIHJldHVybiByYWRhclBvaW50c0RhdGEubWFwKCh7IGRpc3RhbmNlcywgbGluZVBvaW50cywgbmFtZSwgbGluZUNvbG9yIH0pID0+ICh7XG4gICAgICAgICAgICB0eXBlOiAnbGluZVBvaW50cycsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IChsaW5lV2lkdGggIT09IG51bGwgJiYgbGluZVdpZHRoICE9PSB2b2lkIDAgPyBsaW5lV2lkdGggOiByYWRhckRlZmF1bHQuTElORV9XSURUSCksXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGlzdGFuY2VzLFxuICAgICAgICAgICAgcG9pbnRzOiBsaW5lUG9pbnRzLFxuICAgICAgICAgICAgY29sb3I6IGxpbmVDb2xvcixcbiAgICAgICAgICAgIGRhc2hTZWdtZW50cyxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZW5kZXJEb3RNb2RlbHMocmFkYXJQb2ludHNEYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgcmFkaXVzLCBjb2xvcjogZG90Q29sb3IgfSA9IHRoaXMudGhlbWUuZG90O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgcmFkYXJQb2ludHNEYXRhLmZvckVhY2goKHsgbGluZVBvaW50cywgbGluZUNvbG9yLCBuYW1lLCBkYXRhIH0sIHNlcmllc0luZGV4KSA9PiBsaW5lUG9pbnRzLnNsaWNlKDAsIGxpbmVQb2ludHMubGVuZ3RoIC0gMSkuZm9yRWFjaCgocG9pbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIWlzTnVsbChwb2ludCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB0eXBlOiAnY2lyY2xlJyB9LCBwb2ludCksIHsgcmFkaXVzLCBjb2xvcjogKGRvdENvbG9yICE9PSBudWxsICYmIGRvdENvbG9yICE9PSB2b2lkIDAgPyBkb3RDb2xvciA6IGxpbmVDb2xvciksIHN0eWxlOiBbeyBzdHJva2VTdHlsZTogJ3JnYmEoMCwgMCwgMCwgMCknIH1dLCBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsIHZhbHVlOiAoX2EgPSBkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbaW5kZXhdIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXRTZXJpZXNDb2xvcihzaG93QXJlYSwgc2VyaWVzQ29sb3IsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5hY3RpdmVTZXJpZXNNYXBbbmFtZV07XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0LCBhcmVhT3BhY2l0eSB9ID0gdGhpcy50aGVtZTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBPYmplY3QudmFsdWVzKHRoaXMuYWN0aXZlU2VyaWVzTWFwKS5zb21lKChlbGVtKSA9PiAhZWxlbSk7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gZ2V0UkdCQShzZXJpZXNDb2xvciwgYWN0aXZlID8gc2VyaWVzT3BhY2l0eS5BQ1RJVkUgOiBzZXJpZXNPcGFjaXR5LklOQUNUSVZFKTtcbiAgICAgICAgbGV0IGZpbGxPcGFjaXR5ID0gTk9ORV9BUkVBX09QQUNJVFk7XG4gICAgICAgIGlmIChzaG93QXJlYSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRBcmVhT3BhY2l0eSA9IGFjdGl2ZSA/IHNlbGVjdC5hcmVhT3BhY2l0eSA6IHNlbGVjdC5yZXN0U2VyaWVzLmFyZWFPcGFjaXR5O1xuICAgICAgICAgICAgZmlsbE9wYWNpdHkgPSBzZWxlY3RlZCA/IHNlbGVjdGVkQXJlYU9wYWNpdHkgOiBhcmVhT3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsaW5lQ29sb3I6IGNvbG9yLCBmaWxsQ29sb3I6IGdldFJHQkEoY29sb3IsIGZpbGxPcGFjaXR5KSB9O1xuICAgIH1cbn1cbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIi4vY29tcG9uZW50XCI7XG5pbXBvcnQgeyBjYWxjdWxhdGVEZWdyZWVUb1JhZGlhbiwgZ2V0UmFkaWFsUG9zaXRpb24sIERFR1JFRV8zNjAsIERFR1JFRV9ORUdBVElWRV85MCwgY2FsY3VsYXRlVmFsaWRBbmdsZSwgfSBmcm9tIFwiLi4vaGVscGVycy9zZWN0b3JcIjtcbmltcG9ydCB7IGdldFRpdGxlRm9udFN0cmluZyB9IGZyb20gXCIuLi9oZWxwZXJzL3N0eWxlXCI7XG5pbXBvcnQgeyBpbmNsdWRlcyB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBpc05vRGF0YSB9IGZyb20gXCIuLi9oZWxwZXJzL3ZhbGlkYXRpb25cIjtcbmNvbnN0IFJFQ1RfU0laRSA9IDQ7XG5jb25zdCBIQUxGX1RJQ0sgPSA1O1xuZnVuY3Rpb24gaGFzTmVlZFJlbmRlcihpbmRleCwgcG9pbnRPbkNvbHVtbiwgbGFiZWxJbnRlcnZhbCwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzKSB7XG4gICAgcmV0dXJuICFwb2ludE9uQ29sdW1uICYmIGluZGV4ID09PSAwXG4gICAgICAgID8gZmFsc2VcbiAgICAgICAgOiAhKGluZGV4ICUgbGFiZWxJbnRlcnZhbCkgJiZcbiAgICAgICAgICAgICgocG9pbnRPbkNvbHVtbiAmJiBpbm5lclJhZGl1cyA8PSBvdXRlclJhZGl1cykgfHxcbiAgICAgICAgICAgICAgICAoIXBvaW50T25Db2x1bW4gJiYgaW5uZXJSYWRpdXMgPCBvdXRlclJhZGl1cykpO1xufVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkaWFsQXhpcyBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubW9kZWxzID0ge1xuICAgICAgICAgICAgdmVydGljYWxBeGlzTGFiZWw6IFtdLFxuICAgICAgICAgICAgY2lyY3VsYXJBeGlzTGFiZWw6IFtdLFxuICAgICAgICAgICAgZG90OiBbXSxcbiAgICAgICAgICAgIGxpbmU6IFtdLFxuICAgICAgICAgICAgdGljazogW10sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGluaXRpYWxpemUoaW5pdFBhcmFtKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMudHlwZSA9ICdheGlzJztcbiAgICAgICAgdGhpcy5uYW1lID0gKF9iID0gKF9hID0gaW5pdFBhcmFtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSwgKF9iICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdyYWRpYWwnKSk7XG4gICAgfVxuICAgIHJlbmRlcih7IGxheW91dCwgcmFkaWFsQXhlcywgdGhlbWUsIHNlcmllcyB9KSB7XG4gICAgICAgIHRoaXMuaXNTaG93ID0gIWlzTm9EYXRhKHNlcmllcyk7XG4gICAgICAgIHRoaXMucmVjdCA9IGxheW91dC5wbG90O1xuICAgICAgICBpZiAoIXJhZGlhbEF4ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNpcmN1bGFyQXhpc1RoZW1lID0gdGhlbWUuY2lyY3VsYXJBeGlzO1xuICAgICAgICBjb25zdCB7IGNpcmN1bGFyQXhpcywgdmVydGljYWxBeGlzIH0gPSByYWRpYWxBeGVzO1xuICAgICAgICBpZiAodmVydGljYWxBeGlzKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2FsQXhpc1RoZW1lID0gdGhlbWUudmVydGljYWxBeGlzO1xuICAgICAgICAgICAgdGhpcy5tb2RlbHMudmVydGljYWxBeGlzTGFiZWwgPSB0aGlzLnJlbmRlclZlcnRpY2FsQXhpc0xhYmVsKHZlcnRpY2FsQXhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbHMuY2lyY3VsYXJBeGlzTGFiZWwgPSB0aGlzLnJlbmRlckNpcmN1bGFyQXhpc0xhYmVsKGNpcmN1bGFyQXhpcyk7XG4gICAgICAgIGlmICh0aGlzLm5hbWUgPT09ICdnYXVnZScpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWxzLmxpbmUgPSB0aGlzLnJlbmRlckFyY0xpbmUoY2lyY3VsYXJBeGlzKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWxzLnRpY2sgPSB0aGlzLnJlbmRlclRpY2soY2lyY3VsYXJBeGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWxzLmRvdCA9IHRoaXMucmVuZGVyRG90TW9kZWwoY2lyY3VsYXJBeGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRCdWJibGVTaGFkb3dTdHlsZSgpIHtcbiAgICAgICAgY29uc3QgeyB2aXNpYmxlLCBzaGFkb3dDb2xvciwgc2hhZG93T2Zmc2V0WCwgc2hhZG93T2Zmc2V0WSwgc2hhZG93Qmx1ciwgfSA9IHRoaXMudmVydGljYWxBeGlzVGhlbWUubGFiZWwudGV4dEJ1YmJsZTtcbiAgICAgICAgcmV0dXJuIHZpc2libGUgJiYgc2hhZG93Q29sb3JcbiAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd09mZnNldFgsXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd09mZnNldFksXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd0JsdXIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgcmVuZGVyVmVydGljYWxBeGlzTGFiZWwodmVydGljYWxBeGlzKSB7XG4gICAgICAgIGNvbnN0IHsgcmFkaXVzOiB7IHJhbmdlcywgb3V0ZXIgfSwgbGFiZWw6IHsgbGFiZWxzLCBpbnRlcnZhbCwgbWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2luLCBhbGlnbiB9LCBhbmdsZTogeyBzdGFydCB9LCBwb2ludE9uQ29sdW1uLCBjZW50ZXJYLCBjZW50ZXJZLCB0aWNrRGlzdGFuY2UsIH0gPSB2ZXJ0aWNhbEF4aXM7XG4gICAgICAgIGNvbnN0IGxhYmVsQWRqdXN0bWVudCA9IHBvaW50T25Db2x1bW4gPyB0aWNrRGlzdGFuY2UgLyAyIDogMDtcbiAgICAgICAgY29uc3QgZm9udCA9IGdldFRpdGxlRm9udFN0cmluZyh0aGlzLnZlcnRpY2FsQXhpc1RoZW1lLmxhYmVsKTtcbiAgICAgICAgY29uc3QgeyB2aXNpYmxlOiB0ZXh0QnViYmxlVmlzaWJsZSwgYmFja2dyb3VuZENvbG9yLCBib3JkZXJSYWRpdXMsIGJvcmRlckNvbG9yLCBib3JkZXJXaWR0aCwgcGFkZGluZ1gsIHBhZGRpbmdZLCB9ID0gdGhpcy52ZXJ0aWNhbEF4aXNUaGVtZS5sYWJlbC50ZXh0QnViYmxlO1xuICAgICAgICBjb25zdCBsYWJlbFBhZGRpbmdYID0gdGV4dEJ1YmJsZVZpc2libGUgPyBwYWRkaW5nWCA6IDA7XG4gICAgICAgIGNvbnN0IGxhYmVsUGFkZGluZ1kgPSB0ZXh0QnViYmxlVmlzaWJsZSA/IHBhZGRpbmdZIDogMDtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBtYXhXaWR0aCArIGxhYmVsUGFkZGluZ1ggKiAyIC0gbWFyZ2luO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBtYXhIZWlnaHQgKyBsYWJlbFBhZGRpbmdZICogMjtcbiAgICAgICAgY29uc3QgZm9udENvbG9yID0gdGhpcy52ZXJ0aWNhbEF4aXNUaGVtZS5sYWJlbC5jb2xvcjtcbiAgICAgICAgcmV0dXJuIHJhbmdlcy5yZWR1Y2UoKGFjYywgcmFkaXVzLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBnZXRSYWRpYWxQb3NpdGlvbihjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMgLSBsYWJlbEFkanVzdG1lbnQsIGNhbGN1bGF0ZURlZ3JlZVRvUmFkaWFuKHN0YXJ0KSk7XG4gICAgICAgICAgICBjb25zdCBuZWVkUmVuZGVyID0gaGFzTmVlZFJlbmRlcihpbmRleCwgcG9pbnRPbkNvbHVtbiwgaW50ZXJ2YWwsIHJhZGl1cywgb3V0ZXIpO1xuICAgICAgICAgICAgbGV0IHBvc1ggPSB4ICsgbWFyZ2luO1xuICAgICAgICAgICAgbGV0IGxhYmVsUG9zWCA9IHggKyBtYXJnaW4gKyBsYWJlbFBhZGRpbmdYO1xuICAgICAgICAgICAgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIHBvc1ggPSB4IC0gbWFyZ2luIC0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIGxhYmVsUG9zWCA9IHggLSBtYXJnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmNsdWRlcyhbJ3JpZ2h0JywgJ2VuZCddLCBhbGlnbikpIHtcbiAgICAgICAgICAgICAgICBwb3NYID0geCAtIG1hcmdpbiAtIHdpZHRoO1xuICAgICAgICAgICAgICAgIGxhYmVsUG9zWCA9IHggLSBtYXJnaW4gLSBsYWJlbFBhZGRpbmdYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5lZWRSZW5kZXJcbiAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYnViYmxlTGFiZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRpb25Qb3NpdGlvbjogeyB4LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpYW46IGNhbGN1bGF0ZURlZ3JlZVRvUmFkaWFuKHN0YXJ0LCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1YmJsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHBvc1gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogeSAtIGhlaWdodCAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IGJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogdGhpcy5nZXRCdWJibGVTaGFkb3dTdHlsZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbGFiZWxzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBsYWJlbFBvc1gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogW3sgZm9udCwgZmlsbFN0eWxlOiBmb250Q29sb3IsIHRleHRBbGlnbjogYWxpZ24sIHRleHRCYXNlbGluZTogJ21pZGRsZScgfV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICA6IGFjYztcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICByZW5kZXJEb3RNb2RlbChjaXJjdWxhckF4aXMpIHtcbiAgICAgICAgY29uc3QgeyBhbmdsZTogeyBjZW50cmFsLCBkcmF3aW5nU3RhcnQgfSwgbGFiZWw6IHsgbGFiZWxzLCBpbnRlcnZhbCB9LCByYWRpdXM6IHsgb3V0ZXIgfSwgY2VudGVyWCwgY2VudGVyWSwgY2xvY2t3aXNlLCB9ID0gY2lyY3VsYXJBeGlzO1xuICAgICAgICBjb25zdCB7IGRvdENvbG9yIH0gPSB0aGlzLmNpcmN1bGFyQXhpc1RoZW1lO1xuICAgICAgICByZXR1cm4gbGFiZWxzLnJlZHVjZSgoYWNjLCBjdXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGFydERlZ3JlZSA9IGRyYXdpbmdTdGFydCArIGNlbnRyYWwgKiBpbmRleCAqIChjbG9ja3dpc2UgPyAxIDogLTEpO1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBnZXRSYWRpYWxQb3NpdGlvbihjZW50ZXJYLCBjZW50ZXJZLCBvdXRlciwgY2FsY3VsYXRlRGVncmVlVG9SYWRpYW4oY2FsY3VsYXRlVmFsaWRBbmdsZShzdGFydERlZ3JlZSkpKTtcbiAgICAgICAgICAgIHJldHVybiBpbmRleCAlIGludGVydmFsID09PSAwXG4gICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3JlY3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGRvdENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IFJFQ1RfU0laRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogUkVDVF9TSVpFLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDogeCAtIFJFQ1RfU0laRSAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5IC0gUkVDVF9TSVpFIC8gMixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgOiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgcmVuZGVyQ2lyY3VsYXJBeGlzTGFiZWwoY2lyY3VsYXJBeGlzKSB7XG4gICAgICAgIGNvbnN0IHsgY2VudGVyWCwgY2VudGVyWSwgY2xvY2t3aXNlLCBsYWJlbDogeyBsYWJlbHMsIGludGVydmFsLCBtYXJnaW4sIG1heEhlaWdodCB9LCBhbmdsZTogeyBkcmF3aW5nU3RhcnQsIGNlbnRyYWwgfSwgcmFkaXVzOiB7IG91dGVyIH0sIH0gPSBjaXJjdWxhckF4aXM7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IG91dGVyICsgKG1hcmdpbiArIG1heEhlaWdodCAvIDIpICogKHRoaXMubmFtZSA9PT0gJ2dhdWdlJyA/IC0xIDogMSk7XG4gICAgICAgIGNvbnN0IGxhYmVsVGhlbWUgPSB0aGlzLmNpcmN1bGFyQXhpc1RoZW1lLmxhYmVsO1xuICAgICAgICBjb25zdCBmb250ID0gZ2V0VGl0bGVGb250U3RyaW5nKGxhYmVsVGhlbWUpO1xuICAgICAgICBjb25zdCBkZWdyZWUgPSBjZW50cmFsICogKGNsb2Nrd2lzZSA/IDEgOiAtMSk7XG4gICAgICAgIHJldHVybiBsYWJlbHMucmVkdWNlKChhY2MsIHRleHQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGFydERlZ3JlZSA9IGRyYXdpbmdTdGFydCArIGRlZ3JlZSAqIGluZGV4O1xuICAgICAgICAgICAgY29uc3QgdmFsaWRTdGFydEFuZ2xlID0gY2FsY3VsYXRlVmFsaWRBbmdsZShzdGFydERlZ3JlZSk7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXggJSBpbnRlcnZhbCA9PT0gMFxuICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oeyB0eXBlOiAnbGFiZWwnLCBzdHlsZTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdGV4dEFsaWduOiAnY2VudGVyJywgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJywgZm9udCwgZmlsbFN0eWxlOiBsYWJlbFRoZW1lLmNvbG9yIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLCB0ZXh0IH0sIGdldFJhZGlhbFBvc2l0aW9uKGNlbnRlclgsIGNlbnRlclksIHJhZGl1cywgY2FsY3VsYXRlRGVncmVlVG9SYWRpYW4odmFsaWRTdGFydEFuZ2xlKSkpLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICA6IGFjYztcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICByZW5kZXJUaWNrKGNpcmN1bGFyQXhpcykge1xuICAgICAgICBjb25zdCB7IGNlbnRlclgsIGNlbnRlclksIHRpY2tJbnRlcnZhbCwgY2xvY2t3aXNlLCBhbmdsZTogeyBjZW50cmFsLCBkcmF3aW5nU3RhcnQgfSwgbGFiZWw6IHsgbGFiZWxzIH0sIHJhZGl1czogeyBvdXRlciB9LCB9ID0gY2lyY3VsYXJBeGlzO1xuICAgICAgICBjb25zdCB7IHN0cm9rZVN0eWxlLCBsaW5lV2lkdGggfSA9IHRoaXMuY2lyY3VsYXJBeGlzVGhlbWUudGljaztcbiAgICAgICAgcmV0dXJuIGxhYmVscy5yZWR1Y2UoKGFjYywgY3VyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnREZWdyZWUgPSBkcmF3aW5nU3RhcnQgKyBjZW50cmFsICogaW5kZXggKiAoY2xvY2t3aXNlID8gMSA6IC0xKTtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0UmFkaWFsUG9zaXRpb24oY2VudGVyWCwgY2VudGVyWSwgb3V0ZXIgLSBIQUxGX1RJQ0ssIGNhbGN1bGF0ZURlZ3JlZVRvUmFkaWFuKGNhbGN1bGF0ZVZhbGlkQW5nbGUoc3RhcnREZWdyZWUpKSk7XG4gICAgICAgICAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gZ2V0UmFkaWFsUG9zaXRpb24oY2VudGVyWCwgY2VudGVyWSwgb3V0ZXIgKyBIQUxGX1RJQ0ssIGNhbGN1bGF0ZURlZ3JlZVRvUmFkaWFuKGNhbGN1bGF0ZVZhbGlkQW5nbGUoc3RhcnREZWdyZWUpKSk7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXggJSB0aWNrSW50ZXJ2YWwgPT09IDBcbiAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgeDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB5MixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgOiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgcmVuZGVyQXJjTGluZShjaXJjdWxhckF4aXMpIHtcbiAgICAgICAgY29uc3QgeyBjZW50ZXJYLCBjZW50ZXJZLCBjbG9ja3dpc2UsIGFuZ2xlOiB7IHN0YXJ0LCBlbmQsIHRvdGFsIH0sIHJhZGl1czogeyBvdXRlciB9LCB9ID0gY2lyY3VsYXJBeGlzO1xuICAgICAgICBjb25zdCB7IHN0cm9rZVN0eWxlLCBsaW5lV2lkdGggfSA9IHRoaXMuY2lyY3VsYXJBeGlzVGhlbWU7XG4gICAgICAgIHJldHVybiB0b3RhbCA9PT0gREVHUkVFXzM2MFxuICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2lyY2xlJyxcbiAgICAgICAgICAgICAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgeTogY2VudGVyWSxcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBvdXRlcixcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHN0cm9rZVN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMCknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICA6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhcmMnLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogbGluZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogc3Ryb2tlU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIHg6IGNlbnRlclgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlOiB7IHN0YXJ0LCBlbmQgfSxcbiAgICAgICAgICAgICAgICAgICAgZHJhd2luZ1N0YXJ0QW5nbGU6IERFR1JFRV9ORUdBVElWRV85MCxcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBvdXRlcixcbiAgICAgICAgICAgICAgICAgICAgY2xvY2t3aXNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgIH1cbn1cbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIi4vY29tcG9uZW50XCI7XG5pbXBvcnQgeyBpc051bWJlciwgcGljaywgaXNOdWxsLCBjYWxjdWxhdGVTaXplV2l0aFBlcmNlbnRTdHJpbmcsIGRlZXBDb3B5LCB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBtZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2VcIjtcbmltcG9ydCB7IG1ha2VHcm91cGVkU2VjdG9yUmVzcG9uZGVyTW9kZWwgfSBmcm9tIFwiLi4vaGVscGVycy9yZXNwb25kZXJzXCI7XG5pbXBvcnQgeyBnZXRSYWRpYWxBbmNob3JQb3NpdGlvbiwgbWFrZUFuY2hvclBvc2l0aW9uUGFyYW0sIHdpdGhpblJhZGlhbiwgZ2V0UmFkaXVzUmFuZ2VzLCBERUdSRUVfMzYwLCBERUdSRUVfMCwgREVHUkVFX05FR0FUSVZFXzkwLCB9IGZyb20gXCIuLi9oZWxwZXJzL3NlY3RvclwiO1xuaW1wb3J0IHsgZ2V0QWN0aXZlU2VyaWVzTWFwIH0gZnJvbSBcIi4uL2hlbHBlcnMvbGVnZW5kXCI7XG5pbXBvcnQgeyBnZXREYXRhTGFiZWxzT3B0aW9ucyB9IGZyb20gXCIuLi9oZWxwZXJzL2RhdGFMYWJlbHNcIjtcbmltcG9ydCB7IGdldFJHQkEgfSBmcm9tIFwiLi4vaGVscGVycy9jb2xvclwiO1xuaW1wb3J0IHsgZ2V0VG90YWxBbmdsZSB9IGZyb20gXCIuLi9oZWxwZXJzL3BpZVNlcmllc1wiO1xuaW1wb3J0IHsgaXNBdmFpbGFibGVTaG93VG9vbHRpcEluZm8gfSBmcm9tIFwiLi4vaGVscGVycy92YWxpZGF0aW9uXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRpYWxCYXJTZXJpZXMgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1vZGVscyA9IHt9O1xuICAgICAgICB0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudERldGVjdFR5cGUgPSAncG9pbnQnO1xuICAgICAgICB0aGlzLm9uTW91c2VvdXRDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nlcmllc1BvaW50SG92ZXJlZCcsIHsgbW9kZWxzOiBbXSwgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJIb3ZlcmVkU2VyaWVzJywgeyBtb2RlbHM6IFtdLCBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VsZWN0U2VyaWVzID0gKGluZm8pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5kZXgsIHNlcmllc0luZGV4IH0gPSBpbmZvO1xuICAgICAgICAgICAgY29uc3QgaXNBdmFpbGFibGUgPSBpc051bWJlcihpbmRleCkgJiYgKHRoaXMuZXZlbnREZXRlY3RUeXBlID09PSAnZ3JvdXBlZCcgfHwgaXNOdW1iZXIoc2VyaWVzSW5kZXgpKTtcbiAgICAgICAgICAgIGlmICghaXNBdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2RlbHMgPSB0aGlzLmV2ZW50RGV0ZWN0VHlwZSA9PT0gJ2dyb3VwZWQnXG4gICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2V0R3JvdXBlZFNlY3RvcihbdGhpcy5yZXNwb25kZXJzW2luZGV4XV0sICdzZWxlY3QnKSxcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5nZXRSYWRpYWxCYXJTZWN0b3JNb2RlbHNGcm9tUmVzcG9uZGVycyhbdGhpcy5yZXNwb25kZXJzW2luZGV4XV0pLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICA6IChfYSA9IHRoaXMuZ2V0UmVzcG9uZGVyTW9kZWxzV2l0aFRoZW1lKFt0aGlzLnRvb2x0aXBTZWN0b3JNYXBbaW5kZXhdW3Nlcmllc0luZGV4XV0sICdzZWxlY3QnKSwgKF9hICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSk7XG4gICAgICAgICAgICBpZiAoIW1vZGVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZS5TRUxFQ1RfU0VSSUVTX0FQSV9JTkRFWF9FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlclNlbGVjdGVkU2VyaWVzJywge1xuICAgICAgICAgICAgICAgIG1vZGVsczogbW9kZWxzLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBldmVudERldGVjdFR5cGU6IHRoaXMuZXZlbnREZXRlY3RUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2hvd1Rvb2x0aXAgPSAoaW5mbykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpbmRleCwgc2VyaWVzSW5kZXggfSA9IGluZm87XG4gICAgICAgICAgICBpZiAoIWlzQXZhaWxhYmxlU2hvd1Rvb2x0aXBJbmZvKGluZm8sIHRoaXMuZXZlbnREZXRlY3RUeXBlLCAncmFkaWFsQmFyJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2RlbHMgPSB0aGlzLmV2ZW50RGV0ZWN0VHlwZSA9PT0gJ2dyb3VwZWQnXG4gICAgICAgICAgICAgICAgPyB0aGlzLmdldEdyb3VwZWRTZWN0b3IoW3RoaXMucmVzcG9uZGVyc1tpbmRleF1dLCAnaG92ZXInKVxuICAgICAgICAgICAgICAgIDogdGhpcy5nZXRSZXNwb25kZXJNb2RlbHNXaXRoVGhlbWUoW3RoaXMudG9vbHRpcFNlY3Rvck1hcFtpbmRleF1bc2VyaWVzSW5kZXhdXSwgJ2hvdmVyJyk7XG4gICAgICAgICAgICBpZiAoIW1vZGVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlckhvdmVyZWRTZXJpZXMnLCB7XG4gICAgICAgICAgICAgICAgbW9kZWxzLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBldmVudERldGVjdFR5cGU6IHRoaXMuZXZlbnREZXRlY3RUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMgPVxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREZXRlY3RUeXBlID09PSAnZ3JvdXBlZCcgPyB0aGlzLnRvb2x0aXBTZWN0b3JNYXBbaW5kZXhdIDogbW9kZWxzO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdzZXJpZXNQb2ludEhvdmVyZWQnLCB7IG1vZGVsczogdGhpcy5hY3RpdmF0ZWRSZXNwb25kZXJzLCBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGluaXRVcGRhdGUoZGVsdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRyYXdNb2RlbHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFuZ2xlOiB7IHN0YXJ0OiBzdGFydEFuZ2xlLCB0b3RhbDogdG90YWxBbmdsZSB9LCB9ID0gdGhpcy5jaXJjdWxhckF4aXM7XG4gICAgICAgIGxldCBjdXJyZW50RGVncmVlO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLm1vZGVscykuZm9yRWFjaCgoY2F0ZWdvcnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tb2RlbHNbY2F0ZWdvcnldLmZpbmRJbmRleCgoeyBjbG9ja3dpc2UsIGRlZ3JlZTogeyBzdGFydCwgZW5kIH0gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnREZWdyZWUgPSBjbG9ja3dpc2VcbiAgICAgICAgICAgICAgICAgICAgPyBzdGFydEFuZ2xlICsgdG90YWxBbmdsZSAqIGRlbHRhXG4gICAgICAgICAgICAgICAgICAgIDogc3RhcnRBbmdsZSAtIHRvdGFsQW5nbGUgKiBkZWx0YTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aGluUmFkaWFuKGNsb2Nrd2lzZSwgc3RhcnQsIGVuZCwgY3VycmVudERlZ3JlZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3luY0VuZEFuZ2xlKGluZGV4IDwgMCA/IHRoaXMubW9kZWxzW2NhdGVnb3J5XS5sZW5ndGggOiBpbmRleCwgY2F0ZWdvcnkpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd01vZGVsc1tjYXRlZ29yeV1baW5kZXhdLmRlZ3JlZS5lbmQgPSBjdXJyZW50RGVncmVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3luY0VuZEFuZ2xlKGluZGV4LCBjYXRlZ29yeSkge1xuICAgICAgICBpZiAoaW5kZXggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2VGFyZ2V0RW5kRGVncmVlID0gdGhpcy5tb2RlbHNbY2F0ZWdvcnldW2ldLmRlZ3JlZS5lbmQ7XG4gICAgICAgICAgICBpZiAodGhpcy5kcmF3TW9kZWxzW2NhdGVnb3J5XVtpXS5kZWdyZWUuZW5kICE9PSBwcmV2VGFyZ2V0RW5kRGVncmVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TW9kZWxzW2NhdGVnb3J5XVtpXS5kZWdyZWUuZW5kID0gcHJldlRhcmdldEVuZERlZ3JlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnc2VyaWVzJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ3JhZGlhbEJhcic7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMub24oJ3NlbGVjdFNlcmllcycsIHRoaXMuc2VsZWN0U2VyaWVzKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignc2hvd1Rvb2x0aXAnLCB0aGlzLnNob3dUb29sdGlwKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignaGlkZVRvb2x0aXAnLCB0aGlzLm9uTW91c2VvdXRDb21wb25lbnQpO1xuICAgIH1cbiAgICByZW5kZXIoY2hhcnRTdGF0ZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB7IGxheW91dCwgc2VyaWVzLCBsZWdlbmQsIG9wdGlvbnMsIHRoZW1lLCBzdGFja1Nlcmllcywgc2NhbGUsIHJhZGlhbEF4ZXMgfSA9IGNoYXJ0U3RhdGU7XG4gICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSAoX2EgPSBjaGFydFN0YXRlLmNhdGVnb3JpZXMsIChfYSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkpO1xuICAgICAgICBpZiAoIXNlcmllcy5yYWRpYWxCYXIgfHwgIXN0YWNrU2VyaWVzLnJhZGlhbEJhcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2Uubm9EYXRhRXJyb3IodGhpcy5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aGVtZSA9IHRoZW1lLnNlcmllcy5yYWRpYWxCYXI7XG4gICAgICAgIHRoaXMucmVjdCA9IGxheW91dC5wbG90O1xuICAgICAgICB0aGlzLmFjdGl2ZVNlcmllc01hcCA9IGdldEFjdGl2ZVNlcmllc01hcChsZWdlbmQpO1xuICAgICAgICB0aGlzLnNlbGVjdGFibGUgPSB0aGlzLmdldFNlbGVjdGFibGVPcHRpb24ob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2V0RXZlbnREZXRlY3RUeXBlKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBpbml0aWFsQ2F0ZWdvcnlNYXAgPSBjYXRlZ29yaWVzLnJlZHVjZSgoYWNjLCBjYXRlZ29yeSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFhY2NbY2F0ZWdvcnldKSB7XG4gICAgICAgICAgICAgICAgYWNjW2NhdGVnb3J5XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICBjb25zdCBzZXJpZXNEYXRhID0gc2VyaWVzLnJhZGlhbEJhci5kYXRhO1xuICAgICAgICB0aGlzLmNpcmN1bGFyQXhpcyA9IHJhZGlhbEF4ZXMuY2lyY3VsYXJBeGlzO1xuICAgICAgICBjb25zdCB2ZXJ0aWNhbEF4aXNEYXRhID0gcmFkaWFsQXhlcy52ZXJ0aWNhbEF4aXM7XG4gICAgICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSB0aGlzLm1ha2VSZW5kZXJPcHRpb25zKHZlcnRpY2FsQXhpc0RhdGEsIHNjYWxlLmNpcmN1bGFyQXhpcywgKF9iID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNlcmllcyk7XG4gICAgICAgIGNvbnN0IHsgY2F0ZWdvcnlNYXAsIHNlcmllc01vZGVscyB9ID0gdGhpcy5tYWtlU2VyaWVzTW9kZWxEYXRhKHNlcmllc0RhdGEsIHN0YWNrU2VyaWVzLnJhZGlhbEJhci5zdGFja0RhdGEsIHJlbmRlck9wdGlvbnMsIGluaXRpYWxDYXRlZ29yeU1hcCk7XG4gICAgICAgIGNvbnN0IHRvb2x0aXBEYXRhID0gdGhpcy5tYWtlVG9vbHRpcERhdGEoc2VyaWVzTW9kZWxzLCBjYXRlZ29yaWVzKTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSBjYXRlZ29yeU1hcDtcbiAgICAgICAgaWYgKCF0aGlzLmRyYXdNb2RlbHMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERyYXdNb2RlbHMoY2F0ZWdvcnlNYXApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXREYXRhTGFiZWxzT3B0aW9ucyhvcHRpb25zLCB0aGlzLm5hbWUpLnZpc2libGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFMYWJlbERhdGEgPSBzZXJpZXNNb2RlbHMucmVkdWNlKChhY2MsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWy4uLmFjYywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgeyB0eXBlOiAnc2VjdG9yJywgdGhlbWU6IHRoaXMudGhlbWUuZGF0YUxhYmVscyB9KV07XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckRhdGFMYWJlbHMoZGF0YUxhYmVsRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b29sdGlwU2VjdG9yTWFwID0gdGhpcy5tYWtlVG9vbHRpcFNlY3Rvck1hcChzZXJpZXNNb2RlbHMsIHRvb2x0aXBEYXRhKTtcbiAgICAgICAgdGhpcy5yZXNwb25kZXJzID0gdGhpcy5tYWtlUmVzcG9uZGVycyh2ZXJ0aWNhbEF4aXNEYXRhLnJhZGl1cy5yYW5nZXMsIHNlcmllc01vZGVscywgcmVuZGVyT3B0aW9ucywgY2F0ZWdvcmllcywgdG9vbHRpcERhdGEpO1xuICAgIH1cbiAgICBpbml0RHJhd01vZGVscyhjYXRlZ29yeU1hcCkge1xuICAgICAgICB0aGlzLmRyYXdNb2RlbHMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoY2F0ZWdvcnlNYXApLmZvckVhY2goKGNhdGVnb3J5KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRyYXdNb2RlbHNbY2F0ZWdvcnldID0gY2F0ZWdvcnlNYXBbY2F0ZWdvcnldLm1hcCgobSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbSksIHsgZGVncmVlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG0uZGVncmVlKSwgeyBlbmQ6IG0uZGVncmVlLnN0YXJ0IH0pIH0pKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYWtlUmVzcG9uZGVycyhyYWRpdXNSYW5nZXMsIHNlcmllc01vZGVscywgcmVuZGVyT3B0aW9ucywgY2F0ZWdvcmllcywgdG9vbHRpcERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnREZXRlY3RUeXBlID09PSAnZ3JvdXBlZCdcbiAgICAgICAgICAgID8gbWFrZUdyb3VwZWRTZWN0b3JSZXNwb25kZXJNb2RlbChyYWRpdXNSYW5nZXMsIHJlbmRlck9wdGlvbnMsIGNhdGVnb3JpZXMpXG4gICAgICAgICAgICA6IHNlcmllc01vZGVscy5tYXAoKG0sIGluZGV4KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCB0b29sdGlwRGF0YVtpbmRleF0pIH0pKSk7XG4gICAgfVxuICAgIG1ha2VUb29sdGlwU2VjdG9yTWFwKHNlcmllc01vZGVscywgdG9vbHRpcERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHNlcmllc01vZGVscy5yZWR1Y2UoKGFjYywgY3VyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnlJbmRleCA9IGN1ci5pbmRleDtcbiAgICAgICAgICAgIGlmICghYWNjW2NhdGVnb3J5SW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgYWNjW2NhdGVnb3J5SW5kZXhdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2NbY2F0ZWdvcnlJbmRleF0ucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGN1ciksIHsgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgdG9vbHRpcERhdGFbaW5kZXhdKSB9KSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIHNldEV2ZW50RGV0ZWN0VHlwZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICgoX2IgPSAoX2EgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VyaWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZXZlbnREZXRlY3RUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGV0ZWN0VHlwZSA9IG9wdGlvbnMuc2VyaWVzLmV2ZW50RGV0ZWN0VHlwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRCYXJXaWR0aCh0aWNrRGlzdGFuY2UsIGF4aXNTaXplKSB7XG4gICAgICAgIGNvbnN0IHsgYmFyV2lkdGggfSA9IHRoaXMudGhlbWU7XG4gICAgICAgIGNvbnN0IERFRkFVTFRfUEFERElORyA9IDU7XG4gICAgICAgIHJldHVybiBiYXJXaWR0aFxuICAgICAgICAgICAgPyBNYXRoLm1pbih0aWNrRGlzdGFuY2UsIGNhbGN1bGF0ZVNpemVXaXRoUGVyY2VudFN0cmluZyhheGlzU2l6ZSwgYmFyV2lkdGgpKVxuICAgICAgICAgICAgOiB0aWNrRGlzdGFuY2UgLSBERUZBVUxUX1BBRERJTkcgKiAyO1xuICAgIH1cbiAgICBtYWtlUmVuZGVyT3B0aW9ucyh7IGF4aXNTaXplLCBjZW50ZXJYLCBjZW50ZXJZLCB0aWNrRGlzdGFuY2UsIHJhZGl1czogeyByYW5nZXMgfSwgYW5nbGU6IHsgc3RhcnQsIGVuZCB9LCB9LCBzY2FsZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB7IGxpbWl0OiB7IG1heCB9LCBzdGVwU2l6ZSwgfSA9IHNjYWxlO1xuICAgICAgICBjb25zdCBjbG9ja3dpc2UgPSAoX2IgPSAoX2EgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvY2t3aXNlLCAoX2IgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZSkpO1xuICAgICAgICBjb25zdCB0b3RhbEFuZ2xlID0gZ2V0VG90YWxBbmdsZShjbG9ja3dpc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgICBjb25zdCBiYXJXaWR0aCA9IHRoaXMuZ2V0QmFyV2lkdGgodGlja0Rpc3RhbmNlLCBheGlzU2l6ZSk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSAodGlja0Rpc3RhbmNlIC0gYmFyV2lkdGgpIC8gMjtcbiAgICAgICAgY29uc3Qgc2NhbGVNYXhMaW1pdFZhbHVlID0gbWF4ICsgKHRvdGFsQW5nbGUgPCBERUdSRUVfMzYwID8gREVHUkVFXzAgOiBzdGVwU2l6ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbG9ja3dpc2UsXG4gICAgICAgICAgICBjZW50ZXJYLFxuICAgICAgICAgICAgY2VudGVyWSxcbiAgICAgICAgICAgIHJhZGl1c1JhbmdlczogZ2V0UmFkaXVzUmFuZ2VzKHJhbmdlcywgcGFkZGluZyksXG4gICAgICAgICAgICBhbmdsZVJhbmdlOiB7XG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvdGFsQW5nbGUsXG4gICAgICAgICAgICBzY2FsZU1heExpbWl0VmFsdWUsXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbWFrZVNlcmllc01vZGVsRGF0YShzZXJpZXNEYXRhLCBzdGFja1Nlcmllc0RhdGEsIHJlbmRlck9wdGlvbnMsIGluaXRpYWxDYXRlZ29yeU1hcCkge1xuICAgICAgICBjb25zdCB7IGNsb2Nrd2lzZSwgY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzUmFuZ2VzLCB0b3RhbEFuZ2xlLCBzY2FsZU1heExpbWl0VmFsdWUsIHN0YXJ0QW5nbGUsIH0gPSByZW5kZXJPcHRpb25zO1xuICAgICAgICBjb25zdCBkZWZhdWx0U3RhcnREZWdyZWUgPSBzdGFydEFuZ2xlO1xuICAgICAgICBjb25zdCB7IGxpbmVXaWR0aCwgc3Ryb2tlU3R5bGUgfSA9IHRoaXMudGhlbWU7XG4gICAgICAgIGNvbnN0IHNlY3Rvck1vZGVscyA9IFtdO1xuICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gT2JqZWN0LmtleXMoaW5pdGlhbENhdGVnb3J5TWFwKTtcbiAgICAgICAgY29uc3QgY2F0ZWdvcnlNYXAgPSBkZWVwQ29weShpbml0aWFsQ2F0ZWdvcnlNYXApO1xuICAgICAgICBzdGFja1Nlcmllc0RhdGEuZm9yRWFjaCgoeyB2YWx1ZXMgfSwgY2F0ZWdvcnlJbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpbm5lciwgb3V0ZXIgfSA9IHJhZGl1c1Jhbmdlc1tjYXRlZ29yeUluZGV4XTtcbiAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwgc2VyaWVzSW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVncmVlID0gTWF0aC5tYXgoKHZhbHVlIC8gc2NhbGVNYXhMaW1pdFZhbHVlKSAqIHRvdGFsQW5nbGUsIDEpICogKGNsb2Nrd2lzZSA/IDEgOiAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZNb2RlbCA9IHNlY3Rvck1vZGVsc1tzZWN0b3JNb2RlbHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0RGVncmVlID0gc2VyaWVzSW5kZXggJiYgcHJldk1vZGVsID8gcHJldk1vZGVsLmRlZ3JlZS5lbmQgOiBkZWZhdWx0U3RhcnREZWdyZWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZERlZ3JlZSA9IGNsb2Nrd2lzZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBNYXRoLm1pbihzdGFydERlZ3JlZSArIGRlZ3JlZSwgREVHUkVFXzM2MClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5tYXgoc3RhcnREZWdyZWUgKyBkZWdyZWUsIERFR1JFRV8wKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBjb2xvcjogc2VyaWVzQ29sb3IgfSA9IHNlcmllc0RhdGFbc2VyaWVzSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMuZ2V0U2VyaWVzQ29sb3IobmFtZSwgc2VyaWVzQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWN0b3JNb2RlbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzZWN0b3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNlbnRlclgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVncmVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0RGVncmVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZW5kRGVncmVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFt7IHN0cm9rZVN0eWxlIH1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvY2t3aXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogY2F0ZWdvcnlJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdpbmdTdGFydEFuZ2xlOiBERUdSRUVfTkVHQVRJVkVfOTAsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5TWFwW2NhdGVnb3JpZXNbY2F0ZWdvcnlJbmRleF1dLnB1c2goc2VjdG9yTW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICBzZWN0b3JNb2RlbHMucHVzaChzZWN0b3JNb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBzZXJpZXNNb2RlbHM6IHNlY3Rvck1vZGVscywgY2F0ZWdvcnlNYXAgfTtcbiAgICB9XG4gICAgZ2V0U2VyaWVzQ29sb3IobmFtZSwgY29sb3IpIHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3QsIGFyZWFPcGFjaXR5IH0gPSB0aGlzLnRoZW1lO1xuICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmFjdGl2ZVNlcmllc01hcFtuYW1lXTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBPYmplY3QudmFsdWVzKHRoaXMuYWN0aXZlU2VyaWVzTWFwKS5zb21lKChlbGVtKSA9PiAhZWxlbSk7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZFxuICAgICAgICAgICAgPyBnZXRSR0JBKGNvbG9yLCBhY3RpdmUgPyBzZWxlY3QuYXJlYU9wYWNpdHkgOiBzZWxlY3QucmVzdFNlcmllcy5hcmVhT3BhY2l0eSlcbiAgICAgICAgICAgIDogZ2V0UkdCQShjb2xvciwgYXJlYU9wYWNpdHkpO1xuICAgIH1cbiAgICBtYWtlVG9vbHRpcERhdGEoc2VyaWVzTW9kZWxzLCBjYXRlZ29yaWVzKSB7XG4gICAgICAgIGNvbnN0IHRvb2x0aXBEYXRhID0gW107XG4gICAgICAgIHNlcmllc01vZGVscy5mb3JFYWNoKCh7IHNlcmllc0NvbG9yLCBuYW1lLCB2YWx1ZSwgaW5kZXggfSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc051bGwodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcERhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogc2VyaWVzQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6IGlzTnVtYmVyKGluZGV4KSA/IGNhdGVnb3JpZXNbaW5kZXhdIDogJycsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG9vbHRpcERhdGE7XG4gICAgfVxuICAgIG1ha2VUb29sdGlwUmVzcG9uZGVyKHJlc3BvbmRlcnMpIHtcbiAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IE9iamVjdC5rZXlzKHRoaXMubW9kZWxzKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbmRlcnMubWFwKChyZXNwb25kZXIpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3BvbmRlciksIGdldFJhZGlhbEFuY2hvclBvc2l0aW9uKG1ha2VBbmNob3JQb3NpdGlvblBhcmFtKCdjZW50ZXInLCB0aGlzLm1vZGVsc1tjYXRlZ29yaWVzW3Jlc3BvbmRlci5pbmRleF1dLmZpbmQoKHsgbmFtZSB9KSA9PiBuYW1lID09PSByZXNwb25kZXIubmFtZSkpKSkpKTtcbiAgICB9XG4gICAgZ2V0UmFkaWFsQmFyU2VjdG9yTW9kZWxzRnJvbVJlc3BvbmRlcnMocmVzcG9uZGVycykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghcmVzcG9uZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2EgPSB0aGlzLnRvb2x0aXBTZWN0b3JNYXBbcmVzcG9uZGVyc1swXS5pbmRleF0sIChfYSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSk7XG4gICAgfVxuICAgIGdldEdyb3VwZWRTZWN0b3IocmVzcG9uZGVycywgdHlwZSkge1xuICAgICAgICBjb25zdCBSYWRpYWxCYXJTZWN0b3JNb2RlbHMgPSB0aGlzLmdldFJhZGlhbEJhclNlY3Rvck1vZGVsc0Zyb21SZXNwb25kZXJzKHJlc3BvbmRlcnMpO1xuICAgICAgICBjb25zdCB7IGNvbG9yLCBvcGFjaXR5IH0gPSB0aGlzLnRoZW1lW3R5cGVdLmdyb3VwZWRTZWN0b3I7XG4gICAgICAgIHJldHVybiBSYWRpYWxCYXJTZWN0b3JNb2RlbHMubGVuZ3RoXG4gICAgICAgICAgICA/IHJlc3BvbmRlcnMubWFwKChtKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyBjb2xvcjogZ2V0UkdCQShjb2xvciwgb3BhY2l0eSkgfSkpKVxuICAgICAgICAgICAgOiBbXTtcbiAgICB9XG4gICAgb25Nb3VzZW1vdmVHcm91cGVkVHlwZShyZXNwb25kZXJzKSB7XG4gICAgICAgIGNvbnN0IFJhZGlhbEJhclNlY3Rvck1vZGVscyA9IHRoaXMuZ2V0UmFkaWFsQmFyU2VjdG9yTW9kZWxzRnJvbVJlc3BvbmRlcnMocmVzcG9uZGVycyk7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVySG92ZXJlZFNlcmllcycsIHtcbiAgICAgICAgICAgIG1vZGVsczogdGhpcy5nZXRHcm91cGVkU2VjdG9yKHJlc3BvbmRlcnMsICdob3ZlcicpLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgZXZlbnREZXRlY3RUeXBlOiB0aGlzLmV2ZW50RGV0ZWN0VHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IFJhZGlhbEJhclNlY3Rvck1vZGVscztcbiAgICB9XG4gICAgb25Nb3VzZW1vdmUoeyByZXNwb25kZXJzIH0pIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnREZXRlY3RUeXBlID09PSAnZ3JvdXBlZCcpIHtcbiAgICAgICAgICAgIHRoaXMub25Nb3VzZW1vdmVHcm91cGVkVHlwZShyZXNwb25kZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVySG92ZXJlZFNlcmllcycsIHtcbiAgICAgICAgICAgICAgICBtb2RlbHM6IHRoaXMuZ2V0UmVzcG9uZGVyTW9kZWxzV2l0aFRoZW1lKHJlc3BvbmRlcnMsICdob3ZlcicpLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZWRSZXNwb25kZXJzID0gdGhpcy5tYWtlVG9vbHRpcFJlc3BvbmRlcihyZXNwb25kZXJzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nlcmllc1BvaW50SG92ZXJlZCcsIHtcbiAgICAgICAgICAgIG1vZGVsczogdGhpcy5hY3RpdmF0ZWRSZXNwb25kZXJzLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgZXZlbnREZXRlY3RUeXBlOiB0aGlzLmV2ZW50RGV0ZWN0VHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICB9XG4gICAgb25DbGljayh7IHJlc3BvbmRlcnMgfSkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICBsZXQgbW9kZWxzO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnREZXRlY3RUeXBlID09PSAnZ3JvdXBlZCcpIHtcbiAgICAgICAgICAgICAgICBtb2RlbHMgPSBbXG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2V0R3JvdXBlZFNlY3RvcihyZXNwb25kZXJzLCAnc2VsZWN0JyksXG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2V0UmFkaWFsQmFyU2VjdG9yTW9kZWxzRnJvbVJlc3BvbmRlcnMocmVzcG9uZGVycyksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vZGVscyA9IHRoaXMuZ2V0UmVzcG9uZGVyTW9kZWxzV2l0aFRoZW1lKHJlc3BvbmRlcnMsICdzZWxlY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVyU2VsZWN0ZWRTZXJpZXMnLCB7XG4gICAgICAgICAgICAgICAgbW9kZWxzLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBldmVudERldGVjdFR5cGU6IHRoaXMuZXZlbnREZXRlY3RUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmVzcG9uZGVyTW9kZWxzV2l0aFRoZW1lKHJlc3BvbmRlcnMsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgdGhlbWUgPSB0aGlzLnRoZW1lW3R5cGVdO1xuICAgICAgICBjb25zdCBsaW5lV2lkdGggPSB0aGVtZS5saW5lV2lkdGg7XG4gICAgICAgIGNvbnN0IGlzU2FtZUxpbmVXaWR0aCA9IHRoaXMudGhlbWUubGluZVdpZHRoID09PSBsaW5lV2lkdGg7XG4gICAgICAgIGNvbnN0IHRoaWNrbmVzcyA9IGlzU2FtZUxpbmVXaWR0aCA/IDAgOiBsaW5lV2lkdGggKiAwLjU7XG4gICAgICAgIHJldHVybiByZXNwb25kZXJzLm1hcCgobSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyBjb2xvcjogKF9iID0gKF9hID0gdGhlbWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2xvciwgKF9iICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG0uY29sb3IpKSwgbGluZVdpZHRoOiBsaW5lV2lkdGgsIHN0eWxlOiBbXG4gICAgICAgICAgICAgICAgICAgIHBpY2sodGhlbWUsICdzdHJva2VTdHlsZScsICdzaGFkb3dCbHVyJywgJ3NoYWRvd0NvbG9yJywgJ3NoYWRvd09mZnNldFgnLCAnc2hhZG93T2Zmc2V0WScpLFxuICAgICAgICAgICAgICAgIF0sIHJhZGl1czoge1xuICAgICAgICAgICAgICAgICAgICBpbm5lcjogTWF0aC5tYXgobS5yYWRpdXMuaW5uZXIgLSB0aGlja25lc3MsIDApLFxuICAgICAgICAgICAgICAgICAgICBvdXRlcjogbS5yYWRpdXMub3V0ZXIgKyB0aGlja25lc3MsXG4gICAgICAgICAgICAgICAgfSB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIi4vY29tcG9uZW50XCI7XG5pbXBvcnQgeyBnZXRSYWRpYWxQb3NpdGlvbiwgY2FsY3VsYXRlRGVncmVlVG9SYWRpYW4sIERFR1JFRV9ORUdBVElWRV85MCwgREVHUkVFXzM2MCwgY2FsY3VsYXRlVmFsaWRBbmdsZSwgREVHUkVFXzAsIH0gZnJvbSBcIi4uL2hlbHBlcnMvc2VjdG9yXCI7XG5pbXBvcnQgeyByYW5nZSB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBpc0xhYmVsQXhpc09uWUF4aXMgfSBmcm9tIFwiLi4vaGVscGVycy9heGVzXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGVNYXhMaW1pdFZhbHVlKHNjYWxlLCB0b3RhbEFuZ2xlKSB7XG4gICAgY29uc3QgeyBsaW1pdDogeyBtYXggfSwgc3RlcFNpemUsIH0gPSBzY2FsZTtcbiAgICByZXR1cm4gbWF4ICsgKHRvdGFsQW5nbGUgPCBERUdSRUVfMzYwID8gREVHUkVFXzAgOiBzdGVwU2l6ZSk7XG59XG5mdW5jdGlvbiBmaW5kQ2F0ZWdvcnlJbmRleChjYXRlZ29yaWVzLCB2YWx1ZSkge1xuICAgIHJldHVybiBjYXRlZ29yaWVzLmZpbmRJbmRleCgoY2F0ZWdvcnkpID0+IGNhdGVnb3J5ID09PSB2YWx1ZSk7XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRhclBsb3QgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1vZGVscyA9IHsgcGxvdDogW10sIGxpbmU6IFtdLCBiYW5kOiBbXSB9O1xuICAgIH1cbiAgICBpbml0aWFsaXplKGluaXRQYXJhbSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLnR5cGUgPSAncGxvdCc7XG4gICAgICAgIHRoaXMubmFtZSA9IChfYiA9IChfYSA9IGluaXRQYXJhbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUsIChfYiAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAncmFkaWFsUGxvdCcpKTtcbiAgICB9XG4gICAgcmVuZGVyKHN0YXRlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBjb25zdCB7IGxheW91dCwgcmFkaWFsQXhlcywgb3B0aW9ucywgc2VyaWVzLCB0aGVtZSwgc2NhbGUgfSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnJlY3QgPSBsYXlvdXQucGxvdDtcbiAgICAgICAgdGhpcy5jaXJjdWxhckF4aXNUaGVtZSA9IHRoZW1lLmNpcmN1bGFyQXhpcztcbiAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IChfYSA9IHN0YXRlLmNhdGVnb3JpZXMsIChfYSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkpO1xuICAgICAgICBpZiAodGhpcy5uYW1lID09PSAnZ2F1Z2UnKSB7XG4gICAgICAgICAgICBjb25zdCBiYW5kRGF0YSA9IChfZCA9IChfYyA9IChfYiA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wbG90KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYmFuZHMsIChfZCAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBbXSkpO1xuICAgICAgICAgICAgY29uc3QgaGFzQ2F0ZWdvcnlBeGlzID0gIWlzTGFiZWxBeGlzT25ZQXhpcyh7IHNlcmllcywgY2F0ZWdvcmllcyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSB0aGlzLm1ha2VSZW5kZXJPcHRpb25zT25HYXVnZShoYXNDYXRlZ29yeUF4aXMsIHJhZGlhbEF4ZXMuY2lyY3VsYXJBeGlzLCBjYXRlZ29yaWVzLCBzY2FsZSk7XG4gICAgICAgICAgICB0aGlzLm1vZGVscy5iYW5kID0gdGhpcy5yZW5kZXJCYW5kcyhiYW5kRGF0YSwgcmVuZGVyT3B0aW9ucywgY2F0ZWdvcmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpc1JhZGFyQ2hhcnQgPSAhIXNlcmllcy5yYWRhcjtcbiAgICAgICAgICAgIGNvbnN0IHBsb3RUeXBlID0gKF9mID0gKF9lID0gb3B0aW9ucy5wbG90KSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UudHlwZSwgKF9mICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IChpc1JhZGFyQ2hhcnQgPyAnc3BpZGVyd2ViJyA6ICdjaXJjbGUnKSkpO1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyT3B0aW9ucyA9IHRoaXMubWFrZVJlbmRlck9wdGlvbnMocmFkaWFsQXhlcywgcGxvdFR5cGUsIGNhdGVnb3JpZXMpO1xuICAgICAgICAgICAgdGhpcy5tb2RlbHMucGxvdCA9IHRoaXMucmVuZGVyUGxvdChyZW5kZXJPcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWxzLmxpbmUgPSBzZXJpZXMucmFkaWFsQmFyID8gdGhpcy5yZW5kZXJMaW5lKHJlbmRlck9wdGlvbnMpIDogW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWFrZVJlbmRlck9wdGlvbnNPbkdhdWdlKGhhc0NhdGVnb3J5QXhpcywgY2lyY3VsYXJBeGlzLCBjYXRlZ29yaWVzLCBzY2FsZSkge1xuICAgICAgICBjb25zdCB7IGFuZ2xlOiB7IHRvdGFsLCBzdGFydCB9LCByYWRpdXM6IHsgb3V0ZXIgfSwgY2xvY2t3aXNlLCBjZW50ZXJYLCBjZW50ZXJZLCB9ID0gY2lyY3VsYXJBeGlzO1xuICAgICAgICBjb25zdCB7IHdpZHRoOiBiYW5kV2lkdGgsIG1hcmdpbjogYmFuZE1hcmdpbiB9ID0gY2lyY3VsYXJBeGlzLmJhbmQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjZW50ZXJYLFxuICAgICAgICAgICAgY2VudGVyWSxcbiAgICAgICAgICAgIGNsb2Nrd2lzZSxcbiAgICAgICAgICAgIHRvdGFsQW5nbGU6IHRvdGFsLFxuICAgICAgICAgICAgc2NhbGVNYXhMaW1pdFZhbHVlOiBoYXNDYXRlZ29yeUF4aXNcbiAgICAgICAgICAgICAgICA/IGNhdGVnb3JpZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgOiBnZXRTY2FsZU1heExpbWl0VmFsdWUoc2NhbGUuY2lyY3VsYXJBeGlzLCB0b3RhbCksXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydCxcbiAgICAgICAgICAgIG91dGVyUmFkaXVzOiBvdXRlcixcbiAgICAgICAgICAgIGJhbmRXaWR0aCxcbiAgICAgICAgICAgIGJhbmRNYXJnaW4sXG4gICAgICAgICAgICBoYXNDYXRlZ29yeUF4aXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIG1ha2VSZW5kZXJPcHRpb25zKHJhZGlhbEF4ZXMsIHR5cGUsIGNhdGVnb3JpZXMgPSBbXSkge1xuICAgICAgICBjb25zdCB7IGNlbnRlclgsIGNlbnRlclksIHJhZGl1czogeyByYW5nZXMsIGlubmVyLCBvdXRlciB9LCB9ID0gcmFkaWFsQXhlcy52ZXJ0aWNhbEF4aXM7XG4gICAgICAgIGNvbnN0IHsgYW5nbGU6IHsgY2VudHJhbCwgdG90YWwsIHN0YXJ0LCBlbmQsIGRyYXdpbmdTdGFydCB9LCBsYWJlbDogeyBsYWJlbHMgfSwgdGlja0ludGVydmFsLCBjbG9ja3dpc2UsIH0gPSByYWRpYWxBeGVzLmNpcmN1bGFyQXhpcztcbiAgICAgICAgY29uc3QgdXNpbmdBcmNQbG90ID0gdG90YWwgIT09IERFR1JFRV8zNjA7XG4gICAgICAgIGNvbnN0IGxpbmVDb3VudCA9IGxhYmVscy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgY2F0ZWdvcmllcyxcbiAgICAgICAgICAgIGNlbnRyYWxBbmdsZTogY2VudHJhbCxcbiAgICAgICAgICAgIGNlbnRlclgsXG4gICAgICAgICAgICBjZW50ZXJZLFxuICAgICAgICAgICAgaW5pdGlhbFJhZGl1czogaW5uZXIsXG4gICAgICAgICAgICByYWRpdXM6IG91dGVyLFxuICAgICAgICAgICAgcmFkaXVzUmFuZ2VzOiByYW5nZXMsXG4gICAgICAgICAgICBsaW5lQ291bnQsXG4gICAgICAgICAgICB0aWNrSW50ZXJ2YWwsXG4gICAgICAgICAgICBkcmF3aW5nU3RhcnRBbmdsZTogZHJhd2luZ1N0YXJ0LFxuICAgICAgICAgICAgdXNpbmdBcmNQbG90LFxuICAgICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnQsXG4gICAgICAgICAgICBlbmRBbmdsZTogZW5kLFxuICAgICAgICAgICAgY2xvY2t3aXNlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXJQbG90KHJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCB1c2luZ0FyY1Bsb3QgfSA9IHJlbmRlck9wdGlvbnM7XG4gICAgICAgIGlmICh1c2luZ0FyY1Bsb3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VBcmMocmVuZGVyT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdzcGlkZXJ3ZWInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlU3BpZGVyd2ViUGxvdChyZW5kZXJPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYWtlQ2lyY2xlUGxvdChyZW5kZXJPcHRpb25zKTtcbiAgICB9XG4gICAgbWFrZVNwaWRlcndlYlBsb3QocmVuZGVyT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGNlbnRyYWxBbmdsZSwgY2VudGVyWCwgY2VudGVyWSwgY2F0ZWdvcmllcywgcmFkaXVzUmFuZ2VzIH0gPSByZW5kZXJPcHRpb25zO1xuICAgICAgICBjb25zdCB7IHN0cm9rZVN0eWxlLCBsaW5lV2lkdGggfSA9IHRoaXMuY2lyY3VsYXJBeGlzVGhlbWU7XG4gICAgICAgIHJldHVybiByYWRpdXNSYW5nZXMubWFwKChyYWRpdXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IGNhdGVnb3JpZXMubWFwKChfLCBpbmRleCkgPT4gZ2V0UmFkaWFsUG9zaXRpb24oY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzLCBjYWxjdWxhdGVEZWdyZWVUb1JhZGlhbihjZW50cmFsQW5nbGUgKiBpbmRleCkpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3BvbHlnb24nLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBzdHJva2VTdHlsZSxcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGgsXG4gICAgICAgICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1ha2VDaXJjbGVQbG90KHJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXNSYW5nZXMgfSA9IHJlbmRlck9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCB9ID0gdGhpcy5jaXJjdWxhckF4aXNUaGVtZTtcbiAgICAgICAgcmV0dXJuIHJhZGl1c1Jhbmdlcy5tYXAoKHJhZGl1cykgPT4gKHtcbiAgICAgICAgICAgIHR5cGU6ICdjaXJjbGUnLFxuICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDAsIDAsIDAsIDApJyxcbiAgICAgICAgICAgIHJhZGl1cyxcbiAgICAgICAgICAgIHg6IGNlbnRlclgsXG4gICAgICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHN0cm9rZVN0eWxlLFxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBtYWtlQXJjKHJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXNSYW5nZXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjbG9ja3dpc2UgfSA9IHJlbmRlck9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCB9ID0gdGhpcy5jaXJjdWxhckF4aXNUaGVtZTtcbiAgICAgICAgcmV0dXJuIHJhZGl1c1Jhbmdlcy5tYXAoKHJhZGl1cykgPT4gKHtcbiAgICAgICAgICAgIHR5cGU6ICdhcmMnLFxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBzdHJva2VTdHlsZSxcbiAgICAgICAgICAgIHg6IGNlbnRlclgsXG4gICAgICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICAgICAgYW5nbGU6IHsgc3RhcnQ6IHN0YXJ0QW5nbGUsIGVuZDogZW5kQW5nbGUgfSxcbiAgICAgICAgICAgIGRyYXdpbmdTdGFydEFuZ2xlOiBERUdSRUVfTkVHQVRJVkVfOTAsXG4gICAgICAgICAgICByYWRpdXMsXG4gICAgICAgICAgICBjbG9ja3dpc2UsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmVuZGVyTGluZShyZW5kZXJPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgY2VudGVyWCwgY2VudGVyWSwgaW5pdGlhbFJhZGl1cywgcmFkaXVzLCBsaW5lQ291bnQsIGNlbnRyYWxBbmdsZSwgdGlja0ludGVydmFsLCBkcmF3aW5nU3RhcnRBbmdsZSwgY2xvY2t3aXNlLCB9ID0gcmVuZGVyT3B0aW9ucztcbiAgICAgICAgY29uc3QgeyBzdHJva2VTdHlsZSwgbGluZVdpZHRoIH0gPSB0aGlzLmNpcmN1bGFyQXhpc1RoZW1lO1xuICAgICAgICByZXR1cm4gcmFuZ2UoMCwgbGluZUNvdW50KS5yZWR1Y2UoKGFjYywgY3VyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnREZWdyZWUgPSBkcmF3aW5nU3RhcnRBbmdsZSArIGNlbnRyYWxBbmdsZSAqIGluZGV4ICogKGNsb2Nrd2lzZSA/IDEgOiAtMSk7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGdldFJhZGlhbFBvc2l0aW9uKGNlbnRlclgsIGNlbnRlclksIGluaXRpYWxSYWRpdXMsIGNhbGN1bGF0ZURlZ3JlZVRvUmFkaWFuKHN0YXJ0RGVncmVlKSk7XG4gICAgICAgICAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gZ2V0UmFkaWFsUG9zaXRpb24oY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzLCBjYWxjdWxhdGVEZWdyZWVUb1JhZGlhbihzdGFydERlZ3JlZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4ICUgdGlja0ludGVydmFsID09PSAwXG4gICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgICAgICB4MixcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIDogYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIHJlbmRlckJhbmRzKGJhbmRzLCByZW5kZXJPcHRpb25zLCBjYXRlZ29yaWVzKSB7XG4gICAgICAgIGNvbnN0IHNlY3RvcnMgPSBbXTtcbiAgICAgICAgY29uc3QgeyBjZW50ZXJYLCBjZW50ZXJZLCBjbG9ja3dpc2UsIHRvdGFsQW5nbGUsIHNjYWxlTWF4TGltaXRWYWx1ZSwgc3RhcnRBbmdsZSwgb3V0ZXJSYWRpdXMsIGJhbmRXaWR0aCwgYmFuZE1hcmdpbiwgaGFzQ2F0ZWdvcnlBeGlzLCB9ID0gcmVuZGVyT3B0aW9ucztcbiAgICAgICAgYmFuZHMuZm9yRWFjaCgoeyByYW5nZTogcmFuZ2VEYXRhLCBjb2xvciB9LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBoYXNDYXRlZ29yeUF4aXNcbiAgICAgICAgICAgICAgICA/IGZpbmRDYXRlZ29yeUluZGV4KGNhdGVnb3JpZXMsIHJhbmdlRGF0YVsxXS50b1N0cmluZygpKSAtXG4gICAgICAgICAgICAgICAgICAgIGZpbmRDYXRlZ29yeUluZGV4KGNhdGVnb3JpZXMsIHJhbmdlRGF0YVswXS50b1N0cmluZygpKVxuICAgICAgICAgICAgICAgIDogTnVtYmVyKHJhbmdlRGF0YVsxXSkgLSBOdW1iZXIocmFuZ2VEYXRhWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IGRlZ3JlZSA9ICh2YWx1ZSAvIHNjYWxlTWF4TGltaXRWYWx1ZSkgKiB0b3RhbEFuZ2xlICogKGNsb2Nrd2lzZSA/IDEgOiAtMSk7XG4gICAgICAgICAgICBjb25zdCB2YWxpZERlZ3JlZSA9IGNhbGN1bGF0ZVZhbGlkQW5nbGUoZGVncmVlKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZNb2RlbCA9IHNlY3RvcnNbc2VjdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0RGVncmVlID0gaW5kZXggJiYgcHJldk1vZGVsID8gcHJldk1vZGVsLmRlZ3JlZS5lbmQgOiBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgY29uc3QgZW5kRGVncmVlID0gY2FsY3VsYXRlVmFsaWRBbmdsZShzdGFydERlZ3JlZSArIHZhbGlkRGVncmVlKTtcbiAgICAgICAgICAgIHNlY3RvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NlY3RvcicsXG4gICAgICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgIGNsb2Nrd2lzZSxcbiAgICAgICAgICAgICAgICBkZWdyZWU6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0RGVncmVlLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZERlZ3JlZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJhZGl1czoge1xuICAgICAgICAgICAgICAgICAgICBpbm5lcjogb3V0ZXJSYWRpdXMgKyBiYW5kTWFyZ2luLFxuICAgICAgICAgICAgICAgICAgICBvdXRlcjogb3V0ZXJSYWRpdXMgKyBiYW5kV2lkdGgsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlY3RvcnM7XG4gICAgfVxufVxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi9jb21wb25lbnRcIjtcbmltcG9ydCB7IGlzTnVsbCwgcmFuZ2UgfSBmcm9tIFwiLi4vaGVscGVycy91dGlsc1wiO1xuaW1wb3J0IHsgc29ydE51bWJlciB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBtYWtlT2JzZXJ2YWJsZU9iamVjdFRvTm9ybWFsIH0gZnJvbSBcIi4uL3N0b3JlL3JlYWN0aXZlXCI7XG5pbXBvcnQgeyBnZXRDb29yZGluYXRlRGF0YUluZGV4LCBnZXRDb29yZGluYXRlWFZhbHVlLCBpc0Nvb3JkaW5hdGVTZXJpZXMsIH0gZnJvbSBcIi4uL2hlbHBlcnMvY29vcmRpbmF0ZVwiO1xuaW1wb3J0IHsgZ2V0WFBvc2l0aW9uIH0gZnJvbSBcIi4uL2hlbHBlcnMvY2FsY3VsYXRvclwiO1xuaW1wb3J0IHsgbWFrZVJlY3RSZXNwb25kZXJNb2RlbEZvckNvb3JkaW5hdGVUeXBlLCB9IGZyb20gXCIuLi9oZWxwZXJzL3Jlc3BvbmRlcnNcIjtcbmNvbnN0IERSQUdfTUlOX1dJRFRIID0gMTU7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYW5nZVNlbGVjdGlvbiBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubW9kZWxzID0geyBzZWxlY3Rpb25BcmVhOiBbXSB9O1xuICAgICAgICB0aGlzLmRyYWdTdGFydFBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnU3RhcnRQb2ludCA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAncmFuZ2VTZWxlY3Rpb24nO1xuICAgIH1cbiAgICByZW5kZXIoc3RhdGUsIGNvbXB1dGVkKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghc3RhdGUuc2VsZWN0aW9uUmFuZ2UgJiYgIXN0YXRlLnpvb21SYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzZXRTZWxlY3Rpb25BcmVhKCk7XG4gICAgICAgIGNvbnN0IHsgdmlld1JhbmdlIH0gPSBjb21wdXRlZDtcbiAgICAgICAgY29uc3QgeyBsYXlvdXQsIGF4ZXMsIHNlcmllcywgc2NhbGUgfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gc3RhdGUuY2F0ZWdvcmllcztcbiAgICAgICAgdGhpcy5yZWN0ID0gbGF5b3V0LnBsb3Q7XG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IChfYiA9IChfYSA9IHZpZXdSYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdLCAoX2IgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkpO1xuICAgICAgICBjb25zdCBjb29yZGluYXRlQ2hhcnQgPSBpc0Nvb3JkaW5hdGVTZXJpZXMoc2VyaWVzKTtcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVDaGFydCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uZGVySW5mbyA9IHRoaXMuZ2V0UmVjdFJlc3BvbmRlckluZm9Gb3JDb29yZGluYXRlVHlwZShzZXJpZXMsIHNjYWxlLCBheGVzLnhBeGlzLCBjYXRlZ29yaWVzKTtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uZGVycyA9IHRoaXMubWFrZVJlY3RSZXNwb25kZXJNb2RlbEZvckNvb3JkaW5hdGVUeXBlKHJlc3BvbmRlckluZm8sIGNhdGVnb3JpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXNwb25kZXJzID0gdGhpcy5tYWtlUmVjdFJlc3BvbmRlck1vZGVsKGNhdGVnb3JpZXMsIGF4ZXMueEF4aXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJlY3RSZXNwb25kZXJJbmZvRm9yQ29vcmRpbmF0ZVR5cGUoc2VyaWVzLCBzY2FsZSwgYXhpc0RhdGEsIGNhdGVnb3JpZXMpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgIGNvbnN0IGR1cGxpY2F0ZUNoZWNrTWFwID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHNlcmllcykuZm9yRWFjaCgoc2VyaWVzTmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHNlcmllc1tzZXJpZXNOYW1lXS5kYXRhO1xuICAgICAgICAgICAgZGF0YS5mb3JFYWNoKCh7IHJhd0RhdGEgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJhd0RhdGEuZm9yRWFjaCgoZGF0dW0sIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGRhdHVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFJbmRleCA9IGdldENvb3JkaW5hdGVEYXRhSW5kZXgoZGF0dW0sIGNhdGVnb3JpZXMsIGlkeCwgdGhpcy5zdGFydEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IGdldFhQb3NpdGlvbihheGlzRGF0YSwgdGhpcy5yZWN0LndpZHRoLCBnZXRDb29yZGluYXRlWFZhbHVlKGRhdHVtKSwgZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeFdpdGhpblJlY3QgPSB4ID49IDAgJiYgeCA8PSB0aGlzLnJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZHVwbGljYXRlQ2hlY2tNYXBbeF0gJiYgeFdpdGhpblJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cGxpY2F0ZUNoZWNrTWFwW3hdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHsgeCwgbGFiZWw6IGNhdGVnb3JpZXNbZGF0YUluZGV4XSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cbiAgICByZXNldFNlbGVjdGlvbkFyZWEoKSB7XG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmRyYWdTdGFydFBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb2RlbHMuc2VsZWN0aW9uQXJlYSA9IFtdO1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgb25Nb3VzZWRvd24oeyByZXNwb25kZXJzLCBtb3VzZVBvc2l0aW9uIH0pIHtcbiAgICAgICAgaWYgKHJlc3BvbmRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdTdGFydFBvaW50ID0gcmVzcG9uZGVycy5maW5kKChyZXNwb25kZXIpID0+IHJlc3BvbmRlci5kYXRhLm5hbWUgPT09ICdzZWxlY3Rpb25BcmVhJyk7XG4gICAgICAgICAgICB0aGlzLmRyYWdTdGFydFBvc2l0aW9uID0gbW91c2VQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbk1vdXNldXAoeyByZXNwb25kZXJzIH0pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZyAmJiB0aGlzLmRyYWdTdGFydFBvaW50ICYmIHJlc3BvbmRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBkcmFnUmFuZ2UgPSBbdGhpcy5kcmFnU3RhcnRQb2ludCwgcmVzcG9uZGVyc1swXV1cbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5pbmRleCAtIGIuaW5kZXgpXG4gICAgICAgICAgICAgICAgLm1hcCgobSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBtLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZTsgfSk7XG4gICAgICAgICAgICBjb25zdCB7IHNlcmllcywgb3B0aW9ucyB9ID0gdGhpcy5zdG9yZS5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VyaWVzOiBzZXJpZXNPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgaWYgKCFzZXJpZXMuY29sdW1uICYmICgoX2EgPSBzZXJpZXNPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euem9vbWFibGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgnem9vbScsIGRyYWdSYW5nZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCd6b29tJywgbWFrZU9ic2VydmFibGVPYmplY3RUb05vcm1hbChkcmFnUmFuZ2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoX2IgPSBzZXJpZXNPcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmFuZ2VTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyYW5nZVNlbGVjdGlvbicsIGRyYWdSYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Jlc2V0SG92ZXJlZFNlcmllcycpO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdoaWRlVG9vbHRpcCcpO1xuICAgICAgICAgICAgLy8gQFRPRE86IFNob3VsZCBvY2N1ciBhZnRlciB0aGUgc2VyaWVzJyBjbGljayBldmVudFxuICAgICAgICAgICAgLy8gQWRkaXRpb25hbCBsb2dpYyB0byBjb250cm9sIHRoZSBzZXF1ZW5jZSBvZiBldmVudHMgd2l0aCBlYWNoIG90aGVyIGlzIHJlcXVpcmVkLlxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZXNldFNlbGVjdGVkU2VyaWVzJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uQXJlYSgpO1xuICAgIH1cbiAgICBtYWtlUmVjdFJlc3BvbmRlck1vZGVsKGNhdGVnb3JpZXMsIGF4aXNEYXRhKSB7XG4gICAgICAgIGNvbnN0IGNhdGVnb3J5U2l6ZSA9IGNhdGVnb3JpZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCB7IHBvaW50T25Db2x1bW4sIHRpY2tEaXN0YW5jZSB9ID0gYXhpc0RhdGE7XG4gICAgICAgIGNvbnN0IHsgaGVpZ2h0IH0gPSB0aGlzLnJlY3Q7XG4gICAgICAgIGNvbnN0IGhhbGZEZXRlY3RBcmVhSW5kZXggPSBwb2ludE9uQ29sdW1uID8gW10gOiBbMCwgY2F0ZWdvcnlTaXplIC0gMV07XG4gICAgICAgIGNvbnN0IGhhbGZXaWR0aCA9IHRpY2tEaXN0YW5jZSAvIDI7XG4gICAgICAgIHJldHVybiByYW5nZSgwLCBjYXRlZ29yeVNpemUpLm1hcCgoaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhbGYgPSBoYWxmRGV0ZWN0QXJlYUluZGV4LmluY2x1ZGVzKGluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gaGFsZiA/IGhhbGZXaWR0aCA6IHRpY2tEaXN0YW5jZTtcbiAgICAgICAgICAgIGxldCBzdGFydFggPSAwO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRYICs9IHBvaW50T25Db2x1bW4gPyB0aWNrRGlzdGFuY2UgKiBpbmRleCA6IGhhbGZXaWR0aCArIHRpY2tEaXN0YW5jZSAqIChpbmRleCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmVjdCcsXG4gICAgICAgICAgICAgICAgeDogc3RhcnRYLFxuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGRhdGE6IHsgbmFtZTogJ3NlbGVjdGlvbkFyZWEnLCB2YWx1ZTogY2F0ZWdvcmllc1tpbmRleF0gfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYWtlUmVjdFJlc3BvbmRlck1vZGVsRm9yQ29vcmRpbmF0ZVR5cGUocmVzcG9uZGVySW5mbywgY2F0ZWdvcmllcykge1xuICAgICAgICBjb25zdCByZXNwb25kZXJzID0gbWFrZVJlY3RSZXNwb25kZXJNb2RlbEZvckNvb3JkaW5hdGVUeXBlKHJlc3BvbmRlckluZm8sIHRoaXMucmVjdCk7XG4gICAgICAgIHJldHVybiByZXNwb25kZXJzLm1hcCgobSwgaWR4KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyBkYXRhOiB7IG5hbWU6ICdzZWxlY3Rpb25BcmVhJywgdmFsdWU6IGNhdGVnb3JpZXNbaWR4XSB9IH0pKSk7XG4gICAgfVxuICAgIG9uTW91c2Vtb3ZlKHsgcmVzcG9uZGVycywgbW91c2VQb3NpdGlvbiB9KSB7XG4gICAgICAgIGlmICghcmVzcG9uZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kcmFnU3RhcnRQb3NpdGlvbiAmJiAhdGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICBjb25zdCB7IHggfSA9IG1vdXNlUG9zaXRpb247XG4gICAgICAgICAgICBjb25zdCB7IHg6IHN0YXJ0WCB9ID0gdGhpcy5kcmFnU3RhcnRQb3NpdGlvbjtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IE1hdGguYWJzKHN0YXJ0WCAtIHgpID4gRFJBR19NSU5fV0lEVEg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IHRoaXMuZHJhZ1N0YXJ0UG9pbnQuaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBlbmRJbmRleCA9IHJlc3BvbmRlcnNbMF0uaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBbc3RhcnRJbmRleCwgZW5kSW5kZXhdLnNvcnQoc29ydE51bWJlcik7XG4gICAgICAgICAgICBjb25zdCBpbmNsdWRlZFJlc3BvbmRlcnMgPSB0aGlzLnJlc3BvbmRlcnMuc2xpY2Uoc3RhcnQsIGVuZCArIDEpO1xuICAgICAgICAgICAgdGhpcy5tb2RlbHMuc2VsZWN0aW9uQXJlYSA9IFtcbiAgICAgICAgICAgICAgICAuLi5pbmNsdWRlZFJlc3BvbmRlcnMubWFwKChtKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyB4OiBtLngsIHk6IDAsIHR5cGU6ICdyZWN0JywgY29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMiknIH0pKSksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCduZWVkRHJhdycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uTW91c2VvdXRDb21wb25lbnQoKSB7XG4gICAgICAgIHRoaXMucmVzZXRTZWxlY3Rpb25BcmVhKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi9jb21wb25lbnRcIjtcbmltcG9ydCB7IGlzVXNpbmdSZXNldEJ1dHRvbiB9IGZyb20gXCIuLi9zdG9yZS9sYXlvdXRcIjtcbmltcG9ydCB7IEJVVFRPTl9SRUNUX1NJWkUgfSBmcm9tIFwiLi9leHBvcnRNZW51XCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXNldEJ1dHRvbiBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ3Jlc2V0QnV0dG9uJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ3Jlc2V0QnV0dG9uJztcbiAgICB9XG4gICAgb25DbGljayh7IHJlc3BvbmRlcnMgfSkge1xuICAgICAgICBpZiAocmVzcG9uZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVzZXRab29tJyk7XG4gICAgICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdyZXNldFpvb20nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoeyBvcHRpb25zLCBsYXlvdXQgfSwgY29tcHV0ZWQpIHtcbiAgICAgICAgaWYgKCFpc1VzaW5nUmVzZXRCdXR0b24ob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlY3QgPSBsYXlvdXQucmVzZXRCdXR0b247XG4gICAgICAgIHRoaXMuaXNTaG93ID0gY29tcHV0ZWQuaXNMaW5lVHlwZVNlcmllc1pvb21pbmc7XG4gICAgICAgIHRoaXMubW9kZWxzID0gdGhpcy5pc1Nob3cgPyBbeyB0eXBlOiAncmVzZXRCdXR0b24nLCB4OiAwLCB5OiAwIH1dIDogW107XG4gICAgICAgIHRoaXMucmVzcG9uZGVycyA9IHRoaXMuaXNTaG93XG4gICAgICAgICAgICA/IFt7IHR5cGU6ICdyZWN0JywgeDogMCwgeTogMCwgd2lkdGg6IEJVVFRPTl9SRUNUX1NJWkUsIGhlaWdodDogQlVUVE9OX1JFQ1RfU0laRSB9XVxuICAgICAgICAgICAgOiBbXTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuL2NvbXBvbmVudFwiO1xuaW1wb3J0IHsgZ2V0Q29vcmRpbmF0ZVhWYWx1ZSwgZ2V0Q29vcmRpbmF0ZVlWYWx1ZSB9IGZyb20gXCIuLi9oZWxwZXJzL2Nvb3JkaW5hdGVcIjtcbmltcG9ydCB7IGdldFJHQkEgfSBmcm9tIFwiLi4vaGVscGVycy9jb2xvclwiO1xuaW1wb3J0IHsgZ2V0VmFsdWVSYXRpbyB9IGZyb20gXCIuLi9oZWxwZXJzL2NhbGN1bGF0b3JcIjtcbmltcG9ydCB7IGRlZXBDb3B5LCBkZWVwTWVyZ2VkQ29weSwgaXNOdW1iZXIsIGlzU3RyaW5nLCBwaWNrIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmltcG9ydCB7IGdldEFjdGl2ZVNlcmllc01hcCB9IGZyb20gXCIuLi9oZWxwZXJzL2xlZ2VuZFwiO1xuaW1wb3J0IHsgZ2V0VmFsdWVBeGlzTmFtZSB9IGZyb20gXCIuLi9oZWxwZXJzL2F4ZXNcIjtcbmltcG9ydCB7IGdldE5lYXJlc3RSZXNwb25kZXIgfSBmcm9tIFwiLi4vaGVscGVycy9yZXNwb25kZXJzXCI7XG5pbXBvcnQgeyBtZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2VcIjtcbmltcG9ydCB7IGlzQXZhaWxhYmxlU2VsZWN0U2VyaWVzIH0gZnJvbSBcIi4uL2hlbHBlcnMvdmFsaWRhdGlvblwiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NhdHRlclNlcmllcyBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubW9kZWxzID0geyBzZXJpZXM6IFtdIH07XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IFtdO1xuICAgICAgICB0aGlzLm9uTW91c2VvdXRDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nlcmllc1BvaW50SG92ZXJlZCcsIHsgbW9kZWxzOiBbXSwgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJIb3ZlcmVkU2VyaWVzJywge1xuICAgICAgICAgICAgICAgIG1vZGVsczogW10sXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0TW9kZWxzRm9yU2VsZWN0SW5mbyA9IChpbmZvKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGluZGV4LCBzZXJpZXNJbmRleCwgc3RhdGUgfSA9IGluZm87XG4gICAgICAgICAgICBpZiAoIWlzTnVtYmVyKGluZGV4KSB8fCAhaXNOdW1iZXIoc2VyaWVzSW5kZXgpIHx8ICFpc0F2YWlsYWJsZVNlbGVjdFNlcmllcyhpbmZvLCAnc2NhdHRlcicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBuYW1lIH0gPSBzdGF0ZS5zZXJpZXMuc2NhdHRlci5kYXRhW3Nlcmllc0luZGV4XTtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5yZXNwb25kZXJzLmZpbHRlcigoeyBuYW1lOiBkYXRhTmFtZSB9KSA9PiBkYXRhTmFtZSA9PT0gbmFtZSlbaW5kZXhdXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZWxlY3RTZXJpZXMgPSAoaW5mbykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxzID0gdGhpcy5nZXRNb2RlbHNGb3JTZWxlY3RJbmZvKGluZm8pO1xuICAgICAgICAgICAgaWYgKCFtb2RlbHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjbG9zZXN0TW9kZWwgPSB0aGlzLmdldENsb3Nlc3RNb2RlbChtb2RlbHMpO1xuICAgICAgICAgICAgaWYgKCFtb2RlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UuU0VMRUNUX1NFUklFU19BUElfSU5ERVhfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJTZWxlY3RlZFNlcmllcycsIHtcbiAgICAgICAgICAgICAgICBtb2RlbHM6IHRoaXMuZ2V0UmVzcG9uZGVyQXBwbGllZFRoZW1lKGNsb3Nlc3RNb2RlbCwgJ3NlbGVjdCcpLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCduZWVkRHJhdycpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNob3dUb29sdGlwID0gKGluZm8pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVscyA9IHRoaXMuZ2V0TW9kZWxzRm9yU2VsZWN0SW5mbyhpbmZvKTtcbiAgICAgICAgICAgIGlmICghbW9kZWxzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJIb3ZlcmVkU2VyaWVzJywgeyBtb2RlbHMsIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IG1vZGVscztcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnc2VyaWVzUG9pbnRIb3ZlcmVkJywgeyBtb2RlbHM6IHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycywgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCduZWVkRHJhdycpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnc2VyaWVzJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ3NjYXR0ZXInO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLm9uKCdzZWxlY3RTZXJpZXMnLCB0aGlzLnNlbGVjdFNlcmllcyk7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMub24oJ3Nob3dUb29sdGlwJywgdGhpcy5zaG93VG9vbHRpcCk7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMub24oJ2hpZGVUb29sdGlwJywgdGhpcy5vbk1vdXNlb3V0Q29tcG9uZW50KTtcbiAgICB9XG4gICAgaW5pdFVwZGF0ZShkZWx0YSkge1xuICAgICAgICB0aGlzLmRyYXdNb2RlbHMuc2VyaWVzLmZvckVhY2goKG1vZGVsLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbW9kZWwuc2l6ZSA9IHRoaXMubW9kZWxzLnNlcmllc1tpbmRleF0uc2l6ZSAqIGRlbHRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVuZGVyKGNoYXJ0U3RhdGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgeyBsYXlvdXQsIHNlcmllcywgc2NhbGUsIGxlZ2VuZCwgb3B0aW9ucywgdGhlbWUsIGF4ZXMgfSA9IGNoYXJ0U3RhdGU7XG4gICAgICAgIGlmICghc2VyaWVzLnNjYXR0ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlLm5vRGF0YUVycm9yKHRoaXMubmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjYXR0ZXJEYXRhID0gc2VyaWVzLnNjYXR0ZXIuZGF0YTtcbiAgICAgICAgdGhpcy50aGVtZSA9IHRoZW1lLnNlcmllcy5zY2F0dGVyO1xuICAgICAgICB0aGlzLnJlY3QgPSBsYXlvdXQucGxvdDtcbiAgICAgICAgdGhpcy5hY3RpdmVTZXJpZXNNYXAgPSBnZXRBY3RpdmVTZXJpZXNNYXAobGVnZW5kKTtcbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlID0gdGhpcy5nZXRTZWxlY3RhYmxlT3B0aW9uKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBsaW1pdCA9IChfYiA9IChfYSA9IGF4ZXMueEF4aXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYWJlbFJhbmdlLCAoX2IgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogc2NhbGUueEF4aXMubGltaXQpKTsgLy8gbGFiZWxSYW5nZSBpcyBjcmVhdGVkIG9ubHkgZm9yIGxpbmUgc2NhdHRlciBjaGFydHNcbiAgICAgICAgY29uc3Qgc2VyaWVzTW9kZWwgPSB0aGlzLnJlbmRlclNjYXR0ZXJQb2ludHNNb2RlbChzY2F0dGVyRGF0YSwgbGltaXQsIHNjYWxlW2dldFZhbHVlQXhpc05hbWUob3B0aW9ucywgdGhpcy5uYW1lLCAneUF4aXMnKV0ubGltaXQpO1xuICAgICAgICBjb25zdCB0b29sdGlwTW9kZWwgPSB0aGlzLm1ha2VUb29sdGlwTW9kZWwoc2NhdHRlckRhdGEpO1xuICAgICAgICB0aGlzLm1vZGVscy5zZXJpZXMgPSBzZXJpZXNNb2RlbDtcbiAgICAgICAgaWYgKCF0aGlzLmRyYXdNb2RlbHMpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd01vZGVscyA9IGRlZXBDb3B5KHRoaXMubW9kZWxzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc3BvbmRlcnMgPSBzZXJpZXNNb2RlbC5tYXAoKG0sIGluZGV4KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyB0eXBlOiAnY2lyY2xlJywgZGV0ZWN0aW9uU2l6ZTogMCwgcmFkaXVzOiB0aGlzLnRoZW1lLnNpemUgLyAyLCBjb2xvcjogbS5maWxsQ29sb3IsIHN0eWxlOiBbeyBzdHJva2VTdHlsZTogbS5ib3JkZXJDb2xvciwgbGluZVdpZHRoOiBtLmJvcmRlcldpZHRoIH1dLCBkYXRhOiB0b29sdGlwTW9kZWxbaW5kZXhdIH0pKSk7XG4gICAgfVxuICAgIHJlbmRlclNjYXR0ZXJQb2ludHNNb2RlbChzZXJpZXNSYXdEYXRhLCB4QXhpc0xpbWl0LCB5QXhpc0xpbWl0KSB7XG4gICAgICAgIHJldHVybiBzZXJpZXNSYXdEYXRhLmZsYXRNYXAoKHsgZGF0YSwgbmFtZSwgY29sb3I6IHNlcmllc0NvbG9yLCBpY29uVHlwZSB9LCBzZXJpZXNJbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxzID0gW107XG4gICAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmFjdGl2ZVNlcmllc01hcFtuYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gZ2V0UkdCQShzZXJpZXNDb2xvciwgYWN0aXZlID8gMSA6IDAuMyk7XG4gICAgICAgICAgICBkYXRhLmZvckVhY2goKGRhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhd1hWYWx1ZSA9IGdldENvb3JkaW5hdGVYVmFsdWUoZGF0dW0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHhWYWx1ZSA9IGlzU3RyaW5nKHJhd1hWYWx1ZSkgPyBOdW1iZXIobmV3IERhdGUocmF3WFZhbHVlKSkgOiBOdW1iZXIocmF3WFZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5VmFsdWUgPSBnZXRDb29yZGluYXRlWVZhbHVlKGRhdHVtKTtcbiAgICAgICAgICAgICAgICBjb25zdCB4VmFsdWVSYXRpbyA9IGdldFZhbHVlUmF0aW8oeFZhbHVlLCB4QXhpc0xpbWl0KTtcbiAgICAgICAgICAgICAgICBjb25zdCB5VmFsdWVSYXRpbyA9IGdldFZhbHVlUmF0aW8oeVZhbHVlLCB5QXhpc0xpbWl0KTtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0geFZhbHVlUmF0aW8gKiB0aGlzLnJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9ICgxIC0geVZhbHVlUmF0aW8pICogdGhpcy5yZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICBtb2RlbHMucHVzaChPYmplY3QuYXNzaWduKHsgeCxcbiAgICAgICAgICAgICAgICAgICAgeSwgdHlwZTogJ3NjYXR0ZXJTZXJpZXMnLCBpY29uVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsIGJvcmRlckNvbG9yOiBjb2xvciwgaW5kZXggfSwgcGljayh0aGlzLnRoZW1lLCAnYm9yZGVyV2lkdGgnLCAnc2l6ZScsICdmaWxsQ29sb3InKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWxzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFrZVRvb2x0aXBNb2RlbChjaXJjbGVEYXRhKSB7XG4gICAgICAgIHJldHVybiBbLi4uY2lyY2xlRGF0YV0uZmxhdE1hcCgoeyBkYXRhLCBuYW1lLCBjb2xvciB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0b29sdGlwRGF0YSA9IFtdO1xuICAgICAgICAgICAgZGF0YS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBnZXRDb29yZGluYXRlWFZhbHVlKGRhdHVtKSxcbiAgICAgICAgICAgICAgICAgICAgeTogZ2V0Q29vcmRpbmF0ZVlWYWx1ZShkYXR1bSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0b29sdGlwRGF0YS5wdXNoKHsgbGFiZWw6IG5hbWUsIGNvbG9yLCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRvb2x0aXBEYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q2xvc2VzdE1vZGVsKGNsb3Nlc3RSZXNwb25kZXIpIHtcbiAgICAgICAgaWYgKCFjbG9zZXN0UmVzcG9uZGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5tb2RlbHMuc2VyaWVzLmZpbmQoKHsgaW5kZXgsIHNlcmllc0luZGV4IH0pID0+IGlzTnVtYmVyKGluZGV4KSAmJlxuICAgICAgICAgICAgaXNOdW1iZXIoc2VyaWVzSW5kZXgpICYmXG4gICAgICAgICAgICBpbmRleCA9PT0gY2xvc2VzdFJlc3BvbmRlclswXS5pbmRleCAmJlxuICAgICAgICAgICAgc2VyaWVzSW5kZXggPT09IGNsb3Nlc3RSZXNwb25kZXJbMF0uc2VyaWVzSW5kZXgpO1xuICAgICAgICByZXR1cm4gbW9kZWwgPyBbbW9kZWxdIDogW107XG4gICAgfVxuICAgIGdldFJlc3BvbmRlckFwcGxpZWRUaGVtZShjbG9zZXN0TW9kZWwsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgeyBmaWxsQ29sb3IsIHNpemUgfSA9IHRoaXMudGhlbWVbdHlwZV07XG4gICAgICAgIHJldHVybiBjbG9zZXN0TW9kZWwubWFwKChtKSA9PiBkZWVwTWVyZ2VkQ29weShtLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMudGhlbWVbdHlwZV0pLCB7IGNvbG9yOiBmaWxsQ29sb3IsIHJhZGl1czogc2l6ZSAvIDIgfSkpKTtcbiAgICB9XG4gICAgb25Nb3VzZW1vdmUoeyByZXNwb25kZXJzLCBtb3VzZVBvc2l0aW9uIH0pIHtcbiAgICAgICAgY29uc3QgY2xvc2VzdFJlc3BvbmRlciA9IGdldE5lYXJlc3RSZXNwb25kZXIocmVzcG9uZGVycywgbW91c2VQb3NpdGlvbiwgdGhpcy5yZWN0KTtcbiAgICAgICAgbGV0IGNsb3Nlc3RNb2RlbCA9IHRoaXMuZ2V0Q2xvc2VzdE1vZGVsKGNsb3Nlc3RSZXNwb25kZXIpO1xuICAgICAgICBjbG9zZXN0TW9kZWwgPSB0aGlzLmdldFJlc3BvbmRlckFwcGxpZWRUaGVtZShjbG9zZXN0TW9kZWwsICdob3ZlcicpO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlckhvdmVyZWRTZXJpZXMnLCB7IG1vZGVsczogY2xvc2VzdE1vZGVsLCBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycyA9IGNsb3Nlc3RSZXNwb25kZXI7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnc2VyaWVzUG9pbnRIb3ZlcmVkJywgeyBtb2RlbHM6IHRoaXMuYWN0aXZhdGVkUmVzcG9uZGVycywgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ25lZWREcmF3Jyk7XG4gICAgfVxuICAgIG9uQ2xpY2soeyByZXNwb25kZXJzLCBtb3VzZVBvc2l0aW9uIH0pIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgY29uc3QgY2xvc2VzdFJlc3BvbmRlciA9IGdldE5lYXJlc3RSZXNwb25kZXIocmVzcG9uZGVycywgbW91c2VQb3NpdGlvbiwgdGhpcy5yZWN0KTtcbiAgICAgICAgICAgIGxldCBjbG9zZXN0TW9kZWwgPSB0aGlzLmdldENsb3Nlc3RNb2RlbChjbG9zZXN0UmVzcG9uZGVyKTtcbiAgICAgICAgICAgIGNsb3Nlc3RNb2RlbCA9IHRoaXMuZ2V0UmVzcG9uZGVyQXBwbGllZFRoZW1lKGNsb3Nlc3RNb2RlbCwgJ3NlbGVjdCcpO1xuICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJTZWxlY3RlZFNlcmllcycsIHtcbiAgICAgICAgICAgICAgICBtb2RlbHM6IGNsb3Nlc3RNb2RlbCxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIi4vY29tcG9uZW50XCI7XG5pbXBvcnQgeyBpbmNsdWRlcyB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBpc1NhbWVTZXJpZXNSZXNwb25kZXIgfSBmcm9tIFwiLi4vaGVscGVycy9yZXNwb25kZXJzXCI7XG5pbXBvcnQgeyBtYWtlT2JzZXJ2YWJsZU9iamVjdFRvTm9ybWFsIH0gZnJvbSBcIi4uL3N0b3JlL3JlYWN0aXZlXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWxlY3RlZFNlcmllcyBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubW9kZWxzID0ge307XG4gICAgICAgIHRoaXMuc2VyaWVzTW9kZWxzID0ge307XG4gICAgICAgIHRoaXMuYWN0aXZlU2VyaWVzTmFtZXMgPSB7fTtcbiAgICAgICAgdGhpcy5pc1Nob3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW5kZXJTZWxlY3RlZFNlcmllcyA9IChzZWxlY3RlZFNlcmllc0V2ZW50TW9kZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgYWxpYXMgfSA9IHNlbGVjdGVkU2VyaWVzRXZlbnRNb2RlbDtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVscyA9IHRoaXMuZ2V0U2VsZWN0ZWRTZXJpZXNNb2RlbHNGb3JSZW5kZXJpbmcoc2VsZWN0ZWRTZXJpZXNFdmVudE1vZGVsKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWxzW2FsaWFzIHx8IG5hbWVdID0gaXNTYW1lU2VyaWVzUmVzcG9uZGVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VsZWN0ZWRTZXJpZXNFdmVudE1vZGVsKSwgeyBtb2RlbHMsIGNvbXBhcmlzb25Nb2RlbDogdGhpcy5tb2RlbHNbYWxpYXMgfHwgbmFtZV0gfSkpXG4gICAgICAgICAgICAgICAgPyBbXVxuICAgICAgICAgICAgICAgIDogbW9kZWxzO1xuICAgICAgICAgICAgdGhpcy5zZXJpZXNNb2RlbHNbYWxpYXMgfHwgbmFtZV0gPSB0aGlzLmdldFNlbGVjdGVkU2VyaWVzTW9kZWxzKHNlbGVjdGVkU2VyaWVzRXZlbnRNb2RlbCk7XG4gICAgICAgICAgICB0aGlzLmlzU2hvdyA9ICEhT2JqZWN0LnZhbHVlcyh0aGlzLm1vZGVscykuZmxhdE1hcCgodmFsdWUpID0+IHZhbHVlKS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQodGhpcy5pc1Nob3cgPyAnc2VsZWN0U2VyaWVzJyA6ICd1bnNlbGVjdFNlcmllcycsIG1ha2VPYnNlcnZhYmxlT2JqZWN0VG9Ob3JtYWwodGhpcy5zZXJpZXNNb2RlbHMpKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlU2VyaWVzTmFtZXNbbmFtZV0gPSB0aGlzLmdldFNlcmllc05hbWVzKHNlbGVjdGVkU2VyaWVzRXZlbnRNb2RlbC5tb2RlbHMsIG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVTdGF0ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlc2V0U2VsZWN0ZWRTZXJpZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1vZGVscyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgnc2V0QWxsTGVnZW5kQWN0aXZlU3RhdGUnLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0U2VyaWVzTmFtZXMoc2VsZWN0ZWRTZXJpZXMsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBbXTtcbiAgICAgICAgaWYgKGluY2x1ZGVzKFsnbGluZScsICdhcmVhJywgJ3JhZGFyJywgJ2J1YmJsZScsICdzY2F0dGVyJywgJ2J1bGxldCcsICdib3hQbG90J10sIG5hbWUpKSB7XG4gICAgICAgICAgICBzZWxlY3RlZFNlcmllcy5mb3JFYWNoKChtb2RlbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gbW9kZWxcbiAgICAgICAgICAgICAgICAgICAgLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzLnB1c2gobGFiZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluY2x1ZGVzKFsnYmFyJywgJ2NvbHVtbicsICdyYWRpYWxCYXInXSwgbmFtZSkpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkU2VyaWVzLmZvckVhY2goKG1vZGVsKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gKF9hID0gbW9kZWwuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhYmVsO1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKGxhYmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAncGllJykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5tb2RlbHMpXG4gICAgICAgICAgICAgICAgLmZsYXRNYXAoKGtleSkgPT4gdGhpcy5tb2RlbHNba2V5XSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgobW9kZWwpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gKChfYSA9IG1vZGVsLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yb290UGFyZW50TmFtZSkgfHwgKChfYiA9IG1vZGVsLmRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sYWJlbCk7XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzLnB1c2gobGFiZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lcztcbiAgICB9XG4gICAgZ2V0U2VsZWN0ZWRTZXJpZXNNb2RlbHNGb3JSZW5kZXJpbmcoc2VsZWN0ZWRTZXJpZXNFdmVudE1vZGVsKSB7XG4gICAgICAgIGNvbnN0IHsgbW9kZWxzLCBldmVudERldGVjdFR5cGUsIG5hbWUgfSA9IHNlbGVjdGVkU2VyaWVzRXZlbnRNb2RlbDtcbiAgICAgICAgbGV0IHJlbmRlcmluZ01vZGVscyA9IG1vZGVscztcbiAgICAgICAgaWYgKChuYW1lID09PSAnY29sdW1uJyB8fCBuYW1lID09PSAnYmFyJyB8fCBuYW1lID09PSAnYnVsbGV0JykgJiZcbiAgICAgICAgICAgIGV2ZW50RGV0ZWN0VHlwZSA9PT0gJ2dyb3VwZWQnKSB7XG4gICAgICAgICAgICByZW5kZXJpbmdNb2RlbHMgPSBtb2RlbHMuZmlsdGVyKChtb2RlbCkgPT4gIW1vZGVsLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdyYWRpYWxCYXInICYmIGV2ZW50RGV0ZWN0VHlwZSA9PT0gJ2dyb3VwZWQnKSB7XG4gICAgICAgICAgICByZW5kZXJpbmdNb2RlbHMgPSBtb2RlbHMuZmlsdGVyKChtb2RlbCkgPT4gIW1vZGVsLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW5kZXJpbmdNb2RlbHM7XG4gICAgfVxuICAgIGdldFNlbGVjdGVkU2VyaWVzTW9kZWxzKHNlbGVjdGVkU2VyaWVzRXZlbnRNb2RlbCkge1xuICAgICAgICBjb25zdCB7IG1vZGVscywgZXZlbnREZXRlY3RUeXBlLCBuYW1lIH0gPSBzZWxlY3RlZFNlcmllc0V2ZW50TW9kZWw7XG4gICAgICAgIGxldCBzZWxlY3RlZFNlcmllc01vZGVscyA9IG1vZGVscztcbiAgICAgICAgaWYgKChuYW1lID09PSAnY29sdW1uJyB8fCBuYW1lID09PSAnYmFyJyB8fCBuYW1lID09PSAnYnVsbGV0JykgJiZcbiAgICAgICAgICAgIGV2ZW50RGV0ZWN0VHlwZSA9PT0gJ2dyb3VwZWQnKSB7XG4gICAgICAgICAgICBzZWxlY3RlZFNlcmllc01vZGVscyA9IG1vZGVscy5maWx0ZXIoKG1vZGVsKSA9PiBtb2RlbC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAncmFkaWFsQmFyJyAmJiBldmVudERldGVjdFR5cGUgPT09ICdncm91cGVkJykge1xuICAgICAgICAgICAgc2VsZWN0ZWRTZXJpZXNNb2RlbHMgPSBtb2RlbHMuZmlsdGVyKChtb2RlbCkgPT4gbW9kZWwuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkU2VyaWVzTW9kZWxzO1xuICAgIH1cbiAgICBzZXRBY3RpdmVTdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTaG93KSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKCdzZXRBbGxMZWdlbmRBY3RpdmVTdGF0ZScsIGZhbHNlKTtcbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5hY3RpdmVTZXJpZXNOYW1lcykuZm9yRWFjaCgobmFtZXMpID0+IHtcbiAgICAgICAgICAgICAgICBuYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3NldExlZ2VuZEFjdGl2ZVN0YXRlJywgeyBuYW1lLCBhY3RpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goJ3NldEFsbExlZ2VuZEFjdGl2ZVN0YXRlJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCduZWVkRHJhdycpO1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnc2VsZWN0ZWRTZXJpZXMnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnc2VsZWN0ZWRTZXJpZXMnO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLm9uKCdyZW5kZXJTZWxlY3RlZFNlcmllcycsIHRoaXMucmVuZGVyU2VsZWN0ZWRTZXJpZXMpO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLm9uKCdyZXNldFNlbGVjdGVkU2VyaWVzJywgdGhpcy5yZXNldFNlbGVjdGVkU2VyaWVzKTtcbiAgICB9XG4gICAgcmVuZGVyKHsgbGF5b3V0IH0pIHtcbiAgICAgICAgdGhpcy5yZWN0ID0gbGF5b3V0LnBsb3Q7XG4gICAgfVxufVxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi9jb21wb25lbnRcIjtcbmltcG9ydCB7IHJhbmdlIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmltcG9ydCB7IGlzVmVydGljYWxBbGlnbiB9IGZyb20gXCIuLi9zdG9yZS9sYXlvdXRcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwZWN0cnVtTGVnZW5kIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICAgICAgdGhpcy5yZW5kZXJTcGVjdHJ1bVRvb2x0aXAgPSAoW3Jlc3BvbmRlckRhdGFdKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzcG9uZGVyRGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGFiZWxzLCBhbGlnbiB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvbG9yVmFsdWUsIGNvbG9yIH0gPSByZXNwb25kZXJEYXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5yZWN0O1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWxzLnRvb2x0aXAgPSBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzcGVjdHJ1bVRvb2x0aXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JSYXRpbzogcmVzcG9uZGVyRGF0YS5jb2xvclJhdGlvLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBTdHJpbmcoY29sb3JWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiBpc1ZlcnRpY2FsQWxpZ24oYWxpZ24pLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVscy50b29sdGlwID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdzcGVjdHJ1bUxlZ2VuZCc7XG4gICAgICAgIHRoaXMubmFtZSA9ICdzcGVjdHJ1bUxlZ2VuZCc7XG4gICAgfVxuICAgIG1ha2VMYWJlbHMoc2NhbGUpIHtcbiAgICAgICAgY29uc3QgeyBzdGVwQ291bnQsIGxpbWl0LCBzdGVwU2l6ZSB9ID0gc2NhbGU7XG4gICAgICAgIGNvbnN0IG1pblZhbHVlID0gbGltaXQubWluO1xuICAgICAgICByZXR1cm4gcmFuZ2UoMCwgc3RlcENvdW50ICsgMSkucmVkdWNlKChsYWJlbHMsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLmxhYmVscywgU3RyaW5nKG1pblZhbHVlICsgc3RlcFNpemUgKiB2YWx1ZSldO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIHJlbmRlclNwZWN0cnVtTGVnZW5kTW9kZWwoc3RhcnRDb2xvciwgZW5kQ29sb3IpIHtcbiAgICAgICAgY29uc3QgeyBsYWJlbHMsIGFsaWduIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMucmVjdDtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3BlY3RydW1MZWdlbmQnLFxuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgbGFiZWxzLFxuICAgICAgICAgICAgICAgIGFsaWduLFxuICAgICAgICAgICAgICAgIHN0YXJ0Q29sb3IsXG4gICAgICAgICAgICAgICAgZW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgdmVydGljYWxBbGlnbjogaXNWZXJ0aWNhbEFsaWduKHRoaXMuYWxpZ24pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmVuZGVyKHsgbGF5b3V0LCBsZWdlbmQsIGNvbG9yVmFsdWVTY2FsZSwgdGhlbWUgfSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLnJlY3QgPSBsYXlvdXQubGVnZW5kO1xuICAgICAgICB0aGlzLmFsaWduID0gbGVnZW5kLmFsaWduO1xuICAgICAgICB0aGlzLmlzU2hvdyA9IGxlZ2VuZC52aXNpYmxlICYmICEhbGVnZW5kLmRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAoIXRoaXMuaXNTaG93KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYWJlbHMgPSB0aGlzLm1ha2VMYWJlbHMoY29sb3JWYWx1ZVNjYWxlKTtcbiAgICAgICAgY29uc3QgeyBzdGFydENvbG9yLCBlbmRDb2xvciB9ID0gKChfYSA9IHRoZW1lLnNlcmllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYXRtYXApIHx8ICgoX2IgPSB0aGVtZS5zZXJpZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50cmVlbWFwKTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSB7IGxlZ2VuZDogdGhpcy5yZW5kZXJTcGVjdHJ1bUxlZ2VuZE1vZGVsKHN0YXJ0Q29sb3IsIGVuZENvbG9yKSwgdG9vbHRpcDogW10gfTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbigncmVuZGVyU3BlY3RydW1Ub29sdGlwJywgdGhpcy5yZW5kZXJTcGVjdHJ1bVRvb2x0aXApO1xuICAgIH1cbn1cbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIi4vY29tcG9uZW50XCI7XG5pbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXRUZXh0V2lkdGggfSBmcm9tIFwiLi4vaGVscGVycy9jYWxjdWxhdG9yXCI7XG5pbXBvcnQgeyBnZXRUaXRsZUZvbnRTdHJpbmcgfSBmcm9tIFwiLi4vaGVscGVycy9zdHlsZVwiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGl0bGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICd0aXRsZSc7XG4gICAgICAgIHRoaXMubmFtZSA9ICd0aXRsZSc7XG4gICAgfVxuICAgIHJlbmRlclRpdGxlKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgIGxldCB4ID0gMDtcbiAgICAgICAgbGV0IHkgPSAwO1xuICAgICAgICBsZXQgYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIGlmIChpc1N0cmluZyhvcHRpb25zKSkge1xuICAgICAgICAgICAgdGV4dCA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ZXh0ID0gb3B0aW9ucy50ZXh0O1xuICAgICAgICAgICAgYWxpZ24gPSAoX2EgPSBvcHRpb25zLmFsaWduLCAoX2EgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2xlZnQnKSk7XG4gICAgICAgICAgICB4ICs9IChfYiA9IG9wdGlvbnMub2Zmc2V0WCwgKF9iICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApKTtcbiAgICAgICAgICAgIHkgKz0gKF9jID0gb3B0aW9ucy5vZmZzZXRZLCAoX2MgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvbnQgPSBnZXRUaXRsZUZvbnRTdHJpbmcodGhpcy50aGVtZSk7XG4gICAgICAgIGNvbnN0IHRleHRXaWR0aCA9IGdldFRleHRXaWR0aCh0ZXh0LCBmb250KTtcbiAgICAgICAgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgeCArPSAodGhpcy5yZWN0LndpZHRoIC0gdGV4dFdpZHRoKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHggKz0gdGhpcy5yZWN0LndpZHRoIC0gdGV4dFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xhYmVsJyxcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICBzdHlsZTogWyd0aXRsZScsIHsgZm9udCwgZmlsbFN0eWxlOiB0aGlzLnRoZW1lLmNvbG9yIH1dLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmVuZGVyKHsgb3B0aW9ucywgbGF5b3V0LCB0aGVtZSB9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5pc1Nob3cgPSAhISgoX2EgPSBvcHRpb25zLmNoYXJ0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGl0bGUpO1xuICAgICAgICBpZiAoIXRoaXMuaXNTaG93KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aGVtZSA9IHRoZW1lLnRpdGxlO1xuICAgICAgICB0aGlzLnJlY3QgPSBsYXlvdXQudGl0bGU7XG4gICAgICAgIHRoaXMubW9kZWxzID0gdGhpcy5yZW5kZXJUaXRsZShvcHRpb25zLmNoYXJ0LnRpdGxlKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuL2NvbXBvbmVudFwiO1xuaW1wb3J0IHsgZ2V0VmFsdWVTdHJpbmcgfSBmcm9tIFwiLi4vaGVscGVycy90b29sdGlwXCI7XG5pbXBvcnQgeyBnZXRCb2R5VGVtcGxhdGUsIHRvb2x0aXBUZW1wbGF0ZXMgfSBmcm9tIFwiLi4vaGVscGVycy90b29sdGlwVGVtcGxhdGVcIjtcbmltcG9ydCB7IGlzQm9vbGVhbiwgaXNOdW1iZXIsIGlzU3RyaW5nIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmltcG9ydCB7IGdldFRyYW5zbGF0ZVN0cmluZyB9IGZyb20gXCIuLi9oZWxwZXJzL3N0eWxlXCI7XG5pbXBvcnQgeyBzYW5pdGl6ZUhUTUwgfSBmcm9tIFwiLi4vaGVscGVycy9odG1sU2FuaXRpemVyXCI7XG5jb25zdCBERUZBVUxUX1RPT0xUSVBfVFJBTlNJVElPTiA9ICd0cmFuc2Zvcm0gMC4ycyBlYXNlJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnRvb2x0aXBJbmZvTW9kZWxzID0ge307XG4gICAgICAgIHRoaXMub25TZXJpZXNQb2ludEhvdmVyZWQgPSAoeyBtb2RlbHMsIG5hbWUgfSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdGhpcy50b29sdGlwSW5mb01vZGVsc1tuYW1lXSA9ICgoX2EgPSBtb2RlbHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpID8gWy4uLm1vZGVsc10gOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IGlzU2hvdyA9ICEhdGhpcy5nZXRUb29sdGlwSW5mb01vZGVscygpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpc1Nob3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRvb2x0aXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVG9vbHRpcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpc1Rvb2x0aXBDb250YWluZXJPdmVyZmxvdyh4LCB5KSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy50b29sdGlwQ29udGFpbmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHsgeDogcmVjdFgsIHk6IHJlY3RZLCB3aWR0aDogcmVjdFdpZHRoLCBoZWlnaHQ6IHJlY3RIZWlnaHQgfSA9IHRoaXMucmVjdDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG92ZXJmbG93WDogeCA+IHJlY3RYICsgcmVjdFdpZHRoIHx8IHggKyB3aWR0aCA+IHJlY3RYICsgcmVjdFdpZHRoLFxuICAgICAgICAgICAgb3ZlcmZsb3dZOiB5ID4gcmVjdFkgKyByZWN0SGVpZ2h0IHx8IHkgKyBoZWlnaHQgPiByZWN0WSArIHJlY3RIZWlnaHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFBvc2l0aW9uSW5SZWN0KG1vZGVsKSB7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBtb2RlbDtcbiAgICAgICAgY29uc3Qgc3RhcnRYID0gdGhpcy5yZWN0LnggKyBtb2RlbC54O1xuICAgICAgICBjb25zdCBzdGFydFkgPSB0aGlzLnJlY3QueSArIG1vZGVsLnk7XG4gICAgICAgIGxldCB4ID0gc3RhcnRYICsgdGFyZ2V0LnJhZGl1cyArIHRhcmdldC53aWR0aCArIHRoaXMub2Zmc2V0WDtcbiAgICAgICAgbGV0IHkgPSBzdGFydFkgKyB0aGlzLm9mZnNldFk7XG4gICAgICAgIGNvbnN0IHsgb3ZlcmZsb3dYLCBvdmVyZmxvd1kgfSA9IHRoaXMuaXNUb29sdGlwQ29udGFpbmVyT3ZlcmZsb3coeCwgeSk7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy50b29sdGlwQ29udGFpbmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChvdmVyZmxvd1gpIHtcbiAgICAgICAgICAgIHggPVxuICAgICAgICAgICAgICAgIHN0YXJ0WCAtICh3aWR0aCArIHRhcmdldC5yYWRpdXMgKyB0aGlzLm9mZnNldFgpID4gMFxuICAgICAgICAgICAgICAgICAgICA/IHN0YXJ0WCAtICh3aWR0aCArIHRhcmdldC5yYWRpdXMgKyB0aGlzLm9mZnNldFgpXG4gICAgICAgICAgICAgICAgICAgIDogc3RhcnRYICsgdGhpcy5vZmZzZXRYO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdmVyZmxvd1kpIHtcbiAgICAgICAgICAgIHkgPVxuICAgICAgICAgICAgICAgIHN0YXJ0WSArIHRhcmdldC5oZWlnaHQgLSAoaGVpZ2h0ICsgdGhpcy5vZmZzZXRZKSA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBzdGFydFkgKyB0YXJnZXQuaGVpZ2h0IC0gKGhlaWdodCArIHRoaXMub2Zmc2V0WSlcbiAgICAgICAgICAgICAgICAgICAgOiB5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9XG4gICAgc2V0VG9vbHRpcFBvc2l0aW9uKG1vZGVsKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5nZXRQb3NpdGlvbkluUmVjdChtb2RlbCk7XG4gICAgICAgIHRoaXMudG9vbHRpcENvbnRhaW5lckVsLnN0eWxlLnRyYW5zZm9ybSA9IGdldFRyYW5zbGF0ZVN0cmluZyh4LCB5KTtcbiAgICB9XG4gICAgZ2V0VG9vbHRpcEluZm9Nb2RlbHMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMudG9vbHRpcEluZm9Nb2RlbHMpLmZsYXRNYXAoKGl0ZW0pID0+IGl0ZW0pO1xuICAgIH1cbiAgICByZW5kZXJUb29sdGlwKCkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuZ2V0VG9vbHRpcEluZm9Nb2RlbHMoKS5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCB4LCB5LCByYWRpdXMsIHdpZHRoLCBoZWlnaHQgfSA9IGl0ZW07XG4gICAgICAgICAgICBhY2MueCA9IGFjYy54ID8gKGFjYy54ICsgeCkgLyAyIDogeDtcbiAgICAgICAgICAgIGFjYy55ID0gYWNjLnkgPyAoYWNjLnkgKyB5KSAvIDIgOiB5O1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHJhZGl1cykpIHtcbiAgICAgICAgICAgICAgICBhY2MudGFyZ2V0LnJhZGl1cyA9IHJhZGl1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgICAgIGFjYy50YXJnZXQud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBhY2MudGFyZ2V0LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjYy5kYXRhLnB1c2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgeyB2YWx1ZTogQXJyYXkuaXNBcnJheShkYXRhLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA/IGRhdGEudmFsdWUubWFwKCh0aXRsZVZhbHVlKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aXRsZVZhbHVlKSwgeyBmb3JtYXR0ZWRWYWx1ZTogdGhpcy5nZXRGb3JtYXR0ZWRWYWx1ZSh0aXRsZVZhbHVlLnZhbHVlLCBkYXRhKSB9KSkpXG4gICAgICAgICAgICAgICAgICAgIDogZGF0YS52YWx1ZSwgZm9ybWF0dGVkVmFsdWU6IHRoaXMuZ2V0Rm9ybWF0dGVkVmFsdWUoZGF0YS52YWx1ZSwgZGF0YSkgfSkpO1xuICAgICAgICAgICAgaWYgKCFhY2MuY2F0ZWdvcnkgJiYgZGF0YS5jYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgIGFjYy5jYXRlZ29yeSA9IGRhdGEuY2F0ZWdvcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS50ZW1wbGF0ZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBhY2MudGVtcGxhdGVUeXBlID0gZGF0YS50ZW1wbGF0ZVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7IHR5cGU6ICd0b29sdGlwJywgeDogMCwgeTogMCwgZGF0YTogW10sIHRhcmdldDogeyByYWRpdXM6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSB9KTtcbiAgICAgICAgdGhpcy50b29sdGlwQ29udGFpbmVyRWwuaW5uZXJIVE1MID0gc2FuaXRpemVIVE1MKHRoaXMudGVtcGxhdGVGdW5jKG1vZGVsLCB7XG4gICAgICAgICAgICBoZWFkZXI6IHRvb2x0aXBUZW1wbGF0ZXMuZGVmYXVsdEhlYWRlcihtb2RlbCwgdGhpcy50aGVtZSksXG4gICAgICAgICAgICBib2R5OiBnZXRCb2R5VGVtcGxhdGUobW9kZWwudGVtcGxhdGVUeXBlKShtb2RlbCwgdGhpcy50aGVtZSksXG4gICAgICAgIH0sIHRoaXMudGhlbWUpKTtcbiAgICAgICAgdGhpcy5zZXRUb29sdGlwUG9zaXRpb24obW9kZWwpO1xuICAgIH1cbiAgICBpbml0aWFsaXplKHsgY2hhcnRFbCB9KSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICd0b29sdGlwJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ3Rvb2x0aXAnO1xuICAgICAgICB0aGlzLmNoYXJ0RWwgPSBjaGFydEVsO1xuICAgICAgICB0aGlzLnRvb2x0aXBDb250YWluZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnRvb2x0aXBDb250YWluZXJFbC5jbGFzc0xpc3QuYWRkKCd0b2FzdHVpLWNoYXJ0LXRvb2x0aXAtY29udGFpbmVyJyk7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgdG9wLCBsZWZ0IH0gPSB0aGlzLmNoYXJ0RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMudG9vbHRpcENvbnRhaW5lckVsLnN0eWxlLnRyYW5zZm9ybSA9IGdldFRyYW5zbGF0ZVN0cmluZyhsZWZ0ICsgd2lkdGggLyAyLCB0b3AgKyBoZWlnaHQgLyAyKTtcbiAgICAgICAgdGhpcy5jaGFydEVsLmFwcGVuZENoaWxkKHRoaXMudG9vbHRpcENvbnRhaW5lckVsKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignc2VyaWVzUG9pbnRIb3ZlcmVkJywgdGhpcy5vblNlcmllc1BvaW50SG92ZXJlZCk7XG4gICAgfVxuICAgIHJlbW92ZVRvb2x0aXAoKSB7XG4gICAgICAgIHRoaXMudG9vbHRpcENvbnRhaW5lckVsLmlubmVySFRNTCA9ICcnO1xuICAgIH1cbiAgICBzZXRUb29sdGlwVHJhbnNpdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IChfYSA9IG9wdGlvbnMudG9vbHRpcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRyYW5zaXRpb247XG4gICAgICAgIGlmIChpc0Jvb2xlYW4odHJhbnNpdGlvbikgJiYgdHJhbnNpdGlvbikge1xuICAgICAgICAgICAgdGhpcy50b29sdGlwQ29udGFpbmVyRWwuc3R5bGUudHJhbnNpdGlvbiA9IERFRkFVTFRfVE9PTFRJUF9UUkFOU0lUSU9OO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3RyaW5nKHRyYW5zaXRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBDb250YWluZXJFbC5zdHlsZS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoeyBsYXlvdXQsIG9wdGlvbnMsIHRoZW1lIH0pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbDtcbiAgICAgICAgdGhpcy5zZXRUb29sdGlwVHJhbnNpdGlvbihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5yZWN0ID0gbGF5b3V0LnBsb3Q7XG4gICAgICAgIHRoaXMudGhlbWUgPSB0aGVtZS50b29sdGlwO1xuICAgICAgICB0aGlzLnRlbXBsYXRlRnVuYyA9IChfYyA9IChfYiA9IChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29sdGlwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudGVtcGxhdGUsIChfYyAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0b29sdGlwVGVtcGxhdGVzWydkZWZhdWx0J10pKTtcbiAgICAgICAgdGhpcy5vZmZzZXRYID0gKF9mID0gKF9lID0gKF9kID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnRvb2x0aXApID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5vZmZzZXRYLCAoX2YgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogMTApKTtcbiAgICAgICAgdGhpcy5vZmZzZXRZID0gKF9qID0gKF9oID0gKF9nID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnRvb2x0aXApID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5vZmZzZXRZLCAoX2ogIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogMCkpO1xuICAgICAgICB0aGlzLmZvcm1hdHRlciA9IChfbCA9IChfayA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay50b29sdGlwKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wuZm9ybWF0dGVyO1xuICAgIH1cbiAgICBnZXRGb3JtYXR0ZWRWYWx1ZSh2YWx1ZSwgdG9vbHRpcERhdGFJbmZvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlclxuICAgICAgICAgICAgPyB0aGlzLmZvcm1hdHRlcih2YWx1ZSwgdG9vbHRpcERhdGFJbmZvKVxuICAgICAgICAgICAgOiBnZXRWYWx1ZVN0cmluZyh2YWx1ZSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi9jb21wb25lbnRcIjtcbmltcG9ydCB7IHNxdWFyaWZ5IH0gZnJvbSBcIi4uL2hlbHBlcnMvc3F1YXJpZmllclwiO1xuaW1wb3J0IHsgZ2V0UkdCQSwgaGV4VG9SR0IgfSBmcm9tIFwiLi4vaGVscGVycy9jb2xvclwiO1xuaW1wb3J0IHsgZ2V0RGVlcGVzdE5vZGUgfSBmcm9tIFwiLi4vaGVscGVycy9yZXNwb25kZXJzXCI7XG5pbXBvcnQgeyBnZXREYXRhTGFiZWxzT3B0aW9ucyB9IGZyb20gXCIuLi9oZWxwZXJzL2RhdGFMYWJlbHNcIjtcbmltcG9ydCB7IGRlZXBNZXJnZWRDb3B5LCBmaXJzdCwgaXNOdW1iZXIsIGxhc3QgfSBmcm9tIFwiLi4vaGVscGVycy91dGlsc1wiO1xuaW1wb3J0IHsgZ2V0Q29sb3JSYXRpbywgZ2V0U3BlY3RydW1Db2xvciwgbWFrZURpc3RhbmNlcyB9IGZyb20gXCIuLi9oZWxwZXJzL2NvbG9yU3BlY3RydW1cIjtcbmltcG9ydCB7IGJveERlZmF1bHQgfSBmcm9tIFwiLi4vaGVscGVycy90aGVtZVwiO1xuaW1wb3J0IHsgbWVzc2FnZSB9IGZyb20gXCIuLi9tZXNzYWdlXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmVlbWFwU2VyaWVzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSB7IHNlcmllczogW10sIGxheWVyOiBbXSB9O1xuICAgICAgICB0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5vbk1vdXNlb3V0Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0TW91c2VFdmVudChbXSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VsZWN0U2VyaWVzID0gKHsgc2VyaWVzSW5kZXggfSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc051bWJlcihzZXJpZXNJbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMucmVzcG9uZGVycy5maW5kKCh7IGluZGV4ZXMgfSkgPT4gbGFzdChpbmRleGVzKSA9PT0gc2VyaWVzSW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlLlNFTEVDVF9TRVJJRVNfQVBJX0lOREVYX0VSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vZGVscyA9IHRoaXMuZ2V0UmVzcG9uZGVyc1dpdGhUaGVtZShbbW9kZWxdLCAnc2VsZWN0Jyk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlclNlbGVjdGVkU2VyaWVzJywgeyBtb2RlbHMsIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zaG93VG9vbHRpcCA9ICh7IHNlcmllc0luZGV4IH0pID0+IHtcbiAgICAgICAgICAgIGlmICghaXNOdW1iZXIoc2VyaWVzSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLnJlc3BvbmRlcnMuZmluZCgoeyBpbmRleGVzIH0pID0+IGxhc3QoaW5kZXhlcykgPT09IHNlcmllc0luZGV4KTtcbiAgICAgICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdE1vdXNlRXZlbnQoW21vZGVsXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdzZXJpZXMnO1xuICAgICAgICB0aGlzLm5hbWUgPSAndHJlZW1hcCc7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMub24oJ3NlbGVjdFNlcmllcycsIHRoaXMuc2VsZWN0U2VyaWVzKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignc2hvd1Rvb2x0aXAnLCB0aGlzLnNob3dUb29sdGlwKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5vbignaGlkZVRvb2x0aXAnLCB0aGlzLm9uTW91c2VvdXRDb21wb25lbnQpO1xuICAgIH1cbiAgICBnZXRBbGxDaGlsZFNlcmllcyhzZXJpZXMsIHBhcmVudElkKSB7XG4gICAgICAgIGNvbnN0IGFsbENoaWxkU2VyaWVzID0gW107XG4gICAgICAgIHNlcmllcy5mb3JFYWNoKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YS5wYXJlbnRJZCA9PT0gcGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICBhbGxDaGlsZFNlcmllcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuZ2V0QWxsQ2hpbGRTZXJpZXMoc2VyaWVzLCBkYXRhLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsQ2hpbGRTZXJpZXMucHVzaCguLi5yZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhbGxDaGlsZFNlcmllcztcbiAgICB9XG4gICAgcmVuZGVyKGNoYXJ0U3RhdGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgY29uc3QgeyBsYXlvdXQsIHRyZWVtYXBTZXJpZXMsIGNvbG9yVmFsdWVTY2FsZSwgb3B0aW9ucywgdGhlbWUsIHRyZWVtYXBab29tSWQgfSA9IGNoYXJ0U3RhdGU7XG4gICAgICAgIGlmICghdHJlZW1hcFNlcmllcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2Uubm9EYXRhRXJyb3IodGhpcy5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFRyZWVtYXBab29tSWQgPSB0cmVlbWFwWm9vbUlkLmN1cjtcbiAgICAgICAgY29uc3Qgc2VyaWVzID0gdGhpcy5nZXRBbGxDaGlsZFNlcmllcyh0cmVlbWFwU2VyaWVzLCBjdXJyZW50VHJlZW1hcFpvb21JZCk7XG4gICAgICAgIHRoaXMudGhlbWUgPSB0aGVtZS5zZXJpZXMudHJlZW1hcDtcbiAgICAgICAgdGhpcy5yZWN0ID0gbGF5b3V0LnBsb3Q7XG4gICAgICAgIHRoaXMuc2VsZWN0YWJsZSA9IHRoaXMuZ2V0U2VsZWN0YWJsZU9wdGlvbihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSB0aGlzLnJlbmRlclRyZWVtYXBTZXJpZXMoc2VyaWVzLCBvcHRpb25zLCBjb2xvclZhbHVlU2NhbGUsIGN1cnJlbnRUcmVlbWFwWm9vbUlkKTtcbiAgICAgICAgdGhpcy56b29tYWJsZSA9IChfYiA9IChfYSA9IG9wdGlvbnMuc2VyaWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euem9vbWFibGUsIChfYiAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSkpO1xuICAgICAgICBpZiAoZ2V0RGF0YUxhYmVsc09wdGlvbnMob3B0aW9ucywgdGhpcy5uYW1lKS52aXNpYmxlKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VUcmVlbWFwTGVhZiA9IChfZSA9IChfZCA9IChfYyA9IG9wdGlvbnMuc2VyaWVzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGF0YUxhYmVscykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnVzZVRyZWVtYXBMZWFmLCAoX2UgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogZmFsc2UpKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFMYWJlbE1vZGVsID0gdGhpcy5tYWtlRGF0YUxhYmVsKHVzZVRyZWVtYXBMZWFmLCBjdXJyZW50VHJlZW1hcFpvb21JZCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckRhdGFMYWJlbHMoZGF0YUxhYmVsTW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzcG9uZGVycyA9IHRoaXMubWFrZVRyZWVtYXBTZXJpZXNSZXNwb25kZXIoY3VycmVudFRyZWVtYXBab29tSWQpO1xuICAgIH1cbiAgICBtYWtlVHJlZW1hcFNlcmllc1Jlc3BvbmRlcih0cmVlbWFwQ3VycmVudERlcHRoUGFyZW50SWQpIHtcbiAgICAgICAgY29uc3QgdG9vbHRpcERhdGEgPSB0aGlzLm1ha2VUb29sdGlwRGF0YSgpO1xuICAgICAgICBsZXQgeyBzZXJpZXMgfSA9IHRoaXMubW9kZWxzO1xuICAgICAgICBpZiAodGhpcy56b29tYWJsZSkge1xuICAgICAgICAgICAgc2VyaWVzID0gc2VyaWVzLmZpbHRlcigoeyBwYXJlbnRJZCB9KSA9PiBwYXJlbnRJZCA9PT0gdHJlZW1hcEN1cnJlbnREZXB0aFBhcmVudElkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWVzLm1hcCgobSwgaWR4KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyBkYXRhOiB0b29sdGlwRGF0YVtpZHhdLCB0aGlja25lc3M6IGJveERlZmF1bHQuSE9WRVJfVEhJQ0tORVNTLCBzdHlsZTogWydzaGFkb3cnXSB9KSkpO1xuICAgIH1cbiAgICBtYWtlVG9vbHRpcERhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVscy5zZXJpZXMubWFwKCh7IGxhYmVsLCBkYXRhLCBjb2xvciB9KSA9PiAoe1xuICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICB2YWx1ZTogZGF0YSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBtYWtlQm91bmRNYXAoc2VyaWVzLCBwYXJlbnRJZCwgbGF5b3V0LCBib3VuZE1hcCA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHNlcmllc0l0ZW1zID0gc2VyaWVzLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5wYXJlbnRJZCA9PT0gcGFyZW50SWQpO1xuICAgICAgICBib3VuZE1hcCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYm91bmRNYXApLCBzcXVhcmlmeShPYmplY3QuYXNzaWduKHt9LCBsYXlvdXQpLCBzZXJpZXNJdGVtcykpO1xuICAgICAgICBzZXJpZXNJdGVtcy5mb3JFYWNoKChzZXJpZXNJdGVtKSA9PiB7XG4gICAgICAgICAgICBib3VuZE1hcCA9IHRoaXMubWFrZUJvdW5kTWFwKHNlcmllcywgc2VyaWVzSXRlbS5pZCwgYm91bmRNYXBbc2VyaWVzSXRlbS5pZF0sIGJvdW5kTWFwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBib3VuZE1hcDtcbiAgICB9XG4gICAgbWFrZURhdGFMYWJlbCh1c2VUcmVlbWFwTGVhZiwgdHJlZW1hcEN1cnJlbnREZXB0aFBhcmVudElkKSB7XG4gICAgICAgIGNvbnN0IHNlcmllcyA9IHVzZVRyZWVtYXBMZWFmXG4gICAgICAgICAgICA/IHRoaXMubW9kZWxzLnNlcmllcy5maWx0ZXIoKHsgaGFzQ2hpbGQgfSkgPT4gIWhhc0NoaWxkKVxuICAgICAgICAgICAgOiB0aGlzLm1vZGVscy5zZXJpZXMuZmlsdGVyKCh7IHBhcmVudElkIH0pID0+IHBhcmVudElkID09PSB0cmVlbWFwQ3VycmVudERlcHRoUGFyZW50SWQpO1xuICAgICAgICBjb25zdCBkYXRhTGFiZWxUaGVtZSA9IHRoaXMudGhlbWUuZGF0YUxhYmVscztcbiAgICAgICAgcmV0dXJuIHNlcmllcy5tYXAoKG0pID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG0pLCB7IHR5cGU6ICd0cmVlbWFwU2VyaWVzTmFtZScsIHZhbHVlOiBtLmxhYmVsLCBkaXJlY3Rpb246ICdsZWZ0JywgcGxvdDogeyB4OiAwLCB5OiAwLCBzaXplOiAwIH0sIHRoZW1lOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGFMYWJlbFRoZW1lKSwgeyBjb2xvcjogZGF0YUxhYmVsVGhlbWUudXNlU2VyaWVzQ29sb3IgPyBtLmNvbG9yIDogZGF0YUxhYmVsVGhlbWUuY29sb3IgfSkgfSkpKTtcbiAgICB9XG4gICAgZ2V0Q29sb3IodHJlZW1hcFNlcmllcywgY29sb3JzKSB7XG4gICAgICAgIGNvbnN0IHsgaW5kZXhlcyB9ID0gdHJlZW1hcFNlcmllcztcbiAgICAgICAgY29uc3QgY29sb3JJZHggPSBmaXJzdChpbmRleGVzKTtcbiAgICAgICAgcmV0dXJuIGNvbG9yc1tjb2xvcklkeF07XG4gICAgfVxuICAgIGdldE9wYWNpdHkodHJlZW1hcFNlcmllcykge1xuICAgICAgICBjb25zdCB7IGluZGV4ZXMsIGRlcHRoIH0gPSB0cmVlbWFwU2VyaWVzO1xuICAgICAgICBjb25zdCBpZHggPSBsYXN0KGluZGV4ZXMpO1xuICAgICAgICByZXR1cm4gaW5kZXhlcy5sZW5ndGggPT09IDEgPyAwIDogTnVtYmVyKCgwLjEgKiBkZXB0aCArIDAuMDUgKiBpZHgpLnRvRml4ZWQoMikpO1xuICAgIH1cbiAgICByZW5kZXJUcmVlbWFwU2VyaWVzKHNlcmllc0RhdGEsIG9wdGlvbnMsIGNvbG9yVmFsdWVTY2FsZSwgdHJlZW1hcEN1cnJlbnREZXB0aFBhcmVudElkKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBsZXQgbGF5ZXIgPSBbXTtcbiAgICAgICAgY29uc3QgYm91bmRNYXAgPSB0aGlzLm1ha2VCb3VuZE1hcChzZXJpZXNEYXRhLCB0cmVlbWFwQ3VycmVudERlcHRoUGFyZW50SWQsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5yZWN0KSwgeyB4OiAwLCB5OiAwIH0pKTtcbiAgICAgICAgY29uc3QgeyBjb2xvcnMsIHN0YXJ0Q29sb3IsIGVuZENvbG9yLCBib3JkZXJXaWR0aCwgYm9yZGVyQ29sb3IgfSA9IHRoaXMudGhlbWU7XG4gICAgICAgIGxldCBzdGFydFJHQiwgZGlzdGFuY2VzO1xuICAgICAgICBjb25zdCB1c2VDb2xvclZhbHVlID0gKF9iID0gKF9hID0gb3B0aW9ucy5zZXJpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51c2VDb2xvclZhbHVlLCAoX2IgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UpKTtcbiAgICAgICAgaWYgKHVzZUNvbG9yVmFsdWUgJiYgc3RhcnRDb2xvciAmJiBlbmRDb2xvcikge1xuICAgICAgICAgICAgc3RhcnRSR0IgPSBoZXhUb1JHQihzdGFydENvbG9yKTtcbiAgICAgICAgICAgIGRpc3RhbmNlcyA9IG1ha2VEaXN0YW5jZXMoc3RhcnRSR0IsIGhleFRvUkdCKGVuZENvbG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VyaWVzID0gT2JqZWN0LmtleXMoYm91bmRNYXApLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyZWVtYXBTZXJpZXMgPSBzZXJpZXNEYXRhLmZpbmQoKGl0ZW0pID0+IGl0ZW0uaWQgPT09IGlkKTtcbiAgICAgICAgICAgIGxldCBjb2xvclJhdGlvO1xuICAgICAgICAgICAgaWYgKHVzZUNvbG9yVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb2xvclJhdGlvID0gZ2V0Q29sb3JSYXRpbyhjb2xvclZhbHVlU2NhbGUubGltaXQsIHRyZWVtYXBTZXJpZXMuY29sb3JWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyZWVtYXBTZXJpZXMpLCBib3VuZE1hcFtpZF0pLCB7IHR5cGU6ICdyZWN0JywgY29sb3JSYXRpbywgY29sb3I6IHVzZUNvbG9yVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRTcGVjdHJ1bUNvbG9yKGNvbG9yUmF0aW8sIGRpc3RhbmNlcywgc3RhcnRSR0IpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5nZXRDb2xvcih0cmVlbWFwU2VyaWVzLCBjb2xvcnMpLCBvcGFjaXR5OiB1c2VDb2xvclZhbHVlID8gMCA6IHRoaXMuZ2V0T3BhY2l0eSh0cmVlbWFwU2VyaWVzKSwgdGhpY2tuZXNzOiBib3JkZXJXaWR0aCwgYm9yZGVyQ29sb3I6IGJvcmRlckNvbG9yIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCEoKF9jID0gb3B0aW9ucy5zZXJpZXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51c2VDb2xvclZhbHVlKSkge1xuICAgICAgICAgICAgbGF5ZXIgPSBzZXJpZXMubWFwKChtKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyBjb2xvcjogZ2V0UkdCQSgnIzAwMDAwMCcsIG0ub3BhY2l0eSkgfSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZXJpZXMsIGxheWVyIH07XG4gICAgfVxuICAgIGdldFJlc3BvbmRlcnNXaXRoVGhlbWUocmVzcG9uZGVycywgdHlwZSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uZGVycy5tYXAoKHJlc3BvbmRlcikgPT4gZGVlcE1lcmdlZENvcHkocmVzcG9uZGVyLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMudGhlbWVbdHlwZV0pLCB7IHN0eWxlOiBbJ3NoYWRvdyddIH0pKSk7XG4gICAgfVxuICAgIG9uQ2xpY2soeyByZXNwb25kZXJzIH0pIHtcbiAgICAgICAgaWYgKHJlc3BvbmRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy56b29tYWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQsIGhhc0NoaWxkIH0gPSByZXNwb25kZXJzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChoYXNDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRNb3VzZUV2ZW50KFtdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCgnc2V0VHJlZW1hcFpvb21JZCcsIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZXNldFNlbGVjdGVkU2VyaWVzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3JlbmRlclNlbGVjdGVkU2VyaWVzJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxzOiB0aGlzLmdldFJlc3BvbmRlcnNXaXRoVGhlbWUocmVzcG9uZGVycywgJ3NlbGVjdCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWVwZXN0Tm9kZSA9IGdldERlZXBlc3ROb2RlKHJlc3BvbmRlcnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVyU2VsZWN0ZWRTZXJpZXMnLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsczogdGhpcy5nZXRSZXNwb25kZXJzV2l0aFRoZW1lKGRlZXBlc3ROb2RlLCAnc2VsZWN0JyksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBvbk1vdXNlbW92ZSh7IHJlc3BvbmRlcnMgfSkge1xuICAgICAgICBjb25zdCBkZWVwZXN0Tm9kZSA9IGdldERlZXBlc3ROb2RlKHJlc3BvbmRlcnMpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlZFJlc3BvbmRlcnMgPSBkZWVwZXN0Tm9kZTtcbiAgICAgICAgdGhpcy5lbWl0TW91c2VFdmVudChkZWVwZXN0Tm9kZSk7XG4gICAgfVxuICAgIGVtaXRNb3VzZUV2ZW50KHJlc3BvbmRlcnMpIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KCdyZW5kZXJIb3ZlcmVkU2VyaWVzJywge1xuICAgICAgICAgICAgbW9kZWxzOiB0aGlzLmdldFJlc3BvbmRlcnNXaXRoVGhlbWUocmVzcG9uZGVycywgJ2hvdmVyJyksXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Nlcmllc1BvaW50SG92ZXJlZCcsIHtcbiAgICAgICAgICAgIG1vZGVsczogcmVzcG9uZGVycyxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgncmVuZGVyU3BlY3RydW1Ub29sdGlwJywgcmVzcG9uZGVycyk7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdCgnbmVlZERyYXcnKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuL2NvbXBvbmVudFwiO1xuaW1wb3J0IHsgaXNMYWJlbEF4aXNPbllBeGlzIH0gZnJvbSBcIi4uL2hlbHBlcnMvYXhlc1wiO1xuaW1wb3J0IHsgY3Jpc3BQaXhlbCB9IGZyb20gXCIuLi9oZWxwZXJzL2NhbGN1bGF0b3JcIjtcbmltcG9ydCB7IGlzTnVtYmVyIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFplcm9BeGlzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSBbXTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ3plcm9BeGlzJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ3plcm9BeGlzJztcbiAgICB9XG4gICAgcmVuZGVyKHsgbGF5b3V0LCBheGVzLCBzZXJpZXMsIG9wdGlvbnMgfSkge1xuICAgICAgICB0aGlzLnJlY3QgPSBsYXlvdXQucGxvdDtcbiAgICAgICAgY29uc3QgbGFiZWxBeGlzT25ZQXhpcyA9IGlzTGFiZWxBeGlzT25ZQXhpcyh7IHNlcmllcywgb3B0aW9ucyB9KTtcbiAgICAgICAgY29uc3QgdmFsdWVBeGlzTmFtZSA9IGxhYmVsQXhpc09uWUF4aXMgPyAneEF4aXMnIDogJ3lBeGlzJztcbiAgICAgICAgY29uc3QgeyB6ZXJvUG9zaXRpb24gfSA9IGF4ZXNbdmFsdWVBeGlzTmFtZV07XG4gICAgICAgIGlmIChpc051bWJlcih6ZXJvUG9zaXRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVscyA9IHRoaXMucmVuZGVyWmVyb01vZGVsKHplcm9Qb3NpdGlvbiwgbGFiZWxBeGlzT25ZQXhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyWmVyb01vZGVsKHplcm9Qb3NpdGlvbiwgdmVydGljYWwpIHtcbiAgICAgICAgY29uc3QgemVyb1BpeGVsID0gY3Jpc3BQaXhlbCgwKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBjcmlzcFBpeGVsKHplcm9Qb3NpdGlvbik7XG4gICAgICAgIGxldCBtb2RlbDtcbiAgICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgICAgICBtb2RlbCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgeDogcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgeTogemVyb1BpeGVsLFxuICAgICAgICAgICAgICAgIHgyOiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICB5MjogY3Jpc3BQaXhlbCh0aGlzLnJlY3QuaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogJ3JnYmEoMCwgMCwgMCwgMC41KScsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW9kZWwgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgIHg6IHplcm9QaXhlbCxcbiAgICAgICAgICAgICAgICB5OiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICB4MjogY3Jpc3BQaXhlbCh0aGlzLnJlY3Qud2lkdGgpLFxuICAgICAgICAgICAgICAgIHkyOiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogJ3JnYmEoMCwgMCwgMCwgMC41KScsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbW9kZWxdO1xuICAgIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICB9XG4gICAgb24odHlwZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAoIXRoaXMuaGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZXJzW3R5cGVdLnB1c2goaGFuZGxlcik7XG4gICAgfVxuICAgIGVtaXQodHlwZSwgLi4uYXJncykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuaGFuZGxlcnNbdHlwZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChoYW5kbGVyKSA9PiBoYW5kbGVyKC4uLmFyZ3MpKTtcbiAgICB9XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gbWF4KGFyciwgY29uZGl0aW9uLCBjb250ZXh0KSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICByZXN1bHQgPSBNYXRoLm1heCguLi5hcnIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgW3Jlc3VsdF0gPSBhcnI7XG4gICAgICAgIGNvbnN0IHJlc3QgPSBhcnIuc2xpY2UoMSk7XG4gICAgICAgIGxldCBtYXhWYWx1ZSA9IGNvbmRpdGlvbi5jYWxsKGNvbnRleHQsIHJlc3VsdCwgMCk7XG4gICAgICAgIHJlc3QuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBhcmVWYWx1ZSA9IGNvbmRpdGlvbi5jYWxsKGNvbnRleHQsIGl0ZW0sIGluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZiAoY29tcGFyZVZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IGNvbXBhcmVWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQXJyYXkgcGl2b3QuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOmFycmF5VXRpbFxuICogQHBhcmFtIHtBcnJheS48QXJyYXk+fSBhcnIyZCB0YXJnZXQgMmQgYXJyYXlcbiAqIEByZXR1cm5zIHtBcnJheS48QXJyYXk+fSBwaXZvdGVkIDJkIGFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwaXZvdChhcnIyZCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IGxlbiA9IG1heChhcnIyZC5tYXAoKGFycikgPT4gYXJyLmxlbmd0aCkpO1xuICAgIGFycjJkLmZvckVhY2goKGFycikgPT4ge1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdFtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdLnB1c2goYXJyW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU2FtZUFycmF5KGFycjEsIGFycjIpIHtcbiAgICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gcGx1Y2soYXJyLCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBhcnIucmVkdWNlKChhY2MsIGN1cikgPT4ge1xuICAgICAgICByZXR1cm4gWy4uLmFjYywgY3VyW3Byb3BlcnR5XV07XG4gICAgfSwgW10pO1xufVxuIiwiaW1wb3J0IHsgQXhpc1R5cGUgfSBmcm9tIFwiLi4vY29tcG9uZW50L2F4aXNcIjtcbmltcG9ydCB7IGRpdmlzb3JzLCBtYWtlVGlja1BpeGVsUG9zaXRpb25zLCBnZXRUZXh0SGVpZ2h0LCBnZXRUZXh0V2lkdGgsIH0gZnJvbSBcIi4vY2FsY3VsYXRvclwiO1xuaW1wb3J0IHsgcmFuZ2UsIGlzU3RyaW5nLCBpc1VuZGVmaW5lZCwgaXNOdW1iZXIsIGNhbGN1bGF0ZVNpemVXaXRoUGVyY2VudFN0cmluZywgaW5jbHVkZXMsIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IEFOR0xFX0NBTkRJREFURVMsIGNhbGN1bGF0ZVJvdGF0ZWRXaWR0aCwgY2FsY3VsYXRlUm90YXRlZEhlaWdodCwgfSBmcm9tIFwiLi9nZW9tZXRyaWNcIjtcbmltcG9ydCB7IGdldERhdGVGb3JtYXQsIGZvcm1hdERhdGUgfSBmcm9tIFwiLi9mb3JtYXREYXRlXCI7XG5pbXBvcnQgeyBjYWxjdWxhdGVEZWdyZWVUb1JhZGlhbiwgREVHUkVFXzM2MCwgREVHUkVFXzAsIGluaXRTZWN0b3JPcHRpb25zLCBnZXREZWZhdWx0UmFkaXVzLCB9IGZyb20gXCIuL3NlY3RvclwiO1xuaW1wb3J0IHsgREVGQVVMVF9MQUJFTF9URVhUIH0gZnJvbSBcIi4uL2JydXNoZXMvbGFiZWxcIjtcbmltcG9ydCB7IGdldFNlbWlDaXJjbGVDZW50ZXJZLCBnZXRUb3RhbEFuZ2xlLCBpc1NlbWlDaXJjbGUgfSBmcm9tIFwiLi9waWVTZXJpZXNcIjtcbmltcG9ydCB7IFJhZGlhbEF4aXNUeXBlIH0gZnJvbSBcIi4uL3N0b3JlL3JhZGlhbEF4ZXNcIjtcbmZ1bmN0aW9uIG1ha2VBZGp1c3RpbmdJbnRlcnZhbEluZm8oYmxvY2tDb3VudCwgYXhpc1dpZHRoLCBibG9ja1NpemUpIHtcbiAgICBsZXQgcmVtYWluQmxvY2tDb3VudDtcbiAgICBsZXQgbmV3QmxvY2tDb3VudCA9IE1hdGguZmxvb3IoYXhpc1dpZHRoIC8gYmxvY2tTaXplKTtcbiAgICBsZXQgaW50ZXJ2YWxJbmZvID0gbnVsbDtcbiAgICBjb25zdCBpbnRlcnZhbCA9IG5ld0Jsb2NrQ291bnQgPyBNYXRoLmZsb29yKGJsb2NrQ291bnQgLyBuZXdCbG9ja0NvdW50KSA6IGJsb2NrQ291bnQ7XG4gICAgaWYgKGludGVydmFsID4gMSkge1xuICAgICAgICAvLyByZW1haW5CbG9ja0NvdW50IDogcmVtYWluaW5nIGJsb2NrIGNvdW50IGFmdGVyIGZpbGxpbmcgbmV3IGJsb2Nrc1xuICAgICAgICAvLyB8IHwgfCB8IHwgfCB8IHwgfCB8IHwgfCAgLSBwcmV2aW91cyBibG9jayBpbnRlcnZhbFxuICAgICAgICAvLyB8ICAgICB8ICAgICB8ICAgICB8ICAgICAgLSBuZXcgYmxvY2sgaW50ZXJ2YWxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgfCp8KnwgIC0gcmVtYWluaW5nIGJsb2NrXG4gICAgICAgIHJlbWFpbkJsb2NrQ291bnQgPSBibG9ja0NvdW50IC0gaW50ZXJ2YWwgKiBuZXdCbG9ja0NvdW50O1xuICAgICAgICBpZiAocmVtYWluQmxvY2tDb3VudCA+PSBpbnRlcnZhbCkge1xuICAgICAgICAgICAgbmV3QmxvY2tDb3VudCArPSBNYXRoLmZsb29yKHJlbWFpbkJsb2NrQ291bnQgLyBpbnRlcnZhbCk7XG4gICAgICAgICAgICByZW1haW5CbG9ja0NvdW50ID0gcmVtYWluQmxvY2tDb3VudCAlIGludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIGludGVydmFsSW5mbyA9IHtcbiAgICAgICAgICAgIGJsb2NrQ291bnQ6IG5ld0Jsb2NrQ291bnQsXG4gICAgICAgICAgICByZW1haW5CbG9ja0NvdW50LFxuICAgICAgICAgICAgaW50ZXJ2YWwsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBpbnRlcnZhbEluZm87XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QXV0b0FkanVzdGluZ0ludGVydmFsKGNvdW50LCBheGlzV2lkdGgsIGNhdGVnb3JpZXMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYXV0b0ludGVydmFsID0ge1xuICAgICAgICBNSU5fV0lEVEg6IDkwLFxuICAgICAgICBNQVhfV0lEVEg6IDEyMSxcbiAgICAgICAgU1RFUF9TSVpFOiA1LFxuICAgIH07XG4gICAgY29uc3QgTEFCRUxfTUFSR0lOID0gNTtcbiAgICBpZiAoKF9hID0gY2F0ZWdvcmllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSB7XG4gICAgICAgIGNvbnN0IGNhdGVnb3J5TWluV2lkdGggPSBnZXRUZXh0V2lkdGgoY2F0ZWdvcmllc1swXSk7XG4gICAgICAgIGlmIChjYXRlZ29yeU1pbldpZHRoIDwgYXhpc1dpZHRoIC8gY291bnQgLSBMQUJFTF9NQVJHSU4pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjYW5kaWRhdGVzID0gW107XG4gICAgZGl2aXNvcnMoY291bnQpLmZvckVhY2goKGludGVydmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGludGVydmFsV2lkdGggPSAoaW50ZXJ2YWwgLyBjb3VudCkgKiBheGlzV2lkdGg7XG4gICAgICAgIGlmIChpbnRlcnZhbFdpZHRoID49IGF1dG9JbnRlcnZhbC5NSU5fV0lEVEggJiYgaW50ZXJ2YWxXaWR0aCA8PSBhdXRvSW50ZXJ2YWwuTUFYX1dJRFRIKSB7XG4gICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goeyBpbnRlcnZhbCwgYmxvY2tDb3VudDogTWF0aC5mbG9vcihjb3VudCAvIGludGVydmFsKSwgcmVtYWluQmxvY2tDb3VudDogMCB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY2FuZGlkYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYmxvY2tTaXplUmFuZ2UgPSByYW5nZShhdXRvSW50ZXJ2YWwuTUlOX1dJRFRILCBhdXRvSW50ZXJ2YWwuTUFYX1dJRFRILCBhdXRvSW50ZXJ2YWwuU1RFUF9TSVpFKTtcbiAgICAgICAgY2FuZGlkYXRlcyA9IGJsb2NrU2l6ZVJhbmdlLnJlZHVjZSgoYWNjLCBibG9ja1NpemUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IG1ha2VBZGp1c3RpbmdJbnRlcnZhbEluZm8oY291bnQsIGF4aXNXaWR0aCwgYmxvY2tTaXplKTtcbiAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGUgPyBbLi4uYWNjLCBjYW5kaWRhdGVdIDogYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIGxldCB0aWNrSW50ZXJ2YWwgPSAxO1xuICAgIGlmIChjYW5kaWRhdGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBjYW5kaWRhdGVzLnJlZHVjZSgoYWNjLCBjdXIpID0+IChjdXIuYmxvY2tDb3VudCA+IGFjYy5ibG9ja0NvdW50ID8gY3VyIDogYWNjKSwgeyBibG9ja0NvdW50OiAwLCBpbnRlcnZhbDogMSB9KTtcbiAgICAgICAgdGlja0ludGVydmFsID0gY2FuZGlkYXRlLmludGVydmFsO1xuICAgIH1cbiAgICByZXR1cm4gdGlja0ludGVydmFsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTGFiZWxBeGlzT25ZQXhpcyh7IHNlcmllcywgb3B0aW9ucywgY2F0ZWdvcmllcywgfSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuICghIXNlcmllcy5iYXIgfHxcbiAgICAgICAgISFzZXJpZXMucmFkaWFsQmFyIHx8XG4gICAgICAgICghIXNlcmllcy5nYXVnZSAmJiBBcnJheS5pc0FycmF5KGNhdGVnb3JpZXMpICYmICFjYXRlZ29yaWVzLmxlbmd0aCkgfHxcbiAgICAgICAgKCEhc2VyaWVzLmJ1bGxldCAmJiAhKChfYiA9IChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXJpZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi52ZXJ0aWNhbCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNCb3hUeXBlU2VyaWVzKHNlcmllcykge1xuICAgIHJldHVybiAhIXNlcmllcy5jb2x1bW4gfHwgISFzZXJpZXMuYmFyIHx8ICEhc2VyaWVzLmJveFBsb3QgfHwgISFzZXJpZXMuYnVsbGV0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUG9pbnRPbkNvbHVtbihzZXJpZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGhhc0JveFR5cGVTZXJpZXMoc2VyaWVzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHNlcmllcy5saW5lIHx8IHNlcmllcy5hcmVhKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKChfYSA9IG9wdGlvbnMueEF4aXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb2ludE9uQ29sdW1uKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU2VyaWVzVXNpbmdSYWRpYWxBeGVzKHNlcmllcykge1xuICAgIHJldHVybiAhIXNlcmllcy5yYWRhciB8fCAhIXNlcmllcy5yYWRpYWxCYXIgfHwgISFzZXJpZXMuZ2F1Z2U7XG59XG5mdW5jdGlvbiBnZXRBeGlzTmFtZVVzaW5nUmFkaWFsQXhlcyhsYWJlbEF4aXNPbllBeGlzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWVBeGlzTmFtZTogbGFiZWxBeGlzT25ZQXhpcyA/ICdjaXJjdWxhckF4aXMnIDogJ3ZlcnRpY2FsQXhpcycsXG4gICAgICAgIGxhYmVsQXhpc05hbWU6IGxhYmVsQXhpc09uWUF4aXMgPyAndmVydGljYWxBeGlzJyA6ICdjaXJjdWxhckF4aXMnLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QXhpc05hbWUobGFiZWxBeGlzT25ZQXhpcywgc2VyaWVzKSB7XG4gICAgcmV0dXJuIGlzU2VyaWVzVXNpbmdSYWRpYWxBeGVzKHNlcmllcylcbiAgICAgICAgPyBnZXRBeGlzTmFtZVVzaW5nUmFkaWFsQXhlcyhsYWJlbEF4aXNPbllBeGlzKVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIHZhbHVlQXhpc05hbWU6IGxhYmVsQXhpc09uWUF4aXMgPyAneEF4aXMnIDogJ3lBeGlzJyxcbiAgICAgICAgICAgIGxhYmVsQXhpc05hbWU6IGxhYmVsQXhpc09uWUF4aXMgPyAneUF4aXMnIDogJ3hBeGlzJyxcbiAgICAgICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaXplS2V5KGxhYmVsQXhpc09uWUF4aXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZVNpemVLZXk6IGxhYmVsQXhpc09uWUF4aXMgPyAnd2lkdGgnIDogJ2hlaWdodCcsXG4gICAgICAgIGxhYmVsU2l6ZUtleTogbGFiZWxBeGlzT25ZQXhpcyA/ICdoZWlnaHQnIDogJ3dpZHRoJyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldExpbWl0T25BeGlzKGxhYmVscykge1xuICAgIGNvbnN0IHZhbHVlcyA9IGxhYmVscy5tYXAoKGxhYmVsKSA9PiBOdW1iZXIobGFiZWwpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtaW46IE1hdGgubWluKC4uLnZhbHVlcyksXG4gICAgICAgIG1heDogTWF0aC5tYXgoLi4udmFsdWVzKSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc1NlY29uZGFyeVlBeGlzKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoKF9hID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnlBeGlzKSAmJiBvcHRpb25zLnlBeGlzLmxlbmd0aCA9PT0gMjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRZQXhpc09wdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNlY29uZGFyeVlBeGlzID0gaGFzU2Vjb25kYXJ5WUF4aXMob3B0aW9ucyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeUF4aXM6IHNlY29uZGFyeVlBeGlzID8gb3B0aW9ucy55QXhpc1swXSA6IChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS55QXhpcyxcbiAgICAgICAgc2Vjb25kYXJ5WUF4aXM6IHNlY29uZGFyeVlBeGlzID8gb3B0aW9ucy55QXhpc1sxXSA6IG51bGwsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZUF4aXNOYW1lKG9wdGlvbnMsIHNlcmllc05hbWUsIHZhbHVlQXhpc05hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBzZWNvbmRhcnlZQXhpcyB9ID0gZ2V0WUF4aXNPcHRpb24ob3B0aW9ucyk7XG4gICAgcmV0dXJuICgoX2EgPSBzZWNvbmRhcnlZQXhpcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNoYXJ0VHlwZSkgPT09IHNlcmllc05hbWUgPyAnc2Vjb25kYXJ5WUF4aXMnIDogdmFsdWVBeGlzTmFtZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZUF4aXNOYW1lcyhvcHRpb25zLCB2YWx1ZUF4aXNOYW1lKSB7XG4gICAgaWYgKGluY2x1ZGVzKFtBeGlzVHlwZS5YLCBBeGlzVHlwZS5DSVJDVUxBUiwgQXhpc1R5cGUuVkVSVElDQUxdLCB2YWx1ZUF4aXNOYW1lKSkge1xuICAgICAgICByZXR1cm4gW3ZhbHVlQXhpc05hbWVdO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zVXNpbmdZQXhpcyA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyB5QXhpcywgc2Vjb25kYXJ5WUF4aXMgfSA9IGdldFlBeGlzT3B0aW9uKG9wdGlvbnNVc2luZ1lBeGlzKTtcbiAgICByZXR1cm4gc2Vjb25kYXJ5WUF4aXNcbiAgICAgICAgPyBbeUF4aXMuY2hhcnRUeXBlLCBzZWNvbmRhcnlZQXhpcy5jaGFydFR5cGVdLm1hcCgoc2VyaWVzTmFtZSwgaW5kZXgpID0+IHNlcmllc05hbWVcbiAgICAgICAgICAgID8gZ2V0VmFsdWVBeGlzTmFtZShvcHRpb25zVXNpbmdZQXhpcywgc2VyaWVzTmFtZSwgdmFsdWVBeGlzTmFtZSlcbiAgICAgICAgICAgIDogWyd5QXhpcycsICdzZWNvbmRhcnlZQXhpcyddW2luZGV4XSlcbiAgICAgICAgOiBbdmFsdWVBeGlzTmFtZV07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QXhpc1RoZW1lKHRoZW1lLCBuYW1lKSB7XG4gICAgY29uc3QgeyB4QXhpcywgeUF4aXMsIGNpcmN1bGFyQXhpcyB9ID0gdGhlbWU7XG4gICAgbGV0IGF4aXNUaGVtZTtcbiAgICBpZiAobmFtZSA9PT0gQXhpc1R5cGUuWCkge1xuICAgICAgICBheGlzVGhlbWUgPSB4QXhpcztcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh5QXhpcykpIHtcbiAgICAgICAgYXhpc1RoZW1lID0gbmFtZSA9PT0gQXhpc1R5cGUuWSA/IHlBeGlzWzBdIDogeUF4aXNbMV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgPT09IFJhZGlhbEF4aXNUeXBlLkNJUkNVTEFSKSB7XG4gICAgICAgIGF4aXNUaGVtZSA9IGNpcmN1bGFyQXhpcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF4aXNUaGVtZSA9IHlBeGlzO1xuICAgIH1cbiAgICByZXR1cm4gYXhpc1RoZW1lO1xufVxuZnVuY3Rpb24gZ2V0Um90YXRpb25EZWdyZWUoZGlzdGFuY2UsIGxhYmVsV2lkdGgsIGxhYmVsSGVpZ2h0LCBheGlzTGF5b3V0KSB7XG4gICAgbGV0IGRlZ3JlZSA9IDA7XG4gICAgQU5HTEVfQ0FORElEQVRFUy5ldmVyeSgoYW5nbGUpID0+IHtcbiAgICAgICAgY29uc3QgY29tcGFyZVdpZHRoID0gY2FsY3VsYXRlUm90YXRlZFdpZHRoKGFuZ2xlLCBsYWJlbFdpZHRoLCBsYWJlbEhlaWdodCk7XG4gICAgICAgIGRlZ3JlZSA9IGFuZ2xlO1xuICAgICAgICByZXR1cm4gY29tcGFyZVdpZHRoID4gZGlzdGFuY2UgfHwgY29tcGFyZVdpZHRoIC8gMiA+IGF4aXNMYXlvdXQueDtcbiAgICB9KTtcbiAgICByZXR1cm4gZGlzdGFuY2UgPCBsYWJlbFdpZHRoIHx8IGxhYmVsV2lkdGggLyAyID4gYXhpc0xheW91dC54ID8gZGVncmVlIDogMDtcbn1cbmZ1bmN0aW9uIGhhc1lBeGlzTWF4TGFiZWxMZW5ndGhDaGFuZ2VkKHByZXZpb3VzQXhlcywgY3VycmVudEF4ZXMsIGZpZWxkKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBwcmV2WUF4aXMgPSBwcmV2aW91c0F4ZXNbZmllbGRdO1xuICAgIGNvbnN0IHlBeGlzID0gY3VycmVudEF4ZXNbZmllbGRdO1xuICAgIGlmICghcHJldllBeGlzICYmICF5QXhpcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoKF9hID0gcHJldllBeGlzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF4TGFiZWxXaWR0aCkgIT09ICgoX2IgPSB5QXhpcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1heExhYmVsV2lkdGgpO1xufVxuZnVuY3Rpb24gaGFzWUF4aXNUeXBlTWF4TGFiZWxDaGFuZ2VkKHByZXZpb3VzQXhlcywgY3VycmVudEF4ZXMpIHtcbiAgICByZXR1cm4gKGhhc1lBeGlzTWF4TGFiZWxMZW5ndGhDaGFuZ2VkKHByZXZpb3VzQXhlcywgY3VycmVudEF4ZXMsICd5QXhpcycpIHx8XG4gICAgICAgIGhhc1lBeGlzTWF4TGFiZWxMZW5ndGhDaGFuZ2VkKHByZXZpb3VzQXhlcywgY3VycmVudEF4ZXMsICdzZWNvbmRhcnlZQXhpcycpKTtcbn1cbmZ1bmN0aW9uIGhhc1hBeGlzU2l6ZUNoYW5nZWQocHJldmlvdXNBeGVzLCBjdXJyZW50QXhlcykge1xuICAgIGNvbnN0IHsgbWF4SGVpZ2h0OiBwcmV2TWF4SGVpZ2h0IH0gPSBwcmV2aW91c0F4ZXMueEF4aXM7XG4gICAgY29uc3QgeyBtYXhIZWlnaHQgfSA9IGN1cnJlbnRBeGVzLnhBeGlzO1xuICAgIHJldHVybiBwcmV2TWF4SGVpZ2h0ICE9PSBtYXhIZWlnaHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzQXhlc0xheW91dENoYW5nZWQocHJldmlvdXNBeGVzLCBjdXJyZW50QXhlcykge1xuICAgIHJldHVybiAoaGFzWUF4aXNUeXBlTWF4TGFiZWxDaGFuZ2VkKHByZXZpb3VzQXhlcywgY3VycmVudEF4ZXMpIHx8XG4gICAgICAgIGhhc1hBeGlzU2l6ZUNoYW5nZWQocHJldmlvdXNBeGVzLCBjdXJyZW50QXhlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdGF0YWJsZU9wdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIHJldHVybiBfZCA9IChfYyA9IChfYiA9IChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS54QXhpcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxhYmVsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mucm90YXRhYmxlLCAoX2QgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdHJ1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Vmlld0F4aXNMYWJlbHMoYXhpc0RhdGEsIGF4aXNTaXplKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHsgbGFiZWxzLCBwb2ludE9uQ29sdW1uLCBsYWJlbERpc3RhbmNlLCB0aWNrRGlzdGFuY2UsIGxhYmVsSW50ZXJ2YWwsIHRpY2tJbnRlcnZhbCwgdGlja0NvdW50LCBzY2FsZSwgfSA9IGF4aXNEYXRhO1xuICAgIGxldCBheGlzU2l6ZUFwcGxpZWRSYXRpbyA9IGF4aXNTaXplO1xuICAgIGxldCBhZGRpdGlvbmFsID0gMDtcbiAgICBsZXQgbGFiZWxBZGp1c3RtZW50ID0gMDtcbiAgICBpZiAoc2NhbGUpIHtcbiAgICAgICAgY29uc3Qgc2l6ZVJhdGlvID0gKF9iID0gKF9hID0gc2NhbGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaXplUmF0aW8sIChfYiAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxKSk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uUmF0aW8gPSAoX2QgPSAoX2MgPSBzY2FsZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBvc2l0aW9uUmF0aW8sIChfZCAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwKSk7XG4gICAgICAgIGF4aXNTaXplQXBwbGllZFJhdGlvID0gYXhpc1NpemUgKiBzaXplUmF0aW87XG4gICAgICAgIGFkZGl0aW9uYWwgPSBheGlzU2l6ZSAqIHBvc2l0aW9uUmF0aW87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBpbnRlcnZhbCA9IGxhYmVsSW50ZXJ2YWwgPT09IHRpY2tJbnRlcnZhbCA/IGxhYmVsSW50ZXJ2YWwgOiAxO1xuICAgICAgICBsYWJlbEFkanVzdG1lbnQgPSBwb2ludE9uQ29sdW1uID8gKChsYWJlbERpc3RhbmNlICE9PSBudWxsICYmIGxhYmVsRGlzdGFuY2UgIT09IHZvaWQgMCA/IGxhYmVsRGlzdGFuY2UgOiB0aWNrRGlzdGFuY2UgKiBpbnRlcnZhbCkpIC8gMiA6IDA7XG4gICAgfVxuICAgIGNvbnN0IHJlbGF0aXZlUG9zaXRpb25zID0gbWFrZVRpY2tQaXhlbFBvc2l0aW9ucyhheGlzU2l6ZUFwcGxpZWRSYXRpbywgdGlja0NvdW50LCBhZGRpdGlvbmFsKTtcbiAgICByZXR1cm4gbGFiZWxzLnJlZHVjZSgoYWNjLCB0ZXh0LCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBvZmZzZXRQb3MgPSByZWxhdGl2ZVBvc2l0aW9uc1tpbmRleF0gKyBsYWJlbEFkanVzdG1lbnQ7XG4gICAgICAgIGNvbnN0IG5lZWRSZW5kZXIgPSAhKGluZGV4ICUgbGFiZWxJbnRlcnZhbCkgJiYgb2Zmc2V0UG9zIDw9IGF4aXNTaXplO1xuICAgICAgICByZXR1cm4gbmVlZFJlbmRlciA/IFsuLi5hY2MsIHsgb2Zmc2V0UG9zLCB0ZXh0IH1dIDogYWNjO1xuICAgIH0sIFtdKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYWtlVGl0bGVPcHRpb24odGl0bGUpIHtcbiAgICBpZiAoaXNVbmRlZmluZWQodGl0bGUpKSB7XG4gICAgICAgIHJldHVybiB0aXRsZTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbiA9IHsgdGV4dDogJycsIG9mZnNldFg6IDAsIG9mZnNldFk6IDAgfTtcbiAgICByZXR1cm4gaXNTdHJpbmcodGl0bGUpID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9uKSwgeyB0ZXh0OiB0aXRsZSB9KSA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbiksIHRpdGxlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBeGlzRm9ybWF0dGVyKG9wdGlvbnMsIGF4aXNOYW1lKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgYXhpc09wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGdldFlBeGlzT3B0aW9uKG9wdGlvbnMpKSwgeyB4QXhpczogb3B0aW9ucy54QXhpcyB9KTtcbiAgICByZXR1cm4gX2MgPSAoX2IgPSAoX2EgPSBheGlzT3B0aW9uc1theGlzTmFtZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYWJlbCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZvcm1hdHRlciwgKF9jICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICgodmFsdWUpID0+IHZhbHVlKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TGFiZWxzQXBwbGllZEZvcm1hdHRlcihsYWJlbHMsIG9wdGlvbnMsIGRhdGVUeXBlLCBheGlzTmFtZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZGF0ZUZvcm1hdHRlciA9IGdldERhdGVGb3JtYXQoKF9iID0gKF9hID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2F4aXNOYW1lXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRhdGUpO1xuICAgIGNvbnN0IGZvcm1hdHRlZExhYmVscyA9IGRhdGVUeXBlICYmIGRhdGVGb3JtYXR0ZXJcbiAgICAgICAgPyBsYWJlbHMubWFwKChsYWJlbCkgPT4gZm9ybWF0RGF0ZShkYXRlRm9ybWF0dGVyLCBuZXcgRGF0ZShsYWJlbCkpKVxuICAgICAgICA6IGxhYmVscztcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBnZXRBeGlzRm9ybWF0dGVyKG9wdGlvbnMsIGF4aXNOYW1lKTtcbiAgICByZXR1cm4gZm9ybWF0dGVkTGFiZWxzLm1hcCgobGFiZWwsIGluZGV4KSA9PiBmb3JtYXR0ZXIobGFiZWwsIHsgaW5kZXgsIGxhYmVscywgYXhpc05hbWUgfSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VSb3RhdGlvbkRhdGEobWF4TGFiZWxXaWR0aCwgbWF4TGFiZWxIZWlnaHQsIGRpc3RhbmNlLCByb3RhdGFibGUsIGF4aXNMYXlvdXQpIHtcbiAgICBjb25zdCBkZWdyZWUgPSBnZXRSb3RhdGlvbkRlZ3JlZShkaXN0YW5jZSwgbWF4TGFiZWxXaWR0aCwgbWF4TGFiZWxIZWlnaHQsIGF4aXNMYXlvdXQpO1xuICAgIGlmICghcm90YXRhYmxlIHx8IGRlZ3JlZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmVlZFJvdGF0ZUxhYmVsOiBmYWxzZSxcbiAgICAgICAgICAgIHJhZGlhbjogMCxcbiAgICAgICAgICAgIHJvdGF0aW9uSGVpZ2h0OiBtYXhMYWJlbEhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmVlZFJvdGF0ZUxhYmVsOiBkZWdyZWUgPiAwLFxuICAgICAgICByYWRpYW46IGNhbGN1bGF0ZURlZ3JlZVRvUmFkaWFuKGRlZ3JlZSwgMCksXG4gICAgICAgIHJvdGF0aW9uSGVpZ2h0OiBjYWxjdWxhdGVSb3RhdGVkSGVpZ2h0KGRlZ3JlZSwgbWF4TGFiZWxXaWR0aCwgbWF4TGFiZWxIZWlnaHQpLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TWF4TGFiZWxTaXplKGxhYmVscywgeE1hcmdpbiwgZm9udCA9IERFRkFVTFRfTEFCRUxfVEVYVCkge1xuICAgIGNvbnN0IG1heExlbmd0aExhYmVsID0gbGFiZWxzLnJlZHVjZSgoYWNjLCBjdXIpID0+IChhY2MubGVuZ3RoID4gY3VyLmxlbmd0aCA/IGFjYyA6IGN1ciksICcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYXhMYWJlbFdpZHRoOiBnZXRUZXh0V2lkdGgobWF4TGVuZ3RoTGFiZWwsIGZvbnQpICsgeE1hcmdpbixcbiAgICAgICAgbWF4TGFiZWxIZWlnaHQ6IGdldFRleHRIZWlnaHQobWF4TGVuZ3RoTGFiZWwsIGZvbnQpLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TGFiZWxYTWFyZ2luKGF4aXNOYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGlmIChheGlzTmFtZSA9PT0gJ3hBeGlzJykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgYXhpc09wdGlvbnMgPSBnZXRZQXhpc09wdGlvbihvcHRpb25zKTtcbiAgICByZXR1cm4gTWF0aC5hYnMoKF9kID0gKF9jID0gKF9iID0gKF9hID0gYXhpc09wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtheGlzTmFtZV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sYWJlbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1hcmdpbiwgKF9kICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDApKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5pdEF4aXNJbnRlcnZhbERhdGEoaXNMYWJlbEF4aXMsIHBhcmFtcykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIGNvbnN0IHsgYXhpcywgY2F0ZWdvcmllcywgbGF5b3V0LCBpc0Nvb3JkaW5hdGVUeXBlQ2hhcnQgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0aWNrSW50ZXJ2YWwgPSAoX2IgPSAoX2EgPSBheGlzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGljaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmludGVydmFsO1xuICAgIGNvbnN0IGxhYmVsSW50ZXJ2YWwgPSAoX2QgPSAoX2MgPSBheGlzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGFiZWwpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5pbnRlcnZhbDtcbiAgICBjb25zdCBleGlzdEludGVydmFsT3B0aW9ucyA9IGlzTnVtYmVyKHRpY2tJbnRlcnZhbCkgfHwgaXNOdW1iZXIobGFiZWxJbnRlcnZhbCk7XG4gICAgY29uc3QgbmVlZEFkanVzdEludGVydmFsID0gaXNMYWJlbEF4aXMgJiZcbiAgICAgICAgIWlzTnVtYmVyKChfZiA9IChfZSA9IGF4aXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5zY2FsZSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnN0ZXBTaXplKSAmJlxuICAgICAgICAhcGFyYW1zLnNoaWZ0ICYmXG4gICAgICAgICFleGlzdEludGVydmFsT3B0aW9ucyAmJlxuICAgICAgICAhaXNDb29yZGluYXRlVHlwZUNoYXJ0O1xuICAgIGNvbnN0IGluaXRUaWNrSW50ZXJ2YWwgPSBuZWVkQWRqdXN0SW50ZXJ2YWwgPyBnZXRJbml0VGlja0ludGVydmFsKGNhdGVnb3JpZXMsIGxheW91dCkgOiAxO1xuICAgIGNvbnN0IGluaXRMYWJlbEludGVydmFsID0gbmVlZEFkanVzdEludGVydmFsID8gaW5pdFRpY2tJbnRlcnZhbCA6IDE7XG4gICAgY29uc3QgYXhpc0RhdGEgPSB7XG4gICAgICAgIHRpY2tJbnRlcnZhbDogKHRpY2tJbnRlcnZhbCAhPT0gbnVsbCAmJiB0aWNrSW50ZXJ2YWwgIT09IHZvaWQgMCA/IHRpY2tJbnRlcnZhbCA6IGluaXRUaWNrSW50ZXJ2YWwpLFxuICAgICAgICBsYWJlbEludGVydmFsOiAobGFiZWxJbnRlcnZhbCAhPT0gbnVsbCAmJiBsYWJlbEludGVydmFsICE9PSB2b2lkIDAgPyBsYWJlbEludGVydmFsIDogaW5pdExhYmVsSW50ZXJ2YWwpLFxuICAgIH07XG4gICAgcmV0dXJuIGF4aXNEYXRhO1xufVxuZnVuY3Rpb24gZ2V0SW5pdFRpY2tJbnRlcnZhbChjYXRlZ29yaWVzLCBsYXlvdXQpIHtcbiAgICBpZiAoIWNhdGVnb3JpZXMgfHwgIWxheW91dCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgY29uc3QgeyB3aWR0aCB9ID0gbGF5b3V0LnhBeGlzO1xuICAgIGNvbnN0IGNvdW50ID0gY2F0ZWdvcmllcy5sZW5ndGg7XG4gICAgcmV0dXJuIGdldEF1dG9BZGp1c3RpbmdJbnRlcnZhbChjb3VudCwgd2lkdGgsIGNhdGVnb3JpZXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRSYWRpYWxBeGlzRGF0YShvcHRpb25zLCBwbG90LCBtYXhMYWJlbFdpZHRoID0gMCwgbWF4TGFiZWxIZWlnaHQgPSAwLCBpc0xhYmVsT25WZXJ0aWNhbEF4aXMgPSBmYWxzZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBjZW50ZXJYID0gcGxvdC53aWR0aCAvIDI7XG4gICAgaWYgKGlzTGFiZWxPblZlcnRpY2FsQXhpcykge1xuICAgICAgICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjbG9ja3dpc2UgfSA9IGluaXRTZWN0b3JPcHRpb25zKChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXJpZXMpO1xuICAgICAgICBjb25zdCBpc1NlbWlDaXJjdWxhciA9IGlzU2VtaUNpcmNsZShjbG9ja3dpc2UsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzU2VtaUNpcmN1bGFyLFxuICAgICAgICAgICAgYXhpc1NpemU6IGdldERlZmF1bHRSYWRpdXMocGxvdCwgaXNTZW1pQ2lyY3VsYXIsIG1heExhYmVsV2lkdGgsIG1heExhYmVsSGVpZ2h0KSxcbiAgICAgICAgICAgIGNlbnRlclgsXG4gICAgICAgICAgICBjZW50ZXJZOiBpc1NlbWlDaXJjdWxhciA/IGdldFNlbWlDaXJjbGVDZW50ZXJZKHBsb3QuaGVpZ2h0LCBjbG9ja3dpc2UpIDogcGxvdC5oZWlnaHQgLyAyLFxuICAgICAgICAgICAgdG90YWxBbmdsZTogZ2V0VG90YWxBbmdsZShjbG9ja3dpc2UsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSxcbiAgICAgICAgICAgIGRyYXdpbmdTdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgY2xvY2t3aXNlLFxuICAgICAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpc1NlbWlDaXJjdWxhcjogZmFsc2UsXG4gICAgICAgIGF4aXNTaXplOiBnZXREZWZhdWx0UmFkaXVzKHBsb3QsIGZhbHNlLCBtYXhMYWJlbFdpZHRoLCBtYXhMYWJlbEhlaWdodCksXG4gICAgICAgIGNlbnRlclgsXG4gICAgICAgIGNlbnRlclk6IHBsb3QuaGVpZ2h0IC8gMixcbiAgICAgICAgdG90YWxBbmdsZTogREVHUkVFXzM2MCxcbiAgICAgICAgZHJhd2luZ1N0YXJ0QW5nbGU6IERFR1JFRV8wLFxuICAgICAgICBjbG9ja3dpc2U6IHRydWUsXG4gICAgICAgIHN0YXJ0QW5nbGU6IERFR1JFRV8wLFxuICAgICAgICBlbmRBbmdsZTogREVHUkVFXzM2MCxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhZGl1c0luZm8oYXhpc1NpemUsIHJhZGl1c1JhbmdlLCBjb3VudCA9IDEpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBjYWxjdWxhdGVTaXplV2l0aFBlcmNlbnRTdHJpbmcoYXhpc1NpemUsIChfYiA9IChfYSA9IHJhZGl1c1JhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5uZXIsIChfYiAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSkpO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gY2FsY3VsYXRlU2l6ZVdpdGhQZXJjZW50U3RyaW5nKGF4aXNTaXplLCAoX2QgPSAoX2MgPSByYWRpdXNSYW5nZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm91dGVyLCAoX2QgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogYXhpc1NpemUpKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmFkaXVzUmFuZ2VzOiBtYWtlVGlja1BpeGVsUG9zaXRpb25zKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMsIGNvdW50LCBpbm5lclJhZGl1cylcbiAgICAgICAgICAgIC5zcGxpY2UoaW5uZXJSYWRpdXMgPT09IDAgPyAxIDogMCwgY291bnQpXG4gICAgICAgICAgICAucmV2ZXJzZSgpLFxuICAgICAgICBpbm5lclJhZGl1cyxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGVUeXBlKG9wdGlvbnMsIGF4aXNOYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAhISgoX2EgPSBvcHRpb25zW2F4aXNOYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGUpO1xufVxuIiwiZnVuY3Rpb24gbGltaXROZWdhdGl2ZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICBsZXQgcmVzdWx0ID0gdmFsdWU7XG4gICAgaWYgKHJlc3VsdCA+PSBtYXgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChtYXggPCAwKSB7XG4gICAgICAgIHJlc3VsdCA9IE1hdGgubWluKHZhbHVlIC0gbWF4LCAwKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgIHJlc3VsdCAtPSB2YWx1ZSAtIG1pbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxpbWl0UG9zaXRpdmUodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlO1xuICAgIGlmIChtaW4gPiAwKSB7XG4gICAgICAgIHJlc3VsdCA9IE1hdGgubWF4KHZhbHVlIC0gbWluLCAwKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgIHJlc3VsdCAtPSB2YWx1ZSAtIG1heDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjYWxpYnJhdGVEcmF3aW5nVmFsdWUodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgMCA/IGxpbWl0TmVnYXRpdmUodmFsdWUsIG1pbiwgbWF4KSA6IGxpbWl0UG9zaXRpdmUodmFsdWUsIG1pbiwgbWF4KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdW1WYWx1ZXNCZWZvcmVJbmRleCh2YWx1ZXMsIHRhcmdldEluZGV4LCBpbmNsdWRlVGFyZ2V0ID0gZmFsc2UpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB2YWx1ZXNbdGFyZ2V0SW5kZXhdO1xuICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKCh0b3RhbCwgdmFsdWUsIGlkeCkgPT4ge1xuICAgICAgICBjb25zdCBpc0JlZm9yZSA9IGluY2x1ZGVUYXJnZXQgPyBpZHggPD0gdGFyZ2V0SW5kZXggOiBpZHggPCB0YXJnZXRJbmRleDtcbiAgICAgICAgY29uc3QgaXNTYW1lU2lnbiA9IHZhbHVlICogdGFyZ2V0ID49IDA7XG4gICAgICAgIHJldHVybiBpc0JlZm9yZSAmJiBpc1NhbWVTaWduID8gdG90YWwgKyB2YWx1ZSA6IHRvdGFsO1xuICAgIH0sIDApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG91dHNpZGVSYW5nZSh2YWx1ZXMsIGN1cnJlbnRJbmRleCwgbWluLCBtYXgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tjdXJyZW50SW5kZXhdO1xuICAgIGNvbnN0IHRvdGFsT2ZJbmRleEJlZm9yZSA9IHN1bVZhbHVlc0JlZm9yZUluZGV4KHZhbHVlcywgY3VycmVudEluZGV4LCBmYWxzZSk7XG4gICAgY29uc3QgcG9zaXRpdmUgPSB2YWx1ZSA+PSAwO1xuICAgIGNvbnN0IG5lZ2F0aXZlID0gdmFsdWUgPCAwO1xuICAgIHJldHVybiAoKHBvc2l0aXZlICYmIHRvdGFsT2ZJbmRleEJlZm9yZSA+PSBtYXgpIHx8XG4gICAgICAgIChuZWdhdGl2ZSAmJiB0b3RhbE9mSW5kZXhCZWZvcmUgPD0gbWluKSB8fFxuICAgICAgICAoY3VycmVudEluZGV4ID09PSAwICYmIHBvc2l0aXZlICYmIHZhbHVlIDwgbWluKSB8fFxuICAgICAgICAoY3VycmVudEluZGV4ID09PSAwICYmIG5lZ2F0aXZlICYmIHZhbHVlID4gbWF4KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY2FsaWJyYXRlQm94U3RhY2tEcmF3aW5nVmFsdWUodmFsdWVzLCBjdXJyZW50SW5kZXgsIG1pbiwgbWF4KSB7XG4gICAgY29uc3QgdG90YWxPZkluZGV4QmVmb3JlID0gc3VtVmFsdWVzQmVmb3JlSW5kZXgodmFsdWVzLCBjdXJyZW50SW5kZXgsIGZhbHNlKTtcbiAgICBjb25zdCB0b3RhbE9mVmFsdWVzID0gc3VtVmFsdWVzQmVmb3JlSW5kZXgodmFsdWVzLCBjdXJyZW50SW5kZXgsIHRydWUpO1xuICAgIGlmIChvdXRzaWRlUmFuZ2UodmFsdWVzLCBjdXJyZW50SW5kZXgsIG1pbiwgbWF4KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY2FsaWJyYXRlRHJhd2luZ1ZhbHVlKHZhbHVlc1tjdXJyZW50SW5kZXhdLCBtaW4sIG1heCk7XG4gICAgfVxuICAgIGlmICh0b3RhbE9mSW5kZXhCZWZvcmUgPCBtaW4gJiYgdG90YWxPZlZhbHVlcyA+IG1heCkge1xuICAgICAgICByZXR1cm4gbWF4IC0gbWluO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gdmFsdWVzW2N1cnJlbnRJbmRleF07XG4gICAgaWYgKHRvdGFsT2ZWYWx1ZXMgPiBtYXgpIHtcbiAgICAgICAgcmVzdWx0ID0gbWF4IC0gdG90YWxPZkluZGV4QmVmb3JlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0b3RhbE9mVmFsdWVzIDwgbWluKSB7XG4gICAgICAgIHJlc3VsdCA9IG1pbiAtIHRvdGFsT2ZJbmRleEJlZm9yZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodG90YWxPZkluZGV4QmVmb3JlIDwgbWluKSB7XG4gICAgICAgIHJlc3VsdCA9IHRvdGFsT2ZWYWx1ZXMgLSBtaW47XG4gICAgfVxuICAgIGVsc2UgaWYgKHRvdGFsT2ZJbmRleEJlZm9yZSA+IG1heCkge1xuICAgICAgICByZXN1bHQgPSB0b3RhbE9mVmFsdWVzIC0gbWF4O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0IHsgcmFuZ2UsIGlzSW50ZWdlciwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc051bGwgfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgREVGQVVMVF9MQUJFTF9URVhUIH0gZnJvbSBcIi4uL2JydXNoZXMvbGFiZWxcIjtcbmltcG9ydCB7IFRJQ0tfU0laRSB9IGZyb20gXCIuLi9icnVzaGVzL2F4aXNcIjtcbmNvbnN0IExJTkVfSEVJR0hUX05PUk1BTCA9IDEuMjtcbmNvbnN0IGN0eCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dFdpZHRoKHRleHQsIGZvbnQgPSBERUZBVUxUX0xBQkVMX1RFWFQpIHtcbiAgICBjdHguZm9udCA9IGZvbnQ7XG4gICAgcmV0dXJuIE1hdGguY2VpbChjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGgpO1xufVxuLypcbiAqIENhbGN1bGF0ZSBoZWlnaHQgb2YgY2FudmFzIHRleHRcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UZXh0TWV0cmljc1xuICogKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXh0SGVpZ2h0KHRleHQsIGZvbnQgPSBERUZBVUxUX0xBQkVMX1RFWFQpIHtcbiAgICBjdHguZm9udCA9IGZvbnQ7XG4gICAgY29uc3QgeyBhY3R1YWxCb3VuZGluZ0JveEFzY2VudCwgYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50IH0gPSBjdHgubWVhc3VyZVRleHQodGV4dCk7XG4gICAgY29uc3QgdmFsaWRBY3R1YWxCb3VuZGluZ0JveCA9IGlzTnVtYmVyKGFjdHVhbEJvdW5kaW5nQm94QXNjZW50KSAmJiBpc051bWJlcihhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQpO1xuICAgIHJldHVybiB2YWxpZEFjdHVhbEJvdW5kaW5nQm94XG4gICAgICAgID8gTWF0aC5jZWlsKE1hdGguYWJzKGFjdHVhbEJvdW5kaW5nQm94QXNjZW50KSArIE1hdGguYWJzKGFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCkpICsgMVxuICAgICAgICA6IGdldEZvbnRIZWlnaHQoZm9udCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9udEhlaWdodChmb250ID0gREVGQVVMVF9MQUJFTF9URVhUKSB7XG4gICAgY29uc3QgZm9udFNpemUgPSBmb250Lm1hdGNoKC9cXGQrKD89cHgpLyk7XG4gICAgcmV0dXJuIHBhcnNlSW50KFN0cmluZyhOdW1iZXIoZm9udFNpemUpICogTElORV9IRUlHSFRfTk9STUFMKSwgMTApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEF4aXNMYWJlbEFuY2hvclBvaW50KGxhYmVsSGVpZ2h0KSB7XG4gICAgcmV0dXJuIGNyaXNwUGl4ZWwoVElDS19TSVpFICogMiArIGxhYmVsSGVpZ2h0IC8gMik7XG59XG5mdW5jdGlvbiBnZXREZWNpbWFsTGVuZ3RoKHZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gX2IgPSAoX2EgPSBTdHJpbmcodmFsdWUpLnNwbGl0KCcuJylbMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgsIChfYiAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTtcbn1cbmZ1bmN0aW9uIGZpbmRNdWx0aXBsZU51bSguLi5hcmdzKSB7XG4gICAgY29uc3QgdW5kZXJQb2ludExlbnMgPSBhcmdzLm1hcCgodmFsdWUpID0+IGdldERlY2ltYWxMZW5ndGgodmFsdWUpKTtcbiAgICBjb25zdCB1bmRlclBvaW50TGVuID0gTWF0aC5tYXgoLi4udW5kZXJQb2ludExlbnMpO1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdW5kZXJQb2ludExlbik7XG59XG5leHBvcnQgZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAgICBjb25zdCBtdWx0aXBsZU51bSA9IGZpbmRNdWx0aXBsZU51bShhLCBiKTtcbiAgICByZXR1cm4gKGEgKiBtdWx0aXBsZU51bSArIGIgKiBtdWx0aXBsZU51bSkgLyBtdWx0aXBsZU51bTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShhLCBiKSB7XG4gICAgY29uc3QgbXVsdGlwbGVOdW0gPSBmaW5kTXVsdGlwbGVOdW0oYSwgYik7XG4gICAgcmV0dXJuIChhICogbXVsdGlwbGVOdW0gKiAoYiAqIG11bHRpcGxlTnVtKSkgLyAobXVsdGlwbGVOdW0gKiBtdWx0aXBsZU51bSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKGEsIGIpIHtcbiAgICBjb25zdCBtdWx0aXBsZU51bSA9IGZpbmRNdWx0aXBsZU51bShhLCBiKTtcbiAgICByZXR1cm4gKGEgKiBtdWx0aXBsZU51bSkgLyAoYiAqIG11bHRpcGxlTnVtKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdW0odmFsdWVzKSB7XG4gICAgY29uc3QgY29weUFyciA9IHZhbHVlcy5zbGljZSgpO1xuICAgIGNvcHlBcnIudW5zaGlmdCgwKTtcbiAgICByZXR1cm4gY29weUFyci5yZWR1Y2UoKGJhc2UsIHZhbHVlKSA9PiBhZGQocGFyc2VGbG9hdChTdHJpbmcoYmFzZSkpLCBwYXJzZUZsb2F0KFN0cmluZyh2YWx1ZSkpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGl2aXNvcnModmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBhID0gMiwgYjsgYSAqIGEgPD0gdmFsdWU7IGEgKz0gMSkge1xuICAgICAgICBpZiAodmFsdWUgJSBhID09PSAwKSB7XG4gICAgICAgICAgICBiID0gdmFsdWUgLyBhO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYSk7XG4gICAgICAgICAgICBpZiAoYiAhPT0gYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuc29ydCgocHJldiwgbmV4dCkgPT4gcHJldiAtIG5leHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VMYWJlbHNGcm9tTGltaXQobGltaXQsIHN0ZXBTaXplLCBpc0RhdGVUeXBlKSB7XG4gICAgY29uc3QgbXVsdGlwbGVOdW0gPSBmaW5kTXVsdGlwbGVOdW0oc3RlcFNpemUpO1xuICAgIGNvbnN0IG1pbiA9IE1hdGgucm91bmQobGltaXQubWluICogbXVsdGlwbGVOdW0pO1xuICAgIGNvbnN0IG1heCA9IE1hdGgucm91bmQobGltaXQubWF4ICogbXVsdGlwbGVOdW0pO1xuICAgIGNvbnN0IGxhYmVscyA9IHJhbmdlKG1pbiwgbWF4ICsgMSwgc3RlcFNpemUgKiBtdWx0aXBsZU51bSk7XG4gICAgcmV0dXJuIGxhYmVscy5tYXAoKGxhYmVsKSA9PiB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoaXNEYXRlVHlwZSA/IG5ldyBEYXRlKGxhYmVsKSA6IGxhYmVsIC8gbXVsdGlwbGVOdW0pO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VUaWNrUGl4ZWxQb3NpdGlvbnMoc2l6ZSwgY291bnQsIGFkZGl0aW9uYWxQb3NpdGlvbiA9IDAsIHJlbWFpbkxhc3RCbG9ja0ludGVydmFsUG9zaXRpb24gPSAwKSB7XG4gICAgbGV0IHBvc2l0aW9ucyA9IFtdO1xuICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgcG9zaXRpb25zID0gcmFuZ2UoMCwgY291bnQpLm1hcCgoaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJhdGlvID0gaW5kZXggPT09IDAgPyAwIDogaW5kZXggLyAoY291bnQgLSAxKTtcbiAgICAgICAgICAgIHJldHVybiByYXRpbyAqIHNpemUgKyBhZGRpdGlvbmFsUG9zaXRpb247XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocmVtYWluTGFzdEJsb2NrSW50ZXJ2YWxQb3NpdGlvbikge1xuICAgICAgICBwb3NpdGlvbnMucHVzaChyZW1haW5MYXN0QmxvY2tJbnRlcnZhbFBvc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9ucztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmlzcFBpeGVsKHBpeGVsLCB0aGlja25lc3MgPSAxKSB7XG4gICAgY29uc3QgaGFsZlRoaWNrbmVzcyA9IHRoaWNrbmVzcyAvIDI7XG4gICAgcmV0dXJuIHRoaWNrbmVzcyAlIDJcbiAgICAgICAgPyAoaXNJbnRlZ2VyKHBpeGVsKSA/IHBpeGVsIDogTWF0aC5yb3VuZChwaXhlbCAtIGhhbGZUaGlja25lc3MpKSArIGhhbGZUaGlja25lc3NcbiAgICAgICAgOiBNYXRoLnJvdW5kKHBpeGVsKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRyb2xQb2ludHMocHJldiwgY3VyLCBuZXh0KSB7XG4gICAgLy8gaHR0cDovL3NjYWxlZGlubm92YXRpb24uY29tL2FuYWx5dGljcy9zcGxpbmVzL2Fib3V0U3BsaW5lcy5odG1sXG4gICAgY29uc3QgVEVOU0lPTiA9IDAuMzMzO1xuICAgIGNvbnN0IHsgeDogeDAsIHk6IHkwIH0gPSBwcmV2O1xuICAgIGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gPSBjdXI7XG4gICAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IG5leHQ7XG4gICAgY29uc3QgZDEyID0gZ2V0RGlzdGFuY2UobmV4dCwgY3VyKTtcbiAgICBjb25zdCBkMDEgPSBnZXREaXN0YW5jZShjdXIsIHByZXYpO1xuICAgIGNvbnN0IGZhID0gKFRFTlNJT04gKiBkMDEpIC8gKGQwMSArIGQxMikgfHwgMDsgLy8gc2NhbGluZyBmYWN0b3IgZm9yIHRyaWFuZ2xlIFRhXG4gICAgY29uc3QgZmIgPSAoVEVOU0lPTiAqIGQxMikgLyAoZDAxICsgZDEyKSB8fCAwOyAvLyBkaXR0byBmb3IgVGIsIHNpbXBsaWZpZXMgdG8gZmI9dC1mYVxuICAgIHJldHVybiB7XG4gICAgICAgIHByZXY6IHtcbiAgICAgICAgICAgIHg6IHgxIC0gZmEgKiAoeDIgLSB4MCksXG4gICAgICAgICAgICB5OiB5MSAtIGZhICogKHkyIC0geTApLFxuICAgICAgICB9LFxuICAgICAgICBuZXh0OiB7IHg6IHgxICsgZmIgKiAoeDIgLSB4MCksIHk6IHkxICsgZmIgKiAoeTIgLSB5MCkgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldFNwbGluZUNvbnRyb2xQb2ludChwb2ludHMpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgcG9pbnRzU2l6ZSA9IHBvaW50cy5sZW5ndGgsIHByZXYgPSBwb2ludHNbMF07IGkgPCBwb2ludHNTaXplOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgIGlmIChpc051bGwocG9pbnQpKSB7XG4gICAgICAgICAgICBwcmV2ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHQgPSBwb2ludHNbTWF0aC5taW4oaSArIDEsIHBvaW50c1NpemUgLSAxKSAlIHBvaW50c1NpemVdO1xuICAgICAgICBpZiAocHJldiAmJiBuZXh0KSB7XG4gICAgICAgICAgICBwb2ludC5jb250cm9sUG9pbnQgPSBnZXRDb250cm9sUG9pbnRzKHByZXYsIHBvaW50LCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gcG9pbnQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlUmF0aW8odmFsdWUsIHsgbWluLCBtYXggfSkge1xuICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuICh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0YW5jZShwb2ludDEsIHBvaW50Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coKHBvaW50Mi54IC0gcG9pbnQxLngpLCAyKSArIE1hdGgucG93KChwb2ludDIueSAtIHBvaW50MS55KSwgMikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1heExlbmd0aExhYmVsV2lkdGgobGFiZWxzKSB7XG4gICAgY29uc3QgbWF4TGVuZ3RoTGFiZWwgPSBsYWJlbHMucmVkdWNlKChhY2MsIGN1cikgPT4gKGFjYy5sZW5ndGggPiBjdXIubGVuZ3RoID8gYWNjIDogY3VyKSwgJycpO1xuICAgIHJldHVybiBnZXRUZXh0V2lkdGgobWF4TGVuZ3RoTGFiZWwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFhQb3NpdGlvbihheGlzRGF0YSwgb2Zmc2V0U2l6ZSwgdmFsdWUsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHsgcG9pbnRPbkNvbHVtbiwgdGlja0Rpc3RhbmNlLCBsYWJlbFJhbmdlIH0gPSBheGlzRGF0YTtcbiAgICBsZXQgeDtcbiAgICBpZiAobGFiZWxSYW5nZSkge1xuICAgICAgICBjb25zdCB4VmFsdWUgPSBpc1N0cmluZyh2YWx1ZSkgPyBOdW1iZXIobmV3IERhdGUodmFsdWUpKSA6IE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHhWYWx1ZVJhdGlvID0gZ2V0VmFsdWVSYXRpbyh4VmFsdWUsIGxhYmVsUmFuZ2UpO1xuICAgICAgICB4ID0geFZhbHVlUmF0aW8gKiBvZmZzZXRTaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgeCA9IHRpY2tEaXN0YW5jZSAqIGRhdGFJbmRleCArIChwb2ludE9uQ29sdW1uID8gdGlja0Rpc3RhbmNlIC8gMiA6IDApO1xuICAgIH1cbiAgICByZXR1cm4geDtcbn1cbiIsImltcG9ydCB7IHJhbmdlIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmNvbnN0IGhleFJYID0gLyheI1swLTlBLUZdezZ9JCl8KF4jWzAtOUEtRl17M30kKS9pO1xuY29uc3QgcmdiUlggPSAvcmdiXFwoKFxcZHsxLDN9KSwgPyhcXGR7MSwzfSksID8oXFxkezEsM30pXFwpLztcbmNvbnN0IHJnYmFSWCA9IC9yZ2JhXFwoKFxcZHsxLDN9KSwgPyhcXGR7MSwzfSksID8oXFxkezEsM30pLCA/KDF8MD9cXC4/XFxkKylcXCkvO1xuLyoqXG4gKiBDb2xvciBtYXAuXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE1NzMwNTMvamF2YXNjcmlwdC1mdW5jdGlvbi10by1jb252ZXJ0LWNvbG9yLW5hbWVzLXRvLWhleC1jb2Rlc1xuICogaHR0cDovL3d3dy53M3NjaG9vbHMuY29tL0hUTUwvaHRtbF9jb2xvcm5hbWVzLmFzcFxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgY29sb3JNYXAgPSB7XG4gICAgYWxpY2VibHVlOiAnI2YwZjhmZicsXG4gICAgYW50aXF1ZXdoaXRlOiAnI2ZhZWJkNycsXG4gICAgYXF1YTogJyMwMGZmZmYnLFxuICAgIGFxdWFtYXJpbmU6ICcjN2ZmZmQ0JyxcbiAgICBhenVyZTogJyNmMGZmZmYnLFxuICAgIGJlaWdlOiAnI2Y1ZjVkYycsXG4gICAgYmlzcXVlOiAnI2ZmZTRjNCcsXG4gICAgYmxhY2s6ICcjMDAwMDAwJyxcbiAgICBibGFuY2hlZGFsbW9uZDogJyNmZmViY2QnLFxuICAgIGJsdWU6ICcjMDAwMGZmJyxcbiAgICBibHVldmlvbGV0OiAnIzhhMmJlMicsXG4gICAgYnJvd246ICcjYTUyYTJhJyxcbiAgICBidXJseXdvb2Q6ICcjZGViODg3JyxcbiAgICBjYWRldGJsdWU6ICcjNWY5ZWEwJyxcbiAgICBjaGFydHJldXNlOiAnIzdmZmYwMCcsXG4gICAgY2hvY29sYXRlOiAnI2QyNjkxZScsXG4gICAgY29yYWw6ICcjZmY3ZjUwJyxcbiAgICBjb3JuZmxvd2VyYmx1ZTogJyM2NDk1ZWQnLFxuICAgIGNvcm5zaWxrOiAnI2ZmZjhkYycsXG4gICAgY3JpbXNvbjogJyNkYzE0M2MnLFxuICAgIGN5YW46ICcjMDBmZmZmJyxcbiAgICBkYXJrYmx1ZTogJyMwMDAwOGInLFxuICAgIGRhcmtjeWFuOiAnIzAwOGI4YicsXG4gICAgZGFya2dvbGRlbnJvZDogJyNiODg2MGInLFxuICAgIGRhcmtncmF5OiAnI2E5YTlhOScsXG4gICAgZGFya2dyZWVuOiAnIzAwNjQwMCcsXG4gICAgZGFya2toYWtpOiAnI2JkYjc2YicsXG4gICAgZGFya21hZ2VudGE6ICcjOGIwMDhiJyxcbiAgICBkYXJrb2xpdmVncmVlbjogJyM1NTZiMmYnLFxuICAgIGRhcmtvcmFuZ2U6ICcjZmY4YzAwJyxcbiAgICBkYXJrb3JjaGlkOiAnIzk5MzJjYycsXG4gICAgZGFya3JlZDogJyM4YjAwMDAnLFxuICAgIGRhcmtzYWxtb246ICcjZTk5NjdhJyxcbiAgICBkYXJrc2VhZ3JlZW46ICcjOGZiYzhmJyxcbiAgICBkYXJrc2xhdGVibHVlOiAnIzQ4M2Q4YicsXG4gICAgZGFya3NsYXRlZ3JheTogJyMyZjRmNGYnLFxuICAgIGRhcmt0dXJxdW9pc2U6ICcjMDBjZWQxJyxcbiAgICBkYXJrdmlvbGV0OiAnIzk0MDBkMycsXG4gICAgZGVlcHBpbms6ICcjZmYxNDkzJyxcbiAgICBkZWVwc2t5Ymx1ZTogJyMwMGJmZmYnLFxuICAgIGRpbWdyYXk6ICcjNjk2OTY5JyxcbiAgICBkb2RnZXJibHVlOiAnIzFlOTBmZicsXG4gICAgZmlyZWJyaWNrOiAnI2IyMjIyMicsXG4gICAgZmxvcmFsd2hpdGU6ICcjZmZmYWYwJyxcbiAgICBmb3Jlc3RncmVlbjogJyMyMjhiMjInLFxuICAgIGZ1Y2hzaWE6ICcjZmYwMGZmJyxcbiAgICBnYWluc2Jvcm86ICcjZGNkY2RjJyxcbiAgICBnaG9zdHdoaXRlOiAnI2Y4ZjhmZicsXG4gICAgZ29sZDogJyNmZmQ3MDAnLFxuICAgIGdvbGRlbnJvZDogJyNkYWE1MjAnLFxuICAgIGdyYXk6ICcjODA4MDgwJyxcbiAgICBncmVlbjogJyMwMDgwMDAnLFxuICAgIGdyZWVueWVsbG93OiAnI2FkZmYyZicsXG4gICAgaG9uZXlkZXc6ICcjZjBmZmYwJyxcbiAgICBob3RwaW5rOiAnI2ZmNjliNCcsXG4gICAgaW5kaWFucmVkOiAnI2NkNWM1YycsXG4gICAgaW5kaWdvOiAnIzRiMDA4MicsXG4gICAgaXZvcnk6ICcjZmZmZmYwJyxcbiAgICBraGFraTogJyNmMGU2OGMnLFxuICAgIGxhdmVuZGVyOiAnI2U2ZTZmYScsXG4gICAgbGF2ZW5kZXJibHVzaDogJyNmZmYwZjUnLFxuICAgIGxhd25ncmVlbjogJyM3Y2ZjMDAnLFxuICAgIGxlbW9uY2hpZmZvbjogJyNmZmZhY2QnLFxuICAgIGxpZ2h0Ymx1ZTogJyNhZGQ4ZTYnLFxuICAgIGxpZ2h0Y29yYWw6ICcjZjA4MDgwJyxcbiAgICBsaWdodGN5YW46ICcjZTBmZmZmJyxcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogJyNmYWZhZDInLFxuICAgIGxpZ2h0Z3JleTogJyNkM2QzZDMnLFxuICAgIGxpZ2h0Z3JlZW46ICcjOTBlZTkwJyxcbiAgICBsaWdodHBpbms6ICcjZmZiNmMxJyxcbiAgICBsaWdodHNhbG1vbjogJyNmZmEwN2EnLFxuICAgIGxpZ2h0c2VhZ3JlZW46ICcjMjBiMmFhJyxcbiAgICBsaWdodHNreWJsdWU6ICcjODdjZWZhJyxcbiAgICBsaWdodHNsYXRlZ3JheTogJyM3Nzg4OTknLFxuICAgIGxpZ2h0c3RlZWxibHVlOiAnI2IwYzRkZScsXG4gICAgbGlnaHR5ZWxsb3c6ICcjZmZmZmUwJyxcbiAgICBsaW1lOiAnIzAwZmYwMCcsXG4gICAgbGltZWdyZWVuOiAnIzMyY2QzMicsXG4gICAgbGluZW46ICcjZmFmMGU2JyxcbiAgICBtYWdlbnRhOiAnI2ZmMDBmZicsXG4gICAgbWFyb29uOiAnIzgwMDAwMCcsXG4gICAgbWVkaXVtYXF1YW1hcmluZTogJyM2NmNkYWEnLFxuICAgIG1lZGl1bWJsdWU6ICcjMDAwMGNkJyxcbiAgICBtZWRpdW1vcmNoaWQ6ICcjYmE1NWQzJyxcbiAgICBtZWRpdW1wdXJwbGU6ICcjOTM3MGQ4JyxcbiAgICBtZWRpdW1zZWFncmVlbjogJyMzY2IzNzEnLFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogJyM3YjY4ZWUnLFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAnIzAwZmE5YScsXG4gICAgbWVkaXVtdHVycXVvaXNlOiAnIzQ4ZDFjYycsXG4gICAgbWVkaXVtdmlvbGV0cmVkOiAnI2M3MTU4NScsXG4gICAgbWlkbmlnaHRibHVlOiAnIzE5MTk3MCcsXG4gICAgbWludGNyZWFtOiAnI2Y1ZmZmYScsXG4gICAgbWlzdHlyb3NlOiAnI2ZmZTRlMScsXG4gICAgbW9jY2FzaW46ICcjZmZlNGI1JyxcbiAgICBuYXZham93aGl0ZTogJyNmZmRlYWQnLFxuICAgIG5hdnk6ICcjMDAwMDgwJyxcbiAgICBvbGRsYWNlOiAnI2ZkZjVlNicsXG4gICAgb2xpdmU6ICcjODA4MDAwJyxcbiAgICBvbGl2ZWRyYWI6ICcjNmI4ZTIzJyxcbiAgICBvcmFuZ2U6ICcjZmZhNTAwJyxcbiAgICBvcmFuZ2VyZWQ6ICcjZmY0NTAwJyxcbiAgICBvcmNoaWQ6ICcjZGE3MGQ2JyxcbiAgICBwYWxlZ29sZGVucm9kOiAnI2VlZThhYScsXG4gICAgcGFsZWdyZWVuOiAnIzk4ZmI5OCcsXG4gICAgcGFsZXR1cnF1b2lzZTogJyNhZmVlZWUnLFxuICAgIHBhbGV2aW9sZXRyZWQ6ICcjZDg3MDkzJyxcbiAgICBwYXBheWF3aGlwOiAnI2ZmZWZkNScsXG4gICAgcGVhY2hwdWZmOiAnI2ZmZGFiOScsXG4gICAgcGVydTogJyNjZDg1M2YnLFxuICAgIHBpbms6ICcjZmZjMGNiJyxcbiAgICBwbHVtOiAnI2RkYTBkZCcsXG4gICAgcG93ZGVyYmx1ZTogJyNiMGUwZTYnLFxuICAgIHB1cnBsZTogJyM4MDAwODAnLFxuICAgIHJlZDogJyNmZjAwMDAnLFxuICAgIHJvc3licm93bjogJyNiYzhmOGYnLFxuICAgIHJveWFsYmx1ZTogJyM0MTY5ZTEnLFxuICAgIHNhZGRsZWJyb3duOiAnIzhiNDUxMycsXG4gICAgc2FsbW9uOiAnI2ZhODA3MicsXG4gICAgc2FuZHlicm93bjogJyNmNGE0NjAnLFxuICAgIHNlYWdyZWVuOiAnIzJlOGI1NycsXG4gICAgc2Vhc2hlbGw6ICcjZmZmNWVlJyxcbiAgICBzaWVubmE6ICcjYTA1MjJkJyxcbiAgICBzaWx2ZXI6ICcjYzBjMGMwJyxcbiAgICBza3libHVlOiAnIzg3Y2VlYicsXG4gICAgc2xhdGVibHVlOiAnIzZhNWFjZCcsXG4gICAgc2xhdGVncmF5OiAnIzcwODA5MCcsXG4gICAgc25vdzogJyNmZmZhZmEnLFxuICAgIHNwcmluZ2dyZWVuOiAnIzAwZmY3ZicsXG4gICAgc3RlZWxibHVlOiAnIzQ2ODJiNCcsXG4gICAgdGFuOiAnI2QyYjQ4YycsXG4gICAgdGVhbDogJyMwMDgwODAnLFxuICAgIHRoaXN0bGU6ICcjZDhiZmQ4JyxcbiAgICB0b21hdG86ICcjZmY2MzQ3JyxcbiAgICB0dXJxdW9pc2U6ICcjNDBlMGQwJyxcbiAgICB2aW9sZXQ6ICcjZWU4MmVlJyxcbiAgICB3aGVhdDogJyNmNWRlYjMnLFxuICAgIHdoaXRlOiAnI2ZmZmZmZicsXG4gICAgd2hpdGVzbW9rZTogJyNmNWY1ZjUnLFxuICAgIHllbGxvdzogJyNmZmZmMDAnLFxuICAgIHllbGxvd2dyZWVuOiAnIzlhY2QzMicsXG59O1xuZnVuY3Rpb24gbGVhZGluZ1plcm8obnVtYmVyLCBsZW5ndGgpIHtcbiAgICBpZiAobnVtYmVyLmxlbmd0aCA+IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cbiAgICBsZXQgcmVzID0gbnVtYmVyO1xuICAgIHJhbmdlKDAsIGxlbmd0aCAtIDEpLmZvckVhY2goKF8pID0+IHtcbiAgICAgICAgcmVzID0gJzAnICsgcmVzO1xuICAgIH0pO1xuICAgIHJldHVybiByZXMuc2xpY2UobGVuZ3RoICogLTEpO1xufVxuZnVuY3Rpb24gaXNWYWxpZFJHQihzdHIpIHtcbiAgICByZXR1cm4gaGV4UlgudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gY29sb3JOYW1lVG9IZXgoY29sb3JOYW1lKSB7XG4gICAgcmV0dXJuIGNvbG9yTWFwW2NvbG9yTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBjb2xvck5hbWU7XG59XG4vLyBAbGljZW5zZSBSR0IgPC0+IEhTViBjb252ZXJzaW9uIHV0aWxpdGllcyBiYXNlZCBvZmYgb2YgaHR0cDovL3d3dy5jcy5yaXQuZWR1L35uY3MvY29sb3IvdF9jb252ZXJ0Lmh0bWxcbmV4cG9ydCBmdW5jdGlvbiBoZXhUb1JHQihzdHIpIHtcbiAgICBjb25zdCBoZXhTdHIgPSBjb2xvck5hbWVUb0hleChzdHIpO1xuICAgIGlmICghaXNWYWxpZFJHQihoZXhTdHIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGhleFN0clxuICAgICAgICAucmVwbGFjZSgvXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pLCAobSwgciwgZywgYikgPT4gJyMnICsgciArIHIgKyBnICsgZyArIGIgKyBiKVxuICAgICAgICAuc3Vic3RyaW5nKDEpXG4gICAgICAgIC5tYXRjaCgvLnsyfS9nKVxuICAgICAgICAubWFwKCh4KSA9PiBwYXJzZUludCh4LCAxNikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJnYlRvSEVYKHIsIGcsIGIpIHtcbiAgICBjb25zdCBoZXhQcmVGaXggPSAnIyc7XG4gICAgY29uc3QgaGV4U3RyID0gaGV4UHJlRml4ICtcbiAgICAgICAgbGVhZGluZ1plcm8oci50b1N0cmluZygxNiksIDIpICtcbiAgICAgICAgbGVhZGluZ1plcm8oZy50b1N0cmluZygxNiksIDIpICtcbiAgICAgICAgbGVhZGluZ1plcm8oYi50b1N0cmluZygxNiksIDIpO1xuICAgIGlmIChpc1ZhbGlkUkdCKGhleFN0cikpIHtcbiAgICAgICAgcmV0dXJuIGhleFN0cjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJHQkEoc3RyLCBvcGFjaXR5KSB7XG4gICAgY29uc3QgaGV4U3RyID0gY29sb3JOYW1lVG9IZXgoc3RyKTtcbiAgICBpZiAoaXNWYWxpZFJHQihoZXhTdHIpKSB7XG4gICAgICAgIGNvbnN0IFtyLCBnLCBiXSA9IGhleFRvUkdCKGhleFN0cik7XG4gICAgICAgIHJldHVybiBgcmdiYSgke3J9LCAke2d9LCAke2J9LCAke29wYWNpdHl9KWA7XG4gICAgfVxuICAgIGlmIChyZ2JSWC50ZXN0KHN0cikpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSByZ2JSWC5leGVjKHN0cik7XG4gICAgICAgIHJldHVybiBgcmdiYSgke21hdGNoWzFdfSwgJHttYXRjaFsyXX0sICR7bWF0Y2hbM119LCAke29wYWNpdHl9KWA7XG4gICAgfVxuICAgIGlmIChyZ2JhUlgudGVzdChzdHIpKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gcmdiYVJYLmV4ZWMoc3RyKTtcbiAgICAgICAgcmV0dXJuIGByZ2JhKCR7bWF0Y2hbMV19LCAke21hdGNoWzJdfSwgJHttYXRjaFszXX0sICR7b3BhY2l0eX0pYDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbHBoYShzdHIpIHtcbiAgICBpZiAocmdiYVJYLnRlc3Qoc3RyKSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHJnYmFSWC5leGVjKHN0cik7XG4gICAgICAgIHJldHVybiBOdW1iZXIobWF0Y2hbNF0pO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZ2JhKGNvbG9yLCBvcGFjaXR5ID0gMSkge1xuICAgIGNvbnN0IGFscGhhID0gZ2V0QWxwaGEoY29sb3IpICogb3BhY2l0eTtcbiAgICByZXR1cm4gZ2V0UkdCQShjb2xvciwgYWxwaGEpO1xufVxuIiwiaW1wb3J0IHsgcmdiVG9IRVggfSBmcm9tIFwiLi9jb2xvclwiO1xuaW1wb3J0IHsgaXNOdWxsLCBpc1N0cmluZywgaXNVbmRlZmluZWQgfSBmcm9tIFwiLi91dGlsc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VEaXN0YW5jZXMoc3RhcnRSR0IsIGVuZFJHQikge1xuICAgIHJldHVybiBzdGFydFJHQi5tYXAoKHZhbHVlLCBpbmRleCkgPT4gZW5kUkdCW2luZGV4XSAtIHZhbHVlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2xvclJhdGlvKGxpbWl0LCB2YWx1ZSkge1xuICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaXZOdW1iZXIgPSBNYXRoLmFicyhsaW1pdC5tYXggLSBsaW1pdC5taW4pO1xuICAgIHJldHVybiBkaXZOdW1iZXIgJiYgIWlzTnVsbCh2YWx1ZSkgPyAodmFsdWUgLSBsaW1pdC5taW4pIC8gZGl2TnVtYmVyIDogMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRTcGVjdHJ1bUNvbG9yKHJhdGlvLCBkaXN0YW5jZXMsIHN0YXJ0UkdCKSB7XG4gICAgY29uc3QgcmdiQ29sb3IgPSBzdGFydFJHQi5tYXAoKHN0YXJ0LCBpbmRleCkgPT4gc3RhcnQgKyBwYXJzZUludChTdHJpbmcoZGlzdGFuY2VzW2luZGV4XSAqIHJhdGlvKSwgMTApKTtcbiAgICBjb25zdCBjb2xvciA9IHJnYlRvSEVYKC4uLnJnYkNvbG9yKTtcbiAgICByZXR1cm4gaXNTdHJpbmcoY29sb3IpID8gY29sb3IgOiAnJztcbn1cbiIsImltcG9ydCB7IGdldEZpcnN0VmFsaWRWYWx1ZSwgaXNOdW1iZXIsIGlzT2JqZWN0LCBsYXN0IH0gZnJvbSBcIi4vdXRpbHNcIjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb29yZGluYXRlWVZhbHVlKGRhdHVtKSB7XG4gICAgaWYgKGlzTnVtYmVyKGRhdHVtKSkge1xuICAgICAgICByZXR1cm4gZGF0dW07XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGRhdHVtKSA/IGRhdHVtWzFdIDogZGF0dW0ueTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb29yZGluYXRlWFZhbHVlKGRhdHVtKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGF0dW0pID8gZGF0dW1bMF0gOiBkYXR1bS54O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsdWVBZnRlckxhc3RDYXRlZ29yeSh2YWx1ZSwgY2F0ZWdvcmllcykge1xuICAgIGNvbnN0IGNhdGVnb3J5ID0gbGFzdChjYXRlZ29yaWVzKTtcbiAgICBpZiAoIWNhdGVnb3J5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSA/IHZhbHVlID49IE51bWJlcihjYXRlZ29yeSkgOiBuZXcgRGF0ZSh2YWx1ZSkgPj0gbmV3IERhdGUoY2F0ZWdvcnkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVEYXRhSW5kZXgoZGF0dW0sIGNhdGVnb3JpZXMsIGRhdGFJbmRleCwgc3RhcnRJbmRleCkge1xuICAgIGlmIChpc051bWJlcihkYXR1bSkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFJbmRleCAtIHN0YXJ0SW5kZXg7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gZ2V0Q29vcmRpbmF0ZVhWYWx1ZShkYXR1bSk7XG4gICAgbGV0IGluZGV4ID0gY2F0ZWdvcmllcy5maW5kSW5kZXgoKGNhdGVnb3J5KSA9PiBjYXRlZ29yeSA9PT0gU3RyaW5nKHZhbHVlKSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSAmJiBpc1ZhbHVlQWZ0ZXJMYXN0Q2F0ZWdvcnkodmFsdWUsIGNhdGVnb3JpZXMpKSB7XG4gICAgICAgIGluZGV4ID0gY2F0ZWdvcmllcy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIGlzTGluZUNvb3JkaW5hdGVTZXJpZXMoc2VyaWVzKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghc2VyaWVzLmxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdERhdGEgPSBnZXRGaXJzdFZhbGlkVmFsdWUoKF9hID0gc2VyaWVzLmxpbmVbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKTtcbiAgICByZXR1cm4gZmlyc3REYXRhICYmIChBcnJheS5pc0FycmF5KGZpcnN0RGF0YSkgfHwgaXNPYmplY3QoZmlyc3REYXRhKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDb29yZGluYXRlU2VyaWVzKHNlcmllcykge1xuICAgIHJldHVybiBpc0xpbmVDb29yZGluYXRlU2VyaWVzKHNlcmllcykgfHwgISFzZXJpZXMuc2NhdHRlciB8fCAhIXNlcmllcy5idWJibGU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNNb2RlbEV4aXN0aW5nSW5SZWN0KHJlY3QsIHBvaW50KSB7XG4gICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSByZWN0O1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQ7XG4gICAgcmV0dXJuIHggPj0gMCAmJiB4IDw9IHdpZHRoICYmIHkgPj0gMCAmJiB5IDw9IGhlaWdodDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc01vdXNlSW5SZWN0KHJlY3QsIG1vdXNlUG9zaXRpb24pIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHJlY3Q7XG4gICAgcmV0dXJuIChtb3VzZVBvc2l0aW9uLnggPj0geCAmJlxuICAgICAgICBtb3VzZVBvc2l0aW9uLnggPD0geCArIHdpZHRoICYmXG4gICAgICAgIG1vdXNlUG9zaXRpb24ueSA+PSB5ICYmXG4gICAgICAgIG1vdXNlUG9zaXRpb24ueSA8PSB5ICsgaGVpZ2h0KTtcbn1cbiIsImltcG9ydCB7IGlzRnVuY3Rpb24sIGluY2x1ZGVzLCBpc0Jvb2xlYW4sIGlzU3RyaW5nIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IGdldFRleHRXaWR0aCwgZ2V0VGV4dEhlaWdodCB9IGZyb20gXCIuL2NhbGN1bGF0b3JcIjtcbmltcG9ydCB7IGdldFJhZGlhbEFuY2hvclBvc2l0aW9uLCBtYWtlQW5jaG9yUG9zaXRpb25QYXJhbSwgY2FsY3VsYXRlRGVncmVlVG9SYWRpYW4sIGdldFJhZGlhbExhYmVsQWxpZ24sIH0gZnJvbSBcIi4vc2VjdG9yXCI7XG5pbXBvcnQgeyBnZXRGb250IH0gZnJvbSBcIi4vc3R5bGVcIjtcbmV4cG9ydCBjb25zdCBSQURJVVNfUEFERElORyA9IDMwO1xuY29uc3QgQ0FMTE9VVF9MRU5HVEggPSAyMDtcbmZ1bmN0aW9uIGdldERlZmF1bHRBbmNob3IodHlwZSwgd2l0aFN0YWNrID0gZmFsc2UpIHtcbiAgICBsZXQgYW5jaG9yID0gJ2F1dG8nO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdwb2ludCc6XG4gICAgICAgICAgICBhbmNob3IgPSAnY2VudGVyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyZWN0JzpcbiAgICAgICAgICAgIGFuY2hvciA9ICF3aXRoU3RhY2sgPyAnYXV0bycgOiAnY2VudGVyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzZWN0b3InOlxuICAgICAgICBjYXNlICd0cmVlbWFwU2VyaWVzTmFtZSc6XG4gICAgICAgICAgICBhbmNob3IgPSAnY2VudGVyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdGFja1RvdGFsJzpcbiAgICAgICAgICAgIGFuY2hvciA9ICdhdXRvJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYW5jaG9yO1xufVxuZnVuY3Rpb24gZ2V0QW5jaG9yKGRhdGFMYWJlbE9wdGlvbnMsIHR5cGUsIHdpdGhTdGFjayA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHR5cGUgIT09ICdzdGFja1RvdGFsJyAmJlxuICAgICAgICBpbmNsdWRlcyhbJ2NlbnRlcicsICdzdGFydCcsICdlbmQnLCAnYXV0bycsICdvdXRlciddLCBkYXRhTGFiZWxPcHRpb25zLmFuY2hvcilcbiAgICAgICAgPyBkYXRhTGFiZWxPcHRpb25zLmFuY2hvclxuICAgICAgICA6IGdldERlZmF1bHRBbmNob3IodHlwZSwgd2l0aFN0YWNrKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0RGF0YUxhYmVsc09wdGlvbnMoZGF0YUxhYmVsT3B0aW9ucywgdHlwZSwgd2l0aFN0YWNrID0gZmFsc2UpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBhbmNob3IgPSBnZXRBbmNob3IoZGF0YUxhYmVsT3B0aW9ucywgdHlwZSwgd2l0aFN0YWNrKTtcbiAgICBjb25zdCB7IG9mZnNldFggPSAwLCBvZmZzZXRZID0gMCB9ID0gZGF0YUxhYmVsT3B0aW9ucztcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBpc0Z1bmN0aW9uKGRhdGFMYWJlbE9wdGlvbnMuZm9ybWF0dGVyKVxuICAgICAgICA/IGRhdGFMYWJlbE9wdGlvbnMuZm9ybWF0dGVyXG4gICAgICAgIDogKHZhbHVlKSA9PiBTdHJpbmcodmFsdWUpIHx8ICcnO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICAgICAgZm9ybWF0dGVyLFxuICAgIH07XG4gICAgaWYgKHdpdGhTdGFjaykge1xuICAgICAgICBjb25zdCBzdGFja1RvdGFsID0gZGF0YUxhYmVsT3B0aW9ucy5zdGFja1RvdGFsO1xuICAgICAgICBvcHRpb25zLnN0YWNrVG90YWwgPSB7XG4gICAgICAgICAgICB2aXNpYmxlOiBpc0Jvb2xlYW4oKF9hID0gc3RhY2tUb3RhbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZpc2libGUpID8gc3RhY2tUb3RhbC52aXNpYmxlIDogdHJ1ZSxcbiAgICAgICAgICAgIGZvcm1hdHRlcjogaXNGdW5jdGlvbigoX2IgPSBzdGFja1RvdGFsKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZm9ybWF0dGVyKSA/IHN0YWNrVG90YWwuZm9ybWF0dGVyIDogZm9ybWF0dGVyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3NlY3RvcicgJiYgKChfYyA9IGRhdGFMYWJlbE9wdGlvbnMucGllU2VyaWVzTmFtZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnZpc2libGUpKSB7XG4gICAgICAgIG9wdGlvbnMucGllU2VyaWVzTmFtZSA9IE9iamVjdC5hc3NpZ24oeyBhbmNob3I6ICdjZW50ZXInIH0sIGRhdGFMYWJlbE9wdGlvbnMucGllU2VyaWVzTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQb2ludExhYmVsSW5mbyhwb2ludCwgZGF0YUxhYmVsT3B0aW9ucywgcmVjdCkge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcmVjdDtcbiAgICBjb25zdCB7IGFuY2hvciwgb2Zmc2V0WCA9IDAsIG9mZnNldFkgPSAwLCBmb3JtYXR0ZXIgfSA9IGRhdGFMYWJlbE9wdGlvbnM7XG4gICAgY29uc3QgeyBuYW1lLCB0aGVtZSB9ID0gcG9pbnQ7XG4gICAgbGV0IHRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGlmIChhbmNob3IgPT09ICdlbmQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgIH1cbiAgICBlbHNlIGlmIChhbmNob3IgPT09ICdzdGFydCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgfVxuICAgIGNvbnN0IHhXaXRoT2Zmc2V0ID0gcG9pbnQueCArIG9mZnNldFg7XG4gICAgY29uc3QgeVdpdGhPZmZzZXQgPSBwb2ludC55ICsgb2Zmc2V0WTtcbiAgICBjb25zdCB4ID0geFdpdGhPZmZzZXQgPCAwIHx8IHhXaXRoT2Zmc2V0ID4gd2lkdGggPyBwb2ludC54IDogeFdpdGhPZmZzZXQ7XG4gICAgY29uc3QgeSA9IHlXaXRoT2Zmc2V0IDwgMCB8fCB5V2l0aE9mZnNldCA+IGhlaWdodCA/IHBvaW50LnkgOiB5V2l0aE9mZnNldDtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAncG9pbnQnLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB0ZXh0OiBmb3JtYXR0ZXIocG9pbnQudmFsdWUsIHBvaW50LmRhdGEpLFxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHRoZW1lLFxuICAgIH07XG59XG5mdW5jdGlvbiBpc0hvcml6b250YWwoZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIGluY2x1ZGVzKFsnbGVmdCcsICdyaWdodCddLCBkaXJlY3Rpb24pO1xufVxuZnVuY3Rpb24gbWFrZUhvcml6b250YWxSZWN0UG9zaXRpb24ocmVjdCwgYW5jaG9yKSB7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24gfSA9IHJlY3Q7XG4gICAgY29uc3QgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY29uc3QgcG9zWSA9IHkgKyBoZWlnaHQgLyAyO1xuICAgIGxldCB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBsZXQgcG9zWDtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgIHN3aXRjaCAoYW5jaG9yKSB7XG4gICAgICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIHBvc1ggPSB4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIHBvc1ggPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIHBvc1ggPSB4ICsgd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgcG9zWCA9IHggKyB3aWR0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChhbmNob3IpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIHBvc1ggPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBwb3NYID0geDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgcG9zWCA9IHggKyB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgcG9zWCA9IHg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcG9zWCxcbiAgICAgICAgeTogcG9zWSxcbiAgICAgICAgdGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VWZXJ0aWNhbFJlY3RQb3NpdGlvbihyZWN0LCBhbmNob3IpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiB9ID0gcmVjdDtcbiAgICBjb25zdCB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjb25zdCBwb3NYID0geCArIHdpZHRoIC8gMjtcbiAgICBsZXQgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgbGV0IHBvc1kgPSAwO1xuICAgIGlmIChkaXJlY3Rpb24gPT09ICd0b3AnKSB7XG4gICAgICAgIHN3aXRjaCAoYW5jaG9yKSB7XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgICAgICAgICAgIHBvc1kgPSB5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgICAgICAgICAgICAgIHBvc1kgPSB5ICsgaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgICAgICBwb3NZID0geSArIGhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgICAgICAgICAgICAgIHBvc1kgPSB5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGFuY2hvcikge1xuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgICAgICAgICAgICBwb3NZID0geSArIGhlaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgICAgICAgICAgICBwb3NZID0geTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICAgICAgcG9zWSA9IHkgKyBoZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgICAgICAgICAgICBwb3NZID0geSArIGhlaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBwb3NYLFxuICAgICAgICB5OiBwb3NZLFxuICAgICAgICB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYWRqdXN0T3ZlcmZsb3dIb3Jpem9udGFsUmVjdChyZWN0LCBkYXRhTGFiZWxPcHRpb25zLCBwb3NpdGlvbikge1xuICAgIGNvbnN0IHsgd2lkdGgsIHZhbHVlLCBkaXJlY3Rpb24sIHBsb3QsIHRoZW1lIH0gPSByZWN0O1xuICAgIGNvbnN0IHsgZm9ybWF0dGVyIH0gPSBkYXRhTGFiZWxPcHRpb25zO1xuICAgIGNvbnN0IGZvbnQgPSBnZXRGb250KHRoZW1lKTtcbiAgICBjb25zdCB0ZXh0ID0gaXNTdHJpbmcodmFsdWUpID8gdmFsdWUgOiBmb3JtYXR0ZXIodmFsdWUpO1xuICAgIGNvbnN0IHRleHRXaWR0aCA9IGdldFRleHRXaWR0aCh0ZXh0LCBmb250KTtcbiAgICBsZXQgeyB4LCB0ZXh0QWxpZ24gfSA9IHBvc2l0aW9uO1xuICAgIGNvbnN0IGlzT3ZlcmZsb3cgPSAoZGlyZWN0aW9uID09PSAnbGVmdCcgJiYgeCAtIHRleHRXaWR0aCA8IDApIHx8IHggKyB0ZXh0V2lkdGggPiBwbG90LnNpemU7XG4gICAgaWYgKGlzT3ZlcmZsb3cpIHtcbiAgICAgICAgeCA9IHJlY3QueCArIHdpZHRoO1xuICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcgJiYgd2lkdGggPj0gdGV4dFdpZHRoKSB7XG4gICAgICAgICAgICB4ID0gcmVjdC54O1xuICAgICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHRleHRBbGlnbixcbiAgICB9O1xufVxuZnVuY3Rpb24gYWRqdXN0T3ZlcmZsb3dWZXJ0aWNhbFJlY3QocmVjdCwgZGF0YUxhYmVsT3B0aW9ucywgcG9zaXRpb24pIHtcbiAgICBjb25zdCB7IGhlaWdodCwgZGlyZWN0aW9uLCBwbG90LCB0aGVtZSwgdmFsdWUgfSA9IHJlY3Q7XG4gICAgY29uc3QgZm9udCA9IGdldEZvbnQodGhlbWUpO1xuICAgIGNvbnN0IHBsb3RTaXplID0gcGxvdC5zaXplO1xuICAgIGNvbnN0IHRleHRIZWlnaHQgPSBnZXRUZXh0SGVpZ2h0KGAke3ZhbHVlfWAsIGZvbnQpOyAvLyBAVE9ETzogZm9ybWF0dGVyIOqwku2VtOyEnCDrhJjquLDquLBcbiAgICBsZXQgeyB5LCB0ZXh0QmFzZWxpbmUgfSA9IHBvc2l0aW9uO1xuICAgIGNvbnN0IGlzT3ZlcmZsb3cgPSAoIShkaXJlY3Rpb24gPT09ICdib3R0b20nKSAmJiB5IC0gdGV4dEhlaWdodCA8IDApIHx8IHkgKyB0ZXh0SGVpZ2h0ID4gcGxvdFNpemU7XG4gICAgaWYgKGlzT3ZlcmZsb3cpIHtcbiAgICAgICAgeSA9IHJlY3QueTtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgIGlmICh5ICsgdGV4dEhlaWdodCA+IHBsb3RTaXplKSB7XG4gICAgICAgICAgICB5ID0gcmVjdC55O1xuICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIHkgPSByZWN0LnkgKyBoZWlnaHQ7XG4gICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB5LFxuICAgICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VIb3Jpem9udGFsUmVjdExhYmVsSW5mbyhyZWN0LCBkYXRhTGFiZWxPcHRpb25zKSB7XG4gICAgY29uc3QgeyBhbmNob3IsIG9mZnNldFggPSAwLCBvZmZzZXRZID0gMCB9ID0gZGF0YUxhYmVsT3B0aW9ucztcbiAgICBjb25zdCB7IGRpcmVjdGlvbiwgcGxvdDogeyB4OiBzdGFydE9mZnNldFggPSAwLCB5OiBzdGFydE9mZnNldFkgPSAwIH0sIH0gPSByZWN0O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gbWFrZUhvcml6b250YWxSZWN0UG9zaXRpb24ocmVjdCwgYW5jaG9yKTtcbiAgICBsZXQgeyB4OiBwb3NYLCB5OiBwb3NZLCB0ZXh0QWxpZ24gfSA9IHBvc2l0aW9uO1xuICAgIGlmIChhbmNob3IgPT09ICdhdXRvJykge1xuICAgICAgICBjb25zdCBhZGp1c3RSZWN0ID0gYWRqdXN0T3ZlcmZsb3dIb3Jpem9udGFsUmVjdChyZWN0LCBkYXRhTGFiZWxPcHRpb25zLCB7IHg6IHBvc1gsIHRleHRBbGlnbiB9KTtcbiAgICAgICAgcG9zWCA9IGFkanVzdFJlY3QueDtcbiAgICAgICAgdGV4dEFsaWduID0gYWRqdXN0UmVjdC50ZXh0QWxpZ247XG4gICAgfVxuICAgIHBvc1kgKz0gb2Zmc2V0WTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgcG9zWCA9IHBvc1ggLSBvZmZzZXRYO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9zWCA9IHBvc1ggKyBvZmZzZXRYO1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nID0gMTA7XG4gICAgaWYgKHRleHRBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBwb3NYIC09IHBhZGRpbmc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHBvc1ggKz0gcGFkZGluZztcbiAgICB9XG4gICAgcG9zWCAtPSBzdGFydE9mZnNldFg7XG4gICAgcG9zWSAtPSBzdGFydE9mZnNldFk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcG9zWCxcbiAgICAgICAgeTogcG9zWSxcbiAgICAgICAgdGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6IHBvc2l0aW9uLnRleHRCYXNlbGluZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFrZVZlcnRpY2FsUmVjdExhYmVsSW5mbyhyZWN0LCBkYXRhTGFiZWxPcHRpb25zKSB7XG4gICAgY29uc3QgeyBhbmNob3IsIG9mZnNldFggPSAwLCBvZmZzZXRZID0gMCB9ID0gZGF0YUxhYmVsT3B0aW9ucztcbiAgICBjb25zdCB7IGRpcmVjdGlvbiwgcGxvdDogeyB4OiBzdGFydE9mZnNldFggPSAwLCB5OiBzdGFydE9mZnNldFkgPSAwIH0sIH0gPSByZWN0O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gbWFrZVZlcnRpY2FsUmVjdFBvc2l0aW9uKHJlY3QsIGFuY2hvcik7XG4gICAgbGV0IHsgeDogcG9zWCwgeTogcG9zWSwgdGV4dEJhc2VsaW5lIH0gPSBwb3NpdGlvbjtcbiAgICBpZiAoYW5jaG9yID09PSAnYXV0bycpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0UmVjdCA9IGFkanVzdE92ZXJmbG93VmVydGljYWxSZWN0KHJlY3QsIGRhdGFMYWJlbE9wdGlvbnMsIHBvc2l0aW9uKTtcbiAgICAgICAgcG9zWSA9IGFkanVzdFJlY3QueTtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gYWRqdXN0UmVjdC50ZXh0QmFzZWxpbmU7XG4gICAgfVxuICAgIHBvc1ggKz0gb2Zmc2V0WDtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAndG9wJykge1xuICAgICAgICBwb3NZID0gcG9zWSArIG9mZnNldFk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgcG9zWSA9IHBvc1kgLSBvZmZzZXRZO1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nID0gNTtcbiAgICBpZiAodGV4dEJhc2VsaW5lID09PSAnYm90dG9tJykge1xuICAgICAgICBwb3NZIC09IHBhZGRpbmc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRleHRCYXNlbGluZSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgcG9zWSArPSBwYWRkaW5nO1xuICAgIH1cbiAgICBwb3NYIC09IHN0YXJ0T2Zmc2V0WDtcbiAgICBwb3NZIC09IHN0YXJ0T2Zmc2V0WTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBwb3NYLFxuICAgICAgICB5OiBwb3NZLFxuICAgICAgICB0ZXh0QWxpZ246IHBvc2l0aW9uLnRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZVJlY3RMYWJlbEluZm8ocmVjdCwgZGF0YUxhYmVsT3B0aW9ucykge1xuICAgIGNvbnN0IHsgdHlwZSwgdmFsdWUsIGRpcmVjdGlvbiwgbmFtZSwgdGhlbWUgfSA9IHJlY3Q7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IGlzSG9yaXpvbnRhbChkaXJlY3Rpb24pO1xuICAgIGNvbnN0IGxhYmVsUG9zaXRpb24gPSBob3Jpem9udGFsXG4gICAgICAgID8gbWFrZUhvcml6b250YWxSZWN0TGFiZWxJbmZvKHJlY3QsIGRhdGFMYWJlbE9wdGlvbnMpXG4gICAgICAgIDogbWFrZVZlcnRpY2FsUmVjdExhYmVsSW5mbyhyZWN0LCBkYXRhTGFiZWxPcHRpb25zKTtcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSB0eXBlID09PSAnc3RhY2tUb3RhbCcgPyBkYXRhTGFiZWxPcHRpb25zLnN0YWNrVG90YWwuZm9ybWF0dGVyIDogZGF0YUxhYmVsT3B0aW9ucy5mb3JtYXR0ZXI7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHR5cGUgfSwgbGFiZWxQb3NpdGlvbiksIHsgdGV4dDogaXNTdHJpbmcodmFsdWUpID8gdmFsdWUgOiBmb3JtYXR0ZXIodmFsdWUpLCBuYW1lLCBzZXJpZXNDb2xvcjogcmVjdC5jb2xvciwgdGhlbWUgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZVNlY3RvckxhYmVsUG9zaXRpb24obW9kZWwsIGRhdGFMYWJlbE9wdGlvbnMpIHtcbiAgICBjb25zdCBhbmNob3IgPSBkYXRhTGFiZWxPcHRpb25zLmFuY2hvcjtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJhZGlhbEFuY2hvclBvc2l0aW9uKG1ha2VBbmNob3JQb3NpdGlvblBhcmFtKGFuY2hvciwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtb2RlbCksIHsgcmFkaXVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1vZGVsLnJhZGl1cyksIHsgb3V0ZXI6IGFuY2hvciA9PT0gJ291dGVyJyA/IG1vZGVsLnJhZGl1cy5vdXRlciArIFJBRElVU19QQURESU5HIDogbW9kZWwucmFkaXVzLm91dGVyIH0pIH0pKSk7XG4gICAgY29uc3QgdGV4dEFsaWduID0gZ2V0UmFkaWFsTGFiZWxBbGlnbihtb2RlbCwgYW5jaG9yKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiksIHsgdGV4dEFsaWduLCB0ZXh0QmFzZWxpbmU6IGhhc1NhbWVBbmNob3JQaWVEYXRhTGFiZWwoZGF0YUxhYmVsT3B0aW9ucykgPyAnYm90dG9tJyA6ICdtaWRkbGUnIH0pO1xufVxuZnVuY3Rpb24gbWFrZVNlY3RvckJhckxhYmVsUG9zaXRpb24obW9kZWwsIGRhdGFMYWJlbE9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFuY2hvciB9ID0gZGF0YUxhYmVsT3B0aW9ucztcbiAgICBjb25zdCB7IGNsb2Nrd2lzZSwgZGVncmVlOiB7IHN0YXJ0LCBlbmQgfSwgcmFkaXVzOiB7IGlubmVyLCBvdXRlciB9LCB9ID0gbW9kZWw7XG4gICAgbGV0IHN0YXJ0QW5nbGUgPSBzdGFydDtcbiAgICBsZXQgZW5kQW5nbGUgPSBlbmQ7XG4gICAgbGV0IHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGxldCByb3RhdGlvbkRlZ3JlZSA9IChzdGFydCArIGVuZCkgLyAyO1xuICAgIGlmIChhbmNob3IgPT09ICdzdGFydCcpIHtcbiAgICAgICAgdGV4dEFsaWduID0gY2xvY2t3aXNlID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgICAgICByb3RhdGlvbkRlZ3JlZSA9IHN0YXJ0O1xuICAgIH1cbiAgICBlbHNlIGlmIChhbmNob3IgPT09ICdlbmQnKSB7XG4gICAgICAgIHRleHRBbGlnbiA9IGNsb2Nrd2lzZSA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZTtcbiAgICAgICAgcm90YXRpb25EZWdyZWUgPSBlbmQ7XG4gICAgfVxuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0UmFkaWFsQW5jaG9yUG9zaXRpb24obWFrZUFuY2hvclBvc2l0aW9uUGFyYW0oYW5jaG9yLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1vZGVsKSwgeyBkZWdyZWU6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgZW5kOiBlbmRBbmdsZSxcbiAgICAgICAgfSwgcmFkaXVzOiB7XG4gICAgICAgICAgICBpbm5lcjogaW5uZXIsXG4gICAgICAgICAgICBvdXRlcjogb3V0ZXIsXG4gICAgICAgIH0gfSkpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICAgIHJhZGlhbjogY2FsY3VsYXRlRGVncmVlVG9SYWRpYW4ocm90YXRpb25EZWdyZWUsIDApLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZVNlY3RvckJhckxhYmVsSW5mbyhtb2RlbCwgZGF0YUxhYmVsT3B0aW9ucykge1xuICAgIGNvbnN0IHsgZm9ybWF0dGVyIH0gPSBkYXRhTGFiZWxPcHRpb25zO1xuICAgIGNvbnN0IGxhYmVsUG9zaXRpb24gPSBtYWtlU2VjdG9yQmFyTGFiZWxQb3NpdGlvbihtb2RlbCwgZGF0YUxhYmVsT3B0aW9ucyk7XG4gICAgY29uc3QgeyB2YWx1ZSwgbmFtZSwgdGhlbWU6IGRhdGFMYWJlbFRoZW1lIH0gPSBtb2RlbDtcbiAgICBjb25zdCB0aGVtZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0YUxhYmVsVGhlbWUpLCB7IGNvbG9yOiBkYXRhTGFiZWxUaGVtZS51c2VTZXJpZXNDb2xvciA/IG1vZGVsLmNvbG9yIDogZGF0YUxhYmVsVGhlbWUuY29sb3IgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdzZWN0b3InIH0sIGxhYmVsUG9zaXRpb24pLCB7IHRleHQ6IGZvcm1hdHRlcih2YWx1ZSksIG5hbWUsXG4gICAgICAgIHRoZW1lIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VTZWN0b3JMYWJlbEluZm8obW9kZWwsIGRhdGFMYWJlbE9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGZvcm1hdHRlciB9ID0gZGF0YUxhYmVsT3B0aW9ucztcbiAgICBjb25zdCBsYWJlbFBvc2l0aW9uID0gbWFrZVNlY3RvckxhYmVsUG9zaXRpb24obW9kZWwsIGRhdGFMYWJlbE9wdGlvbnMpO1xuICAgIGNvbnN0IHsgdmFsdWUsIG5hbWUsIHRoZW1lOiBkYXRhTGFiZWxUaGVtZSB9ID0gbW9kZWw7XG4gICAgY29uc3QgYW5jaG9yID0gZGF0YUxhYmVsT3B0aW9ucy5hbmNob3I7XG4gICAgY29uc3QgdGhlbWUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGFMYWJlbFRoZW1lKSwgeyBjb2xvcjogZGF0YUxhYmVsVGhlbWUudXNlU2VyaWVzQ29sb3IgPyBtb2RlbC5jb2xvciA6IGRhdGFMYWJlbFRoZW1lLmNvbG9yIH0pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB0eXBlOiAnc2VjdG9yJyB9LCBsYWJlbFBvc2l0aW9uKSwgeyB0ZXh0OiBmb3JtYXR0ZXIodmFsdWUpLCBuYW1lLCBjYWxsb3V0OiBoYXNTZWN0b3JDYWxsb3V0KGRhdGFMYWJlbE9wdGlvbnMpID8gZ2V0UGllRGF0YUxhYmVsQ2FsbG91dChtb2RlbCwgYW5jaG9yKSA6IG51bGwsIHRoZW1lIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQaWVTZXJpZXNOYW1lTGFiZWxJbmZvKG1vZGVsLCBkYXRhTGFiZWxPcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNlcmllc05hbWVBbmNob3IgPSAoX2EgPSBkYXRhTGFiZWxPcHRpb25zLnBpZVNlcmllc05hbWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hbmNob3I7XG4gICAgY29uc3QgaGFzT3V0ZXJBbmNob3IgPSBzZXJpZXNOYW1lQW5jaG9yID09PSAnb3V0ZXInO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmFkaWFsQW5jaG9yUG9zaXRpb24obWFrZUFuY2hvclBvc2l0aW9uUGFyYW0oc2VyaWVzTmFtZUFuY2hvciwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtb2RlbCksIHsgcmFkaXVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1vZGVsLnJhZGl1cyksIHsgb3V0ZXI6IGhhc091dGVyQW5jaG9yID8gbW9kZWwucmFkaXVzLm91dGVyICsgUkFESVVTX1BBRERJTkcgOiBtb2RlbC5yYWRpdXMub3V0ZXIgfSkgfSkpKTtcbiAgICBjb25zdCB0ZXh0QWxpZ24gPSBnZXRSYWRpYWxMYWJlbEFsaWduKG1vZGVsLCBzZXJpZXNOYW1lQW5jaG9yKTtcbiAgICBjb25zdCBwaWVTZXJpZXNOYW1lVGhlbWUgPSBtb2RlbC50aGVtZS5waWVTZXJpZXNOYW1lO1xuICAgIGNvbnN0IHRoZW1lID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwaWVTZXJpZXNOYW1lVGhlbWUpLCB7IGNvbG9yOiBwaWVTZXJpZXNOYW1lVGhlbWUudXNlU2VyaWVzQ29sb3IgPyBtb2RlbC5jb2xvciA6IHBpZVNlcmllc05hbWVUaGVtZS5jb2xvciB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdHlwZTogJ3BpZVNlcmllc05hbWUnIH0sIHBvc2l0aW9uKSwgeyB0ZXh0OiBtb2RlbC5uYW1lLCBjYWxsb3V0OiBoYXNQaWVTZXJpZXNOYW1lQ2FsbG91dChkYXRhTGFiZWxPcHRpb25zKVxuICAgICAgICAgICAgPyBnZXRQaWVEYXRhTGFiZWxDYWxsb3V0KG1vZGVsLCBzZXJpZXNOYW1lQW5jaG9yKVxuICAgICAgICAgICAgOiBudWxsLCB0ZXh0QWxpZ24sIHRleHRCYXNlbGluZTogaGFzU2FtZUFuY2hvclBpZURhdGFMYWJlbChkYXRhTGFiZWxPcHRpb25zKSA/ICd0b3AnIDogJ21pZGRsZScsIHRoZW1lIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGFMYWJlbHNPcHRpb25zKG9wdGlvbnMsIG5hbWUpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIHJldHVybiAoKF9jID0gKF9iID0gKF9hID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlcmllcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW25hbWVdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGF0YUxhYmVscykgfHwgKChfZSA9IChfZCA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zZXJpZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5kYXRhTGFiZWxzKSB8fCB7fTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYWtlTGluZUxhYmVsSW5mbyhtb2RlbCwgZGF0YUxhYmVsT3B0aW9ucykge1xuICAgIGNvbnN0IHsgdmFsdWUsIHRleHRBbGlnbiwgdGV4dEJhc2VsaW5lIH0gPSBtb2RlbDtcbiAgICBjb25zdCB7IGZvcm1hdHRlciB9ID0gZGF0YUxhYmVsT3B0aW9ucztcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtb2RlbCksIHsgeDogbW9kZWwueCwgeTogKG1vZGVsLnkgKyBtb2RlbC55MikgLyAyLCB0ZXh0QWxpZ246ICh0ZXh0QWxpZ24gIT09IG51bGwgJiYgdGV4dEFsaWduICE9PSB2b2lkIDAgPyB0ZXh0QWxpZ24gOiAnY2VudGVyJyksIHRleHRCYXNlbGluZTogKHRleHRCYXNlbGluZSAhPT0gbnVsbCAmJiB0ZXh0QmFzZWxpbmUgIT09IHZvaWQgMCA/IHRleHRCYXNlbGluZSA6ICdtaWRkbGUnKSwgdGV4dDogaXNTdHJpbmcodmFsdWUpID8gdmFsdWUgOiBmb3JtYXR0ZXIodmFsdWUpIH0pO1xufVxuZnVuY3Rpb24gaGFzU2FtZUFuY2hvclBpZURhdGFMYWJlbChkYXRhTGFiZWxPcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBkYXRhTGFiZWxPcHRpb25zLmFuY2hvciA9PT0gKChfYSA9IGRhdGFMYWJlbE9wdGlvbnMucGllU2VyaWVzTmFtZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFuY2hvcik7XG59XG5mdW5jdGlvbiBoYXNTZWN0b3JDYWxsb3V0KGRhdGFMYWJlbE9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIGRhdGFMYWJlbE9wdGlvbnMuYW5jaG9yID09PSAnb3V0ZXInIHx8ICgoX2EgPSBkYXRhTGFiZWxPcHRpb25zLnBpZVNlcmllc05hbWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hbmNob3IpICE9PSAnb3V0ZXInO1xufVxuZnVuY3Rpb24gaGFzUGllU2VyaWVzTmFtZUNhbGxvdXQoZGF0YUxhYmVsT3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gZGF0YUxhYmVsT3B0aW9ucy5hbmNob3IgIT09ICdvdXRlcicgfHwgKChfYSA9IGRhdGFMYWJlbE9wdGlvbnMucGllU2VyaWVzTmFtZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFuY2hvcikgPT09ICdvdXRlcic7XG59XG5mdW5jdGlvbiBnZXRQaWVEYXRhTGFiZWxDYWxsb3V0KG1vZGVsLCBhbmNob3IpIHtcbiAgICBpZiAoYW5jaG9yICE9PSAnb3V0ZXInKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldFJhZGlhbEFuY2hvclBvc2l0aW9uKG1ha2VBbmNob3JQb3NpdGlvblBhcmFtKCdvdXRlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbW9kZWwpLCB7IHJhZGl1czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtb2RlbC5yYWRpdXMpLCB7IG91dGVyOiBtb2RlbC5yYWRpdXMub3V0ZXIgKyBDQUxMT1VUX0xFTkdUSCB9KSB9KSkpO1xuICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSBnZXRSYWRpYWxBbmNob3JQb3NpdGlvbihtYWtlQW5jaG9yUG9zaXRpb25QYXJhbSgnb3V0ZXInLCBPYmplY3QuYXNzaWduKHt9LCBtb2RlbCkpKTtcbiAgICBjb25zdCB7IGNhbGxvdXQgfSA9IG1vZGVsLnRoZW1lO1xuICAgIGNvbnN0IHRoZW1lID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjYWxsb3V0KSwgeyBsaW5lQ29sb3I6IGNhbGxvdXQudXNlU2VyaWVzQ29sb3IgPyBtb2RlbC5jb2xvciA6IGNhbGxvdXQubGluZUNvbG9yIH0pO1xuICAgIHJldHVybiB7IHgsIHksIHgyLCB5MiwgdGhlbWUgfTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBmaW5kTm9kZXMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBpc1N0cmluZywgaXNVbmRlZmluZWQsIGlzTnVtYmVyLCBpbmNsdWRlcywgaXNOdWxsLCByYW5nZSwgZ2V0Rmlyc3RWYWxpZFZhbHVlLCB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXRDb29yZGluYXRlWFZhbHVlLCBnZXRDb29yZGluYXRlWVZhbHVlIH0gZnJvbSBcIi4vY29vcmRpbmF0ZVwiO1xuY29uc3QgREFUQV9VUklfSEVBREVSUyA9IHtcbiAgICB4bHM6ICdkYXRhOmFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbDtiYXNlNjQsJyxcbiAgICBjc3Y6ICdkYXRhOnRleHQvY3N2O2NoYXJzZXQ9dXRmLTgsJUVGJUJCJUJGJyAvKiBCT00gZm9yIHV0Zi04ICovLFxufTtcbmZ1bmN0aW9uIGdldERvd25sb2FkTWV0aG9kKCkge1xuICAgIGxldCBtZXRob2Q7XG4gICAgY29uc3QgaXNEb3dubG9hZEF0dHJpYnV0ZVN1cHBvcnRlZCA9ICFpc1VuZGVmaW5lZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJykuZG93bmxvYWQpO1xuICAgIGNvbnN0IGlzTVNTYXZlT3JPcGVuQmxvYlN1cHBvcnRlZCA9ICFpc1VuZGVmaW5lZCh3aW5kb3cuQmxvYiAmJiB3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IpO1xuICAgIGlmIChpc01TU2F2ZU9yT3BlbkJsb2JTdXBwb3J0ZWQpIHtcbiAgICAgICAgbWV0aG9kID0gZG93bmxvYWRXaXRoTVNTYXZlT3JPcGVuQmxvYjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEb3dubG9hZEF0dHJpYnV0ZVN1cHBvcnRlZCkge1xuICAgICAgICBtZXRob2QgPSBkb3dubG9hZFdpdGhBbmNob3JFbGVtZW50RG93bmxvYWRBdHRyaWJ1dGU7XG4gICAgfVxuICAgIHJldHVybiBtZXRob2Q7XG59XG4vKipcbiAqIEJhc2U2NCBzdHJpbmcgdG8gYmxvYlxuICogb3JpZ2luYWwgc291cmNlIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL21pZ3VlbG1vdGEvYmFzZTY0dG9ibG9iL2Jsb2IvbWFzdGVyL2Jhc2U2NHRvYmxvYi5qc1xuICogTGljZW5jZTogTUlUIExpY2VuY2VcbiAqL1xuZnVuY3Rpb24gYmFzZTY0dG9CbG9iKGJhc2U2NFN0cmluZykge1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gYmFzZTY0U3RyaW5nXG4gICAgICAgIC5zdWJzdHIoMCwgYmFzZTY0U3RyaW5nLmluZGV4T2YoJztiYXNlNjQsJykpXG4gICAgICAgIC5zdWJzdHIoYmFzZTY0U3RyaW5nLmluZGV4T2YoJzonKSArIDEpO1xuICAgIGNvbnN0IHNsaWNlU2l6ZSA9IDEwMjQ7XG4gICAgY29uc3QgYnl0ZUNoYXJhY3RlcnMgPSBhdG9iKGJhc2U2NFN0cmluZy5zdWJzdHIoYmFzZTY0U3RyaW5nLmluZGV4T2YoJywnKSArIDEpKTtcbiAgICBjb25zdCBieXRlQXJyYXlzID0gW107XG4gICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYnl0ZUNoYXJhY3RlcnMubGVuZ3RoOyBvZmZzZXQgKz0gc2xpY2VTaXplKSB7XG4gICAgICAgIGNvbnN0IHNsaWNlID0gYnl0ZUNoYXJhY3RlcnMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzbGljZVNpemUpO1xuICAgICAgICBjb25zdCBieXRlTnVtYmVycyA9IG5ldyBBcnJheShzbGljZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWNlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBieXRlTnVtYmVyc1tpXSA9IHNsaWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZUFycmF5cy5wdXNoKG5ldyB3aW5kb3cuVWludDhBcnJheShieXRlTnVtYmVycykpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBmb3IgSUUgMTFcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKGJ5dGVBcnJheXMsIHsgdHlwZTogY29udGVudFR5cGUgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGZvciBJRSAxMFxuICAgICAgICByZXR1cm4gbmV3IEJsb2IoYnl0ZUFycmF5cy5tYXAoKGJ5dGVBcnIpID0+IGJ5dGVBcnIuYnVmZmVyKSwgeyB0eXBlOiBjb250ZW50VHlwZSB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0ltYWdlRXh0ZW5zaW9uKGV4dGVuc2lvbikge1xuICAgIHJldHVybiBleHRlbnNpb24gPT09ICdqcGVnJyB8fCBleHRlbnNpb24gPT09ICdwbmcnO1xufVxuZnVuY3Rpb24gZG93bmxvYWRXaXRoTVNTYXZlT3JPcGVuQmxvYihmaWxlTmFtZSwgZXh0ZW5zaW9uLCBjb250ZW50LCBjb250ZW50VHlwZSkge1xuICAgIGNvbnN0IGJsb2JPYmplY3QgPSBpc0ltYWdlRXh0ZW5zaW9uKGV4dGVuc2lvbilcbiAgICAgICAgPyBiYXNlNjR0b0Jsb2IoY29udGVudClcbiAgICAgICAgOiBuZXcgQmxvYihbY29udGVudF0sIHsgdHlwZTogY29udGVudFR5cGUgfSk7XG4gICAgd2luZG93Lm5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKGJsb2JPYmplY3QsIGAke2ZpbGVOYW1lfS4ke2V4dGVuc2lvbn1gKTtcbn1cbmZ1bmN0aW9uIGRvd25sb2FkV2l0aEFuY2hvckVsZW1lbnREb3dubG9hZEF0dHJpYnV0ZShmaWxlTmFtZSwgZXh0ZW5zaW9uLCBjb250ZW50KSB7XG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgYW5jaG9yRWxlbWVudC5ocmVmID0gY29udGVudDtcbiAgICAgICAgYW5jaG9yRWxlbWVudC50YXJnZXQgPSAnX2JsYW5rJztcbiAgICAgICAgYW5jaG9yRWxlbWVudC5kb3dubG9hZCA9IGAke2ZpbGVOYW1lfS4ke2V4dGVuc2lvbn1gO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGFuY2hvckVsZW1lbnQpO1xuICAgICAgICBhbmNob3JFbGVtZW50LmNsaWNrKCk7XG4gICAgICAgIGFuY2hvckVsZW1lbnQucmVtb3ZlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gb25lTGluZVRyaW0oLi4uYXJncykge1xuICAgIGNvbnN0IG5vcm1hbFRhZyA9ICh0ZW1wbGF0ZSwgLi4uZXhwcmVzc2lvbnMpID0+IHRlbXBsYXRlLnJlZHVjZSgoYWNjdW11bGF0b3IsIHBhcnQsIGkpID0+IGFjY3VtdWxhdG9yICsgZXhwcmVzc2lvbnNbaSAtIDFdICsgcGFydCk7XG4gICAgcmV0dXJuIG5vcm1hbFRhZyguLi5hcmdzKS5yZXBsYWNlKC9cXG5cXHMqL2csICcnKTtcbn1cbmZ1bmN0aW9uIGlzTmVlZERhdGFFbmNvZGluZygpIHtcbiAgICBjb25zdCBpc0Rvd25sb2FkQXR0cmlidXRlU3VwcG9ydGVkID0gIWlzVW5kZWZpbmVkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKS5kb3dubG9hZCk7XG4gICAgY29uc3QgaXNNU1NhdmVPck9wZW5CbG9iU3VwcG9ydGVkID0gIWlzVW5kZWZpbmVkKHdpbmRvdy5CbG9iICYmIHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYik7XG4gICAgcmV0dXJuICFpc01TU2F2ZU9yT3BlbkJsb2JTdXBwb3J0ZWQgJiYgaXNEb3dubG9hZEF0dHJpYnV0ZVN1cHBvcnRlZDtcbn1cbmZ1bmN0aW9uIGdldEJ1bGxldExvbmdlc3RBcnJheUxlbmd0aChhcnIsIGZpZWxkKSB7XG4gICAgcmV0dXJuIGFyci5yZWR1Y2UoKGFjYywgY3VyLCBpZHgpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuICghaWR4IHx8IGFjYyA8ICgoX2IgPSAoX2EgPSBjdXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtmaWVsZF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpID8gY3VyW2ZpZWxkXS5sZW5ndGggOiBhY2MpOyB9LCAwKTtcbn1cbmZ1bmN0aW9uIG1ha2VCdWxsZXRFeHBvcnREYXRhKHsgc2VyaWVzIH0pIHtcbiAgICBjb25zdCBzZXJpZXNEYXRhID0gc2VyaWVzLmJ1bGxldC5kYXRhO1xuICAgIGNvbnN0IG1hcmtlckNvdW50ID0gZ2V0QnVsbGV0TG9uZ2VzdEFycmF5TGVuZ3RoKHNlcmllc0RhdGEsICdtYXJrZXJzJyk7XG4gICAgY29uc3QgcmFuZ2VDb3VudCA9IGdldEJ1bGxldExvbmdlc3RBcnJheUxlbmd0aChzZXJpZXNEYXRhLCAncmFuZ2VzJyk7XG4gICAgY29uc3QgcmFuZ2VzSGVhZGVycyA9IHJhbmdlKDAsIHJhbmdlQ291bnQpLm1hcCgoaWR4KSA9PiBgUmFuZ2UgJHtpZHggKyAxfWApO1xuICAgIGNvbnN0IG1hcmtlckhlYWRlcnMgPSByYW5nZSgwLCBtYXJrZXJDb3VudCkubWFwKChpZHgpID0+IGBNYXJrZXIgJHtpZHggKyAxfWApO1xuICAgIHJldHVybiBzZXJpZXNEYXRhLnJlZHVjZSgoYWNjLCB7IGRhdGEsIG1hcmtlcnMsIG5hbWUsIHJhbmdlcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHJhbmdlRGF0dW0gPSByYW5nZXNIZWFkZXJzLm1hcCgoXywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlRGF0YSA9IChfYSA9IHJhbmdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2luZGV4XTtcbiAgICAgICAgICAgIHJldHVybiByYW5nZURhdGEgPyBgJHtyYW5nZURhdGFbMF19IH4gJHtyYW5nZURhdGFbMV19YCA6ICcnO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbWFya2VyRGF0dW0gPSBtYXJrZXJIZWFkZXJzLm1hcCgoXywgaW5kZXgpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIF9iID0gKF9hID0gbWFya2VycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2luZGV4XSwgKF9iICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnKTsgfSk7XG4gICAgICAgIHJldHVybiBbLi4uYWNjLCBbbmFtZSwgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdm9pZCAwID8gZGF0YSA6ICcnKSwgLi4ucmFuZ2VEYXR1bSwgLi4ubWFya2VyRGF0dW1dXTtcbiAgICB9LCBbWycnLCAnQWN0dWFsJywgLi4ucmFuZ2VzSGVhZGVycywgLi4ubWFya2VySGVhZGVyc11dKTtcbn1cbmZ1bmN0aW9uIG1ha2VIZWF0bWFwRXhwb3J0RGF0YSh7IGNhdGVnb3JpZXMsIHNlcmllcyB9KSB7XG4gICAgY29uc3QgeENhdGVnb3JpZXMgPSBjYXRlZ29yaWVzLng7XG4gICAgcmV0dXJuIHNlcmllcy5oZWF0bWFwLmRhdGEucmVkdWNlKChhY2MsIHsgZGF0YSwgeUNhdGVnb3J5IH0pID0+IFtcbiAgICAgICAgLi4uYWNjLFxuICAgICAgICBbeUNhdGVnb3J5LCAuLi5kYXRhLm1hcCgoZGF0dW0pID0+IChpc051bGwoZGF0dW0pID8gJycgOiBkYXR1bSkpXSxcbiAgICBdLCBbWycnLCAuLi54Q2F0ZWdvcmllc11dKTtcbn1cbmZ1bmN0aW9uIHJlY3Vyc2l2ZVRyZWVtYXBEYXRhKHsgbGFiZWwsIGRhdGEsIGNoaWxkcmVuID0gW10gfSwgcmVzdWx0KSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goW2xhYmVsLCBkYXRhXSk7XG4gICAgfVxuICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkcmVuRGF0YSkgPT4gcmVjdXJzaXZlVHJlZW1hcERhdGEoY2hpbGRyZW5EYXRhLCByZXN1bHQpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWFrZVRyZWVtYXBFeHBvcnREYXRhKGV4cG9ydERhdGEpIHtcbiAgICBjb25zdCB7IHNlcmllcyB9ID0gZXhwb3J0RGF0YTtcbiAgICBjb25zdCByZXN1bHQgPSBbWydMYWJlbCcsICdEYXRhJ11dO1xuICAgIHNlcmllcy50cmVlbWFwLmRhdGEuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgICAgcmVjdXJzaXZlVHJlZW1hcERhdGEoZGF0dW0sIHJlc3VsdCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1ha2VCdWJibGVFeHBvcnREYXRhKGV4cG9ydERhdGEpIHtcbiAgICBjb25zdCB7IHNlcmllcyB9ID0gZXhwb3J0RGF0YTtcbiAgICByZXR1cm4gc2VyaWVzLmJ1YmJsZS5kYXRhLnJlZHVjZSgoYWNjLCB7IG5hbWUsIGRhdGEgfSkgPT4gW1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIC4uLmRhdGEubWFwKChkYXR1bSkgPT4gaXNOdWxsKGRhdHVtKSA/IFtdIDogW25hbWUsIGRhdHVtLmxhYmVsLCBTdHJpbmcoZGF0dW0ueCksIGRhdHVtLnksIGRhdHVtLnJdKSxcbiAgICBdLCBbWydOYW1lJywgJ0xhYmVsJywgJ1gnLCAnWScsICdSYWRpdXMnXV0pO1xufVxuZnVuY3Rpb24gbWFrZUJveFBsb3RFeHBvcnREYXRhKGV4cG9ydERhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBzZXJpZXMgfSA9IGV4cG9ydERhdGE7XG4gICAgY29uc3QgY2F0ZWdvcmllcyA9IChfYSA9IGV4cG9ydERhdGEuY2F0ZWdvcmllcywgKF9hICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSk7XG4gICAgcmV0dXJuIHNlcmllcy5ib3hQbG90LmRhdGEucmVkdWNlKChhY2MsIHsgbmFtZSwgZGF0YSwgb3V0bGllcnMgfSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSAoKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdm9pZCAwID8gZGF0YSA6IFtdKSkubWFwKChyYXdEYXRhLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3Qgb3V0bGllclZhbHVlID0gKF9hID0gKChvdXRsaWVycyAhPT0gbnVsbCAmJiBvdXRsaWVycyAhPT0gdm9pZCAwID8gb3V0bGllcnMgOiBbXSkpLmZpbmQoKG91dGxpZXIpID0+IG91dGxpZXJbMF0gPT09IGluZGV4KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzFdO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvdXRsaWVyVmFsdWUgPyBbLi4ucmF3RGF0YSwgb3V0bGllclZhbHVlXSA6IFsuLi5yYXdEYXRhXTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5qb2luKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gWy4uLmFjYywgW25hbWUsIC4uLnZhbHVlc11dO1xuICAgIH0sIFtbJycsIC4uLmNhdGVnb3JpZXNdXSk7XG59XG5mdW5jdGlvbiBtYWtlUGllRXhwb3J0RGF0YShleHBvcnREYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgc2VyaWVzIH0gPSBleHBvcnREYXRhO1xuICAgIGNvbnN0IGNhdGVnb3JpZXMgPSAoX2EgPSBleHBvcnREYXRhLmNhdGVnb3JpZXMsIChfYSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkpO1xuICAgIHJldHVybiBzZXJpZXMucGllLmRhdGEucmVkdWNlKChhY2MsIHsgbmFtZSwgZGF0YSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkoZGF0YSlcbiAgICAgICAgICAgID8gKChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHZvaWQgMCA/IGRhdGEgOiBbXSkpLnJlZHVjZSgoYWNjTmVzdGVkUGllVmFsdWUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiBbLi4uYWNjTmVzdGVkUGllVmFsdWUsIFt2YWx1ZS5uYW1lLCAoX2EgPSB2YWx1ZS5kYXRhLCAoX2EgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpKV1dO1xuICAgICAgICAgICAgfSwgW10pXG4gICAgICAgICAgICA6IFtbbmFtZSwgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdm9pZCAwID8gZGF0YSA6ICcnKV1dO1xuICAgICAgICByZXR1cm4gWy4uLmFjYywgLi4udmFsdWVzXTtcbiAgICB9LCBjYXRlZ29yaWVzLmxlbmd0aCA/IFtbJycsIC4uLmNhdGVnb3JpZXNdXSA6IFtdKTtcbn1cbmZ1bmN0aW9uIG1ha2VDb29yZGluYXRlRXhwb3J0RGF0YVZhbHVlcyh0eXBlLCBjYXRlZ29yaWVzLCBkYXRhKSB7XG4gICAgcmV0dXJuIGNhdGVnb3JpZXMubWFwKChjYXRlZ29yeSwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdhcmVhJyAmJiBBcnJheS5pc0FycmF5KGRhdGFbaW5kZXhdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFbaW5kZXhdLmpvaW4oKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3VuZEl0ZW0gPSBkYXRhLmZpbmQoKHZhbHVlKSA9PiBjYXRlZ29yeSA9PT0gU3RyaW5nKGdldENvb3JkaW5hdGVYVmFsdWUodmFsdWUpKSk7XG4gICAgICAgIHJldHVybiBmb3VuZEl0ZW0gPyBnZXRDb29yZGluYXRlWVZhbHVlKGZvdW5kSXRlbSkgOiAnJztcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG1ha2VFeHBvcnREYXRhKGV4cG9ydERhdGEpIHtcbiAgICBjb25zdCB7IHNlcmllcyB9ID0gZXhwb3J0RGF0YTtcbiAgICBjb25zdCBjYXRlZ29yaWVzID0gZXhwb3J0RGF0YS5jYXRlZ29yaWVzO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzZXJpZXMpLnJlZHVjZSgoYWNjLCB0eXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHNlcmllc1t0eXBlXS5kYXRhLm1hcCgoeyBuYW1lLCBkYXRhIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9ICFpc051bWJlcihnZXRGaXJzdFZhbGlkVmFsdWUoZGF0YSkpICYmIGluY2x1ZGVzKFsnbGluZScsICdhcmVhJywgJ3NjYXR0ZXInXSwgdHlwZSlcbiAgICAgICAgICAgICAgICA/IG1ha2VDb29yZGluYXRlRXhwb3J0RGF0YVZhbHVlcyh0eXBlLCBjYXRlZ29yaWVzLCBkYXRhKVxuICAgICAgICAgICAgICAgIDogZGF0YS5tYXAoKHZhbHVlKSA9PiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKCkgOiB2YWx1ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIFtuYW1lLCAuLi52YWx1ZXNdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFsuLi5hY2MsIC4uLnJlc3VsdF07XG4gICAgfSwgc2VyaWVzLmdhdWdlID8gW10gOiBbWycnLCAuLi5jYXRlZ29yaWVzXV0pO1xufVxuZnVuY3Rpb24gZ2V0MkRBcnJheUZyb21SYXdEYXRhKGV4cG9ydERhdGEpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGNvbnN0IHsgc2VyaWVzIH0gPSBleHBvcnREYXRhO1xuICAgIGlmIChzZXJpZXMuYnVsbGV0KSB7XG4gICAgICAgIHJlc3VsdCA9IG1ha2VCdWxsZXRFeHBvcnREYXRhKGV4cG9ydERhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZXJpZXMuaGVhdG1hcCkge1xuICAgICAgICByZXN1bHQgPSBtYWtlSGVhdG1hcEV4cG9ydERhdGEoZXhwb3J0RGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlcmllcy5idWJibGUpIHtcbiAgICAgICAgcmVzdWx0ID0gbWFrZUJ1YmJsZUV4cG9ydERhdGEoZXhwb3J0RGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlcmllcy5ib3hQbG90KSB7XG4gICAgICAgIHJlc3VsdCA9IG1ha2VCb3hQbG90RXhwb3J0RGF0YShleHBvcnREYXRhKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VyaWVzLnBpZSkge1xuICAgICAgICByZXN1bHQgPSBtYWtlUGllRXhwb3J0RGF0YShleHBvcnREYXRhKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VyaWVzLnRyZWVtYXApIHtcbiAgICAgICAgcmVzdWx0ID0gbWFrZVRyZWVtYXBFeHBvcnREYXRhKGV4cG9ydERhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gbWFrZUV4cG9ydERhdGEoZXhwb3J0RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRUYWJsZUVsZW1lbnRTdHJpbmdGb3JYTFMoY2hhcnREYXRhMkRBcnJheSkge1xuICAgIGxldCB0YWJsZUVsZW1lbnRTdHJpbmcgPSAnPHRhYmxlPic7XG4gICAgY2hhcnREYXRhMkRBcnJheS5mb3JFYWNoKChyb3csIHJvd0luZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGNlbGxUYWdOYW1lID0gcm93SW5kZXggPT09IDAgPyAndGgnIDogJ3RkJztcbiAgICAgICAgdGFibGVFbGVtZW50U3RyaW5nICs9ICc8dHI+JztcbiAgICAgICAgcm93LmZvckVhY2goKGNlbGwsIGNlbGxJbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2VsbE51bWJlckNsYXNzID0gcm93SW5kZXggIT09IDAgfHwgY2VsbEluZGV4ID09PSAwID8gJyBjbGFzcz1cIm51bWJlclwiJyA6ICcnO1xuICAgICAgICAgICAgY29uc3QgY2VsbFN0cmluZyA9IGA8JHtjZWxsVGFnTmFtZX0ke2NlbGxOdW1iZXJDbGFzc30+JHtjZWxsfTwvJHtjZWxsVGFnTmFtZX0+YDtcbiAgICAgICAgICAgIHRhYmxlRWxlbWVudFN0cmluZyArPSBjZWxsU3RyaW5nO1xuICAgICAgICB9KTtcbiAgICAgICAgdGFibGVFbGVtZW50U3RyaW5nICs9ICc8L3RyPic7XG4gICAgfSk7XG4gICAgdGFibGVFbGVtZW50U3RyaW5nICs9ICc8L3RhYmxlPic7XG4gICAgcmV0dXJuIHRhYmxlRWxlbWVudFN0cmluZztcbn1cbmZ1bmN0aW9uIG1ha2VYTFNCb2R5V2l0aFJhd0RhdGEoY2hhcnREYXRhMkRBcnJheSkge1xuICAgIHJldHVybiBvbmVMaW5lVHJpbSBgPGh0bWwgeG1sbnM6bz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206b2ZmaWNlOm9mZmljZVwiXG4gICAgICAgIHhtbG5zOng9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOm9mZmljZTpleGNlbFwiXG4gICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLWh0bWw0MFwiPlxuICAgICAgICA8aGVhZD5cbiAgICAgICAgICAgIDwhLS1baWYgZ3RlIG1zbyA5XT5cbiAgICAgICAgICAgICAgICA8eG1sPlxuICAgICAgICAgICAgICAgICAgICA8eDpFeGNlbFdvcmtib29rPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHg6RXhjZWxXb3Jrc2hlZXRzPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4OkV4Y2VsV29ya3NoZWV0PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8eDpOYW1lPkFyazE8L3g6TmFtZT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHg6V29ya3NoZWV0T3B0aW9ucz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx4OkRpc3BsYXlHcmlkbGluZXMvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3g6V29ya3NoZWV0T3B0aW9ucz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3g6RXhjZWxXb3Jrc2hlZXQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3g6RXhjZWxXb3Jrc2hlZXRzPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC94OkV4Y2VsV29ya2Jvb2s+XG4gICAgICAgICAgICAgICAgPC94bWw+XG4gICAgICAgICAgICA8IVtlbmRpZl0tLT5cbiAgICAgICAgICAgIDxtZXRhIG5hbWU9UHJvZ0lkIGNvbnRlbnQ9RXhjZWwuU2hlZXQ+XG4gICAgICAgICAgICA8bWV0YSBjaGFyc2V0PVVURi04PlxuICAgICAgICA8L2hlYWQ+XG4gICAgICAgIDxib2R5PlxuICAgICAgICAgICAgJHtnZXRUYWJsZUVsZW1lbnRTdHJpbmdGb3JYTFMoY2hhcnREYXRhMkRBcnJheSl9XG4gICAgICAgIDwvYm9keT5cbiAgICAgICAgPC9odG1sPmA7XG59XG5mdW5jdGlvbiBtYWtlQ1NWQm9keVdpdGhSYXdEYXRhKGNoYXJ0RGF0YTJEQXJyYXksIG9wdGlvbiA9IHt9KSB7XG4gICAgY29uc3QgeyBsaW5lRGVsaW1pdGVyID0gJ1xcdTAwMGEnLCBpdGVtRGVsaW1pdGVyID0gJywnIH0gPSBvcHRpb247XG4gICAgY29uc3QgbGFzdFJvd0luZGV4ID0gY2hhcnREYXRhMkRBcnJheS5sZW5ndGggLSAxO1xuICAgIGxldCBjc3ZUZXh0ID0gJyc7XG4gICAgY2hhcnREYXRhMkRBcnJheS5mb3JFYWNoKChyb3csIHJvd0luZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGxhc3RDZWxsSW5kZXggPSByb3cubGVuZ3RoIC0gMTtcbiAgICAgICAgcm93LmZvckVhY2goKGNlbGwsIGNlbGxJbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2VsbENvbnRlbnQgPSBpc051bWJlcihjZWxsKSA/IGNlbGwgOiBgXCIke2NlbGx9XCJgO1xuICAgICAgICAgICAgY3N2VGV4dCArPSBjZWxsQ29udGVudDtcbiAgICAgICAgICAgIGlmIChjZWxsSW5kZXggPCBsYXN0Q2VsbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgY3N2VGV4dCArPSBpdGVtRGVsaW1pdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJvd0luZGV4IDwgbGFzdFJvd0luZGV4KSB7XG4gICAgICAgICAgICBjc3ZUZXh0ICs9IGxpbmVEZWxpbWl0ZXI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY3N2VGV4dDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleGVjRG93bmxvYWQoZmlsZU5hbWUsIGV4dGVuc2lvbiwgY29udGVudCwgY29udGVudFR5cGUpIHtcbiAgICBjb25zdCBkb3dubG9hZE1ldGhvZCA9IGdldERvd25sb2FkTWV0aG9kKCk7XG4gICAgaWYgKCFpc1N0cmluZyhjb250ZW50KSB8fCAhZG93bmxvYWRNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkb3dubG9hZE1ldGhvZChmaWxlTmFtZSwgZXh0ZW5zaW9uLCBjb250ZW50LCBjb250ZW50VHlwZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZG93bmxvYWRTcHJlYWRTaGVldChmaWxlTmFtZSwgZXh0ZW5zaW9uLCBkYXRhKSB7XG4gICAgY29uc3QgY2hhcnREYXRhMkRBcnJheSA9IGdldDJEQXJyYXlGcm9tUmF3RGF0YShkYXRhKTtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IERBVEFfVVJJX0hFQURFUlNbZXh0ZW5zaW9uXS5yZXBsYWNlKC8oZGF0YTp8O2Jhc2U2NCx8LCVFRiVCQiVCRikvZywgJycpO1xuICAgIGxldCBjb250ZW50ID0gJyc7XG4gICAgaWYgKGV4dGVuc2lvbiA9PT0gJ2NzdicpIHtcbiAgICAgICAgY29udGVudCA9IGVuY29kZVVSSUNvbXBvbmVudChtYWtlQ1NWQm9keVdpdGhSYXdEYXRhKGNoYXJ0RGF0YTJEQXJyYXkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnRlbnQgPSBtYWtlWExTQm9keVdpdGhSYXdEYXRhKGNoYXJ0RGF0YTJEQXJyYXkpO1xuICAgIH1cbiAgICBpZiAoaXNOZWVkRGF0YUVuY29kaW5nKCkpIHtcbiAgICAgICAgaWYgKGV4dGVuc2lvbiAhPT0gJ2NzdicpIHtcbiAgICAgICAgICAgIC8vIGJhc2U2NCBlbmNvZGluZyBmb3IgZGF0YSBVUkkgc2NoZW1lLlxuICAgICAgICAgICAgY29udGVudCA9IHdpbmRvdy5idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChjb250ZW50KSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnQgPSBEQVRBX1VSSV9IRUFERVJTW2V4dGVuc2lvbl0gKyBjb250ZW50O1xuICAgIH1cbiAgICBleGVjRG93bmxvYWQoZmlsZU5hbWUsIGV4dGVuc2lvbiwgY29udGVudCwgY29udGVudFR5cGUpO1xufVxuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL25obi90dWkuY29kZS1zbmlwcGV0L2Jsb2IvbWFzdGVyL2Zvcm1hdERhdGUvZm9ybWF0RGF0ZS5qc1xuaW1wb3J0IHsgaXNEYXRlLCBpc09iamVjdCB9IGZyb20gXCIuL3V0aWxzXCI7XG5leHBvcnQgY29uc3QgREVGQVVMVF9EQVRFX0ZPUk1BVCA9ICdZWS1NTS1ERCBoaDptbTpzcyc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0ZUZvcm1hdChkYXRlKSB7XG4gICAgaWYgKCFkYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGlzT2JqZWN0KGRhdGUpID8gZGF0ZS5mb3JtYXQgOiBERUZBVUxUX0RBVEVfRk9STUFUO1xufVxuY29uc3QgdG9rZW5zID0gL1tcXFxcXSpZWVlZfFtcXFxcXSpZWXxbXFxcXF0qTU1NTXxbXFxcXF0qTU1NfFtcXFxcXSpNTXxbXFxcXF0qTXxbXFxcXF0qRER8W1xcXFxdKkR8W1xcXFxdKkhIfFtcXFxcXSpIfFtcXFxcXSptbXxbXFxcXF0qbXxbXFxcXF0qc3N8W1xcXFxdKnN8W1xcXFxdKkEvZ2k7XG5jb25zdCBNT05USF9TVFIgPSBbXG4gICAgJ0ludmFsaWQgbW9udGgnLFxuICAgICdKYW51YXJ5JyxcbiAgICAnRmVicnVhcnknLFxuICAgICdNYXJjaCcsXG4gICAgJ0FwcmlsJyxcbiAgICAnTWF5JyxcbiAgICAnSnVuJyxcbiAgICAnSnVsJyxcbiAgICAnQXVndXN0JyxcbiAgICAnU2VwdGVtYmVyJyxcbiAgICAnT2N0b2JlcicsXG4gICAgJ05vdmVtYmVyJyxcbiAgICAnRGVjZW1iZXInLFxuXTtcbmNvbnN0IE1PTlRIX0RBWVMgPSBbMCwgMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5jb25zdCByZXBsYWNlTWFwID0ge1xuICAgIE06IChkYXRlKSA9PiBOdW1iZXIoZGF0ZS5tb250aCksXG4gICAgTU06IChkYXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gZGF0ZS5tb250aDtcbiAgICAgICAgcmV0dXJuIE51bWJlcihtb250aCkgPCAxMCA/IGAwJHttb250aH1gIDogbW9udGg7XG4gICAgfSxcbiAgICBNTU06IChkYXRlKSA9PiBNT05USF9TVFJbTnVtYmVyKGRhdGUubW9udGgpXS5zdWJzdHIoMCwgMyksXG4gICAgTU1NTTogKGRhdGUpID0+IE1PTlRIX1NUUltOdW1iZXIoZGF0ZS5tb250aCldLFxuICAgIEQ6IChkYXRlKSA9PiBOdW1iZXIoZGF0ZS5kYXRlKSxcbiAgICBkOiAoZGF0ZSkgPT4gcmVwbGFjZU1hcC5EKGRhdGUpLFxuICAgIEREOiAoZGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBkYXlJbk1vbnRoID0gZGF0ZS5kYXRlO1xuICAgICAgICByZXR1cm4gTnVtYmVyKGRheUluTW9udGgpIDwgMTAgPyBgMCR7ZGF5SW5Nb250aH1gIDogZGF5SW5Nb250aDtcbiAgICB9LFxuICAgIGRkOiAoZGF0ZSkgPT4gcmVwbGFjZU1hcC5ERChkYXRlKSxcbiAgICBZWTogKGRhdGUpID0+IE51bWJlcihkYXRlLnllYXIpICUgMTAwLFxuICAgIHl5OiAoZGF0ZSkgPT4gcmVwbGFjZU1hcC5ZWShkYXRlKSxcbiAgICBZWVlZOiAoZGF0ZSkgPT4ge1xuICAgICAgICBsZXQgcHJlZml4ID0gJzIwJztcbiAgICAgICAgY29uc3QgeWVhciA9IGRhdGUueWVhcjtcbiAgICAgICAgaWYgKHllYXIgPiA2OSAmJiB5ZWFyIDwgMTAwKSB7XG4gICAgICAgICAgICBwcmVmaXggPSAnMTknO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOdW1iZXIoeWVhcikgPCAxMDAgPyBwcmVmaXggKyBTdHJpbmcoeWVhcikgOiB5ZWFyO1xuICAgIH0sXG4gICAgeXl5eTogKGRhdGUpID0+IHJlcGxhY2VNYXAuWVlZWShkYXRlKSxcbiAgICBBOiAoZGF0ZSkgPT4gZGF0ZS5tZXJpZGllbSxcbiAgICBhOiAoZGF0ZSkgPT4gZGF0ZS5tZXJpZGllbSxcbiAgICBoaDogKGRhdGUpID0+IHtcbiAgICAgICAgY29uc3QgaG91ciA9IGRhdGUuaG91cjtcbiAgICAgICAgcmV0dXJuIE51bWJlcihob3VyKSA8IDEwID8gJzAnICsgaG91ciA6IGhvdXI7XG4gICAgfSxcbiAgICBISDogKGRhdGUpID0+IHJlcGxhY2VNYXAuaGgoZGF0ZSksXG4gICAgaDogKGRhdGUpID0+IFN0cmluZyhOdW1iZXIoZGF0ZS5ob3VyKSksXG4gICAgSDogKGRhdGUpID0+IHJlcGxhY2VNYXAuaChkYXRlKSxcbiAgICBtOiAoZGF0ZSkgPT4gU3RyaW5nKE51bWJlcihkYXRlLm1pbnV0ZSkpLFxuICAgIG1tOiAoZGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBtaW51dGUgPSBkYXRlLm1pbnV0ZTtcbiAgICAgICAgcmV0dXJuIE51bWJlcihtaW51dGUpIDwgMTAgPyBgMCR7bWludXRlfWAgOiBtaW51dGU7XG4gICAgfSxcbiAgICBzOiAoZGF0ZSkgPT4gU3RyaW5nKE51bWJlcihkYXRlLnNlY29uZCkpLFxuICAgIHNzOiAoZGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBzZWNvbmQgPSBkYXRlLnNlY29uZDtcbiAgICAgICAgcmV0dXJuIE51bWJlcihzZWNvbmQpIDwgMTAgPyBgMCR7c2Vjb25kfWAgOiBzZWNvbmQ7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBpc0xlYXBZZWFyKG1vbnRoLCB5ZWFyKSB7XG4gICAgcmV0dXJuIG1vbnRoID09PSAyICYmIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xufVxuZnVuY3Rpb24gaXNWYWxpZERhdGUoeSwgbSwgZCkge1xuICAgIGNvbnN0IHllYXIgPSBOdW1iZXIoeSk7XG4gICAgY29uc3QgbW9udGggPSBOdW1iZXIobSk7XG4gICAgY29uc3QgZGF0ZSA9IE51bWJlcihkKTtcbiAgICBjb25zdCBpc1ZhbGlkWWVhciA9ICh5ZWFyID4gLTEgJiYgeWVhciA8IDEwMCkgfHwgKHllYXIgPiAxOTY5ICYmIHllYXIgPCAyMDcwKTtcbiAgICBjb25zdCBpc1ZhbGlkTW9udGggPSBtb250aCA+IDAgJiYgbW9udGggPCAxMztcbiAgICBpZiAoIWlzVmFsaWRZZWFyIHx8ICFpc1ZhbGlkTW9udGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsYXN0RGF5SW5Nb250aCA9IGlzTGVhcFllYXIobW9udGgsIHllYXIpID8gMjkgOiBNT05USF9EQVlTW21vbnRoXTtcbiAgICByZXR1cm4gZGF0ZSA+IDAgJiYgZGF0ZSA8PSBsYXN0RGF5SW5Nb250aDtcbn1cbi8qXG4gKiBrZXkgICAgICAgICAgICAgfCBTaG9ydGhhbmRcbiAqIC0tLS0tLS0tLS0tLS0tLSB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIHllYXJzICAgICAgICAgICB8IFlZIC8gWVlZWSAvIHl5IC8geXl5eVxuICogbW9udGhzKG4pICAgICAgIHwgTSAvIE1NXG4gKiBtb250aHMoc3RyKSAgICAgfCBNTU0gLyBNTU1NXG4gKiBkYXlzICAgICAgICAgICAgfCBEIC8gREQgLyBkIC8gZGRcbiAqIGhvdXJzICAgICAgICAgICB8IEggLyBISCAvIGggLyBoaFxuICogbWludXRlcyAgICAgICAgIHwgbSAvIG1tXG4gKiBzZWNvbmRzICAgICAgICAgfCBzIC8gc3NcbiAqIG1lcmlkaWVtKEFNLFBNKSB8IEEgLyBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRlKGZvcm0sIGRhdGUsIG9wdGlvbikge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IGFtID0gKF9iID0gKF9hID0gb3B0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVyaWRpZW1TZXQuQU0sIChfYiAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnQU0nKSk7XG4gICAgY29uc3QgcG0gPSAoKF9jID0gb3B0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubWVyaWRpZW1TZXQuUE0pIHx8ICdQTSc7XG4gICAgbGV0IG5EYXRlO1xuICAgIGlmIChpc0RhdGUoZGF0ZSkpIHtcbiAgICAgICAgbkRhdGUgPSB7XG4gICAgICAgICAgICB5ZWFyOiBkYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICBtb250aDogZGF0ZS5nZXRNb250aCgpICsgMSxcbiAgICAgICAgICAgIGRhdGU6IGRhdGUuZ2V0RGF0ZSgpLFxuICAgICAgICAgICAgaG91cjogZGF0ZS5nZXRIb3VycygpLFxuICAgICAgICAgICAgbWludXRlOiBkYXRlLmdldE1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHNlY29uZDogZGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBob3VyLCBtaW51dGUsIHNlY29uZCB9ID0gZGF0ZTtcbiAgICAgICAgbkRhdGUgPSB7IHllYXIsIG1vbnRoLCBkYXRlOiBkYXRlLmRhdGUsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kIH07XG4gICAgfVxuICAgIGlmICghaXNWYWxpZERhdGUobkRhdGUueWVhciwgbkRhdGUubW9udGgsIG5EYXRlLmRhdGUpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgbkRhdGUubWVyaWRpZW0gPSAnJztcbiAgICBpZiAoLyhbXlxcXFxdfF4pW2FBXVxcYi8udGVzdChmb3JtKSkge1xuICAgICAgICBpZiAobkRhdGUuaG91ciA+IDEyKSB7XG4gICAgICAgICAgICAvLyBTZWUgdGhlIGNsb2NrIHN5c3RlbTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvMTItaG91cl9jbG9ja1xuICAgICAgICAgICAgbkRhdGUuaG91ciAlPSAxMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobkRhdGUuaG91ciA9PT0gMCkge1xuICAgICAgICAgICAgbkRhdGUuaG91ciA9IDEyO1xuICAgICAgICB9XG4gICAgICAgIG5EYXRlLm1lcmlkaWVtID0gbkRhdGUuaG91ciA+IDExID8gcG0gOiBhbTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm0ucmVwbGFjZSh0b2tlbnMsIChrZXkpID0+IHtcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKCdcXFxcJykgPiAtMSkge1xuICAgICAgICAgICAgLy8gZXNjYXBlIGNoYXJhY3RlclxuICAgICAgICAgICAgcmV0dXJuIGtleS5yZXBsYWNlKC9cXFxcLywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXBsYWNlTWFwW2tleV0obkRhdGUpIHx8ICcnO1xuICAgIH0pO1xufVxuIiwiY29uc3QgUkFEID0gTWF0aC5QSSAvIDE4MDtcbmNvbnN0IEFOR0xFXzkwID0gOTA7XG5leHBvcnQgY29uc3QgQU5HTEVfQ0FORElEQVRFUyA9IFswLCAyNSwgNDUsIDY1LCA4NSwgOTBdO1xuLyoqXG4gKiBDYWxjdWxhdGUgYWRqYWNlbnQuXG4gKlxuICogICBIIDogSHlwb3RlbnVzZVxuICogICBBIDogQWRqYWNlbnRcbiAqICAgTyA6IE9wcG9zaXRlXG4gKiAgIEQgOiBEZWdyZWVcbiAqXG4gKiAgICAgICAgL3xcbiAqICAgICAgIC8gfFxuICogICAgSCAvICB8IE9cbiAqICAgICAvICAgfFxuICogICAgL1xcIEQgfFxuICogICAgLS0tLS1cbiAqICAgICAgIEFcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlQWRqYWNlbnQoZGVncmVlLCBoeXBvdGVudXNlKSB7XG4gICAgcmV0dXJuIE1hdGguY29zKGRlZ3JlZSAqIFJBRCkgKiBoeXBvdGVudXNlO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlT3Bwb3NpdGUoZGVncmVlLCBoeXBvdGVudXNlKSB7XG4gICAgcmV0dXJuIE1hdGguc2luKGRlZ3JlZSAqIFJBRCkgKiBoeXBvdGVudXNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVJvdGF0ZWRXaWR0aChkZWdyZWUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBjZW50ZXJIYWxmID0gY2FsY3VsYXRlQWRqYWNlbnQoZGVncmVlLCB3aWR0aCAvIDIpO1xuICAgIGNvbnN0IHNpZGVIYWxmID0gY2FsY3VsYXRlQWRqYWNlbnQoQU5HTEVfOTAgLSBkZWdyZWUsIGhlaWdodCAvIDIpO1xuICAgIHJldHVybiAoY2VudGVySGFsZiArIHNpZGVIYWxmKSAqIDI7XG59XG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUm90YXRlZEhlaWdodChkZWdyZWUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBjZW50ZXJIYWxmID0gY2FsY3VsYXRlT3Bwb3NpdGUoZGVncmVlLCB3aWR0aCAvIDIpO1xuICAgIGNvbnN0IHNpZGVIYWxmID0gY2FsY3VsYXRlT3Bwb3NpdGUoQU5HTEVfOTAgLSBkZWdyZWUsIGhlaWdodCAvIDIpO1xuICAgIHJldHVybiAoY2VudGVySGFsZiArIHNpZGVIYWxmKSAqIDI7XG59XG4iLCJjb25zdCBNU183X0RBWVMgPSA3ICogMjQgKiA2MCAqIDYwICogMTAwMDtcbmZ1bmN0aW9uIGlzRXhwaXJlZChkYXRlKSB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgcmV0dXJuIG5vdyAtIGRhdGUgPiBNU183X0RBWVM7XG59XG5mdW5jdGlvbiBpbWFnZVBpbmcodXJsLCB0cmFja2luZ0luZm8pIHtcbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IE9iamVjdC5rZXlzKHRyYWNraW5nSW5mbylcbiAgICAgICAgLm1hcCgoaWQsIGluZGV4KSA9PiBgJHtpbmRleCA/ICcmJyA6ICcnfSR7aWR9PSR7dHJhY2tpbmdJbmZvW2lkXX1gKVxuICAgICAgICAuam9pbignJyk7XG4gICAgY29uc3QgdHJhY2tpbmdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgdHJhY2tpbmdFbGVtZW50LnNyYyA9IGAke3VybH0/JHtxdWVyeVN0cmluZ31gO1xuICAgIHRyYWNraW5nRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodHJhY2tpbmdFbGVtZW50KTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRyYWNraW5nRWxlbWVudCk7XG4gICAgcmV0dXJuIHRyYWNraW5nRWxlbWVudDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZW5kSG9zdG5hbWUoKSB7XG4gICAgY29uc3QgaG9zdG5hbWUgPSBsb2NhdGlvbi5ob3N0bmFtZTtcbiAgICBjb25zdCBhcHBsaWNhdGlvbktleUZvclN0b3JhZ2UgPSBgVE9BU1QgVUkgY2hhcnQgZm9yICR7aG9zdG5hbWV9OiBTdGF0aXN0aWNzYDtcbiAgICBjb25zdCBkYXRlID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGFwcGxpY2F0aW9uS2V5Rm9yU3RvcmFnZSk7XG4gICAgaWYgKGRhdGUgJiYgIWlzRXhwaXJlZChOdW1iZXIoZGF0ZSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKGFwcGxpY2F0aW9uS2V5Rm9yU3RvcmFnZSwgU3RyaW5nKG5ldyBEYXRlKCkuZ2V0VGltZSgpKSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgIGltYWdlUGluZygnaHR0cHM6Ly93d3cuZ29vZ2xlLWFuYWx5dGljcy5jb20vY29sbGVjdCcsIHtcbiAgICAgICAgICAgICAgICB2OiAxLFxuICAgICAgICAgICAgICAgIHQ6ICdldmVudCcsXG4gICAgICAgICAgICAgICAgdGlkOiAnVUEtMTI5OTgzNTI4LTInLFxuICAgICAgICAgICAgICAgIGNpZDogaG9zdG5hbWUsXG4gICAgICAgICAgICAgICAgZHA6IGhvc3RuYW1lLFxuICAgICAgICAgICAgICAgIGRoOiAnY2hhcnQnLFxuICAgICAgICAgICAgICAgIGVsOiAnY2hhcnQnLFxuICAgICAgICAgICAgICAgIGVjOiAndXNlJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgMTAwMCk7XG59XG4iLCJpbXBvcnQgeyBmaW5kTm9kZXMsIHJlbW92ZU5vZGUgfSBmcm9tIFwiLi9kb21cIjtcbmltcG9ydCB7IGlzU3RyaW5nLCB0b0FycmF5IH0gZnJvbSBcIi4vdXRpbHNcIjtcbmNvbnN0IEhUTUxfQVRUUl9MSVNUX1JYID0gbmV3IFJlZ0V4cCgnXihhYmJyfGFsaWdufGFsdHxheGlzfGJnY29sb3J8Ym9yZGVyfGNlbGxwYWRkaW5nfGNlbGxzcGFjaW5nfGNsYXNzfGNsZWFyfCcgK1xuICAgICdjb2xvcnxjb2xzfGNvbXBhY3R8Y29vcmRzfGRpcnxmYWNlfGhlYWRlcnN8aGVpZ2h0fGhyZWZsYW5nfGhzcGFjZXwnICtcbiAgICAnaXNtYXB8bGFuZ3xsYW5ndWFnZXxub2hyZWZ8bm93cmFwfHJlbHxyZXZ8cm93c3xydWxlc3wnICtcbiAgICAnc2NvcGV8c2Nyb2xsaW5nfHNoYXBlfHNpemV8c3BhbnxzdGFydHxzdW1tYXJ5fHRhYmluZGV4fHRhcmdldHx0aXRsZXx0eXBlfCcgK1xuICAgICd2YWxpZ258dmFsdWV8dnNwYWNlfHdpZHRofGNoZWNrZWR8bWF0aHZhcmlhbnR8ZW5jb2Rpbmd8aWR8bmFtZXwnICtcbiAgICAnYmFja2dyb3VuZHxjaXRlfGhyZWZ8bG9uZ2Rlc2N8c3JjfHVzZW1hcHx4bGluazpocmVmfGRhdGEtK3xjaGVja2VkfHN0eWxlKScsICdnJyk7XG5jb25zdCBTVkdfQVRUUl9MSVNUX1JYID0gbmV3IFJlZ0V4cCgnXihhY2NlbnQtaGVpZ2h0fGFjY3VtdWxhdGV8YWRkaXRpdmV8YWxwaGFiZXRpY3xhcmFiaWMtZm9ybXxhc2NlbnR8JyArXG4gICAgJ2Jhc2VQcm9maWxlfGJib3h8YmVnaW58Ynl8Y2FsY01vZGV8Y2FwLWhlaWdodHxjbGFzc3xjb2xvcnxjb2xvci1yZW5kZXJpbmd8Y29udGVudHwnICtcbiAgICAnY3h8Y3l8ZHxkeHxkeXxkZXNjZW50fGRpc3BsYXl8ZHVyfGVuZHxmaWxsfGZpbGwtcnVsZXxmb250LWZhbWlseXxmb250LXNpemV8Zm9udC1zdHJldGNofCcgK1xuICAgICdmb250LXN0eWxlfGZvbnQtdmFyaWFudHxmb250LXdlaWdodHxmcm9tfGZ4fGZ5fGcxfGcyfGdseXBoLW5hbWV8Z3JhZGllbnRVbml0c3xoYW5naW5nfCcgK1xuICAgICdoZWlnaHR8aG9yaXotYWR2LXh8aG9yaXotb3JpZ2luLXh8aWRlb2dyYXBoaWN8a3xrZXlQb2ludHN8a2V5U3BsaW5lc3xrZXlUaW1lc3xsYW5nfCcgK1xuICAgICdtYXJrZXItZW5kfG1hcmtlci1taWR8bWFya2VyLXN0YXJ0fG1hcmtlckhlaWdodHxtYXJrZXJVbml0c3xtYXJrZXJXaWR0aHxtYXRoZW1hdGljYWx8JyArXG4gICAgJ21heHxtaW58b2Zmc2V0fG9wYWNpdHl8b3JpZW50fG9yaWdpbnxvdmVybGluZS1wb3NpdGlvbnxvdmVybGluZS10aGlja25lc3N8cGFub3NlLTF8JyArXG4gICAgJ3BhdGh8cGF0aExlbmd0aHxwb2ludHN8cHJlc2VydmVBc3BlY3RSYXRpb3xyfHJlZlh8cmVmWXxyZXBlYXRDb3VudHxyZXBlYXREdXJ8JyArXG4gICAgJ3JlcXVpcmVkRXh0ZW5zaW9uc3xyZXF1aXJlZEZlYXR1cmVzfHJlc3RhcnR8cm90YXRlfHJ4fHJ5fHNsb3BlfHN0ZW1ofHN0ZW12fHN0b3AtY29sb3J8JyArXG4gICAgJ3N0b3Atb3BhY2l0eXxzdHJpa2V0aHJvdWdoLXBvc2l0aW9ufHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzfHN0cm9rZXxzdHJva2UtZGFzaGFycmF5fCcgK1xuICAgICdzdHJva2UtZGFzaG9mZnNldHxzdHJva2UtbGluZWNhcHxzdHJva2UtbGluZWpvaW58c3Ryb2tlLW1pdGVybGltaXR8c3Ryb2tlLW9wYWNpdHl8JyArXG4gICAgJ3N0cm9rZS13aWR0aHxzeXN0ZW1MYW5ndWFnZXx0YXJnZXR8dGV4dC1hbmNob3J8dG98dHJhbnNmb3JtfHR5cGV8dTF8dTJ8dW5kZXJsaW5lLXBvc2l0aW9ufCcgK1xuICAgICd1bmRlcmxpbmUtdGhpY2tuZXNzfHVuaWNvZGV8dW5pY29kZS1yYW5nZXx1bml0cy1wZXItZW18dmFsdWVzfHZlcnNpb258dmlld0JveHx2aXNpYmlsaXR5fCcgK1xuICAgICd3aWR0aHx3aWR0aHN8eHx4LWhlaWdodHx4MXx4Mnx4bGluazphY3R1YXRlfHhsaW5rOmFyY3JvbGV8eGxpbms6cm9sZXx4bGluazpzaG93fHhsaW5rOnRpdGxlfCcgK1xuICAgICd4bGluazp0eXBlfHhtbDpiYXNlfHhtbDpsYW5nfHhtbDpzcGFjZXx4bWxuc3x4bWxuczp4bGlua3x5fHkxfHkyfHpvb21BbmRQYW4pJywgJ2cnKTtcbmNvbnN0IERFRkFVTFRfVEFHX0RFTllfTElTVCA9IFtcbiAgICAnc2NyaXB0JyxcbiAgICAnaWZyYW1lJyxcbiAgICAndGV4dGFyZWEnLFxuICAgICdmb3JtJyxcbiAgICAnYnV0dG9uJyxcbiAgICAnc2VsZWN0JyxcbiAgICAnaW5wdXQnLFxuICAgICdtZXRhJyxcbiAgICAnc3R5bGUnLFxuICAgICdsaW5rJyxcbiAgICAndGl0bGUnLFxuICAgICdlbWJlZCcsXG4gICAgJ29iamVjdCcsXG5dO1xuY29uc3QgWFNTX0FUVFJfUlggPSAvaHJlZnxzcmN8YmFja2dyb3VuZC9naTtcbmNvbnN0IFhTU19WQUxVRV9SWCA9IC8oKGphdmF8dmJ8bGl2ZSlzY3JpcHR8eCk6L2dpO1xuY29uc3QgT05fRVZFTlRfUlggPSAvXm9uXFxTKy87XG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVIVE1MKGh0bWwpIHtcbiAgICBjb25zdCByb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaWYgKGlzU3RyaW5nKGh0bWwpKSB7XG4gICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoLzwhLS1bXFxzXFxTXSo/LS0+L2csICcnKTtcbiAgICAgICAgcm9vdC5pbm5lckhUTUwgPSBodG1sO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChodG1sKTtcbiAgICB9XG4gICAgcmVtb3ZlVW5uZWNlc3NhcnlUYWdzKHJvb3QpO1xuICAgIGxlYXZlT25seVdoaXRlbGlzdEF0dHJpYnV0ZShyb290KTtcbiAgICByZXR1cm4gcm9vdC5pbm5lckhUTUw7XG59XG5mdW5jdGlvbiByZW1vdmVVbm5lY2Vzc2FyeVRhZ3MoaHRtbCkge1xuICAgIGNvbnN0IHJlbW92ZWRUYWdzID0gZmluZE5vZGVzKGh0bWwsIERFRkFVTFRfVEFHX0RFTllfTElTVC5qb2luKCcsJykpO1xuICAgIHJlbW92ZWRUYWdzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgcmVtb3ZlTm9kZShub2RlKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzWFNTQXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpIHtcbiAgICByZXR1cm4gYXR0ck5hbWUubWF0Y2goWFNTX0FUVFJfUlgpICYmIGF0dHJWYWx1ZS5tYXRjaChYU1NfVkFMVUVfUlgpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQmxhY2tsaXN0QXR0cmlidXRlcyhub2RlLCBibGFja2xpc3RBdHRycykge1xuICAgIGJsYWNrbGlzdEF0dHJzLmZvckVhY2goKHsgbmFtZSB9KSA9PiB7XG4gICAgICAgIGlmIChPTl9FVkVOVF9SWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBub2RlW25hbWVdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBsZWF2ZU9ubHlXaGl0ZWxpc3RBdHRyaWJ1dGUoaHRtbCkge1xuICAgIGZpbmROb2RlcyhodG1sLCAnKicpLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBhdHRyaWJ1dGVzIH0gPSBub2RlO1xuICAgICAgICBjb25zdCBibGFja2xpc3QgPSB0b0FycmF5KGF0dHJpYnV0ZXMpLmZpbHRlcigoYXR0cikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCB2YWx1ZSB9ID0gYXR0cjtcbiAgICAgICAgICAgIGNvbnN0IGh0bWxBdHRyID0gbmFtZS5tYXRjaChIVE1MX0FUVFJfTElTVF9SWCk7XG4gICAgICAgICAgICBjb25zdCBzdmdBdHRyID0gbmFtZS5tYXRjaChTVkdfQVRUUl9MSVNUX1JYKTtcbiAgICAgICAgICAgIGNvbnN0IHhzc0F0dHIgPSBodG1sQXR0ciAmJiBpc1hTU0F0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gKCFodG1sQXR0ciAmJiAhc3ZnQXR0cikgfHwgeHNzQXR0cjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW92ZUJsYWNrbGlzdEF0dHJpYnV0ZXMobm9kZSwgYmxhY2tsaXN0KTtcbiAgICB9KTtcbn1cbiIsImltcG9ydCB7IGluY2x1ZGVzLCBpc1VuZGVmaW5lZCB9IGZyb20gXCIuL3V0aWxzXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0QWN0aXZlU2VyaWVzTWFwKGxlZ2VuZCkge1xuICAgIHJldHVybiBsZWdlbmQuZGF0YS5yZWR1Y2UoKGFjYywgeyBhY3RpdmUsIGxhYmVsIH0pID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHsgW2xhYmVsXTogYWN0aXZlIH0pKSwge30pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNob3dDaXJjbGVMZWdlbmQob3B0aW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiBfYyA9IChfYiA9IChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jaXJjbGVMZWdlbmQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi52aXNpYmxlLCAoX2MgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdHJ1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2hvd0xlZ2VuZChvcHRpb25zLCBzZXJpZXMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBpZiAoc2VyaWVzLmdhdWdlIHx8XG4gICAgICAgIChzZXJpZXMudHJlZW1hcCAmJiAhKChfYSA9IG9wdGlvbnMuc2VyaWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXNlQ29sb3JWYWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKChfYiA9IG9wdGlvbnMubGVnZW5kKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudmlzaWJsZSkgPyB0cnVlIDogISEoKF9jID0gb3B0aW9ucy5sZWdlbmQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy52aXNpYmxlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaG93Q2hlY2tib3gob3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKChfYSA9IG9wdGlvbnMubGVnZW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2hvd0NoZWNrYm94KSA/IHRydWUgOiAhISgoX2IgPSBvcHRpb25zLmxlZ2VuZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNob3dDaGVja2JveCk7XG59XG4vLyBAVE9ETzogTmVlZCB0byBtYW5hZ2Ugd2l0aCBjaGFydCB0eXBlIGNvbnN0YW50L0VudW1cbmZ1bmN0aW9uIHVzZVJlY3RJY29uKHR5cGUpIHtcbiAgICByZXR1cm4gaW5jbHVkZXMoWydiYXInLCAnY29sdW1uJywgJ2FyZWEnLCAncGllJywgJ2JveFBsb3QnLCAnYnVsbGV0JywgJ3JhZGlhbEJhciddLCB0eXBlKTtcbn1cbmZ1bmN0aW9uIHVzZUNpcmNsZUljb24odHlwZSkge1xuICAgIHJldHVybiBpbmNsdWRlcyhbJ2J1YmJsZScsICdzY2F0dGVyJ10sIHR5cGUpO1xufVxuZnVuY3Rpb24gdXNlTGluZUljb24odHlwZSkge1xuICAgIHJldHVybiBpbmNsdWRlcyhbJ2xpbmUnLCAncmFkYXInXSwgdHlwZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0SWNvblR5cGUodHlwZSkge1xuICAgIGxldCBpY29uVHlwZSA9ICdzcGVjdHJ1bSc7XG4gICAgaWYgKHVzZUNpcmNsZUljb24odHlwZSkpIHtcbiAgICAgICAgaWNvblR5cGUgPSAnY2lyY2xlJztcbiAgICB9XG4gICAgZWxzZSBpZiAodXNlUmVjdEljb24odHlwZSkpIHtcbiAgICAgICAgaWNvblR5cGUgPSAncmVjdCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVzZUxpbmVJY29uKHR5cGUpKSB7XG4gICAgICAgIGljb25UeXBlID0gJ2xpbmUnO1xuICAgIH1cbiAgICByZXR1cm4gaWNvblR5cGU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVnZW5kQWxpZ24ob3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIF9iID0gKF9hID0gb3B0aW9ucy5sZWdlbmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hbGlnbiwgKF9iICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdyaWdodCcpO1xufVxuIiwiaW1wb3J0IHsgZ2V0UGVyY2VudGFnZVZhbHVlLCBpc1N0cmluZywgaXNOdWxsIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IERFR1JFRV9ORUdBVElWRV85MCwgREVHUkVFXzkwLCBERUdSRUVfMTgwLCBERUdSRUVfTkVHQVRJVkVfMTgwLCBERUdSRUVfMzYwLCBERUdSRUVfMCwgfSBmcm9tIFwiLi9zZWN0b3JcIjtcbmNvbnN0IHNlbWlDaXJjbGVDZW50ZXJZUmF0aW8gPSB7XG4gICAgQ09VTlRFUl9DTE9DS1dJU0U6IDAuMSxcbiAgICBDTE9DS1dJU0U6IDEsXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0Nsb2Nrd2lzZVNlbWlDaXJjbGUoY2xvY2t3aXNlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkge1xuICAgIHJldHVybiAoY2xvY2t3aXNlICYmXG4gICAgICAgICgoc3RhcnRBbmdsZSA+PSBERUdSRUVfTkVHQVRJVkVfOTAgJiYgZW5kQW5nbGUgPD0gREVHUkVFXzkwKSB8fFxuICAgICAgICAgICAgKHN0YXJ0QW5nbGUgPj0gREVHUkVFXzkwICYmIGVuZEFuZ2xlIDw9IERFR1JFRV8xODApKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzQ291bnRlckNsb2Nrd2lzZVNlbWlDaXJjbGUoY2xvY2t3aXNlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkge1xuICAgIHJldHVybiAoIWNsb2Nrd2lzZSAmJlxuICAgICAgICAoKHN0YXJ0QW5nbGUgPj0gREVHUkVFX05FR0FUSVZFXzE4MCAmJiBlbmRBbmdsZSA8PSBERUdSRUVfOTApIHx8XG4gICAgICAgICAgICAoc3RhcnRBbmdsZSA8PSBERUdSRUVfOTAgJiYgZW5kQW5nbGUgPj0gREVHUkVFX05FR0FUSVZFXzkwKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhZGl1cyhkZWZhdWx0UmFkaXVzLCByYWRpdXMpIHtcbiAgICByZXR1cm4gaXNTdHJpbmcocmFkaXVzKVxuICAgICAgICA/IE51bWJlcigoKGRlZmF1bHRSYWRpdXMgKiBnZXRQZXJjZW50YWdlVmFsdWUocmFkaXVzKSkgLyAxMDApLnRvRml4ZWQoMikpXG4gICAgICAgIDogcmFkaXVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFRvdGFsQW5nbGUoY2xvY2t3aXNlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkge1xuICAgIGNvbnN0IGRpZmZBbmdsZSA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcbiAgICBjb25zdCBhYnNEaWZmID0gTWF0aC5hYnMoZGlmZkFuZ2xlKTtcbiAgICBjb25zdCBuZWVkU3Vic3RyYWN0QW5nbGUgPSAoZGlmZkFuZ2xlID4gREVHUkVFXzAgJiYgYWJzRGlmZiAhPT0gREVHUkVFXzM2MCAmJiAhY2xvY2t3aXNlKSB8fFxuICAgICAgICAoZGlmZkFuZ2xlIDwgREVHUkVFXzAgJiYgYWJzRGlmZiAhPT0gREVHUkVFXzM2MCAmJiBjbG9ja3dpc2UpO1xuICAgIHJldHVybiBuZWVkU3Vic3RyYWN0QW5nbGUgPyBERUdSRUVfMzYwIC0gYWJzRGlmZiA6IGFic0RpZmY7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTZW1pQ2lyY2xlKGNsb2Nrd2lzZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpIHtcbiAgICByZXR1cm4gKGdldFRvdGFsQW5nbGUoY2xvY2t3aXNlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkgPD0gREVHUkVFXzE4MCAmJlxuICAgICAgICAoaGFzQ2xvY2t3aXNlU2VtaUNpcmNsZShjbG9ja3dpc2UsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSB8fFxuICAgICAgICAgICAgaGFzQ291bnRlckNsb2Nrd2lzZVNlbWlDaXJjbGUoY2xvY2t3aXNlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZW1pQ2lyY2xlQ2VudGVyWShyZWN0SGVpZ2h0LCBjbG9ja3dpc2UpIHtcbiAgICByZXR1cm4gY2xvY2t3aXNlXG4gICAgICAgID8gcmVjdEhlaWdodCAqIHNlbWlDaXJjbGVDZW50ZXJZUmF0aW8uQ0xPQ0tXSVNFXG4gICAgICAgIDogcmVjdEhlaWdodCAqIHNlbWlDaXJjbGVDZW50ZXJZUmF0aW8uQ09VTlRFUl9DTE9DS1dJU0U7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZVBpZVRvb2x0aXBEYXRhKHNlcmllc1Jhd0RhdGEsIGNhdGVnb3J5ID0gJycpIHtcbiAgICByZXR1cm4gc2VyaWVzUmF3RGF0YVxuICAgICAgICAuZmlsdGVyKCh7IGRhdGEgfSkgPT4gIWlzTnVsbChkYXRhKSlcbiAgICAgICAgLm1hcCgoeyBkYXRhLCBuYW1lLCBjb2xvciwgcm9vdFBhcmVudE5hbWUgfSkgPT4gKHtcbiAgICAgICAgbGFiZWw6IG5hbWUsXG4gICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICByb290UGFyZW50TmFtZSxcbiAgICAgICAgdGVtcGxhdGVUeXBlOiAncGllJyxcbiAgICB9KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzTmVzdGVkUGllU2VyaWVzKHNlcmllcykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gISEoc2VyaWVzLnBpZSAmJiBBcnJheS5pc0FycmF5KChfYSA9IHNlcmllcy5waWVbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TmVzdGVkUGllQ2hhcnRBbGlhc05hbWVzKHNlcmllcykge1xuICAgIHJldHVybiBzZXJpZXMucGllLm1hcCgoeyBuYW1lIH0pID0+IG5hbWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBpZVRvb2x0aXBMYWJlbEZvcm1hdHRlcihwZXJjZW50VmFsdWUpIHtcbiAgICBjb25zdCBwZXJjZW50YWdlU3RyaW5nID0gcGVyY2VudFZhbHVlLnRvRml4ZWQoMik7XG4gICAgY29uc3QgcGVyY2VudCA9IHBhcnNlRmxvYXQocGVyY2VudGFnZVN0cmluZyk7XG4gICAgY29uc3QgbmVlZFNsaWNlID0gcGVyY2VudGFnZVN0cmluZy5sZW5ndGggPiA1O1xuICAgIHJldHVybiBgJHtuZWVkU2xpY2UgPyBwYXJzZUZsb2F0KHBlcmNlbnRhZ2VTdHJpbmcuc3Vic3RyKDAsIDQpKSA6IFN0cmluZyhwZXJjZW50KX0lYDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNPdXRlckRhdGFMYWJlbChvcHRpb25zLCBzZXJpZXMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gISFzZXJpZXMucGllICYmICgoX2MgPSAoX2IgPSAoX2EgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VyaWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGF0YUxhYmVscykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFuY2hvcikgPT09ICdvdXRlcic7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzT3V0ZXJQaWVTZXJpZXNOYW1lKG9wdGlvbnMsIHNlcmllcykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICByZXR1cm4gKCEhc2VyaWVzLnBpZSAmJlxuICAgICAgICAoKF9kID0gKF9jID0gKF9iID0gKF9hID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlcmllcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRhdGFMYWJlbHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5waWVTZXJpZXNOYW1lKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYW5jaG9yKSA9PT0gJ291dGVyJyk7XG59XG4iLCJpbXBvcnQgeyBpc1VuZGVmaW5lZCB9IGZyb20gXCIuL3V0aWxzXCI7XG5leHBvcnQgZnVuY3Rpb24gaXNFeGlzdFBsb3RJZChwbG90cywgZGF0YSkge1xuICAgIHJldHVybiBwbG90cy5zb21lKCh7IGlkOiBiYW5kSWQgfSkgPT4gIWlzVW5kZWZpbmVkKGJhbmRJZCkgJiYgIWlzVW5kZWZpbmVkKGRhdGEuaWQpICYmIGJhbmRJZCA9PT0gZGF0YS5pZCk7XG59XG4iLCJpbXBvcnQgeyBnZXRGaXJzdFZhbGlkVmFsdWUgfSBmcm9tIFwiLi91dGlsc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmFuZ2VWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDI7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNSYW5nZURhdGEoZGF0YSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGRhdGEpICYmIGlzUmFuZ2VWYWx1ZShnZXRGaXJzdFZhbGlkVmFsdWUoZGF0YSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzWm9vbWluZyhjYXRlZ29yaWVzLCB6b29tUmFuZ2UpIHtcbiAgICByZXR1cm4gISEoem9vbVJhbmdlICYmICh6b29tUmFuZ2VbMF0gIT09IDAgfHwgem9vbVJhbmdlWzFdICE9PSBjYXRlZ29yaWVzLmxlbmd0aCAtIDEpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhSW5SYW5nZShkYXRhLCByYW5nZSkge1xuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhLnNsaWNlKHJhbmdlWzBdLCByYW5nZVsxXSArIDEpO1xufVxuIiwiaW1wb3J0IHsgZ2V0RGlzdGFuY2UgfSBmcm9tIFwiLi9jYWxjdWxhdG9yXCI7XG5pbXBvcnQgeyByYW5nZSB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXRSYWRpdXNSYW5nZXMgfSBmcm9tIFwiLi9zZWN0b3JcIjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gaXNTYW1lU2VyaWVzUmVzcG9uZGVyKHsgbW9kZWxzLCBjb21wYXJpc29uTW9kZWwsIG5hbWUsIGV2ZW50RGV0ZWN0VHlwZSwgfSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlICdoZWF0bWFwJzpcbiAgICAgICAgICAgIHJldHVybiBpc0NsaWNrU2FtZU5hbWVSZXNwb25kZXIobW9kZWxzLCBjb21wYXJpc29uTW9kZWwpO1xuICAgICAgICBjYXNlICdidWxsZXQnOlxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50RGV0ZWN0VHlwZSA9PT0gJ2dyb3VwZWQnXG4gICAgICAgICAgICAgICAgPyBpc0NsaWNrU2FtZUdyb3VwZWRSZWN0UmVzcG9uZGVyKG1vZGVscywgY29tcGFyaXNvbk1vZGVsKVxuICAgICAgICAgICAgICAgIDogaXNDbGlja1NhbWVOYW1lUmVzcG9uZGVyKG1vZGVscywgY29tcGFyaXNvbk1vZGVsKTtcbiAgICAgICAgY2FzZSAncmFkYXInOlxuICAgICAgICBjYXNlICdidWJibGUnOlxuICAgICAgICBjYXNlICdzY2F0dGVyJzpcbiAgICAgICAgY2FzZSAnYXJlYSc6XG4gICAgICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgICAgICAgcmV0dXJuIGlzQ2xpY2tTYW1lQ2lyY2xlUmVzcG9uZGVyKG1vZGVscywgY29tcGFyaXNvbk1vZGVsKTtcbiAgICAgICAgY2FzZSAncGllJzpcbiAgICAgICAgICAgIHJldHVybiBpc0NsaWNrU2FtZURhdGFSZXNwb25kZXIobW9kZWxzLCBjb21wYXJpc29uTW9kZWwpO1xuICAgICAgICBjYXNlICdjb2x1bW4nOlxuICAgICAgICBjYXNlICdiYXInOlxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50RGV0ZWN0VHlwZSA9PT0gJ2dyb3VwZWQnXG4gICAgICAgICAgICAgICAgPyBpc0NsaWNrU2FtZUdyb3VwZWRSZWN0UmVzcG9uZGVyKG1vZGVscywgY29tcGFyaXNvbk1vZGVsKVxuICAgICAgICAgICAgICAgIDogaXNDbGlja1NhbWVEYXRhUmVzcG9uZGVyKG1vZGVscywgY29tcGFyaXNvbk1vZGVsKTtcbiAgICAgICAgY2FzZSAnYm94UGxvdCc6XG4gICAgICAgICAgICByZXR1cm4gZXZlbnREZXRlY3RUeXBlID09PSAnZ3JvdXBlZCdcbiAgICAgICAgICAgICAgICA/IGlzQ2xpY2tTYW1lRGF0YVJlc3BvbmRlcihtb2RlbHMsIGNvbXBhcmlzb25Nb2RlbClcbiAgICAgICAgICAgICAgICA6IGlzQ2xpY2tTYW1lQm94UGxvdERhdGFSZXNwb25kZXIobW9kZWxzLCBjb21wYXJpc29uTW9kZWwpO1xuICAgICAgICBjYXNlICd0cmVlbWFwJzpcbiAgICAgICAgICAgIHJldHVybiBpc0NsaWNrU2FtZUxhYmVsUmVzcG9uZGVyKG1vZGVscywgY29tcGFyaXNvbk1vZGVsKTtcbiAgICAgICAgY2FzZSAnZ2F1Z2UnOlxuICAgICAgICAgICAgcmV0dXJuIGlzQ2xpY2tTYW1lTmFtZVJlc3BvbmRlcihtb2RlbHMsIGNvbXBhcmlzb25Nb2RlbCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE5lYXJlc3RSZXNwb25kZXIocmVzcG9uZGVycywgbW91c2VQb3NpdGlvbiwgcmVjdCkge1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICByZXNwb25kZXJzLmZvckVhY2goKHJlc3BvbmRlcikgPT4ge1xuICAgICAgICBjb25zdCB7IHgsIHksIHJhZGl1cyB9ID0gcmVzcG9uZGVyO1xuICAgICAgICBjb25zdCByZXNwb25kZXJQb2ludCA9IHsgeDogeCArIHJlY3QueCwgeTogeSArIHJlY3QueSB9O1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGdldERpc3RhbmNlKHJlc3BvbmRlclBvaW50LCBtb3VzZVBvc2l0aW9uKTtcbiAgICAgICAgaWYgKG1pbkRpc3RhbmNlID4gZGlzdGFuY2UpIHtcbiAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgICByZXN1bHQgPSBbcmVzcG9uZGVyXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtaW5EaXN0YW5jZSA9PT0gZGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICYmIHJlc3VsdFswXS5yYWRpdXMgPiByYWRpdXMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbcmVzcG9uZGVyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlc3BvbmRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VSZWN0UmVzcG9uZGVyTW9kZWwocmVjdCwgYXhpcywgY2F0ZWdvcmllcywgdmVydGljYWwgPSB0cnVlKSB7XG4gICAgY29uc3QgeyBwb2ludE9uQ29sdW1uLCB0aWNrRGlzdGFuY2UsIHJlY3RSZXNwb25kZXJDb3VudCB9ID0gYXhpcztcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHJlY3Q7XG4gICAgY29uc3QgaGFsZkRldGVjdEFyZWFJbmRleCA9IHBvaW50T25Db2x1bW4gPyBbXSA6IFswLCByZWN0UmVzcG9uZGVyQ291bnQgLSAxXTtcbiAgICBjb25zdCBoYWxmU2l6ZSA9IHRpY2tEaXN0YW5jZSAvIDI7XG4gICAgcmV0dXJuIHJhbmdlKDAsIHJlY3RSZXNwb25kZXJDb3VudCkubWFwKChpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBoYWxmID0gaGFsZkRldGVjdEFyZWFJbmRleC5pbmNsdWRlcyhpbmRleCk7XG4gICAgICAgIGNvbnN0IHNpemUgPSBoYWxmID8gaGFsZlNpemUgOiB0aWNrRGlzdGFuY2U7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IDA7XG4gICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgc3RhcnRQb3MgKz0gcG9pbnRPbkNvbHVtbiA/IHRpY2tEaXN0YW5jZSAqIGluZGV4IDogaGFsZlNpemUgKyB0aWNrRGlzdGFuY2UgKiAoaW5kZXggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3JlY3QnLFxuICAgICAgICAgICAgeTogdmVydGljYWwgPyAwIDogc3RhcnRQb3MsXG4gICAgICAgICAgICBoZWlnaHQ6IHZlcnRpY2FsID8gaGVpZ2h0IDogc2l6ZSxcbiAgICAgICAgICAgIHg6IHZlcnRpY2FsID8gc3RhcnRQb3MgOiAwLFxuICAgICAgICAgICAgd2lkdGg6IHZlcnRpY2FsID8gc2l6ZSA6IHdpZHRoLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBsYWJlbDogY2F0ZWdvcmllc1tpbmRleF0sXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZVJlY3RSZXNwb25kZXJNb2RlbEZvckNvb3JkaW5hdGVUeXBlKHJlc3BvbmRlckluZm8sIHJlY3QpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHJlY3Q7XG4gICAgbGV0IHN0YXJ0UG9zID0gMDtcbiAgICByZXR1cm4gcmVzcG9uZGVySW5mb1xuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS54IC0gYi54KVxuICAgICAgICAucmVkdWNlKChhY2MsIG1vZGVsLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB7IHgsIGxhYmVsIH0gPSBtb2RlbDtcbiAgICAgICAgY29uc3QgbmV4dCA9IHJlc3BvbmRlckluZm9baW5kZXggKyAxXTtcbiAgICAgICAgY29uc3QgZW5kUG9zID0gbmV4dCA/IChuZXh0LnggKyB4KSAvIDIgOiB3aWR0aDtcbiAgICAgICAgY29uc3QgcmVjdFJlc3BvbmRlck1vZGVsID0ge1xuICAgICAgICAgICAgdHlwZTogJ3JlY3QnLFxuICAgICAgICAgICAgeDogc3RhcnRQb3MsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IGVuZFBvcyAtIHN0YXJ0UG9zLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgfTtcbiAgICAgICAgc3RhcnRQb3MgPSBlbmRQb3M7XG4gICAgICAgIHJldHVybiBbLi4uYWNjLCByZWN0UmVzcG9uZGVyTW9kZWxdO1xuICAgIH0sIFtdKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYWtlVG9vbHRpcENpcmNsZU1hcChzZXJpZXNDaXJjbGVNb2RlbCwgdG9vbHRpcERhdGFBcnIpIHtcbiAgICBjb25zdCBkYXRhTWFwID0gdG9vbHRpcERhdGFBcnIucmVkdWNlKChhY2MsIGN1cikgPT4ge1xuICAgICAgICBjb25zdCB7IGluZGV4LCBzZXJpZXNJbmRleCB9ID0gY3VyO1xuICAgICAgICBpZiAoIWFjY1tzZXJpZXNJbmRleF0pIHtcbiAgICAgICAgICAgIGFjY1tzZXJpZXNJbmRleF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBhY2Nbc2VyaWVzSW5kZXhdW2luZGV4XSA9IGN1cjtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHNlcmllc0NpcmNsZU1vZGVsLnJlZHVjZSgoYWNjLCBtb2RlbCkgPT4ge1xuICAgICAgICBjb25zdCB7IHNlcmllc0luZGV4LCBpbmRleCB9ID0gbW9kZWw7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBkYXRhTWFwW3Nlcmllc0luZGV4XVtpbmRleF07XG4gICAgICAgIGNvbnN0IHsgY2F0ZWdvcnkgfSA9IGRhdGE7XG4gICAgICAgIGlmICghY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhY2NbY2F0ZWdvcnldKSB7XG4gICAgICAgICAgICBhY2NbY2F0ZWdvcnldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgYWNjW2NhdGVnb3J5XS5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbW9kZWwpLCB7IGRhdGEgfSkpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWVwZXN0Tm9kZShyZXNwb25kZXJzKSB7XG4gICAgcmV0dXJuIHJlc3BvbmRlcnMucmVkdWNlKChhY2MsIHJlc3BvbmRlcikgPT4ge1xuICAgICAgICBpZiAoIWFjYy5sZW5ndGggfHwgcmVzcG9uZGVyLmRlcHRoID4gYWNjWzBdLmRlcHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3Jlc3BvbmRlcl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDbGlja1NhbWVOYW1lUmVzcG9uZGVyKHJlc3BvbmRlcnMsIHNlbGVjdGVkU2VyaWVzKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAocmVzcG9uZGVycy5sZW5ndGggJiYgKChfYSA9IHNlbGVjdGVkU2VyaWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAmJiByZXNwb25kZXJzWzBdLm5hbWUgPT09IHNlbGVjdGVkU2VyaWVzWzBdLm5hbWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2xpY2tTYW1lQ2lyY2xlUmVzcG9uZGVyKHJlc3BvbmRlcnMsIHNlbGVjdGVkU2VyaWVzKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBzYW1lID0gZmFsc2U7XG4gICAgaWYgKHJlc3BvbmRlcnMubGVuZ3RoICYmICgoX2EgPSBzZWxlY3RlZFNlcmllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgJiYgcmVzcG9uZGVycy5sZW5ndGggPT09IHNlbGVjdGVkU2VyaWVzLmxlbmd0aCkge1xuICAgICAgICBzYW1lID0gcmVzcG9uZGVycy5yZWR1Y2UoKGFjYywgY3VyLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoYWNjICYmXG4gICAgICAgICAgICAgICAgY3VyLnNlcmllc0luZGV4ID09PSBzZWxlY3RlZFNlcmllc1tpZHhdLnNlcmllc0luZGV4ICYmXG4gICAgICAgICAgICAgICAgY3VyLmluZGV4ID09PSBzZWxlY3RlZFNlcmllc1tpZHhdLmluZGV4KTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBzYW1lO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2xpY2tTYW1lRGF0YVJlc3BvbmRlcihyZXNwb25kZXJzLCBzZWxlY3RlZFNlcmllcykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgc2FtZSA9IGZhbHNlO1xuICAgIGlmIChyZXNwb25kZXJzLmxlbmd0aCAmJiAoKF9hID0gc2VsZWN0ZWRTZXJpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICYmIHJlc3BvbmRlcnMubGVuZ3RoID09PSBzZWxlY3RlZFNlcmllcy5sZW5ndGgpIHtcbiAgICAgICAgc2FtZSA9IHJlc3BvbmRlcnMucmVkdWNlKChhY2MsIGN1ciwgaWR4KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICByZXR1cm4gKGFjYyAmJlxuICAgICAgICAgICAgICAgICgoX2EgPSBjdXIuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhYmVsKSA9PT0gKChfYiA9IHNlbGVjdGVkU2VyaWVzW2lkeF0uZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxhYmVsKSAmJlxuICAgICAgICAgICAgICAgICgoX2MgPSBjdXIuZGF0YSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhdGVnb3J5KSA9PT0gKChfZCA9IHNlbGVjdGVkU2VyaWVzW2lkeF0uZGF0YSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhdGVnb3J5KSk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gc2FtZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0NsaWNrU2FtZUxhYmVsUmVzcG9uZGVyKHJlc3BvbmRlcnMsIHNlbGVjdGVkU2VyaWVzKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAocmVzcG9uZGVycy5sZW5ndGggJiYgKChfYSA9IHNlbGVjdGVkU2VyaWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAmJiByZXNwb25kZXJzWzBdLmxhYmVsID09PSBzZWxlY3RlZFNlcmllc1swXS5sYWJlbCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDbGlja1NhbWVHcm91cGVkUmVjdFJlc3BvbmRlcihyZXNwb25kZXJzLCBzZWxlY3RlZFNlcmllcykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKHJlc3BvbmRlcnMubGVuZ3RoICYmICgoX2EgPSBzZWxlY3RlZFNlcmllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgJiYgcmVzcG9uZGVyc1swXS5pbmRleCA9PT0gc2VsZWN0ZWRTZXJpZXNbMF0uaW5kZXgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2xpY2tTYW1lQm94UGxvdERhdGFSZXNwb25kZXIocmVzcG9uZGVycywgc2VsZWN0ZWRTZXJpZXMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGxldCBzYW1lID0gZmFsc2U7XG4gICAgaWYgKHJlc3BvbmRlcnMubGVuZ3RoICYmICgoX2EgPSBzZWxlY3RlZFNlcmllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpIHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBkYXRhIH0gPSByZXNwb25kZXJzWzBdO1xuICAgICAgICBzYW1lID1cbiAgICAgICAgICAgIHR5cGUgPT09IHNlbGVjdGVkU2VyaWVzWzBdLnR5cGUgJiZcbiAgICAgICAgICAgICAgICAoKF9iID0gZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxhYmVsKSA9PT0gKChfYyA9IHNlbGVjdGVkU2VyaWVzWzBdLmRhdGEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sYWJlbCkgJiZcbiAgICAgICAgICAgICAgICAoKF9kID0gZGF0YSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhdGVnb3J5KSA9PT0gKChfZSA9IHNlbGVjdGVkU2VyaWVzWzBdLmRhdGEpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYXRlZ29yeSk7XG4gICAgfVxuICAgIHJldHVybiBzYW1lO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VHcm91cGVkU2VjdG9yUmVzcG9uZGVyTW9kZWwocmFkaXVzUmFuZ2VzLCByZW5kZXJPcHRpb25zLCBjYXRlZ29yaWVzKSB7XG4gICAgY29uc3QgeyBjZW50ZXJYLCBjZW50ZXJZLCBhbmdsZVJhbmdlOiB7IHN0YXJ0LCBlbmQgfSwgY2xvY2t3aXNlLCB9ID0gcmVuZGVyT3B0aW9ucztcbiAgICByZXR1cm4gZ2V0UmFkaXVzUmFuZ2VzKHJhZGl1c1JhbmdlcywgMCkubWFwKChyYWRpdXMsIGluZGV4KSA9PiAoe1xuICAgICAgICB0eXBlOiAnc2VjdG9yJyxcbiAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgeTogY2VudGVyWSxcbiAgICAgICAgZGVncmVlOiB7IHN0YXJ0LCBlbmQgfSxcbiAgICAgICAgcmFkaXVzLFxuICAgICAgICBuYW1lOiBjYXRlZ29yaWVzW2luZGV4XSxcbiAgICAgICAgY2xvY2t3aXNlLFxuICAgICAgICBpbmRleCxcbiAgICB9KSk7XG59XG4iLCJpbXBvcnQgeyBwaWNrIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmV4cG9ydCBjb25zdCBERUdSRUVfMTgwID0gMTgwO1xuZXhwb3J0IGNvbnN0IERFR1JFRV9ORUdBVElWRV8xODAgPSAtMTgwO1xuZXhwb3J0IGNvbnN0IERFR1JFRV8zNjAgPSAzNjA7XG5leHBvcnQgY29uc3QgREVHUkVFXzAgPSAwO1xuZXhwb3J0IGNvbnN0IERFR1JFRV9ORUdBVElWRV85MCA9IC05MDtcbmV4cG9ydCBjb25zdCBERUdSRUVfOTAgPSA5MDtcbmNvbnN0IE1JTklNVU1fUkFESVVTID0gMTA7XG5leHBvcnQgZnVuY3Rpb24gbWFrZUFuY2hvclBvc2l0aW9uUGFyYW0oYW5jaG9yLCBtb2RlbCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgYW5jaG9yIH0sIHBpY2sobW9kZWwsICd4JywgJ3knLCAncmFkaXVzJywgJ2RlZ3JlZScsICdkcmF3aW5nU3RhcnRBbmdsZScpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVEZWdyZWVUb1JhZGlhbihkZWdyZWUsIGRyYXdpbmdTdGFydEFuZ2xlID0gREVHUkVFX05FR0FUSVZFXzkwKSB7XG4gICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgaWYgKGRlZ3JlZSAlIERFR1JFRV8zNjAgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gKE1hdGguUEkgLyBERUdSRUVfMTgwKSAqIGRyYXdpbmdTdGFydEFuZ2xlO1xuICAgIH1cbiAgICBlbHNlIGlmIChkZWdyZWUgPj0gMCkge1xuICAgICAgICByZXN1bHQgPSAoTWF0aC5QSSAvIERFR1JFRV8xODApICogKGRlZ3JlZSArIGRyYXdpbmdTdGFydEFuZ2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVSYWRpYW5Ub0RlZ3JlZShyYWRpYW4sIGRyYXdpbmdTdGFydEFuZ2xlID0gREVHUkVFX05FR0FUSVZFXzkwKSB7XG4gICAgcmV0dXJuICgocmFkaWFuICogREVHUkVFXzE4MCkgLyBNYXRoLlBJIC0gZHJhd2luZ1N0YXJ0QW5nbGUgKyBERUdSRUVfMzYwKSAlIERFR1JFRV8zNjA7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFkaWFsQW5jaG9yUG9zaXRpb24ocGFyYW0pIHtcbiAgICBjb25zdCB7IGFuY2hvciwgeCwgeSwgcmFkaXVzOiB7IGlubmVyLCBvdXRlciB9LCBkZWdyZWU6IHsgc3RhcnQsIGVuZCB9LCBkcmF3aW5nU3RhcnRBbmdsZSA9IERFR1JFRV9ORUdBVElWRV85MCwgfSA9IHBhcmFtO1xuICAgIGNvbnN0IGhhbGZEZWdyZWUgPSBzdGFydCArIChlbmQgLSBzdGFydCkgLyAyO1xuICAgIGNvbnN0IHJhZGlhbiA9IGNhbGN1bGF0ZURlZ3JlZVRvUmFkaWFuKGhhbGZEZWdyZWUsIGRyYXdpbmdTdGFydEFuZ2xlKTtcbiAgICBjb25zdCByID0gYW5jaG9yID09PSAnb3V0ZXInID8gb3V0ZXIgOiAob3V0ZXIgKyBpbm5lcikgLyAyO1xuICAgIHJldHVybiBnZXRSYWRpYWxQb3NpdGlvbih4LCB5LCByLCByYWRpYW4pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhZGlhbFBvc2l0aW9uKHgsIHksIHIsIHJhZGlhbikge1xuICAgIHJldHVybiB7IHg6IE1hdGgucm91bmQoeCArIHIgKiBNYXRoLmNvcyhyYWRpYW4pKSwgeTogTWF0aC5yb3VuZCh5ICsgciAqIE1hdGguc2luKHJhZGlhbikpIH07XG59XG5leHBvcnQgZnVuY3Rpb24gd2l0aGluUmFkaWFuKGNsb2Nrd2lzZSwgc3RhcnREZWdyZWUsIGVuZERlZ3JlZSwgY3VycmVudERlZ3JlZSkge1xuICAgIHJldHVybiBjbG9ja3dpc2VcbiAgICAgICAgPyBzdGFydERlZ3JlZSA8PSBjdXJyZW50RGVncmVlICYmIGVuZERlZ3JlZSA+PSBjdXJyZW50RGVncmVlXG4gICAgICAgIDogc3RhcnREZWdyZWUgPj0gY3VycmVudERlZ3JlZSAmJiBlbmREZWdyZWUgPD0gY3VycmVudERlZ3JlZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbml0U2VjdG9yT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICBjb25zdCBjbG9ja3dpc2UgPSAoX2IgPSAoX2EgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvY2t3aXNlLCAoX2IgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNsb2Nrd2lzZSxcbiAgICAgICAgc3RhcnRBbmdsZTogKF9lID0gKF9kID0gKF9jID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFuZ2xlUmFuZ2UpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zdGFydCwgKF9lICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IChjbG9ja3dpc2UgPyBERUdSRUVfMCA6IERFR1JFRV8zNjApKSksXG4gICAgICAgIGVuZEFuZ2xlOiAoX2ggPSAoX2cgPSAoX2YgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuYW5nbGVSYW5nZSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmVuZCwgKF9oICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IChjbG9ja3dpc2UgPyBERUdSRUVfMzYwIDogREVHUkVFXzApKSksXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0UmFkaXVzKHsgd2lkdGgsIGhlaWdodCB9LCBpc1NlbWlDaXJjdWxhciA9IGZhbHNlLCBtYXhMYWJlbFdpZHRoID0gMCwgbWF4TGFiZWxIZWlnaHQgPSAwKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoaXNTZW1pQ2lyY3VsYXIpIHtcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5taW4od2lkdGggLyAyLCBoZWlnaHQpIC0gbWF4TGFiZWxIZWlnaHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHdpZHRoID4gaGVpZ2h0KSB7XG4gICAgICAgIHJlc3VsdCA9IGhlaWdodCAvIDIgLSBtYXhMYWJlbEhlaWdodDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHdpZHRoIC8gMiAtIG1heExhYmVsV2lkdGg7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heChyZXN1bHQsIE1JTklNVU1fUkFESVVTKTtcbn1cbmZ1bmN0aW9uIGdldFJhZGlhbihzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZHJhd2luZ1N0YXJ0QW5nbGUsIG5lZWRDYWxjdWxhdGVCeUhhbGYpIHtcbiAgICBjb25zdCBkZWdyZWUgPSBuZWVkQ2FsY3VsYXRlQnlIYWxmID8gKGVuZEFuZ2xlICsgc3RhcnRBbmdsZSkgLyAyIDogc3RhcnRBbmdsZTtcbiAgICByZXR1cm4gY2FsY3VsYXRlRGVncmVlVG9SYWRpYW4oZGVncmVlLCBkcmF3aW5nU3RhcnRBbmdsZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFkaWFsTGFiZWxBbGlnbihtb2RlbCwgYW5jaG9yLCBuZWVkQ2FsY3VsYXRlQnlIYWxmID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgdG90YWxBbmdsZSA9IERFR1JFRV8zNjAsIGRlZ3JlZTogeyBzdGFydCwgZW5kIH0sIGRyYXdpbmdTdGFydEFuZ2xlID0gREVHUkVFX05FR0FUSVZFXzkwLCB9ID0gbW9kZWw7XG4gICAgbGV0IHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGlmIChhbmNob3IgIT09ICdvdXRlcicpIHtcbiAgICAgICAgcmV0dXJuIHRleHRBbGlnbjtcbiAgICB9XG4gICAgY29uc3QgcmFkaWFuMCA9IGNhbGN1bGF0ZURlZ3JlZVRvUmFkaWFuKDAsIGRyYXdpbmdTdGFydEFuZ2xlKTtcbiAgICBjb25zdCBoYWxmUmFkaWFuID0gY2FsY3VsYXRlRGVncmVlVG9SYWRpYW4odG90YWxBbmdsZSAvIDIsIGRyYXdpbmdTdGFydEFuZ2xlKTtcbiAgICBjb25zdCByYWRpYW4gPSBnZXRSYWRpYW4oc3RhcnQsIGVuZCwgZHJhd2luZ1N0YXJ0QW5nbGUsIG5lZWRDYWxjdWxhdGVCeUhhbGYpO1xuICAgIGlmIChkcmF3aW5nU3RhcnRBbmdsZSA+PSBERUdSRUVfTkVHQVRJVkVfOTAgJiYgZHJhd2luZ1N0YXJ0QW5nbGUgPCBERUdSRUVfOTApIHtcbiAgICAgICAgaWYgKHJhZGlhbjAgPCByYWRpYW4gJiYgaGFsZlJhZGlhbiA+IHJhZGlhbikge1xuICAgICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhbGZSYWRpYW4gPCByYWRpYW4pIHtcbiAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmFkaWFuMCA8IHJhZGlhbiAmJiBoYWxmUmFkaWFuID4gcmFkaWFuKSB7XG4gICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhbGZSYWRpYW4gPCByYWRpYW4pIHtcbiAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dEFsaWduO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhZGl1c1JhbmdlcyhyYWRpdXNSYW5nZXMsIHBhZGRpbmcpIHtcbiAgICByZXR1cm4gcmFkaXVzUmFuZ2VzLnJlZHVjZSgoYWNjLCBjdXIsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpbmRleCkge1xuICAgICAgICAgICAgYWNjLnB1c2goe1xuICAgICAgICAgICAgICAgIGlubmVyOiBjdXIgKyBwYWRkaW5nLFxuICAgICAgICAgICAgICAgIG91dGVyOiByYWRpdXNSYW5nZXNbaW5kZXggLSAxXSAtIHBhZGRpbmcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPT09IHJhZGl1c1Jhbmdlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBhY2MucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5uZXI6IHBhZGRpbmcsXG4gICAgICAgICAgICAgICAgb3V0ZXI6IGN1ciAtIHBhZGRpbmcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbn1cbi8vIFJlY2FsY3VsYXRlIHRvIGFuIGFuZ2xlIGJldHdlZW4gMCBhbmQgMzYwIGRlZ3JlZXMuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlVmFsaWRBbmdsZShhbmdsZSkge1xuICAgIGlmIChhbmdsZSA8IERFR1JFRV8wKSB7XG4gICAgICAgIHJldHVybiBERUdSRUVfMzYwICsgKGFuZ2xlICUgREVHUkVFXzM2MCk7XG4gICAgfVxuICAgIGlmIChhbmdsZSA+IERFR1JFRV8zNjApIHtcbiAgICAgICAgcmV0dXJuIGFuZ2xlICUgREVHUkVFXzM2MDtcbiAgICB9XG4gICAgcmV0dXJuIGFuZ2xlO1xufVxuIiwiaW1wb3J0IHsgc3VtIH0gZnJvbSBcIi4vY2FsY3VsYXRvclwiO1xuaW1wb3J0IHsgcGx1Y2sgfSBmcm9tIFwiLi9hcnJheVV0aWxcIjtcbmZ1bmN0aW9uIGNhbGN1bGF0ZVNjYWxlKHZhbHVlcywgd2lkdGgsIGhlaWdodCkge1xuICAgIHJldHVybiAod2lkdGggKiBoZWlnaHQpIC8gc3VtKHZhbHVlcyk7XG59XG5mdW5jdGlvbiBpc1ZlcnRpY2FsU3RhY2soeyBoZWlnaHQsIHdpZHRoIH0pIHtcbiAgICByZXR1cm4gaGVpZ2h0IDwgd2lkdGg7XG59XG5mdW5jdGlvbiBzZWxlY3RCYXNlU2l6ZShiYXNlQm91bmQpIHtcbiAgICByZXR1cm4gaXNWZXJ0aWNhbFN0YWNrKGJhc2VCb3VuZCkgPyBiYXNlQm91bmQuaGVpZ2h0IDogYmFzZUJvdW5kLndpZHRoO1xufVxuZnVuY3Rpb24gbWFrZUJhc2VEYXRhKHNlcmllc0l0ZW1zLCBiYXNlQm91bmQpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGJhc2VCb3VuZDtcbiAgICBjb25zdCBzY2FsZSA9IGNhbGN1bGF0ZVNjYWxlKHBsdWNrKHNlcmllc0l0ZW1zLCAnZGF0YScpLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICByZXR1cm4gc2VyaWVzSXRlbXNcbiAgICAgICAgLm1hcCgoc2VyaWVzSXRlbSkgPT4gKHtcbiAgICAgICAgaWQ6IHNlcmllc0l0ZW0uaWQsXG4gICAgICAgIHdlaWdodDogc2VyaWVzSXRlbS5kYXRhICogc2NhbGUsXG4gICAgfSkpXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLndlaWdodCAtIGEud2VpZ2h0KTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHdvcnN0IGFzcGVjdCByYXRpby5cbiAqIFJlZmVycmVkIGZ1bmN0aW9uIHdvcnN0KCkgaW4gaHR0cHM6Ly93d3cud2luLnR1ZS5ubC9+dmFud2lqay9zdG0ucGRmXG4gKi9cbmZ1bmN0aW9uIHdvcnN0KHRvdGFsLCBtaW4sIG1heCwgYmFzZVNpemUpIHtcbiAgICBjb25zdCBzdW1TcXVhcmUgPSB0b3RhbCAqIHRvdGFsO1xuICAgIGNvbnN0IHNpemVTcXVhcmUgPSBiYXNlU2l6ZSAqIGJhc2VTaXplO1xuICAgIHJldHVybiBNYXRoLm1heCgoc2l6ZVNxdWFyZSAqIG1heCkgLyBzdW1TcXVhcmUsIHN1bVNxdWFyZSAvIChzaXplU3F1YXJlICogbWluKSk7XG59XG5mdW5jdGlvbiBjaGFuZ2VkU3RhY2tEaXJlY3Rpb24odG90YWwsIHdlaWdodHMsIGJhc2VTaXplLCBuZXdXZWlnaHQpIHtcbiAgICBjb25zdCBtaW5XZWlnaHQgPSBNYXRoLm1pbiguLi53ZWlnaHRzKTtcbiAgICBjb25zdCBtYXhXZWlnaHQgPSBNYXRoLm1heCguLi53ZWlnaHRzKTtcbiAgICBjb25zdCBiZWZvcmVXb3JzdCA9IHdvcnN0KHRvdGFsLCBtaW5XZWlnaHQsIG1heFdlaWdodCwgYmFzZVNpemUpO1xuICAgIGNvbnN0IG5ld1dvcnN0ID0gd29yc3QodG90YWwgKyBuZXdXZWlnaHQsIE1hdGgubWluKG1pbldlaWdodCwgbmV3V2VpZ2h0KSwgTWF0aC5tYXgobWF4V2VpZ2h0LCBuZXdXZWlnaHQpLCBiYXNlU2l6ZSk7XG4gICAgcmV0dXJuIG5ld1dvcnN0ID49IGJlZm9yZVdvcnN0O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRml4ZWRTaXplKGJhc2VTaXplLCB0b3RhbCwgcm93cykge1xuICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgY29uc3Qgd2VpZ2h0cyA9IHBsdWNrKHJvd3MsICd3ZWlnaHQnKTtcbiAgICAgICAgdG90YWwgPSBzdW0od2VpZ2h0cyk7XG4gICAgfVxuICAgIHJldHVybiB0b3RhbCAvIGJhc2VTaXplO1xufVxuZnVuY3Rpb24gYWRkQm91bmRzKHN0YXJ0UG9zaXRpb24sIHJvd3MsIGZpeGVkU2l6ZSwgY2FsbGJhY2spIHtcbiAgICByb3dzLnJlZHVjZSgoc3RvcmVkUG9zaXRpb24sIHJvd0RhdHVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGR5bmFtaWNTaXplID0gcm93RGF0dW0ud2VpZ2h0IC8gZml4ZWRTaXplO1xuICAgICAgICBjYWxsYmFjayhkeW5hbWljU2l6ZSwgc3RvcmVkUG9zaXRpb24sIHJvd0RhdHVtLmlkKTtcbiAgICAgICAgcmV0dXJuIHN0b3JlZFBvc2l0aW9uICsgZHluYW1pY1NpemU7XG4gICAgfSwgc3RhcnRQb3NpdGlvbik7XG59XG5mdW5jdGlvbiBhZGRCb3VuZChib3VuZE1hcCwgaWQsIHJlY3QpIHtcbiAgICBib3VuZE1hcFtpZF0gPSByZWN0O1xufVxuZnVuY3Rpb24gYWRkQm91bmRzRm9yVmVydGljYWxTdGFjayhib3VuZE1hcCwgcm93cywgYmFzZUJvdW5kLCBiYXNlU2l6ZSwgdG90YWwpIHtcbiAgICBjb25zdCBmaXhlZFdpZHRoID0gY2FsY3VsYXRlRml4ZWRTaXplKGJhc2VTaXplLCB0b3RhbCwgcm93cyk7XG4gICAgYWRkQm91bmRzKGJhc2VCb3VuZC55LCByb3dzLCBmaXhlZFdpZHRoLCAoZHluYW1pY0hlaWdodCwgc3RvcmVkVG9wLCBpZCkgPT4ge1xuICAgICAgICBhZGRCb3VuZChib3VuZE1hcCwgaWQsIHtcbiAgICAgICAgICAgIHg6IGJhc2VCb3VuZC54LFxuICAgICAgICAgICAgeTogc3RvcmVkVG9wLFxuICAgICAgICAgICAgd2lkdGg6IGZpeGVkV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGR5bmFtaWNIZWlnaHQsXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGJhc2VCb3VuZC54ICs9IGZpeGVkV2lkdGg7XG4gICAgYmFzZUJvdW5kLndpZHRoIC09IGZpeGVkV2lkdGg7XG59XG5mdW5jdGlvbiBhZGRCb3VuZHNGb3JIb3Jpem9udGFsU3RhY2soYm91bmRNYXAsIHJvd3MsIGJhc2VCb3VuZCwgYmFzZVNpemUsIHRvdGFsKSB7XG4gICAgY29uc3QgZml4ZWRIZWlnaHQgPSBjYWxjdWxhdGVGaXhlZFNpemUoYmFzZVNpemUsIHRvdGFsLCByb3dzKTtcbiAgICBhZGRCb3VuZHMoYmFzZUJvdW5kLngsIHJvd3MsIGZpeGVkSGVpZ2h0LCAoZHluYW1pY1dpZHRoLCBzdG9yZWRMZWZ0LCBpZCkgPT4ge1xuICAgICAgICBhZGRCb3VuZChib3VuZE1hcCwgaWQsIHtcbiAgICAgICAgICAgIHg6IHN0b3JlZExlZnQsXG4gICAgICAgICAgICB5OiBiYXNlQm91bmQueSxcbiAgICAgICAgICAgIHdpZHRoOiBkeW5hbWljV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGZpeGVkSGVpZ2h0LFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBiYXNlQm91bmQueSArPSBmaXhlZEhlaWdodDtcbiAgICBiYXNlQm91bmQuaGVpZ2h0IC09IGZpeGVkSGVpZ2h0O1xufVxuZnVuY3Rpb24gZ2V0QWRkaW5nQm91bmRzRnVuY3Rpb24oYmFzZUJvdW5kKSB7XG4gICAgaWYgKGlzVmVydGljYWxTdGFjayhiYXNlQm91bmQpKSB7XG4gICAgICAgIHJldHVybiBhZGRCb3VuZHNGb3JWZXJ0aWNhbFN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gYWRkQm91bmRzRm9ySG9yaXpvbnRhbFN0YWNrO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyaWZ5KGxheW91dCwgc2VyaWVzSXRlbXMpIHtcbiAgICBjb25zdCBiYXNlQm91bmQgPSBsYXlvdXQ7XG4gICAgY29uc3QgYmFzZURhdGEgPSBtYWtlQmFzZURhdGEoc2VyaWVzSXRlbXMsIGJhc2VCb3VuZCk7XG4gICAgbGV0IHJvdyA9IFtdO1xuICAgIGxldCBiYXNlU2l6ZSwgYWRkQm91bmRzRnVuYztcbiAgICBjb25zdCBib3VuZE1hcCA9IHt9O1xuICAgIGJhc2VEYXRhLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHdlaWdodHMgPSBwbHVjayhyb3csICd3ZWlnaHQnKTtcbiAgICAgICAgY29uc3QgdG90YWxXZWlnaHQgPSBzdW0od2VpZ2h0cyk7XG4gICAgICAgIGlmIChyb3cubGVuZ3RoICYmIGNoYW5nZWRTdGFja0RpcmVjdGlvbih0b3RhbFdlaWdodCwgd2VpZ2h0cywgYmFzZVNpemUsIGRhdHVtLndlaWdodCkpIHtcbiAgICAgICAgICAgIGFkZEJvdW5kc0Z1bmMoYm91bmRNYXAsIHJvdywgYmFzZUJvdW5kLCBiYXNlU2l6ZSwgdG90YWxXZWlnaHQpO1xuICAgICAgICAgICAgcm93ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBiYXNlU2l6ZSA9IHNlbGVjdEJhc2VTaXplKGJhc2VCb3VuZCk7XG4gICAgICAgICAgICBhZGRCb3VuZHNGdW5jID0gZ2V0QWRkaW5nQm91bmRzRnVuY3Rpb24oYmFzZUJvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICByb3cucHVzaChkYXR1bSk7XG4gICAgfSk7XG4gICAgaWYgKHJvdy5sZW5ndGgpIHtcbiAgICAgICAgYWRkQm91bmRzRnVuYyhib3VuZE1hcCwgcm93LCBiYXNlQm91bmQsIGJhc2VTaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kTWFwO1xufVxuIiwiaW1wb3J0IHsgaXNTdHJpbmcsIHBpY2sgfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgZ2V0QWxwaGEgfSBmcm9tIFwiLi9jb2xvclwiO1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VTdHlsZU9iaihzdHlsZSwgc3R5bGVTZXQpIHtcbiAgICByZXR1cm4gc3R5bGUucmVkdWNlKChhY2MsIGN1clZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChpc1N0cmluZyhjdXJWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHN0eWxlU2V0W2N1clZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjKSwgY3VyVmFsdWUpO1xuICAgIH0sIHt9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2xhdGVTdHJpbmcoeCwgeSkge1xuICAgIHJldHVybiBgdHJhbnNsYXRlKCR7eH1weCwke3l9cHgpYDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRUaXRsZUZvbnRTdHJpbmcoZm9udFRoZW1lKSB7XG4gICAgY29uc3QgeyBmb250RmFtaWx5LCBmb250U2l6ZSwgZm9udFdlaWdodCB9ID0gZm9udFRoZW1lO1xuICAgIHJldHVybiBgJHtmb250V2VpZ2h0fSAke2ZvbnRTaXplfXB4ICR7Zm9udEZhbWlseX1gO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEZvbnRTdHlsZVN0cmluZyh0aGVtZSkge1xuICAgIGNvbnN0IHsgY29sb3IsIGZvbnRTaXplLCBmb250RmFtaWx5LCBmb250V2VpZ2h0IH0gPSB0aGVtZTtcbiAgICByZXR1cm4gYGZvbnQtd2VpZ2h0OiAke2ZvbnRXZWlnaHR9OyBmb250LWZhbWlseTogJHtmb250RmFtaWx5fTsgZm9udC1zaXplOiAke2ZvbnRTaXplfXB4OyBjb2xvcjogJHtjb2xvcn07YDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRGb250KHRoZW1lKSB7XG4gICAgcmV0dXJuIGdldFRpdGxlRm9udFN0cmluZyhwaWNrKHRoZW1lLCAnZm9udEZhbWlseScsICdmb250V2VpZ2h0JywgJ2ZvbnRTaXplJykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldExpbmVEYXNoKGN0eCwgZGFzaFNlZ21lbnRzKSB7XG4gICAgaWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuICAgICAgICBjdHguc2V0TGluZURhc2goZGFzaFNlZ21lbnRzKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm94VHlwZVNlcmllc1BhZGRpbmcodGlja0Rpc3RhbmNlKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IodGlja0Rpc3RhbmNlICogMC4xNSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZmlsbFN0eWxlKGN0eCwgZmlsbE9wdGlvbikge1xuICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsT3B0aW9uO1xuICAgIGN0eC5maWxsKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3Ryb2tlV2l0aE9wdGlvbnMoY3R4LCBzdHlsZSkge1xuICAgIGNvbnN0IHsgbGluZVdpZHRoLCBzdHJva2VTdHlsZSB9ID0gc3R5bGU7XG4gICAgaWYgKHN0cm9rZVN0eWxlKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgIH1cbiAgICBpZiAobGluZVdpZHRoKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgfVxuICAgIGlmIChjdHgubGluZVdpZHRoICYmIGdldEFscGhhKFN0cmluZyhjdHguc3Ryb2tlU3R5bGUpKSkge1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgZ2V0TmVzdGVkUGllQ2hhcnRBbGlhc05hbWVzIH0gZnJvbSBcIi4vcGllU2VyaWVzXCI7XG5pbXBvcnQgeyBpbmNsdWRlcyB9IGZyb20gXCIuL3V0aWxzXCI7XG5leHBvcnQgY29uc3QgREVGQVVMVF9MSU5FX1NFUklFU19XSURUSCA9IDI7XG5leHBvcnQgY29uc3QgREVGQVVMVF9MSU5FX1NFUklFU19ET1RfUkFESVVTID0gMztcbmNvbnN0IERFRkFVTFRfQVJFQV9PUEFDSVRZID0gMC4zO1xuY29uc3QgREVGQVVMVF9BUkVBX1NFTEVDVEVEX1NFUklFU19PUEFDSVRZID0gREVGQVVMVF9BUkVBX09QQUNJVFk7XG5jb25zdCBERUZBVUxUX0FSRUFfVU5TRUxFQ1RFRF9TRVJJRVNfT1BBQ0lUWSA9IDAuMDY7XG5leHBvcnQgY29uc3QgcmFkYXJEZWZhdWx0ID0ge1xuICAgIExJTkVfV0lEVEg6IDIsXG4gICAgRE9UX1JBRElVUzogMyxcbiAgICBIT1ZFUl9ET1RfUkFESVVTOiA0LFxuICAgIFNFTEVDVEVEX1NFUklFU19PUEFDSVRZOiAwLjMsXG4gICAgVU5TRUxFQ1RFRF9TRVJJRVNfT1BBQ0lUWTogMC4wNSxcbn07XG5leHBvcnQgY29uc3QgYm94RGVmYXVsdCA9IHtcbiAgICBIT1ZFUl9USElDS05FU1M6IDQsXG4gICAgQk9YX0hPVkVSOiB7XG4gICAgICAgIHNoYWRvd0NvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjMpJyxcbiAgICAgICAgc2hhZG93T2Zmc2V0WDogMixcbiAgICAgICAgc2hhZG93T2Zmc2V0WTogMixcbiAgICAgICAgc2hhZG93Qmx1cjogNixcbiAgICB9LFxufTtcbmNvbnN0IGJveHBsb3REZWZhdWx0ID0ge1xuICAgIE9VVExJRVJfUkFESVVTOiA0LFxuICAgIE9VVExJRVJfQk9SREVSX1dJRFRIOiAyLFxuICAgIExJTkVfVFlQRToge1xuICAgICAgICB3aGlza2VyOiB7IGxpbmVXaWR0aDogMSB9LFxuICAgICAgICBtYXhpbXVtOiB7IGxpbmVXaWR0aDogMSB9LFxuICAgICAgICBtaW5pbXVtOiB7IGxpbmVXaWR0aDogMSB9LFxuICAgICAgICBtZWRpYW46IHsgbGluZVdpZHRoOiAxLCBjb2xvcjogJyNmZmZmZmYnIH0sXG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgREVGQVVMVF9CVUxMRVRfUkFOR0VfT1BBQ0lUWSA9IFswLjUsIDAuMywgMC4xXTtcbmNvbnN0IERFRkFVTFRfUElFX0xJTkVfV0lEVEggPSAzO1xuZnVuY3Rpb24gbWFrZURlZmF1bHREYXRhTGFiZWxzVGhlbWUoZ2xvYmFsRm9udEZhbWlseSA9ICdBcmlhbCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb250RmFtaWx5OiBnbG9iYWxGb250RmFtaWx5LFxuICAgICAgICBmb250U2l6ZTogMTEsXG4gICAgICAgIGZvbnRXZWlnaHQ6IDQwMCxcbiAgICAgICAgY29sb3I6ICcjMzMzMzMzJyxcbiAgICAgICAgdXNlU2VyaWVzQ29sb3I6IGZhbHNlLFxuICAgIH07XG59XG5jb25zdCBERUZBVUxUX0JVQkJMRV9BUlJPVyA9IHtcbiAgICB3aWR0aDogOCxcbiAgICBoZWlnaHQ6IDYsXG59O1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRTZXJpZXNUaGVtZSA9IHtcbiAgICBjb2xvcnM6IFtcbiAgICAgICAgJyMwMGE5ZmYnLFxuICAgICAgICAnI2ZmYjg0MCcsXG4gICAgICAgICcjZmY1YTQ2JyxcbiAgICAgICAgJyMwMGJkOWYnLFxuICAgICAgICAnIzc4NWZmZicsXG4gICAgICAgICcjZjI4YjhjJyxcbiAgICAgICAgJyM5ODk0ODYnLFxuICAgICAgICAnIzUxNmY3ZCcsXG4gICAgICAgICcjMjhlNmViJyxcbiAgICAgICAgJyMyODY5NWYnLFxuICAgICAgICAnIzk2Yzg1YScsXG4gICAgICAgICcjNDViYTNmJyxcbiAgICAgICAgJyMyOTViYTAnLFxuICAgICAgICAnIzJhNDE3NScsXG4gICAgICAgICcjMjg5Mzk5JyxcbiAgICAgICAgJyM2NmM4ZDMnLFxuICAgICAgICAnIzYxNzE3OCcsXG4gICAgICAgICcjOGE5YTlhJyxcbiAgICAgICAgJyNiZWJlYmUnLFxuICAgICAgICAnIzM3NGI1YScsXG4gICAgICAgICcjNjRlYmEwJyxcbiAgICAgICAgJyNmZmUxNTUnLFxuICAgICAgICAnI2ZmOTE0MScsXG4gICAgICAgICcjYWY0YmViJyxcbiAgICAgICAgJyNmZjczZmEnLFxuICAgICAgICAnI2ZmNTViMicsXG4gICAgICAgICcjMjg2OWY1JyxcbiAgICAgICAgJyMzMjk2ZmYnLFxuICAgICAgICAnIzhjYzNmZicsXG4gICAgICAgICcjMjgyOGI5JyxcbiAgICAgICAgJyNmYTg3ODcnLFxuICAgICAgICAnI2UxMzc4MicsXG4gICAgICAgICcjN2Q1YWFhJyxcbiAgICAgICAgJyM2NDNjOTEnLFxuICAgICAgICAnI2QyNWY1ZicsXG4gICAgICAgICcjZmFiZTZlJyxcbiAgICAgICAgJyNjM2E5ZWInLFxuICAgICAgICAnI2I5YzhmNScsXG4gICAgICAgICcjNzNhMGNkJyxcbiAgICAgICAgJyMwZjVhOGMnLFxuICAgIF0sXG4gICAgc3RhcnRDb2xvcjogJyNmZmU5OGEnLFxuICAgIGVuZENvbG9yOiAnI2Q3NDE3NycsXG4gICAgbGluZVdpZHRoOiBERUZBVUxUX0xJTkVfU0VSSUVTX1dJRFRILFxuICAgIGRhc2hTZWdtZW50czogW10sXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgYm9yZGVyQ29sb3I6ICcjZmZmZmZmJyxcbiAgICBzZWxlY3Q6IHtcbiAgICAgICAgZG90OiB7XG4gICAgICAgICAgICByYWRpdXM6IERFRkFVTFRfTElORV9TRVJJRVNfRE9UX1JBRElVUyxcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiBERUZBVUxUX0xJTkVfU0VSSUVTX0RPVF9SQURJVVMgKyAyLFxuICAgICAgICB9LFxuICAgICAgICBhcmVhT3BhY2l0eTogREVGQVVMVF9BUkVBX1NFTEVDVEVEX1NFUklFU19PUEFDSVRZLFxuICAgICAgICByZXN0U2VyaWVzOiB7XG4gICAgICAgICAgICBhcmVhT3BhY2l0eTogREVGQVVMVF9BUkVBX1VOU0VMRUNURURfU0VSSUVTX09QQUNJVFksXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBob3Zlcjoge1xuICAgICAgICBkb3Q6IHtcbiAgICAgICAgICAgIHJhZGl1czogREVGQVVMVF9MSU5FX1NFUklFU19ET1RfUkFESVVTLFxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IERFRkFVTFRfTElORV9TRVJJRVNfRE9UX1JBRElVUyArIDIsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBkb3Q6IHtcbiAgICAgICAgcmFkaXVzOiBERUZBVUxUX0xJTkVfU0VSSUVTX0RPVF9SQURJVVMsXG4gICAgfSxcbiAgICBhcmVhT3BhY2l0eTogREVGQVVMVF9BUkVBX09QQUNJVFksXG59O1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VBeGlzVGl0bGVUaGVtZShnbG9iYWxGb250RmFtaWx5ID0gJ0FyaWFsJykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvbnRTaXplOiAxMSxcbiAgICAgICAgZm9udEZhbWlseTogZ2xvYmFsRm9udEZhbWlseSxcbiAgICAgICAgZm9udFdlaWdodDogNzAwLFxuICAgICAgICBjb2xvcjogJyNiYmJiYmInLFxuICAgIH07XG59XG5mdW5jdGlvbiBtYWtlQ29tbW9uVGV4dFRoZW1lKGdsb2JhbEZvbnRGYW1pbHkgPSAnQXJpYWwnKSB7XG4gICAgcmV0dXJuIHsgZm9udFNpemU6IDExLCBmb250RmFtaWx5OiBnbG9iYWxGb250RmFtaWx5LCBmb250V2VpZ2h0OiAnbm9ybWFsJywgY29sb3I6ICcjMzMzMzMzJyB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VEZWZhdWx0VGhlbWUoc2VyaWVzLCBnbG9iYWxGb250RmFtaWx5ID0gJ0FyaWFsJykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgYXhpc1RpdGxlVGhlbWUgPSBtYWtlQXhpc1RpdGxlVGhlbWUoZ2xvYmFsRm9udEZhbWlseSk7XG4gICAgY29uc3QgY29tbW9uVGV4dFRoZW1lID0gbWFrZUNvbW1vblRleHRUaGVtZShnbG9iYWxGb250RmFtaWx5KTtcbiAgICBjb25zdCBoYXNSYWRhclNlcmllcyA9ICEhKChfYSA9IHNlcmllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJhZGFyKTtcbiAgICBjb25zdCBoYXNHYXVnZVNlcmllcyA9ICEhKChfYiA9IHNlcmllcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdhdWdlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFydDoge1xuICAgICAgICAgICAgZm9udEZhbWlseTogZ2xvYmFsRm9udEZhbWlseSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICB9LFxuICAgICAgICBub0RhdGE6IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiAxOCxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IGdsb2JhbEZvbnRGYW1pbHksXG4gICAgICAgICAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICAgICAgICAgIGNvbG9yOiAnIzMzMzMzMycsXG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICBmb250U2l6ZTogMTgsXG4gICAgICAgICAgICBmb250RmFtaWx5OiBnbG9iYWxGb250RmFtaWx5LFxuICAgICAgICAgICAgZm9udFdlaWdodDogMTAwLFxuICAgICAgICAgICAgY29sb3I6ICcjMzMzMzMzJyxcbiAgICAgICAgfSxcbiAgICAgICAgeUF4aXM6IHtcbiAgICAgICAgICAgIHRpdGxlOiBPYmplY3QuYXNzaWduKHt9LCBheGlzVGl0bGVUaGVtZSksXG4gICAgICAgICAgICBsYWJlbDogT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uVGV4dFRoZW1lKSxcbiAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgY29sb3I6ICcjMzMzMzMzJyxcbiAgICAgICAgfSxcbiAgICAgICAgeEF4aXM6IHtcbiAgICAgICAgICAgIHRpdGxlOiBPYmplY3QuYXNzaWduKHt9LCBheGlzVGl0bGVUaGVtZSksXG4gICAgICAgICAgICBsYWJlbDogT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uVGV4dFRoZW1lKSxcbiAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgY29sb3I6ICcjMzMzMzMzJyxcbiAgICAgICAgfSxcbiAgICAgICAgdmVydGljYWxBeGlzOiB7XG4gICAgICAgICAgICBsYWJlbDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb21tb25UZXh0VGhlbWUpLCB7IHRleHRCdWJibGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogaGFzUmFkYXJTZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogaGFzUmFkYXJTZXJpZXMgPyAnI2YzZjNmMycgOiAncmdiYSgwLCAwLCAwLCAwKScsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogNyxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZ1g6IDcsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdZOiAyLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMCknLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgICAgICAgICB9IH0pLFxuICAgICAgICB9LFxuICAgICAgICBjaXJjdWxhckF4aXM6IHtcbiAgICAgICAgICAgIHRpdGxlOiBPYmplY3QuYXNzaWduKHt9LCBheGlzVGl0bGVUaGVtZSksXG4gICAgICAgICAgICBsYWJlbDogT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uVGV4dFRoZW1lKSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBoYXNHYXVnZVNlcmllcyA/ICdyZ2JhKDAsIDAsIDAsIDAuNSknIDogJ3JnYmEoMCwgMCwgMCwgMC4wNSknLFxuICAgICAgICAgICAgZG90Q29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuNSknLFxuICAgICAgICAgICAgdGljazoge1xuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogJ3JnYmEoMCwgMCwgMCwgMC41KScsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMzMzMzMzJyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTEsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ25vcm1hbCcsXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseTogZ2xvYmFsRm9udEZhbWlseSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICdyZ2JhKDg1LCA4NSwgODUsIDAuOTUpJyxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwKScsXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogMCxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogMyxcbiAgICAgICAgICAgIGJvcmRlclN0eWxlOiAnc29saWQnLFxuICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBgJHtnbG9iYWxGb250RmFtaWx5fSwgc2Fucy1zZXJpZmAsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ25vcm1hbCcsXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTMsXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseTogYCR7Z2xvYmFsRm9udEZhbWlseX0sIHNhbnMtc2VyaWZgLFxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICAgICAgICBjb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgcGxvdDoge1xuICAgICAgICAgICAgbGluZUNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjA1KScsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDApJyxcbiAgICAgICAgfSxcbiAgICAgICAgZXhwb3J0TWVudToge1xuICAgICAgICAgICAgYnV0dG9uOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1ha2VCb3JkZXJUaGVtZSg1LCAnI2Y0ZjRmNCcpKSwgeyBiYWNrZ3JvdW5kQ29sb3I6ICcjZjRmNGY0JywgeEljb246IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjNTU1NTU1JyxcbiAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiAyLFxuICAgICAgICAgICAgICAgIH0sIGRvdEljb246IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjNTU1NTU1JyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDIsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMixcbiAgICAgICAgICAgICAgICAgICAgZ2FwOiAyLFxuICAgICAgICAgICAgICAgIH0gfSksXG4gICAgICAgICAgICBwYW5lbDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtYWtlQm9yZGVyVGhlbWUoMCwgJyNiYWI5YmEnKSksIHsgaGVhZGVyOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblRleHRUaGVtZSksIHsgYmFja2dyb3VuZENvbG9yOiAnI2Y0ZjRmNCcgfSksIGJvZHk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uVGV4dFRoZW1lKSwgeyBiYWNrZ3JvdW5kQ29sb3I6ICcjZmZmZmZmJyB9KSB9KSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFrZUJvcmRlclRoZW1lKGJvcmRlclJhZGl1cywgYm9yZGVyQ29sb3IsIGJvcmRlcldpZHRoID0gMSkge1xuICAgIHJldHVybiB7IGJvcmRlcldpZHRoLCBib3JkZXJSYWRpdXMsIGJvcmRlckNvbG9yIH07XG59XG5mdW5jdGlvbiBtYWtlRGVmYXVsdFRleHRCdWJibGVUaGVtZSh2aXNpYmxlID0gZmFsc2UsIGJvcmRlclJhZGl1cyA9IDcsIHBhZGRpbmdYID0gNSwgcGFkZGluZ1kgPSAxLCBiYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmZmZmZicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2aXNpYmxlLFxuICAgICAgICBwYWRkaW5nWCxcbiAgICAgICAgcGFkZGluZ1ksXG4gICAgICAgIGJvcmRlclJhZGl1cyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yLFxuICAgICAgICBzaGFkb3dDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4zKScsXG4gICAgICAgIHNoYWRvd09mZnNldFk6IDIsXG4gICAgICAgIHNoYWRvd0JsdXI6IDQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldExpbmVUeXBlU2VyaWVzVGhlbWUoZ2xvYmFsRm9udEZhbWlseSkge1xuICAgIGNvbnN0IGRlZmF1bHREYXRhTGFiZWxUaGVtZSA9IG1ha2VEZWZhdWx0RGF0YUxhYmVsc1RoZW1lKGdsb2JhbEZvbnRGYW1pbHkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVXaWR0aDogZGVmYXVsdFNlcmllc1RoZW1lLmxpbmVXaWR0aCxcbiAgICAgICAgZGFzaFNlZ21lbnRzOiBkZWZhdWx0U2VyaWVzVGhlbWUuZGFzaFNlZ21lbnRzLFxuICAgICAgICBzZWxlY3Q6IHsgZG90OiBkZWZhdWx0U2VyaWVzVGhlbWUuc2VsZWN0LmRvdCB9LFxuICAgICAgICBob3ZlcjogeyBkb3Q6IGRlZmF1bHRTZXJpZXNUaGVtZS5ob3Zlci5kb3QgfSxcbiAgICAgICAgZG90OiBkZWZhdWx0U2VyaWVzVGhlbWUuZG90LFxuICAgICAgICBkYXRhTGFiZWxzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHREYXRhTGFiZWxUaGVtZSksIHsgdGV4dEJ1YmJsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtYWtlRGVmYXVsdFRleHRCdWJibGVUaGVtZSgpKSwgeyBhcnJvdzogT2JqZWN0LmFzc2lnbih7IHZpc2libGU6IGZhbHNlLCBkaXJlY3Rpb246ICdib3R0b20nIH0sIERFRkFVTFRfQlVCQkxFX0FSUk9XKSB9KSB9KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0VHJlZW1hcEhlYXRtYXBTZXJpZXNUaGVtZShnbG9iYWxGb250RmFtaWx5KSB7XG4gICAgY29uc3QgZGVmYXVsdERhdGFMYWJlbFRoZW1lID0gbWFrZURlZmF1bHREYXRhTGFiZWxzVGhlbWUoZ2xvYmFsRm9udEZhbWlseSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRDb2xvcjogZGVmYXVsdFNlcmllc1RoZW1lLnN0YXJ0Q29sb3IsXG4gICAgICAgIGVuZENvbG9yOiBkZWZhdWx0U2VyaWVzVGhlbWUuZW5kQ29sb3IsXG4gICAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgICBib3JkZXJDb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IGJveERlZmF1bHQuSE9WRVJfVEhJQ0tORVNTLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjZmZmZmZmJyxcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICBib3JkZXJXaWR0aDogYm94RGVmYXVsdC5IT1ZFUl9USElDS05FU1MsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICB9LFxuICAgICAgICBkYXRhTGFiZWxzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHREYXRhTGFiZWxUaGVtZSksIHsgY29sb3I6ICcjZmZmZmZmJywgdGV4dEJ1YmJsZTogT2JqZWN0LmFzc2lnbih7fSwgbWFrZURlZmF1bHRUZXh0QnViYmxlVGhlbWUoZmFsc2UsIDEsIDUsIDEsICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSknKSkgfSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEJhckNvbHVtblNlcmllc1RoZW1lKGdsb2JhbEZvbnRGYW1pbHkpIHtcbiAgICBjb25zdCBkZWZhdWx0RGF0YUxhYmVsVGhlbWUgPSBtYWtlRGVmYXVsdERhdGFMYWJlbHNUaGVtZShnbG9iYWxGb250RmFtaWx5KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhcmVhT3BhY2l0eTogMSxcbiAgICAgICAgaG92ZXI6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYm94RGVmYXVsdC5CT1hfSE9WRVIpLCB7IGJvcmRlcldpZHRoOiBib3hEZWZhdWx0LkhPVkVSX1RISUNLTkVTUywgYm9yZGVyQ29sb3I6ICcjZmZmZmZmJywgZ3JvdXBlZFJlY3Q6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuMDUsXG4gICAgICAgICAgICB9IH0pLFxuICAgICAgICBzZWxlY3Q6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYm94RGVmYXVsdC5CT1hfSE9WRVIpLCB7IGJvcmRlcldpZHRoOiBib3hEZWZhdWx0LkhPVkVSX1RISUNLTkVTUywgYm9yZGVyQ29sb3I6ICcjZmZmZmZmJywgZ3JvdXBlZFJlY3Q6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuMixcbiAgICAgICAgICAgIH0sIHJlc3RTZXJpZXM6IHtcbiAgICAgICAgICAgICAgICBhcmVhT3BhY2l0eTogMC4yLFxuICAgICAgICAgICAgfSwgYXJlYU9wYWNpdHk6IDEgfSksXG4gICAgICAgIGNvbm5lY3Rvcjoge1xuICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDUxLCA4NSwgMTM5LCAwLjMpJyxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgICAgIGRhc2hTZWdtZW50czogW10sXG4gICAgICAgIH0sXG4gICAgICAgIGRhdGFMYWJlbHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdERhdGFMYWJlbFRoZW1lKSwgeyB0ZXh0QnViYmxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1ha2VEZWZhdWx0VGV4dEJ1YmJsZVRoZW1lKGZhbHNlLCAxLCA0LCAzKSksIHsgYXJyb3c6IE9iamVjdC5hc3NpZ24oeyB2aXNpYmxlOiBmYWxzZSB9LCBERUZBVUxUX0JVQkJMRV9BUlJPVykgfSksIHN0YWNrVG90YWw6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdERhdGFMYWJlbFRoZW1lKSwgeyB0ZXh0QnViYmxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1ha2VEZWZhdWx0VGV4dEJ1YmJsZVRoZW1lKHRydWUsIDEsIDQsIDMpKSwgeyBhcnJvdzogT2JqZWN0LmFzc2lnbih7IHZpc2libGU6IHRydWUgfSwgREVGQVVMVF9CVUJCTEVfQVJST1cpIH0pIH0pIH0pLFxuICAgIH07XG59XG5jb25zdCB0cmFuc3BhcmVudENvbG9yID0gJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMCknO1xuY29uc3QgZGVmYXVsdFRoZW1lTWFrZXJzID0ge1xuICAgIGxpbmU6IChnbG9iYWxGb250RmFtaWx5KSA9PiAoT2JqZWN0LmFzc2lnbih7fSwgZ2V0TGluZVR5cGVTZXJpZXNUaGVtZShnbG9iYWxGb250RmFtaWx5KSkpLFxuICAgIGFyZWE6IChnbG9iYWxGb250RmFtaWx5KSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmVUeXBlU2VyaWVzVGhlbWUgPSBnZXRMaW5lVHlwZVNlcmllc1RoZW1lKGdsb2JhbEZvbnRGYW1pbHkpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsaW5lVHlwZVNlcmllc1RoZW1lKSwgeyBzZWxlY3Q6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbGluZVR5cGVTZXJpZXNUaGVtZS5zZWxlY3QpLCB7IGFyZWFPcGFjaXR5OiBERUZBVUxUX0FSRUFfU0VMRUNURURfU0VSSUVTX09QQUNJVFksIHJlc3RTZXJpZXM6IGRlZmF1bHRTZXJpZXNUaGVtZS5zZWxlY3QucmVzdFNlcmllcyB9KSwgYXJlYU9wYWNpdHk6IERFRkFVTFRfQVJFQV9PUEFDSVRZIH0pO1xuICAgIH0sXG4gICAgdHJlZW1hcDogKGdsb2JhbEZvbnRGYW1pbHkpID0+IGdldFRyZWVtYXBIZWF0bWFwU2VyaWVzVGhlbWUoZ2xvYmFsRm9udEZhbWlseSksXG4gICAgaGVhdG1hcDogKGdsb2JhbEZvbnRGYW1pbHkpID0+IGdldFRyZWVtYXBIZWF0bWFwU2VyaWVzVGhlbWUoZ2xvYmFsRm9udEZhbWlseSksXG4gICAgc2NhdHRlcjogKCkgPT4gKHtcbiAgICAgICAgc2l6ZTogMTIsXG4gICAgICAgIGJvcmRlcldpZHRoOiAxLjUsXG4gICAgICAgIGZpbGxDb2xvcjogdHJhbnNwYXJlbnRDb2xvcixcbiAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICBmaWxsQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDEpJyxcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAyLjUsXG4gICAgICAgICAgICBzaXplOiAxMixcbiAgICAgICAgfSxcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgIGZpbGxDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMSknLFxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIuNSxcbiAgICAgICAgICAgIHNpemU6IDEyLFxuICAgICAgICB9LFxuICAgIH0pLFxuICAgIGJ1YmJsZTogKCkgPT4gKHtcbiAgICAgICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgICAgIGJvcmRlckNvbG9yOiB0cmFuc3BhcmVudENvbG9yLFxuICAgICAgICBzZWxlY3Q6IHt9LFxuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgICAgc2hhZG93Q29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMyknLFxuICAgICAgICAgICAgc2hhZG93Qmx1cjogMixcbiAgICAgICAgICAgIHNoYWRvd09mZnNldFk6IDIsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDIsXG4gICAgICAgIH0sXG4gICAgfSksXG4gICAgcmFkYXI6ICgpID0+ICh7XG4gICAgICAgIGFyZWFPcGFjaXR5OiByYWRhckRlZmF1bHQuU0VMRUNURURfU0VSSUVTX09QQUNJVFksXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICBkb3Q6IHtcbiAgICAgICAgICAgICAgICByYWRpdXM6IHJhZGFyRGVmYXVsdC5IT1ZFUl9ET1RfUkFESVVTLFxuICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiByYWRhckRlZmF1bHQuSE9WRVJfRE9UX1JBRElVUyArIDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgIGRvdDoge1xuICAgICAgICAgICAgICAgIHJhZGl1czogcmFkYXJEZWZhdWx0LkhPVkVSX0RPVF9SQURJVVMsXG4gICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IHJhZGFyRGVmYXVsdC5IT1ZFUl9ET1RfUkFESVVTICsgMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN0U2VyaWVzOiB7XG4gICAgICAgICAgICAgICAgYXJlYU9wYWNpdHk6IHJhZGFyRGVmYXVsdC5VTlNFTEVDVEVEX1NFUklFU19PUEFDSVRZLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZWFPcGFjaXR5OiByYWRhckRlZmF1bHQuU0VMRUNURURfU0VSSUVTX09QQUNJVFksXG4gICAgICAgIH0sXG4gICAgICAgIGRvdDoge1xuICAgICAgICAgICAgcmFkaXVzOiByYWRhckRlZmF1bHQuRE9UX1JBRElVUyxcbiAgICAgICAgfSxcbiAgICB9KSxcbiAgICBiYXI6IChnbG9iYWxGb250RmFtaWx5KSA9PiAoT2JqZWN0LmFzc2lnbih7fSwgZ2V0QmFyQ29sdW1uU2VyaWVzVGhlbWUoZ2xvYmFsRm9udEZhbWlseSkpKSxcbiAgICBjb2x1bW46IChnbG9iYWxGb250RmFtaWx5KSA9PiAoT2JqZWN0LmFzc2lnbih7fSwgZ2V0QmFyQ29sdW1uU2VyaWVzVGhlbWUoZ2xvYmFsRm9udEZhbWlseSkpKSxcbiAgICBidWxsZXQ6IChnbG9iYWxGb250RmFtaWx5KSA9PiB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHREYXRhTGFiZWxUaGVtZSA9IG1ha2VEZWZhdWx0RGF0YUxhYmVsc1RoZW1lKGdsb2JhbEZvbnRGYW1pbHkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXJlYU9wYWNpdHk6IDEsXG4gICAgICAgICAgICBiYXJXaWR0aFJhdGlvczoge1xuICAgICAgICAgICAgICAgIHJhbmdlUmF0aW86IDEsXG4gICAgICAgICAgICAgICAgYnVsbGV0UmF0aW86IDAuNSxcbiAgICAgICAgICAgICAgICBtYXJrZXJSYXRpbzogMC44LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hcmtlckxpbmVXaWR0aDogMSxcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDApJyxcbiAgICAgICAgICAgIGhvdmVyOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJveERlZmF1bHQuQk9YX0hPVkVSKSwgeyBib3JkZXJXaWR0aDogYm94RGVmYXVsdC5IT1ZFUl9USElDS05FU1MsIGJvcmRlckNvbG9yOiAnI2ZmZmZmZicsIGdyb3VwZWRSZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuMDUsXG4gICAgICAgICAgICAgICAgfSB9KSxcbiAgICAgICAgICAgIHNlbGVjdDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBib3hEZWZhdWx0LkJPWF9IT1ZFUiksIHsgYm9yZGVyV2lkdGg6IGJveERlZmF1bHQuSE9WRVJfVEhJQ0tORVNTLCBib3JkZXJDb2xvcjogJyNmZmZmZmYnLCBncm91cGVkUmVjdDoge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjIsXG4gICAgICAgICAgICAgICAgfSwgcmVzdFNlcmllczoge1xuICAgICAgICAgICAgICAgICAgICBhcmVhT3BhY2l0eTogMC4yLFxuICAgICAgICAgICAgICAgIH0sIGFyZWFPcGFjaXR5OiAxIH0pLFxuICAgICAgICAgICAgZGF0YUxhYmVsczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0RGF0YUxhYmVsVGhlbWUpLCB7IHRleHRCdWJibGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWFrZURlZmF1bHRUZXh0QnViYmxlVGhlbWUoKSksIHsgYXJyb3c6IE9iamVjdC5hc3NpZ24oeyB2aXNpYmxlOiBmYWxzZSB9LCBERUZBVUxUX0JVQkJMRV9BUlJPVykgfSksIG1hcmtlcjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0RGF0YUxhYmVsVGhlbWUpLCB7IGZvbnRTaXplOiA5LCB1c2VTZXJpZXNDb2xvcjogdHJ1ZSwgdGV4dEJ1YmJsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtYWtlRGVmYXVsdFRleHRCdWJibGVUaGVtZSh0cnVlKSksIHsgYmFja2dyb3VuZENvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpJywgc2hhZG93Q29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMCknLCBzaGFkb3dPZmZzZXRYOiAwLCBzaGFkb3dPZmZzZXRZOiAwLCBzaGFkb3dCbHVyOiAwLCBhcnJvdzogT2JqZWN0LmFzc2lnbih7IHZpc2libGU6IGZhbHNlIH0sIERFRkFVTFRfQlVCQkxFX0FSUk9XKSB9KSB9KSB9KSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGJveFBsb3Q6ICgpID0+ICh7XG4gICAgICAgIGFyZWFPcGFjaXR5OiAxLFxuICAgICAgICBiYXJXaWR0aFJhdGlvczoge1xuICAgICAgICAgICAgYmFyUmF0aW86IDEsXG4gICAgICAgICAgICBtaW5NYXhCYXJSYXRpbzogMC41LFxuICAgICAgICB9LFxuICAgICAgICBtYXJrZXJMaW5lV2lkdGg6IDEsXG4gICAgICAgIGRvdDoge1xuICAgICAgICAgICAgY29sb3I6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgIHJhZGl1czogYm94cGxvdERlZmF1bHQuT1VUTElFUl9SQURJVVMsXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogYm94cGxvdERlZmF1bHQuT1VUTElFUl9CT1JERVJfV0lEVEgsXG4gICAgICAgICAgICB1c2VTZXJpZXNDb2xvcjogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIHJlY3Q6IHsgYm9yZGVyV2lkdGg6IDAgfSxcbiAgICAgICAgbGluZTogT2JqZWN0LmFzc2lnbih7fSwgYm94cGxvdERlZmF1bHQuTElORV9UWVBFKSxcbiAgICAgICAgaG92ZXI6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYm94RGVmYXVsdC5CT1hfSE9WRVIpLCB7IHJlY3Q6IHsgYm9yZGVyV2lkdGg6IGJveERlZmF1bHQuSE9WRVJfVEhJQ0tORVNTLCBib3JkZXJDb2xvcjogJyNmZmZmZmYnIH0sIGRvdDoge1xuICAgICAgICAgICAgICAgIHJhZGl1czogYm94cGxvdERlZmF1bHQuT1VUTElFUl9SQURJVVMsXG4gICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgdXNlU2VyaWVzQ29sb3I6IHRydWUsXG4gICAgICAgICAgICB9LCBsaW5lOiBPYmplY3QuYXNzaWduKHt9LCBib3hwbG90RGVmYXVsdC5MSU5FX1RZUEUpIH0pLFxuICAgICAgICBzZWxlY3Q6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYm94RGVmYXVsdC5CT1hfSE9WRVIpLCB7IHJlY3Q6IHsgYm9yZGVyV2lkdGg6IGJveERlZmF1bHQuSE9WRVJfVEhJQ0tORVNTLCBib3JkZXJDb2xvcjogJyNmZmZmZmYnIH0sIGRvdDoge1xuICAgICAgICAgICAgICAgIHJhZGl1czogYm94cGxvdERlZmF1bHQuT1VUTElFUl9SQURJVVMsXG4gICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgdXNlU2VyaWVzQ29sb3I6IHRydWUsXG4gICAgICAgICAgICB9LCBsaW5lOiBPYmplY3QuYXNzaWduKHt9LCBib3hwbG90RGVmYXVsdC5MSU5FX1RZUEUpLCByZXN0U2VyaWVzOiB7XG4gICAgICAgICAgICAgICAgYXJlYU9wYWNpdHk6IDAuMixcbiAgICAgICAgICAgIH0sIGFyZWFPcGFjaXR5OiAxIH0pLFxuICAgIH0pLFxuICAgIHBpZTogKGdsb2JhbEZvbnRGYW1pbHksIHsgaGFzT3V0ZXJBbmNob3IgPSBmYWxzZSwgaGFzT3V0ZXJBbmNob3JQaWVTZXJpZXNOYW1lID0gZmFsc2UgfSwgaXNOZXN0ZWRQaWVDaGFydCA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHREYXRhTGFiZWxUaGVtZSA9IG1ha2VEZWZhdWx0RGF0YUxhYmVsc1RoZW1lKGdsb2JhbEZvbnRGYW1pbHkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXJlYU9wYWNpdHk6IDEsXG4gICAgICAgICAgICBzdHJva2VTdHlsZTogaXNOZXN0ZWRQaWVDaGFydCA/ICcjZmZmZmZmJyA6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDApJyxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogaXNOZXN0ZWRQaWVDaGFydCA/IDEgOiAwLFxuICAgICAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IERFRkFVTFRfUElFX0xJTkVfV0lEVEgsXG4gICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgICAgICBzaGFkb3dDb2xvcjogJyNjY2NjY2MnLFxuICAgICAgICAgICAgICAgIHNoYWRvd0JsdXI6IDUsXG4gICAgICAgICAgICAgICAgc2hhZG93T2Zmc2V0WDogMCxcbiAgICAgICAgICAgICAgICBzaGFkb3dPZmZzZXRZOiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogREVGQVVMVF9QSUVfTElORV9XSURUSCxcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogJyNmZmZmZmYnLFxuICAgICAgICAgICAgICAgIHNoYWRvd0NvbG9yOiAnI2NjY2NjYycsXG4gICAgICAgICAgICAgICAgc2hhZG93Qmx1cjogNSxcbiAgICAgICAgICAgICAgICBzaGFkb3dPZmZzZXRYOiAwLFxuICAgICAgICAgICAgICAgIHNoYWRvd09mZnNldFk6IDAsXG4gICAgICAgICAgICAgICAgcmVzdFNlcmllczoge1xuICAgICAgICAgICAgICAgICAgICBhcmVhT3BhY2l0eTogMC4zLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXJlYU9wYWNpdHk6IDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IGdsb2JhbEZvbnRGYW1pbHksXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDE2LFxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IDYwMCxcbiAgICAgICAgICAgICAgICBjb2xvcjogaGFzT3V0ZXJBbmNob3IgPyAnIzMzMzMzMycgOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICAgICAgdXNlU2VyaWVzQ29sb3I6IGhhc091dGVyQW5jaG9yLFxuICAgICAgICAgICAgICAgIHRleHRCdWJibGU6IE9iamVjdC5hc3NpZ24oe30sIG1ha2VEZWZhdWx0VGV4dEJ1YmJsZVRoZW1lKGZhbHNlLCAwKSksXG4gICAgICAgICAgICAgICAgY2FsbG91dDoge1xuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICAgIHVzZVNlcmllc0NvbG9yOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBsaW5lQ29sb3I6ICcjZTllOWU5JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBpZVNlcmllc05hbWU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdERhdGFMYWJlbFRoZW1lKSwgeyB1c2VTZXJpZXNDb2xvcjogaGFzT3V0ZXJBbmNob3JQaWVTZXJpZXNOYW1lLCBjb2xvcjogaGFzT3V0ZXJBbmNob3JQaWVTZXJpZXNOYW1lID8gJyMzMzMzMzMnIDogJyNmZmZmZmYnLCB0ZXh0QnViYmxlOiBPYmplY3QuYXNzaWduKHt9LCBtYWtlRGVmYXVsdFRleHRCdWJibGVUaGVtZShmYWxzZSwgMCkpIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHJhZGlhbEJhcjogKGdsb2JhbEZvbnRGYW1pbHkpID0+ICh7XG4gICAgICAgIGFyZWFPcGFjaXR5OiAxLFxuICAgICAgICBzdHJva2VTdHlsZTogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMCknLFxuICAgICAgICBsaW5lV2lkdGg6IDAsXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IERFRkFVTFRfUElFX0xJTkVfV0lEVEgsXG4gICAgICAgICAgICBzdHJva2VTdHlsZTogJyNmZmYnLFxuICAgICAgICAgICAgc2hhZG93Q29sb3I6ICcjY2NjY2NjJyxcbiAgICAgICAgICAgIHNoYWRvd0JsdXI6IDUsXG4gICAgICAgICAgICBzaGFkb3dPZmZzZXRYOiAwLFxuICAgICAgICAgICAgc2hhZG93T2Zmc2V0WTogMCxcbiAgICAgICAgICAgIGdyb3VwZWRTZWN0b3I6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuMDUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogREVGQVVMVF9QSUVfTElORV9XSURUSCxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlOiAnI2ZmZicsXG4gICAgICAgICAgICBzaGFkb3dDb2xvcjogJyNjY2NjY2MnLFxuICAgICAgICAgICAgc2hhZG93Qmx1cjogNSxcbiAgICAgICAgICAgIHNoYWRvd09mZnNldFg6IDAsXG4gICAgICAgICAgICBzaGFkb3dPZmZzZXRZOiAwLFxuICAgICAgICAgICAgcmVzdFNlcmllczoge1xuICAgICAgICAgICAgICAgIGFyZWFPcGFjaXR5OiAwLjMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJlYU9wYWNpdHk6IDEsXG4gICAgICAgICAgICBncm91cGVkU2VjdG9yOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgICBmb250RmFtaWx5OiBnbG9iYWxGb250RmFtaWx5LFxuICAgICAgICAgICAgZm9udFNpemU6IDExLFxuICAgICAgICAgICAgZm9udFdlaWdodDogNDAwLFxuICAgICAgICAgICAgY29sb3I6ICcjMzMzMzMzJyxcbiAgICAgICAgICAgIHVzZVNlcmllc0NvbG9yOiBmYWxzZSxcbiAgICAgICAgICAgIHRleHRCdWJibGU6IE9iamVjdC5hc3NpZ24oe30sIG1ha2VEZWZhdWx0VGV4dEJ1YmJsZVRoZW1lKGZhbHNlLCAwKSksXG4gICAgICAgIH0sXG4gICAgfSksXG4gICAgZ2F1Z2U6IChnbG9iYWxGb250RmFtaWx5KSA9PiAoe1xuICAgICAgICBhcmVhT3BhY2l0eTogMSxcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgIGNsb2NrSGFuZDogeyBiYXNlTGluZTogNSB9LFxuICAgICAgICAgICAgcGluOiB7IHJhZGl1czogNSwgYm9yZGVyV2lkdGg6IDUgfSxcbiAgICAgICAgICAgIHNvbGlkOiB7XG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiBERUZBVUxUX1BJRV9MSU5FX1dJRFRILFxuICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICAgICAgc2hhZG93Q29sb3I6ICcjY2NjY2NjJyxcbiAgICAgICAgICAgICAgICBzaGFkb3dCbHVyOiA1LFxuICAgICAgICAgICAgICAgIHNoYWRvd09mZnNldFg6IDAsXG4gICAgICAgICAgICAgICAgc2hhZG93T2Zmc2V0WTogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgY2xvY2tIYW5kOiB7IGJhc2VMaW5lOiA1IH0sXG4gICAgICAgICAgICBwaW46IHsgcmFkaXVzOiA2LCBib3JkZXJXaWR0aDogNCB9LFxuICAgICAgICAgICAgc29saWQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IERFRkFVTFRfUElFX0xJTkVfV0lEVEgsXG4gICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgICAgICBzaGFkb3dDb2xvcjogJyNjY2NjY2MnLFxuICAgICAgICAgICAgICAgIHNoYWRvd0JsdXI6IDUsXG4gICAgICAgICAgICAgICAgc2hhZG93T2Zmc2V0WDogMCxcbiAgICAgICAgICAgICAgICBzaGFkb3dPZmZzZXRZOiAwLFxuICAgICAgICAgICAgICAgIHJlc3RTZXJpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgYXJlYU9wYWNpdHk6IDAuMyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFyZWFPcGFjaXR5OiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZWFPcGFjaXR5OiAxLFxuICAgICAgICAgICAgcmVzdFNlcmllczogeyBhcmVhT3BhY2l0eTogMC4zIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGNsb2NrSGFuZDogeyBiYXNlTGluZTogNCB9LFxuICAgICAgICBwaW46IHsgcmFkaXVzOiA1LCBib3JkZXJXaWR0aDogNSB9LFxuICAgICAgICBzb2xpZDoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLFxuICAgICAgICAgICAgYmFja2dyb3VuZFNvbGlkOiB7IGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjEpJyB9LFxuICAgICAgICB9LFxuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgICBmb250RmFtaWx5OiBnbG9iYWxGb250RmFtaWx5LFxuICAgICAgICAgICAgZm9udFNpemU6IDExLFxuICAgICAgICAgICAgZm9udFdlaWdodDogNDAwLFxuICAgICAgICAgICAgY29sb3I6ICcjMzMzMzMzJyxcbiAgICAgICAgICAgIHVzZVNlcmllc0NvbG9yOiBmYWxzZSxcbiAgICAgICAgICAgIHRleHRCdWJibGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWFrZURlZmF1bHRUZXh0QnViYmxlVGhlbWUodHJ1ZSwgNCwgNCwgMykpLCB7IHNoYWRvd0NvbG9yOiAncmdiYSgwLCAwLCAwLCAwKScsIHNoYWRvd09mZnNldFk6IDAsIHNoYWRvd0JsdXI6IDAsIGJvcmRlckNvbG9yOiAnI2NjYycsIGJvcmRlcldpZHRoOiAxIH0pLFxuICAgICAgICB9LFxuICAgIH0pLFxufTtcbmZ1bmN0aW9uIGdldFNlcmllc1RoZW1lKGdsb2JhbEZvbnRGYW1pbHksIHNlcmllc05hbWUsIHBhcmFtRm9yUGllU2VyaWVzLCBpc05lc3RlZFBpZUNoYXJ0ID0gZmFsc2UpIHtcbiAgICBpZiAoc2VyaWVzTmFtZSA9PT0gJ3BpZScpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRUaGVtZU1ha2Vyc1tzZXJpZXNOYW1lXShnbG9iYWxGb250RmFtaWx5LCBwYXJhbUZvclBpZVNlcmllcywgaXNOZXN0ZWRQaWVDaGFydCk7XG4gICAgfVxuICAgIGlmIChpbmNsdWRlcyhbJ2J1YmJsZScsICdyYWRhcicsICdib3hQbG90J10sIHNlcmllc05hbWUpKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VGhlbWVNYWtlcnNbc2VyaWVzTmFtZV0oKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRUaGVtZU1ha2Vyc1tzZXJpZXNOYW1lXShnbG9iYWxGb250RmFtaWx5KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0VGhlbWUoc2VyaWVzLCBwaWVTZXJpZXNPdXRlckFuY2hvcnMsIGdsb2JhbEZvbnRGYW1pbHkgPSAnQXJpYWwnLCBpc05lc3RlZFBpZUNoYXJ0ID0gZmFsc2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3Qua2V5cyhzZXJpZXMpLnJlZHVjZSgoYWNjLCBzZXJpZXNOYW1lKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2MpLCB7IHNlcmllczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2Muc2VyaWVzKSwgeyBbc2VyaWVzTmFtZV06IGdldFNlcmllc1RoZW1lKGdsb2JhbEZvbnRGYW1pbHksIHNlcmllc05hbWUsIHBpZVNlcmllc091dGVyQW5jaG9ycykgfSkgfSkpLCBtYWtlRGVmYXVsdFRoZW1lKHNlcmllcywgZ2xvYmFsRm9udEZhbWlseSkpO1xuICAgIGlmIChpc05lc3RlZFBpZUNoYXJ0KSB7XG4gICAgICAgIGNvbnN0IGFsaWFzTmFtZXMgPSBnZXROZXN0ZWRQaWVDaGFydEFsaWFzTmFtZXMoc2VyaWVzKTtcbiAgICAgICAgcmVzdWx0LnNlcmllcy5waWUgPSBhbGlhc05hbWVzLnJlZHVjZSgoYWNjLCBjdXIpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHsgW2N1cl06IGdldFNlcmllc1RoZW1lKGdsb2JhbEZvbnRGYW1pbHksICdwaWUnLCBwaWVTZXJpZXNPdXRlckFuY2hvcnNbY3VyXSwgaXNOZXN0ZWRQaWVDaGFydCkgfSkpLCB7fSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQgeyBpc09iamVjdCB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgeyBpc1JhbmdlVmFsdWUgfSBmcm9tIFwiLi9yYW5nZVwiO1xuZnVuY3Rpb24gaXNCdWJibGVQb2ludFR5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuaGFzT3duUHJvcGVydHkoJ3InKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZVN0cmluZyh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBpZiAoaXNSYW5nZVZhbHVlKHZhbHVlKSkge1xuICAgICAgICByZXN1bHQgPSBgJHt2YWx1ZVswXX0gfiAke3ZhbHVlWzFdfWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0ID0gYCgke3ZhbHVlLnh9LCAke3ZhbHVlLnl9KWAgKyAoaXNCdWJibGVQb2ludFR5cGUodmFsdWUpID8gYCwgcjogJHt2YWx1ZS5yfWAgOiAnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0IHsgcGllVG9vbHRpcExhYmVsRm9ybWF0dGVyIH0gZnJvbSBcIi4vcGllU2VyaWVzXCI7XG5pbXBvcnQgeyBnZXRGb250U3R5bGVTdHJpbmcgfSBmcm9tIFwiLi9zdHlsZVwiO1xuaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgaXNSYW5nZVZhbHVlIH0gZnJvbSBcIi4vcmFuZ2VcIjtcbmZ1bmN0aW9uIGdldFNlcmllc05hbWVUZW1wbGF0ZShsYWJlbCwgY29sb3IpIHtcbiAgICByZXR1cm4gYDxzcGFuIGNsYXNzPVwidG9hc3R1aS1jaGFydC1zZXJpZXMtbmFtZVwiPlxuICAgIDxpIGNsYXNzPVwidG9hc3R1aS1jaGFydC1pY29uXCIgc3R5bGU9XCJiYWNrZ3JvdW5kOiAke2NvbG9yfVwiPjwvaT5cbiAgICA8c3BhbiBjbGFzcz1cInRvYXN0dWktY2hhcnQtbmFtZVwiPiR7bGFiZWx9PC9zcGFuPlxuICA8L3NwYW4+YDtcbn1cbmZ1bmN0aW9uIGdldFRpdGxlVmFsdWVUZW1wbGF0ZSh0aXRsZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gYDxkaXYgY2xhc3M9XCJ0b2FzdHVpLWNoYXJ0LXRvb2x0aXAtc2VyaWVzXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJ0b2FzdHVpLWNoYXJ0LXNlcmllcy1uYW1lXCI+JHt0aXRsZX08L3NwYW4+XG4gICAgPHNwYW4gY2xhc3M9XCJ0b2FzdHVpLWNoYXJ0LXNlcmllcy12YWx1ZVwiPiR7dmFsdWV9PC9zcGFuPlxuICA8L2Rpdj5gO1xufVxuZnVuY3Rpb24gZ2V0Q29sb3JWYWx1ZVRlbXBsYXRlKGNvbG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBgPGRpdiBjbGFzcz1cInRvYXN0dWktY2hhcnQtdG9vbHRpcC1zZXJpZXNcIj5cbiAgICA8aSBjbGFzcz1cInRvYXN0dWktY2hhcnQtaWNvblwiIHN0eWxlPVwiYmFja2dyb3VuZDogJHtjb2xvcn1cIj48L2k+XG4gICAgPHNwYW4gY2xhc3M9XCJ0b2FzdHVpLWNoYXJ0LXNlcmllcy12YWx1ZVwiPiR7dmFsdWV9PC9zcGFuPlxuICA8L2Rpdj5gO1xufVxuZnVuY3Rpb24gbWFrZUJ1bGxldERhdGFUZW1wbGF0ZShkYXRhLCB0aXRsZVR5cGUpIHtcbiAgICByZXR1cm4gZGF0YVxuICAgICAgICAuZmlsdGVyKCh7IHRpdGxlIH0pID0+IHRpdGxlID09PSB0aXRsZVR5cGUpXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGlmIChpc1JhbmdlVmFsdWUoYS52YWx1ZSkgJiYgaXNSYW5nZVZhbHVlKGIudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYS52YWx1ZVswXSAtIGIudmFsdWVbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKGEudmFsdWUpICYmIGlzTnVtYmVyKGIudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYS52YWx1ZSAtIGIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSlcbiAgICAgICAgLm1hcCgoeyBmb3JtYXR0ZWRWYWx1ZSwgY29sb3IgfSkgPT4gZ2V0Q29sb3JWYWx1ZVRlbXBsYXRlKGNvbG9yLCBmb3JtYXR0ZWRWYWx1ZSkpXG4gICAgICAgIC5qb2luKCcnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0VGVtcGxhdGUobW9kZWwsIHsgaGVhZGVyLCBib2R5IH0sIHRoZW1lKSB7XG4gICAgY29uc3QgeyBib3JkZXJDb2xvciwgYm9yZGVyV2lkdGgsIGJhY2tncm91bmQsIGJvcmRlclJhZGl1cywgYm9yZGVyU3R5bGUgfSA9IHRoZW1lO1xuICAgIGNvbnN0IHN0eWxlID0gYGJvcmRlcjogJHtib3JkZXJXaWR0aH1weCAke2JvcmRlclN0eWxlfSAke2JvcmRlckNvbG9yfTtib3JkZXItcmFkaXVzOiAke2JvcmRlclJhZGl1c31weDtiYWNrZ3JvdW5kOiAke2JhY2tncm91bmR9O2A7XG4gICAgcmV0dXJuIGA8ZGl2IGNsYXNzPVwidG9hc3R1aS1jaGFydC10b29sdGlwXCIgc3R5bGU9XCIke3N0eWxlfVwiPiR7aGVhZGVyfSR7Ym9keX08L2Rpdj5gO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEhlYWRlclRlbXBsYXRlKHsgY2F0ZWdvcnkgfSwgdGhlbWUpIHtcbiAgICByZXR1cm4gY2F0ZWdvcnlcbiAgICAgICAgPyBgPGRpdiBjbGFzcz1cInRvYXN0dWktY2hhcnQtdG9vbHRpcC1jYXRlZ29yeVwiIHN0eWxlPVwiJHtnZXRGb250U3R5bGVTdHJpbmcodGhlbWUuaGVhZGVyKX1cIj5cbiAgICAgICAgJHtjYXRlZ29yeX1cbiAgICAgIDwvZGl2PmBcbiAgICAgICAgOiAnJztcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRCb2R5VGVtcGxhdGUoeyBkYXRhIH0sIHRoZW1lKSB7XG4gICAgcmV0dXJuIGBcbiAgICA8ZGl2IGNsYXNzPVwidG9hc3R1aS1jaGFydC10b29sdGlwLXNlcmllcy13cmFwcGVyXCIgc3R5bGU9XCIke2dldEZvbnRTdHlsZVN0cmluZyh0aGVtZS5ib2R5KX1cIj5cbiAgICAgICR7ZGF0YVxuICAgICAgICAubWFwKCh7IGxhYmVsLCBjb2xvciwgZm9ybWF0dGVkVmFsdWUgfSkgPT4gYDxkaXYgY2xhc3M9XCJ0b2FzdHVpLWNoYXJ0LXRvb2x0aXAtc2VyaWVzXCI+XG4gICAgICAgICAgICAgICAgJHtnZXRTZXJpZXNOYW1lVGVtcGxhdGUobGFiZWwsIGNvbG9yKX1cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInRvYXN0dWktY2hhcnQtc2VyaWVzLXZhbHVlXCI+JHtmb3JtYXR0ZWRWYWx1ZX08L3NwYW4+XG4gICAgICAgICAgICAgIDwvZGl2PmApXG4gICAgICAgIC5qb2luKCcnKX1cbiAgICA8L2Rpdj5gO1xufVxuZnVuY3Rpb24gZ2V0Qm94UGxvdFRlbXBsYXRlKHsgZGF0YSB9LCB0aGVtZSkge1xuICAgIGNvbnN0IGdyb3VwZWREYXRhID0gZGF0YS5yZWR1Y2UoKGFjYywgaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKCFpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjYy5jYXRlZ29yeSA9PT0gaXRlbS5jYXRlZ29yeSAmJiBhY2MubGFiZWwgPT09IGl0ZW0ubGFiZWwpIHtcbiAgICAgICAgICAgIGFjYy52YWx1ZSA9IFsuLi5hY2MudmFsdWUsIC4uLml0ZW0udmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBgXG4gICAgPGRpdiBjbGFzcz1cInRvYXN0dWktY2hhcnQtdG9vbHRpcC1zZXJpZXMtd3JhcHBlclwiIHN0eWxlPVwiJHtnZXRGb250U3R5bGVTdHJpbmcodGhlbWUuYm9keSl9XCI+XG4gICAgICAke1tncm91cGVkRGF0YV1cbiAgICAgICAgLm1hcCgoeyBsYWJlbCwgY29sb3IsIHZhbHVlOiB2YWx1ZXMgfSkgPT4gYDxkaXYgY2xhc3M9XCJ0b2FzdHVpLWNoYXJ0LXRvb2x0aXAtc2VyaWVzXCI+XG4gICAgICAgICAgICAgICR7Z2V0U2VyaWVzTmFtZVRlbXBsYXRlKGxhYmVsLCBjb2xvcil9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgJHt2YWx1ZXNcbiAgICAgICAgLm1hcCgoeyB0aXRsZSwgZm9ybWF0dGVkVmFsdWUgfSkgPT4gZ2V0VGl0bGVWYWx1ZVRlbXBsYXRlKHRpdGxlLCBmb3JtYXR0ZWRWYWx1ZSkpXG4gICAgICAgIC5qb2luKCcnKX1cbiAgICAgICAgICAgIDwvZGl2PmApXG4gICAgICAgIC5qb2luKCcnKX1cbiAgICA8L2Rpdj5gO1xufVxuZnVuY3Rpb24gZ2V0QnVsbGV0VGVtcGxhdGUoeyBkYXRhIH0sIHRoZW1lKSB7XG4gICAgcmV0dXJuIGRhdGEubGVuZ3RoID4gMVxuICAgICAgICA/IGdldEJ1bGxldEdyb3VwZWRUZW1wbGF0ZShkYXRhLCB0aGVtZSlcbiAgICAgICAgOiBnZXRCdWxsZXRCYXNpY1RlbXBsYXRlKGRhdGEsIHRoZW1lKTtcbn1cbmZ1bmN0aW9uIGdldEJ1bGxldEJhc2ljVGVtcGxhdGUoZGF0YSwgdGhlbWUpIHtcbiAgICByZXR1cm4gYFxuICAgIDxkaXYgY2xhc3M9XCJ0b2FzdHVpLWNoYXJ0LXRvb2x0aXAtc2VyaWVzLXdyYXBwZXJcIiBzdHlsZT1cIiR7Z2V0Rm9udFN0eWxlU3RyaW5nKHRoZW1lLmJvZHkpfVwiPlxuICAgICAgJHtkYXRhXG4gICAgICAgIC5tYXAoKHsgbGFiZWwsIGNvbG9yLCB2YWx1ZTogdmFsdWVzIH0pID0+IGA8ZGl2IGNsYXNzPVwidG9hc3R1aS1jaGFydC10b29sdGlwLXNlcmllc1wiPiR7Z2V0U2VyaWVzTmFtZVRlbXBsYXRlKGxhYmVsLCBjb2xvcil9PC9kaXY+XG4gICAgICAgICAgICAke3ZhbHVlc1xuICAgICAgICAubWFwKCh7IHRpdGxlLCBmb3JtYXR0ZWRWYWx1ZSB9KSA9PiBnZXRUaXRsZVZhbHVlVGVtcGxhdGUodGl0bGUsIGZvcm1hdHRlZFZhbHVlKSlcbiAgICAgICAgLmpvaW4oJycpfWApXG4gICAgICAgIC5qb2luKCcnKX1cbiAgICA8L2Rpdj5gO1xufVxuZnVuY3Rpb24gZ2V0QnVsbGV0R3JvdXBlZFRlbXBsYXRlKGRhdGEsIHRoZW1lKSB7XG4gICAgY29uc3QgYnVsbGV0RGF0YSA9IGRhdGEubWFwKCh7IHZhbHVlIH0pID0+IHZhbHVlWzBdKTtcbiAgICBjb25zdCBbYWN0dWFsLCByYW5nZXMsIG1hcmtlcnNdID0gWydBY3R1YWwnLCAnUmFuZ2UnLCAnTWFya2VyJ10ubWFwKCh0aXRsZVR5cGUpID0+IG1ha2VCdWxsZXREYXRhVGVtcGxhdGUoYnVsbGV0RGF0YSwgdGl0bGVUeXBlKSk7XG4gICAgcmV0dXJuIGA8ZGl2IGNsYXNzPVwidG9hc3R1aS1jaGFydC10b29sdGlwLWNhdGVnb3J5XCIgc3R5bGU9XCIke2dldEZvbnRTdHlsZVN0cmluZyh0aGVtZS5oZWFkZXIpfVwiPlxuICAgICAgJHtkYXRhWzBdLmxhYmVsfVxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJ0b2FzdHVpLWNoYXJ0LXRvb2x0aXAtc2VyaWVzLXdyYXBwZXJcIiBzdHlsZT1cIiR7Z2V0Rm9udFN0eWxlU3RyaW5nKHRoZW1lLmJvZHkpfVwiPlxuICAgICAgJHthY3R1YWwgPyAnPGRpdiBjbGFzcz1cInRvYXN0dWktY2hhcnQtdG9vbHRpcC10aXRsZVwiPkFjdHVhbDwvZGl2PicgOiAnJ30gJHthY3R1YWx9XG4gICAgICAke3JhbmdlcyA/ICc8ZGl2IGNsYXNzPVwidG9hc3R1aS1jaGFydC10b29sdGlwLXRpdGxlXCI+UmFuZ2VzPC9kaXY+JyA6ICcnfSAke3Jhbmdlc31cbiAgICAgICR7bWFya2VycyA/ICc8ZGl2IGNsYXNzPVwidG9hc3R1aS1jaGFydC10b29sdGlwLXRpdGxlXCI+TWFya2VyczwvZGl2PicgOiAnJ30gJHttYXJrZXJzfVxuICAgIDwvZGl2PmA7XG59XG5mdW5jdGlvbiBnZXRQaWVUZW1wbGF0ZSh7IGRhdGEgfSwgdGhlbWUpIHtcbiAgICByZXR1cm4gYFxuICAgIDxkaXYgY2xhc3M9XCJ0b2FzdHVpLWNoYXJ0LXRvb2x0aXAtc2VyaWVzLXdyYXBwZXJcIiBzdHlsZT1cIiR7Z2V0Rm9udFN0eWxlU3RyaW5nKHRoZW1lLmJvZHkpfVwiPlxuICAgICAgJHtkYXRhXG4gICAgICAgIC5tYXAoKHsgbGFiZWwsIGNvbG9yLCBmb3JtYXR0ZWRWYWx1ZSwgcGVyY2VudFZhbHVlIH0pID0+IGA8ZGl2IGNsYXNzPVwidG9hc3R1aS1jaGFydC10b29sdGlwLXNlcmllc1wiPlxuICAgICAgICAgICR7Z2V0U2VyaWVzTmFtZVRlbXBsYXRlKGxhYmVsLCBjb2xvcil9XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0b2FzdHVpLWNoYXJ0LXNlcmllcy12YWx1ZVwiPiR7cGllVG9vbHRpcExhYmVsRm9ybWF0dGVyKHBlcmNlbnRWYWx1ZSl9Jm5ic3A7Jm5ic3A7KCR7Zm9ybWF0dGVkVmFsdWV9KTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+YClcbiAgICAgICAgLmpvaW4oJycpfVxuICAgIDwvZGl2PmA7XG59XG5mdW5jdGlvbiBnZXRIZWF0bWFwVGVtcGxhdGUoeyBkYXRhIH0sIHRoZW1lKSB7XG4gICAgcmV0dXJuIGAke2RhdGFcbiAgICAgICAgLm1hcCgoeyBsYWJlbCwgY29sb3IsIGZvcm1hdHRlZFZhbHVlIH0pID0+IGA8ZGl2IGNsYXNzPVwidG9hc3R1aS1jaGFydC10b29sdGlwLWNhdGVnb3J5XCIgc3R5bGU9XCIke2dldEZvbnRTdHlsZVN0cmluZyh0aGVtZS5oZWFkZXIpfVwiPlxuICAgICAgICAgICR7bGFiZWx9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwidG9hc3R1aS1jaGFydC10b29sdGlwLXNlcmllcy13cmFwcGVyXCIgc3R5bGU9XCIke2dldEZvbnRTdHlsZVN0cmluZyh0aGVtZS5ib2R5KX1cIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwidG9hc3R1aS1jaGFydC10b29sdGlwLXNlcmllc1wiPlxuICAgICAgICAgICAgJHtnZXRTZXJpZXNOYW1lVGVtcGxhdGUoZm9ybWF0dGVkVmFsdWUsIGNvbG9yKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+YClcbiAgICAgICAgLmpvaW4oJycpfWA7XG59XG5leHBvcnQgY29uc3QgdG9vbHRpcFRlbXBsYXRlcyA9IHtcbiAgICBkZWZhdWx0OiBnZXREZWZhdWx0VGVtcGxhdGUsXG4gICAgZGVmYXVsdEhlYWRlcjogZ2V0SGVhZGVyVGVtcGxhdGUsXG4gICAgZGVmYXVsdEJvZHk6IGdldERlZmF1bHRCb2R5VGVtcGxhdGUsXG4gICAgYm94UGxvdDogZ2V0Qm94UGxvdFRlbXBsYXRlLFxuICAgIGJ1bGxldDogZ2V0QnVsbGV0VGVtcGxhdGUsXG4gICAgcGllOiBnZXRQaWVUZW1wbGF0ZSxcbiAgICBoZWF0bWFwOiBnZXRIZWF0bWFwVGVtcGxhdGUsXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJvZHlUZW1wbGF0ZSh0eXBlKSB7XG4gICAgcmV0dXJuIHRvb2x0aXBUZW1wbGF0ZXNbdHlwZSB8fCAnZGVmYXVsdEJvZHknXTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBpc0V4aXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuICFpc1VuZGVmaW5lZCh2YWx1ZSkgJiYgIWlzTnVsbCh2YWx1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2gob2JqLCBjYikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGNiKG9ialtrZXldLCBrZXkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2hBcnJheShhcnIsIGl0ZXJhdGVlLCBjb250ZXh0ID0gbnVsbCkge1xuICAgIGZvciAobGV0IGluZGV4ID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaW5kZXggPCBsZW47IGluZGV4ICs9IDEpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGVlLmNhbGwoY29udGV4dCwgYXJyW2luZGV4XSwgaW5kZXgsIGFycikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5nZShzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChpc1VuZGVmaW5lZChzdG9wKSkge1xuICAgICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBzdGVwID0gc3RlcCB8fCAxO1xuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIGlmIChzdG9wKSB7XG4gICAgICAgIGNvbnN0IGZsYWcgPSBzdGVwIDwgMCA/IC0xIDogMTtcbiAgICAgICAgc3RvcCAqPSBmbGFnO1xuICAgICAgICBmb3IgKDsgc3RhcnQgKiBmbGFnIDwgc3RvcDsgc3RhcnQgKz0gc3RlcCkge1xuICAgICAgICAgICAgYXJyLnB1c2goc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheShhcnJheUxpa2UpIHtcbiAgICBsZXQgYXJyID0gW107XG4gICAgdHJ5IHtcbiAgICAgICAgYXJyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZm9yRWFjaEFycmF5KGFycmF5TGlrZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBhcnIucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGluY2x1ZGVzKGFyciwgc2VhcmNoSXRlbSwgc2VhcmNoSW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHNlYXJjaEluZGV4ID09PSAnbnVtYmVyJyAmJiBhcnJbc2VhcmNoSW5kZXhdICE9PSBzZWFyY2hJdGVtKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgICBpZiAoaXRlbSA9PT0gc2VhcmNoSXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBpY2sob2JqLCAuLi5wcm9wTmFtZXMpIHtcbiAgICBjb25zdCByZXN1bHRNYXAgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAoaW5jbHVkZXMocHJvcE5hbWVzLCBrZXkpKSB7XG4gICAgICAgICAgICByZXN1bHRNYXBba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdE1hcDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvbWl0KG9iaiwgLi4ucHJvcE5hbWVzKSB7XG4gICAgY29uc3QgcmVzdWx0TWFwID0ge307XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKCFpbmNsdWRlcyhwcm9wTmFtZXMsIGtleSkpIHtcbiAgICAgICAgICAgIHJlc3VsdE1hcFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0TWFwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBpY2tQcm9wZXJ0eSh0YXJnZXQsIGtleXMpIHtcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0ga2V5cztcbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh0YXJnZXQpIHx8IGlzTnVsbCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXRba2V5c1tpXV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwaWNrUHJvcGVydHlXaXRoTWFrZXVwKHRhcmdldCwgYXJncykge1xuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBhcmdzO1xuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRhcmdldFthcmdzW2ldXSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbYXJnc1tpXV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldFthcmdzW2ldXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlKGZuLCBkZWxheSA9IDApIHtcbiAgICBsZXQgdGltZXI7XG4gICAgZnVuY3Rpb24gZGVib3VuY2VkKC4uLmFyZ3MpIHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZm4oLi4uYXJncyk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlYm91bmNlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIC4uLmFyZ3MpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwge307XG4gICAgYXJncy5mb3JFYWNoKChvYmopID0+IHtcbiAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3JFYWNoKG9iaiwgKGl0ZW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVtKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlKHRhcmdldFtrZXldLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZShmbiwgaW50ZXJ2YWwgPSAwKSB7XG4gICAgbGV0IGJhc2UgPSBudWxsO1xuICAgIGxldCBpc0xlYWRpbmcgPSB0cnVlO1xuICAgIGNvbnN0IHRpY2sgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBmbiguLi5hcmdzKTtcbiAgICAgICAgYmFzZSA9IG51bGw7XG4gICAgfTtcbiAgICBsZXQgc3RhbXAgPSAwO1xuICAgIGNvbnN0IGRlYm91bmNlZCA9IGRlYm91bmNlKHRpY2ssIGludGVydmFsKTtcbiAgICBmdW5jdGlvbiB0aHJvdHRsZWQoLi4uYXJncykge1xuICAgICAgICBpZiAoaXNMZWFkaW5nKSB7XG4gICAgICAgICAgICB0aWNrKC4uLmFyZ3MpO1xuICAgICAgICAgICAgaXNMZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhbXAgPSBOdW1iZXIobmV3IERhdGUoKSk7XG4gICAgICAgIGJhc2UgPSBiYXNlIHx8IHN0YW1wO1xuICAgICAgICBkZWJvdW5jZWQoYXJncyk7XG4gICAgICAgIGlmIChzdGFtcCAtIGJhc2UgPj0gaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRpY2soYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgICAgICBpc0xlYWRpbmcgPSB0cnVlO1xuICAgICAgICBiYXNlID0gbnVsbDtcbiAgICB9XG4gICAgdGhyb3R0bGVkLnJlc2V0ID0gcmVzZXQ7XG4gICAgcmV0dXJuIHRocm90dGxlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWVwTWVyZ2VkQ29weSh0YXJnZXRPYmosIG9iaikge1xuICAgIGNvbnN0IHJlc3VsdE9iaiA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldE9iaik7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGlmIChpc09iamVjdChyZXN1bHRPYmpbcHJvcF0pKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0T2JqW3Byb3BdID0gZGVlcENvcHlBcnJheShvYmpbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0T2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0T2JqW3Byb3BdID0gZGVlcE1lcmdlZENvcHkocmVzdWx0T2JqW3Byb3BdLCBvYmpbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0T2JqW3Byb3BdID0gZGVlcENvcHkob2JqW3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdE9ialtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRPYmo7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVlcENvcHlBcnJheShpdGVtcykge1xuICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShpdGVtKSA/IGRlZXBDb3B5QXJyYXkoaXRlbSkgOiBkZWVwQ29weShpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ29weShvYmopIHtcbiAgICBjb25zdCByZXN1bHRPYmogPSB7fTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGtleXMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBpZiAoaXNPYmplY3Qob2JqW3Byb3BdKSkge1xuICAgICAgICAgICAgcmVzdWx0T2JqW3Byb3BdID0gQXJyYXkuaXNBcnJheShvYmpbcHJvcF0pID8gZGVlcENvcHlBcnJheShvYmpbcHJvcF0pIDogZGVlcENvcHkob2JqW3Byb3BdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdE9ialtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRPYmo7XG59XG5leHBvcnQgZnVuY3Rpb24gc29ydENhdGVnb3JpZXMoeCwgeSkge1xuICAgIHJldHVybiBpc0ludGVnZXIoeCkgPyBOdW1iZXIoeCkgLSBOdW1iZXIoeSkgOiBuZXcgRGF0ZSh4KS5nZXRUaW1lKCkgLSBuZXcgRGF0ZSh5KS5nZXRUaW1lKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gc29ydE51bWJlcih4LCB5KSB7XG4gICAgcmV0dXJuIHggLSB5O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0KGl0ZW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuICAgIHJldHVybiBpdGVtcy5sZW5ndGggPyBpdGVtc1swXSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsYXN0KGl0ZW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuICAgIHJldHVybiBpdGVtcy5sZW5ndGggPyBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNOZWdhdGl2ZSh2YWx1ZXMgPSBbXSkge1xuICAgIHJldHVybiB2YWx1ZXMuc29tZSgodmFsdWUpID0+IE51bWJlcih2YWx1ZSkgPCAwKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdW0oaXRlbXMpIHtcbiAgICByZXR1cm4gaXRlbXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzUG9zaXRpdmVPbmx5KHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMuZXZlcnkoKHZhbHVlKSA9PiBOdW1iZXIodmFsdWUpID49IDApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc05lZ2F0aXZlT25seSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLmV2ZXJ5KCh2YWx1ZSkgPT4gTnVtYmVyKHZhbHVlKSA8PSAwKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaXJzdFZhbGlkVmFsdWUodmFsdWVzKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB2YWx1ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maW5kKCh2YWx1ZSkgPT4gdmFsdWUgIT09IG51bGwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFBlcmNlbnRhZ2VWYWx1ZSh0ZXh0KSB7XG4gICAgcmV0dXJuIE51bWJlcih0ZXh0LnN1YnN0cigwLCB0ZXh0Lmxlbmd0aCAtIDEpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVTaXplV2l0aFBlcmNlbnRTdHJpbmcoc2l6ZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpID8gdmFsdWUgOiBOdW1iZXIoKChzaXplICogZ2V0UGVyY2VudGFnZVZhbHVlKHZhbHVlKSkgLyAxMDApLnRvRml4ZWQoMikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEluaXRpYWxTaXplKHNpemUpIHtcbiAgICByZXR1cm4gaXNOdW1iZXIoc2l6ZSkgPyBzaXplIDogMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dG9WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nO1xufVxuIiwiaW1wb3J0IHsgaXNOdW1iZXIsIGlzVW5kZWZpbmVkIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmV4cG9ydCBmdW5jdGlvbiBpc0F2YWlsYWJsZVNob3dUb29sdGlwSW5mbyhpbmZvLCBldmVudERldGVjdFR5cGUsIHRhcmdldENoYXJ0VHlwZSkge1xuICAgIGNvbnN0IHsgaW5kZXgsIHNlcmllc0luZGV4LCBjaGFydFR5cGUgfSA9IGluZm87XG4gICAgcmV0dXJuIChpc051bWJlcihpbmRleCkgJiZcbiAgICAgICAgKGV2ZW50RGV0ZWN0VHlwZSA9PT0gJ2dyb3VwZWQnIHx8IGlzTnVtYmVyKHNlcmllc0luZGV4KSkgJiZcbiAgICAgICAgKGlzVW5kZWZpbmVkKGNoYXJ0VHlwZSkgfHwgY2hhcnRUeXBlID09PSB0YXJnZXRDaGFydFR5cGUpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0F2YWlsYWJsZVNlbGVjdFNlcmllcyhpbmZvLCB0YXJnZXRDaGFydFR5cGUpIHtcbiAgICBjb25zdCB7IGluZGV4LCBzZXJpZXNJbmRleCwgY2hhcnRUeXBlIH0gPSBpbmZvO1xuICAgIHJldHVybiAoaXNOdW1iZXIoaW5kZXgpICYmXG4gICAgICAgIGlzTnVtYmVyKHNlcmllc0luZGV4KSAmJlxuICAgICAgICAoaXNVbmRlZmluZWQoY2hhcnRUeXBlKSB8fCBjaGFydFR5cGUgPT09IHRhcmdldENoYXJ0VHlwZSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9EYXRhKHNlcmllcykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzZXJpZXMpLnJlZHVjZSgoYWNjLCBjaGFydFR5cGUpID0+ICFzZXJpZXNbY2hhcnRUeXBlXS5kYXRhLmxlbmd0aCAmJiBhY2MsIHRydWUpO1xufVxuIiwiaW1wb3J0IExpbmVDaGFydCBmcm9tIFwiLi9jaGFydHMvbGluZUNoYXJ0XCI7XG5pbXBvcnQgUGllQ2hhcnQgZnJvbSBcIi4vY2hhcnRzL3BpZUNoYXJ0XCI7XG5pbXBvcnQgSGVhdG1hcENoYXJ0IGZyb20gXCIuL2NoYXJ0cy9oZWF0bWFwQ2hhcnRcIjtcbmltcG9ydCBBcmVhQ2hhcnQgZnJvbSBcIi4vY2hhcnRzL2FyZWFDaGFydFwiO1xuaW1wb3J0IExpbmVTY2F0dGVyQ2hhcnQgZnJvbSBcIi4vY2hhcnRzL2xpbmVTY2F0dGVyQ2hhcnRcIjtcbmltcG9ydCBMaW5lQXJlYUNoYXJ0IGZyb20gXCIuL2NoYXJ0cy9saW5lQXJlYUNoYXJ0XCI7XG5pbXBvcnQgQmFyQ2hhcnQgZnJvbSBcIi4vY2hhcnRzL2JhckNoYXJ0XCI7XG5pbXBvcnQgQ29sdW1uQ2hhcnQgZnJvbSBcIi4vY2hhcnRzL2NvbHVtbkNoYXJ0XCI7XG5pbXBvcnQgQ29sdW1uTGluZUNoYXJ0IGZyb20gXCIuL2NoYXJ0cy9jb2x1bW5MaW5lQ2hhcnRcIjtcbmltcG9ydCBCdWJibGVDaGFydCBmcm9tIFwiLi9jaGFydHMvYnViYmxlQ2hhcnRcIjtcbmltcG9ydCBTY2F0dGVyQ2hhcnQgZnJvbSBcIi4vY2hhcnRzL3NjYXR0ZXJDaGFydFwiO1xuaW1wb3J0IEJ1bGxldENoYXJ0IGZyb20gXCIuL2NoYXJ0cy9idWxsZXRDaGFydFwiO1xuaW1wb3J0IE5lc3RlZFBpZUNoYXJ0IGZyb20gXCIuL2NoYXJ0cy9uZXN0ZWRQaWVDaGFydFwiO1xuaW1wb3J0IFJhZGFyQ2hhcnQgZnJvbSBcIi4vY2hhcnRzL3JhZGFyQ2hhcnRcIjtcbmltcG9ydCBUcmVlbWFwQ2hhcnQgZnJvbSBcIi4vY2hhcnRzL3RyZWVtYXBDaGFydFwiO1xuaW1wb3J0IEJveFBsb3RDaGFydCBmcm9tIFwiLi9jaGFydHMvYm94UGxvdENoYXJ0XCI7XG5pbXBvcnQgUmFkaWFsQmFyQ2hhcnQgZnJvbSBcIi4vY2hhcnRzL3JhZGlhbEJhckNoYXJ0XCI7XG5pbXBvcnQgR2F1Z2VDaGFydCBmcm9tIFwiLi9jaGFydHMvZ2F1Z2VDaGFydFwiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhcnQge1xufVxuQ2hhcnQubGluZUNoYXJ0ID0gKHByb3BzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBMaW5lQ2hhcnQocHJvcHMpO1xufTtcbkNoYXJ0LmFyZWFDaGFydCA9IChwcm9wcykgPT4ge1xuICAgIHJldHVybiBuZXcgQXJlYUNoYXJ0KHByb3BzKTtcbn07XG5DaGFydC5iYXJDaGFydCA9IChwcm9wcykgPT4ge1xuICAgIHJldHVybiBuZXcgQmFyQ2hhcnQocHJvcHMpO1xufTtcbkNoYXJ0LmJveFBsb3RDaGFydCA9IChwcm9wcykgPT4ge1xuICAgIHJldHVybiBuZXcgQm94UGxvdENoYXJ0KHByb3BzKTtcbn07XG5DaGFydC5jb2x1bW5DaGFydCA9IChwcm9wcykgPT4ge1xuICAgIHJldHVybiBuZXcgQ29sdW1uQ2hhcnQocHJvcHMpO1xufTtcbkNoYXJ0LnBpZUNoYXJ0ID0gKHByb3BzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQaWVDaGFydChwcm9wcyk7XG59O1xuQ2hhcnQuaGVhdG1hcENoYXJ0ID0gKHByb3BzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBIZWF0bWFwQ2hhcnQocHJvcHMpO1xufTtcbkNoYXJ0LmJ1YmJsZUNoYXJ0ID0gKHByb3BzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBCdWJibGVDaGFydChwcm9wcyk7XG59O1xuQ2hhcnQuc2NhdHRlckNoYXJ0ID0gKHByb3BzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBTY2F0dGVyQ2hhcnQocHJvcHMpO1xufTtcbkNoYXJ0LmJ1bGxldENoYXJ0ID0gKHByb3BzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBCdWxsZXRDaGFydChwcm9wcyk7XG59O1xuQ2hhcnQucmFkYXJDaGFydCA9IChwcm9wcykgPT4ge1xuICAgIHJldHVybiBuZXcgUmFkYXJDaGFydChwcm9wcyk7XG59O1xuQ2hhcnQudHJlZW1hcENoYXJ0ID0gKHByb3BzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBUcmVlbWFwQ2hhcnQocHJvcHMpO1xufTtcbkNoYXJ0Lm5lc3RlZFBpZUNoYXJ0ID0gKHByb3BzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBOZXN0ZWRQaWVDaGFydChwcm9wcyk7XG59O1xuQ2hhcnQubGluZUFyZWFDaGFydCA9IChwcm9wcykgPT4ge1xuICAgIHJldHVybiBuZXcgTGluZUFyZWFDaGFydChwcm9wcyk7XG59O1xuQ2hhcnQubGluZVNjYXR0ZXJDaGFydCA9IChwcm9wcykgPT4ge1xuICAgIHJldHVybiBuZXcgTGluZVNjYXR0ZXJDaGFydChwcm9wcyk7XG59O1xuQ2hhcnQuY29sdW1uTGluZUNoYXJ0ID0gKHByb3BzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBDb2x1bW5MaW5lQ2hhcnQocHJvcHMpO1xufTtcbkNoYXJ0LnJhZGlhbEJhckNoYXJ0ID0gKHByb3BzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBSYWRpYWxCYXJDaGFydChwcm9wcyk7XG59O1xuQ2hhcnQuZ2F1Z2VDaGFydCA9IChwcm9wcykgPT4ge1xuICAgIHJldHVybiBuZXcgR2F1Z2VDaGFydChwcm9wcyk7XG59O1xuZXhwb3J0IHsgTGluZUNoYXJ0LCBBcmVhQ2hhcnQsIEJhckNoYXJ0LCBDb2x1bW5DaGFydCwgUGllQ2hhcnQsIEhlYXRtYXBDaGFydCwgQnViYmxlQ2hhcnQsIFNjYXR0ZXJDaGFydCwgQnVsbGV0Q2hhcnQsIFJhZGFyQ2hhcnQsIFRyZWVtYXBDaGFydCwgTmVzdGVkUGllQ2hhcnQsIExpbmVBcmVhQ2hhcnQsIExpbmVTY2F0dGVyQ2hhcnQsIENvbHVtbkxpbmVDaGFydCwgQm94UGxvdENoYXJ0LCBSYWRpYWxCYXJDaGFydCwgR2F1Z2VDaGFydCwgfTtcbiIsImV4cG9ydCBjb25zdCBtZXNzYWdlID0ge1xuICAgIFNFTEVDVF9TRVJJRVNfQVBJX1NFTEVDVEFCTEVfRVJST1I6ICdJdCB3b3JrcyBvbmx5IHdoZW4gdGhlIHNlbGVjdGFibGUgb3B0aW9uIGlzIHRydWUuJyxcbiAgICBTRUxFQ1RfU0VSSUVTX0FQSV9JTkRFWF9FUlJPUjogJ1RoZSBpbmRleCB2YWx1ZSBpcyBpbnZhbGlkLicsXG4gICAgQUxSRUFEWV9PQlNFUlZBQkxFX0VSUk9SOiAnU291cmNlIG9iamVjdCBpcyBvYnNlcnZhYmxlIGFscmVhZHknLFxuICAgIENJUkNMRV9MRUdFTkRfUkVOREVSX0VSUk9SOiAnY2lyY2xlTGVnZW5kIGlzIG9ubHkgcG9zc2libGUgd2hlbiBidWJibGUgc2VyaWVzIGlzIHByZXNlbnQnLFxuICAgIG5vRGF0YUVycm9yOiAoY2hhcnROYW1lKSA9PiBgVGhlcmUncyBubyAke2NoYXJ0TmFtZX0gZGF0YSFgLFxuICAgIG5vQnJ1c2hFcnJvcjogKGJydXNoTmFtZSkgPT4gYEJydXNoIGRvbid0IGV4aXN0IGluIHBhaW50ZXI6ICR7YnJ1c2hOYW1lfWAsXG4gICAgREFTSF9TRUdNRU5UU19VTkFWQUlMQUJMRV9FUlJPUjogJ0Rhc2hTZWdtZW50cyBvcHRpb24gaXMgYXZhaWxhYmxlIGZyb20gSUUxMSBhbmQgYWJvdmUuJyxcbiAgICBTRVJJRVNfSU5ERVhfRVJST1I6ICdUaGUgc2VyaWVzSW5kZXggdmFsdWUgaXMgaW52YWxpZCcsXG4gICAgQVVUT19MQVlPVVRfQ09OVEFJTkVSX1NJWkVfRVJST1I6ICdUbyB1c2UgYXV0byBsYXlvdXQsIHRoZSB3aWR0aCBvciBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lciBtdXN0IGJlIHNwZWNpZmllZCBhcyBhIHZhbHVlIHN1Y2ggYXMgXCIlXCIgb3IgXCJ2aFwiLCBcInZ3XCIuJyxcbn07XG4iLCJpbXBvcnQgeyBtZXNzYWdlIH0gZnJvbSBcIi4vbWVzc2FnZVwiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFpbnRlciB7XG4gICAgY29uc3RydWN0b3IoY2hhcnQpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5icnVzaGVzID0ge307XG4gICAgICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICB9XG4gICAgc2hvd1Vuc3VwcG9ydGVkQ2FudmFzRmVhdHVyZUVycm9yKCkge1xuICAgICAgICBpZiAoIXRoaXMuY3R4LnNldExpbmVEYXNoKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZS5EQVNIX1NFR01FTlRTX1VOQVZBSUxBQkxFX0VSUk9SKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXR1cCgpIHtcbiAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSB0aGlzLmNoYXJ0LnN0b3JlLnN0YXRlLmNoYXJ0O1xuICAgICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICAgICAgdGhpcy5jaGFydC5lbC5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jaGFydCk7XG4gICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5jaGFydCk7XG4gICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5jaGFydCk7XG4gICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuY2hhcnQpO1xuICAgICAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5jaGFydCk7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuc2hvd1Vuc3VwcG9ydGVkQ2FudmFzRmVhdHVyZUVycm9yKCk7XG4gICAgfVxuICAgIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9IGAke3dpZHRofXB4YDtcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDtcbiAgICAgICAgbGV0IHJhdGlvID0gMTtcbiAgICAgICAgaWYgKCdkZXZpY2VYRFBJJyBpbiB3aW5kb3cuc2NyZWVuKSB7XG4gICAgICAgICAgICAvLyBJRSBtb2JpbGUgb3IgSUVcbiAgICAgICAgICAgIHJhdGlvID1cbiAgICAgICAgICAgICAgICB3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgL1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnZGV2aWNlUGl4ZWxSYXRpbycpKSB7XG4gICAgICAgICAgICByYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHJhdGlvIHx8IDA7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcmF0aW8gfHwgMDtcbiAgICAgICAgdGhpcy5zY2FsZUNhbnZhc1JhdGlvKHJhdGlvKTtcbiAgICB9XG4gICAgc2NhbGVDYW52YXNSYXRpbyhyYXRpbykge1xuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLmN0eC5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgIH1cbiAgICBhZGQobmFtZSwgYnJ1c2gpIHtcbiAgICAgICAgdGhpcy5icnVzaGVzW25hbWVdID0gYnJ1c2g7XG4gICAgfVxuICAgIGFkZEdyb3Vwcyhncm91cHMpIHtcbiAgICAgICAgZ3JvdXBzLmZvckVhY2goKGdyb3VwKSA9PiB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhncm91cCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoa2V5LCBncm91cFtrZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFpbnQobmFtZSwgYnJ1c2hNb2RlbCkge1xuICAgICAgICBpZiAodGhpcy5icnVzaGVzW25hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLmJydXNoZXNbbmFtZV0odGhpcy5jdHgsIGJydXNoTW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2Uubm9CcnVzaEVycm9yKG5hbWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYWludEZvckVhY2goYnJ1c2hNb2RlbHMpIHtcbiAgICAgICAgYnJ1c2hNb2RlbHMuZm9yRWFjaCgobSkgPT4gdGhpcy5wYWludChtLnR5cGUsIG0pKTtcbiAgICB9XG4gICAgYmVmb3JlRnJhbWUoKSB7XG4gICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG4gICAgYmVmb3JlRHJhdyh0cmFuc1gsIHRyYW5zWSkge1xuICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSh0cmFuc1gsIHRyYW5zWSk7XG4gICAgfVxuICAgIGFmdGVyRHJhdygpIHtcbiAgICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSBcIi4vaGVscGVycy91dGlsc1wiO1xuaW1wb3J0IHsgY2FsY3VsYXRlUmFkaWFuVG9EZWdyZWUsIHdpdGhpblJhZGlhbiB9IGZyb20gXCIuL2hlbHBlcnMvc2VjdG9yXCI7XG5mdW5jdGlvbiB3aXRoaW5Sb3RhdGlvblJlY3QoeyBzbG9wZSwgeUludGVyY2VwdCwgbW91c2VYLCBtb3VzZVksIG1vZGVsWFBvc2l0aW9ucywgY29tcFgsIGNvbXBZLCBkZXRlY3Rpb25TaXplID0gMCwgfSkge1xuICAgIGNvbnN0IFt4MSwgeDJdID0gbW9kZWxYUG9zaXRpb25zO1xuICAgIGNvbnN0IHBvc1kgPSBzbG9wZSAqIChtb3VzZVggLSBjb21wWCkgKyB5SW50ZXJjZXB0O1xuICAgIGNvbnN0IHdpdGhpblJhZGl1cyA9ICh4MSA+IHgyICYmIG1vdXNlWCA+PSBjb21wWCArIHgyICYmIG1vdXNlWCA8PSBjb21wWCArIHgxKSB8fFxuICAgICAgICAoeDEgPCB4MiAmJiBtb3VzZVggPD0gY29tcFggKyB4MiAmJiBtb3VzZVggPj0gY29tcFggKyB4MSk7XG4gICAgY29uc3Qgd2l0aGluRGV0ZWN0aW9uU2l6ZSA9IHBvc1kgLSBkZXRlY3Rpb25TaXplICsgY29tcFkgPD0gbW91c2VZICYmIG1vdXNlWSA8PSBwb3NZICsgZGV0ZWN0aW9uU2l6ZSArIGNvbXBZO1xuICAgIHJldHVybiB3aXRoaW5SYWRpdXMgJiYgd2l0aGluRGV0ZWN0aW9uU2l6ZTtcbn1cbmV4cG9ydCBjb25zdCByZXNwb25kZXJEZXRlY3RvcnMgPSB7XG4gICAgY2lyY2xlOiAobW91c2VQb3NpdGlvbiwgbW9kZWwsIGNvbXBvbmVudFJlY3QpID0+IHtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBtb3VzZVBvc2l0aW9uO1xuICAgICAgICBjb25zdCB7IHg6IG1vZGVsWCwgeTogbW9kZWxZLCByYWRpdXMsIGRldGVjdGlvblNpemUgfSA9IG1vZGVsO1xuICAgICAgICBjb25zdCB7IHg6IGNvbXBYLCB5OiBjb21wWSB9ID0gY29tcG9uZW50UmVjdDtcbiAgICAgICAgY29uc3QgcmFkaXVzQWRqdXN0bWVudCA9IGlzVW5kZWZpbmVkKGRldGVjdGlvblNpemUpID8gMTAgOiBkZXRlY3Rpb25TaXplO1xuICAgICAgICByZXR1cm4gKE1hdGgucG93KCh4IC0gKG1vZGVsWCArIGNvbXBYKSksIDIpICsgTWF0aC5wb3coKHkgLSAobW9kZWxZICsgY29tcFkpKSwgMikgPCBNYXRoLnBvdygocmFkaXVzICsgcmFkaXVzQWRqdXN0bWVudCksIDIpKTtcbiAgICB9LFxuICAgIHJlY3Q6IChtb3VzZVBvc2l0aW9uLCBtb2RlbCwgY29tcG9uZW50UmVjdCA9IHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gbW91c2VQb3NpdGlvbjtcbiAgICAgICAgY29uc3QgeyB4OiBtb2RlbFgsIHk6IG1vZGVsWSwgd2lkdGgsIGhlaWdodCB9ID0gbW9kZWw7XG4gICAgICAgIGNvbnN0IHsgeDogY29tcFgsIHk6IGNvbXBZIH0gPSBjb21wb25lbnRSZWN0O1xuICAgICAgICByZXR1cm4gKHggPj0gbW9kZWxYICsgY29tcFggJiZcbiAgICAgICAgICAgIHggPD0gbW9kZWxYICsgY29tcFggKyB3aWR0aCAmJlxuICAgICAgICAgICAgeSA+PSBtb2RlbFkgKyBjb21wWSAmJlxuICAgICAgICAgICAgeSA8PSBtb2RlbFkgKyBjb21wWSArIGhlaWdodCk7XG4gICAgfSxcbiAgICBzZWN0b3I6IChtb3VzZVBvc2l0aW9uLCBtb2RlbCwgY29tcG9uZW50UmVjdCA9IHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gbW91c2VQb3NpdGlvbjtcbiAgICAgICAgY29uc3QgeyB4OiBtb2RlbFgsIHk6IG1vZGVsWSwgcmFkaXVzOiB7IG91dGVyLCBpbm5lciB9LCBkZWdyZWU6IHsgc3RhcnQsIGVuZCB9LCBkcmF3aW5nU3RhcnRBbmdsZSwgY2xvY2t3aXNlLCB9ID0gbW9kZWw7XG4gICAgICAgIGNvbnN0IHsgeDogY29tcFgsIHk6IGNvbXBZIH0gPSBjb21wb25lbnRSZWN0O1xuICAgICAgICBjb25zdCB4UG9zID0geCAtIChtb2RlbFggKyBjb21wWCk7XG4gICAgICAgIGNvbnN0IHlQb3MgPSB5IC0gKG1vZGVsWSArIGNvbXBZKTtcbiAgICAgICAgY29uc3QgaW5zaWRlT3V0ZXJSYWRpdXMgPSBNYXRoLnBvdyh4UG9zLCAyKSArIE1hdGgucG93KHlQb3MsIDIpIDwgTWF0aC5wb3cob3V0ZXIsIDIpO1xuICAgICAgICBjb25zdCBvdXRzaWRlSW5uZXJSYWRpdXMgPSBNYXRoLnBvdyh4UG9zLCAyKSArIE1hdGgucG93KHlQb3MsIDIpID4gTWF0aC5wb3coaW5uZXIsIDIpO1xuICAgICAgICBjb25zdCB3aXRoaW5SYWRpdXMgPSBpbnNpZGVPdXRlclJhZGl1cyAmJiBvdXRzaWRlSW5uZXJSYWRpdXM7XG4gICAgICAgIGNvbnN0IGRldGVjdGlvbkRlZ3JlZSA9IGNhbGN1bGF0ZVJhZGlhblRvRGVncmVlKE1hdGguYXRhbjIoeVBvcywgeFBvcyksIGRyYXdpbmdTdGFydEFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIHdpdGhpblJhZGl1cyAmJiB3aXRoaW5SYWRpYW4oY2xvY2t3aXNlLCBzdGFydCwgZW5kLCBkZXRlY3Rpb25EZWdyZWUpO1xuICAgIH0sXG4gICAgbGluZTogKG1vdXNlUG9zaXRpb24sIG1vZGVsLCBjb21wb25lbnRSZWN0ID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pID0+IHtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBtb3VzZVBvc2l0aW9uO1xuICAgICAgICBjb25zdCB7IHg6IGNvbXBYLCB5OiBjb21wWSB9ID0gY29tcG9uZW50UmVjdDtcbiAgICAgICAgY29uc3QgeyB4OiBtb2RlbFgsIHk6IG1vZGVsWSwgeDIsIHkyLCBkZXRlY3Rpb25TaXplID0gMyB9ID0gbW9kZWw7XG4gICAgICAgIGNvbnN0IG51bWVyYXRvciA9IHkyIC0gbW9kZWxZO1xuICAgICAgICBjb25zdCBkZW5vbWluYXRvciA9IHgyIC0gbW9kZWxYO1xuICAgICAgICBsZXQgd2l0aGluTGluZSA9IGZhbHNlO1xuICAgICAgICBpZiAobnVtZXJhdG9yID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBtaW5YID0gTWF0aC5taW4obW9kZWxYLCB4Mik7XG4gICAgICAgICAgICBjb25zdCBtYXhYID0gTWF0aC5tYXgobW9kZWxYLCB4Mik7XG4gICAgICAgICAgICB3aXRoaW5MaW5lID1cbiAgICAgICAgICAgICAgICB4IC0gY29tcFggPj0gbWluWCAmJlxuICAgICAgICAgICAgICAgICAgICB4IC0gY29tcFggPD0gbWF4WCAmJlxuICAgICAgICAgICAgICAgICAgICB5ID49IG1vZGVsWSArIGNvbXBZIC0gZGV0ZWN0aW9uU2l6ZSAmJlxuICAgICAgICAgICAgICAgICAgICB5IDw9IG1vZGVsWSArIGNvbXBZICsgZGV0ZWN0aW9uU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZW5vbWluYXRvciA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgbWluWSA9IE1hdGgubWluKG1vZGVsWSwgeTIpO1xuICAgICAgICAgICAgY29uc3QgbWF4WSA9IE1hdGgubWF4KG1vZGVsWSwgeTIpO1xuICAgICAgICAgICAgd2l0aGluTGluZSA9XG4gICAgICAgICAgICAgICAgeSAtIGNvbXBZID49IG1pblkgJiZcbiAgICAgICAgICAgICAgICAgICAgeSAtIGNvbXBZIDw9IG1heFkgJiZcbiAgICAgICAgICAgICAgICAgICAgeCA+PSBtb2RlbFggKyBjb21wWCAtIGRldGVjdGlvblNpemUgJiZcbiAgICAgICAgICAgICAgICAgICAgeCA8PSBtb2RlbFggKyBjb21wWCArIGRldGVjdGlvblNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzbG9wZSA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgY29uc3QgeFBvcyA9IHggLSAobW9kZWxYICsgY29tcFgpO1xuICAgICAgICAgICAgY29uc3QgeVBvcyA9IHkgLSAobW9kZWxZICsgY29tcFkpO1xuICAgICAgICAgICAgd2l0aGluTGluZSA9IHNsb3BlICogeFBvcyA9PT0geVBvcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2l0aGluTGluZTtcbiAgICB9LFxuICAgIGJveFBsb3Q6IChtb3VzZVBvc2l0aW9uLCBtb2RlbCwgY29tcG9uZW50UmVjdCA9IHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9KSA9PiB7XG4gICAgICAgIHJldHVybiBbJ3JlY3QnLCAnbWVkaWFuJywgJ21pbmltdW0nLCAnbWF4aW11bScsICd1cHBlcldoaXNrZXInLCAnbG93ZXJXaGlza2VyJ10uc29tZSgocHJvcCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFtb2RlbFtwcm9wXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9wID09PSAncmVjdCdcbiAgICAgICAgICAgICAgICA/IHJlc3BvbmRlckRldGVjdG9ycy5yZWN0KG1vdXNlUG9zaXRpb24sIG1vZGVsW3Byb3BdLCBjb21wb25lbnRSZWN0KVxuICAgICAgICAgICAgICAgIDogcmVzcG9uZGVyRGV0ZWN0b3JzLmxpbmUobW91c2VQb3NpdGlvbiwgbW9kZWxbcHJvcF0sIGNvbXBvbmVudFJlY3QpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGNsb2NrSGFuZDogKG1vdXNlUG9zaXRpb24sIG1vZGVsLCBjb21wb25lbnRSZWN0ID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pID0+IHtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBtb3VzZVBvc2l0aW9uO1xuICAgICAgICBjb25zdCB7IHg6IGNvbXBYLCB5OiBjb21wWSB9ID0gY29tcG9uZW50UmVjdDtcbiAgICAgICAgY29uc3QgeyB4OiBjZW50ZXJYLCB5OiBjZW50ZXJZLCB4MiwgeTIsIGRldGVjdGlvblNpemUgPSA1IH0gPSBtb2RlbDtcbiAgICAgICAgY29uc3QgbnVtZXJhdG9yID0geTIgLSBjZW50ZXJZO1xuICAgICAgICBjb25zdCBkZW5vbWluYXRvciA9IHgyIC0gY2VudGVyWDtcbiAgICAgICAgbGV0IHdpdGhpbkNsb2NrSGFuZCA9IGZhbHNlO1xuICAgICAgICBpZiAobnVtZXJhdG9yID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBtaW5YID0gTWF0aC5taW4oY2VudGVyWCwgeDIpO1xuICAgICAgICAgICAgY29uc3QgbWF4WCA9IE1hdGgubWF4KGNlbnRlclgsIHgyKTtcbiAgICAgICAgICAgIHdpdGhpbkNsb2NrSGFuZCA9XG4gICAgICAgICAgICAgICAgeCAtIGNvbXBYID49IG1pblggJiZcbiAgICAgICAgICAgICAgICAgICAgeCAtIGNvbXBYIDw9IG1heFggJiZcbiAgICAgICAgICAgICAgICAgICAgeSA+PSBjZW50ZXJZICsgY29tcFkgLSBkZXRlY3Rpb25TaXplICYmXG4gICAgICAgICAgICAgICAgICAgIHkgPD0gY2VudGVyWSArIGNvbXBZICsgZGV0ZWN0aW9uU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZW5vbWluYXRvciA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgbWluWSA9IE1hdGgubWluKGNlbnRlclksIHkyKTtcbiAgICAgICAgICAgIGNvbnN0IG1heFkgPSBNYXRoLm1heChjZW50ZXJZLCB5Mik7XG4gICAgICAgICAgICB3aXRoaW5DbG9ja0hhbmQgPVxuICAgICAgICAgICAgICAgIHkgLSBjb21wWSA+PSBtaW5ZICYmXG4gICAgICAgICAgICAgICAgICAgIHkgLSBjb21wWSA8PSBtYXhZICYmXG4gICAgICAgICAgICAgICAgICAgIHggPj0gY2VudGVyWCArIGNvbXBYIC0gZGV0ZWN0aW9uU2l6ZSAmJlxuICAgICAgICAgICAgICAgICAgICB4IDw9IGNlbnRlclggKyBjb21wWCArIGRldGVjdGlvblNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzbG9wZSA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgY29uc3QgeUludGVyY2VwdCA9IGNlbnRlclkgLSBzbG9wZSAqIGNlbnRlclg7XG4gICAgICAgICAgICB3aXRoaW5DbG9ja0hhbmQgPSB3aXRoaW5Sb3RhdGlvblJlY3Qoe1xuICAgICAgICAgICAgICAgIHNsb3BlLFxuICAgICAgICAgICAgICAgIHlJbnRlcmNlcHQsXG4gICAgICAgICAgICAgICAgbW91c2VYOiB4LFxuICAgICAgICAgICAgICAgIG1vdXNlWTogeSxcbiAgICAgICAgICAgICAgICBtb2RlbFhQb3NpdGlvbnM6IFtjZW50ZXJYLCB4Ml0sXG4gICAgICAgICAgICAgICAgY29tcFgsXG4gICAgICAgICAgICAgICAgY29tcFksXG4gICAgICAgICAgICAgICAgZGV0ZWN0aW9uU2l6ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aXRoaW5DbG9ja0hhbmQ7XG4gICAgfSxcbn07XG4iLCJpbXBvcnQgeyBpc051bWJlciB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBpc0RhdGVUeXBlIH0gZnJvbSBcIi4uL2hlbHBlcnMvYXhlc1wiO1xuaW1wb3J0IHsgQXhpc1R5cGUgfSBmcm9tIFwiLi4vY29tcG9uZW50L2F4aXNcIjtcbmNvbnN0IFNOQVBfVkFMVUVTID0gWzEsIDIsIDUsIDEwXTtcbmNvbnN0IERFRkFVTFRfUElYRUxTX1BFUl9TVEVQID0gODg7XG5mdW5jdGlvbiBhZGp1c3RMaW1pdEZvck92ZXJmbG93KHsgbWluLCBtYXggfSwgc3RlcFNpemUsIG92ZXJmbG93ZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtaW46IG92ZXJmbG93ZWQubWluID8gbWluIC0gc3RlcFNpemUgOiBtaW4sXG4gICAgICAgIG1heDogb3ZlcmZsb3dlZC5tYXggPyBtYXggKyBzdGVwU2l6ZSA6IG1heCxcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNTZXJpZXNPdmVyZmxvd2VkKHNjYWxlRGF0YSwgeyBtaW4sIG1heCB9LCBzY2FsZU9wdGlvbikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3Qgc2NhbGVEYXRhTGltaXQgPSBzY2FsZURhdGEubGltaXQ7XG4gICAgY29uc3QgaGFzTWluT3B0aW9uID0gaXNOdW1iZXIoKF9hID0gc2NhbGVPcHRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5taW4pO1xuICAgIGNvbnN0IGhhc01heE9wdGlvbiA9IGlzTnVtYmVyKChfYiA9IHNjYWxlT3B0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWF4KTtcbiAgICBjb25zdCBpc092ZXJmbG93ZWRNaW4gPSAhaGFzTWluT3B0aW9uICYmIHNjYWxlRGF0YUxpbWl0Lm1pbiA9PT0gbWluICYmIHNjYWxlRGF0YUxpbWl0Lm1pbiAhPT0gMDtcbiAgICBjb25zdCBpc092ZXJmbG93ZWRNYXggPSAhaGFzTWF4T3B0aW9uICYmIHNjYWxlRGF0YUxpbWl0Lm1heCA9PT0gbWF4ICYmIHNjYWxlRGF0YUxpbWl0Lm1heCAhPT0gMDtcbiAgICBpZiAoIWlzT3ZlcmZsb3dlZE1pbiAmJiAhaXNPdmVyZmxvd2VkTWF4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtaW46IGlzT3ZlcmZsb3dlZE1pbixcbiAgICAgICAgbWF4OiBpc092ZXJmbG93ZWRNYXgsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERpZ2l0cyhudW0pIHtcbiAgICBjb25zdCBsb2dOdW1iZXJEaXZpZGVkTE4xMCA9IG51bSA9PT0gMCA/IDEgOiBNYXRoLmxvZyhNYXRoLmFicyhudW0pKSAvIE1hdGguTE4xMDtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nTnVtYmVyRGl2aWRlZExOMTApKTtcbn1cbmZ1bmN0aW9uIGdldFNuYXBwZWROdW1iZXIobnVtKSB7XG4gICAgbGV0IHNuYXBOdW1iZXIgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCB0ID0gU05BUF9WQUxVRVMubGVuZ3RoOyBpIDwgdDsgaSArPSAxKSB7XG4gICAgICAgIHNuYXBOdW1iZXIgPSBTTkFQX1ZBTFVFU1tpXTtcbiAgICAgICAgY29uc3QgZ3VpZGVWYWx1ZSA9IChzbmFwTnVtYmVyICsgKFNOQVBfVkFMVUVTW2kgKyAxXSB8fCBzbmFwTnVtYmVyKSkgLyAyO1xuICAgICAgICBpZiAobnVtIDw9IGd1aWRlVmFsdWUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbmFwTnVtYmVyO1xufVxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZFN0ZXAoc3RlcFNpemUpIHtcbiAgICBjb25zdCBwbGFjZU51bWJlciA9IGdldERpZ2l0cyhzdGVwU2l6ZSk7XG4gICAgY29uc3Qgc2ltcGxpZmllZFN0ZXBWYWx1ZSA9IHN0ZXBTaXplIC8gcGxhY2VOdW1iZXI7XG4gICAgcmV0dXJuIGdldFNuYXBwZWROdW1iZXIoc2ltcGxpZmllZFN0ZXBWYWx1ZSkgKiBwbGFjZU51bWJlcjtcbn1cbi8qKlxuICogR2V0IG5vcm1hbGl6ZWQgbGltaXQgdmFsdWVzXG4gKiBtYXggPSAxNTUgYW5kIHN0ZXAgPSAxMCAtLS0+IG1heCA9IDE2MFxuICovXG5mdW5jdGlvbiBnZXROb3JtYWxpemVkTGltaXQobGltaXQsIHN0ZXBTaXplKSB7XG4gICAgbGV0IHsgbWluLCBtYXggfSA9IGxpbWl0O1xuICAgIGNvbnN0IG1pbk51bWJlciA9IE1hdGgubWluKGdldERpZ2l0cyhtYXgpLCBnZXREaWdpdHMoc3RlcFNpemUpKTtcbiAgICBjb25zdCBwbGFjZU51bWJlciA9IG1pbk51bWJlciA+IDEgPyAxIDogMSAvIG1pbk51bWJlcjtcbiAgICBjb25zdCBmaXhlZFN0ZXAgPSBzdGVwU2l6ZSAqIHBsYWNlTnVtYmVyO1xuICAgIC8vIGNlaWwgbWF4IHZhbHVlIHN0ZXAgZGlnaXRzXG4gICAgbWF4ID0gKE1hdGguY2VpbCgobWF4ICogcGxhY2VOdW1iZXIpIC8gZml4ZWRTdGVwKSAqIGZpeGVkU3RlcCkgLyBwbGFjZU51bWJlcjtcbiAgICBpZiAobWluID4gc3RlcFNpemUpIHtcbiAgICAgICAgLy8gZmxvb3IgbWluIHZhbHVlIHRvIG11bHRpcGxlcyBvZiBzdGVwXG4gICAgICAgIG1pbiA9IChNYXRoLmZsb29yKChtaW4gKiBwbGFjZU51bWJlcikgLyBmaXhlZFN0ZXApICogZml4ZWRTdGVwKSAvIHBsYWNlTnVtYmVyO1xuICAgIH1cbiAgICBlbHNlIGlmIChtaW4gPCAwKSB7XG4gICAgICAgIG1pbiA9IC0oTWF0aC5jZWlsKChNYXRoLmFicyhtaW4pICogcGxhY2VOdW1iZXIpIC8gZml4ZWRTdGVwKSAqIGZpeGVkU3RlcCkgLyBwbGFjZU51bWJlcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiB7IG1pbiwgbWF4IH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZFN0ZXBDb3VudChsaW1pdFNpemUsIHN0ZXBTaXplKSB7XG4gICAgY29uc3QgbXVsdGlwbGllciA9IDEgLyBNYXRoLm1pbihnZXREaWdpdHMobGltaXRTaXplKSwgZ2V0RGlnaXRzKHN0ZXBTaXplKSk7XG4gICAgcmV0dXJuIE1hdGguY2VpbCgobGltaXRTaXplICogbXVsdGlwbGllcikgLyAoc3RlcFNpemUgKiBtdWx0aXBsaWVyKSk7XG59XG5mdW5jdGlvbiBoYXNTdGVwU2l6ZShzdGVwU2l6ZSkge1xuICAgIHJldHVybiBpc051bWJlcihzdGVwU2l6ZSk7XG59XG5mdW5jdGlvbiBnZXROb3JtYWxpemVkU2NhbGUoc2NhbGVEYXRhLCBzY2FsZSkge1xuICAgIGNvbnN0IHN0ZXBTaXplID0gaGFzU3RlcFNpemUoc2NhbGUuc3RlcFNpemUpXG4gICAgICAgID8gc2NhbGVEYXRhLnN0ZXBTaXplXG4gICAgICAgIDogZ2V0Tm9ybWFsaXplZFN0ZXAoc2NhbGVEYXRhLnN0ZXBTaXplKTtcbiAgICBjb25zdCBlZGdlID0gZ2V0Tm9ybWFsaXplZExpbWl0KHNjYWxlRGF0YS5saW1pdCwgc3RlcFNpemUpO1xuICAgIGNvbnN0IGxpbWl0U2l6ZSA9IE1hdGguYWJzKGVkZ2UubWF4IC0gZWRnZS5taW4pO1xuICAgIGNvbnN0IHN0ZXBDb3VudCA9IGdldE5vcm1hbGl6ZWRTdGVwQ291bnQobGltaXRTaXplLCBzdGVwU2l6ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGltaXQ6IHtcbiAgICAgICAgICAgIG1pbjogZWRnZS5taW4sXG4gICAgICAgICAgICBtYXg6IGVkZ2UubWF4LFxuICAgICAgICB9LFxuICAgICAgICBzdGVwU2l6ZSxcbiAgICAgICAgc3RlcENvdW50LFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRSb3VnaFNjYWxlKHNjYWxlLCBvZmZzZXRTaXplLCBtaW5TdGVwU2l6ZSA9IDEpIHtcbiAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSBzY2FsZTtcbiAgICBjb25zdCBsaW1pdFNpemUgPSBNYXRoLmFicyhtYXggLSBtaW4pO1xuICAgIGNvbnN0IHZhbHVlUGVyUGl4ZWwgPSBsaW1pdFNpemUgLyBvZmZzZXRTaXplO1xuICAgIGxldCBzdGVwQ291bnQgPSBNYXRoLmNlaWwob2Zmc2V0U2l6ZSAvIERFRkFVTFRfUElYRUxTX1BFUl9TVEVQKTtcbiAgICBjb25zdCBwaXhlbHNQZXJTdGVwID0gb2Zmc2V0U2l6ZSAvIHN0ZXBDb3VudDtcbiAgICBsZXQgc3RlcFNpemUgPSB2YWx1ZVBlclBpeGVsICogcGl4ZWxzUGVyU3RlcDtcbiAgICBpZiAoaGFzU3RlcFNpemUoc2NhbGUuc3RlcFNpemUpKSB7XG4gICAgICAgIHN0ZXBTaXplID0gc2NhbGUuc3RlcFNpemU7XG4gICAgICAgIHN0ZXBDb3VudCA9IGxpbWl0U2l6ZSAvIHN0ZXBTaXplO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc051bWJlcihtaW5TdGVwU2l6ZSkgJiYgc3RlcFNpemUgPCBtaW5TdGVwU2l6ZSkge1xuICAgICAgICBzdGVwU2l6ZSA9IG1pblN0ZXBTaXplO1xuICAgICAgICBzdGVwQ291bnQgPSBsaW1pdFNpemUgLyBzdGVwU2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbGltaXQ6IHsgbWluLCBtYXggfSwgc3RlcFNpemUsIHN0ZXBDb3VudCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VTY2FsZU9wdGlvbihkYXRhUmFuZ2UsIHNjYWxlT3B0aW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1heDogKF9iID0gKF9hID0gc2NhbGVPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF4LCAoX2IgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGF0YVJhbmdlLm1heCkpLFxuICAgICAgICBtaW46IChfZCA9IChfYyA9IHNjYWxlT3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1pbiwgKF9kICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRhdGFSYW5nZS5taW4pKSxcbiAgICAgICAgc3RlcFNpemU6IChfZiA9IChfZSA9IHNjYWxlT3B0aW9ucykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnN0ZXBTaXplLCAoX2YgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogJ2F1dG8nKSksXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVDb29yZGluYXRlU2NhbGUob3B0aW9ucykge1xuICAgIGNvbnN0IHsgZGF0YVJhbmdlLCBzY2FsZU9wdGlvbiwgb2Zmc2V0U2l6ZSwgbWluU3RlcFNpemUsIHVzZVNwZWN0cnVtTGVnZW5kIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHNjYWxlID0gbWFrZVNjYWxlT3B0aW9uKGRhdGFSYW5nZSwgc2NhbGVPcHRpb24pO1xuICAgIGNvbnN0IHJvdWdoU2NhbGUgPSBnZXRSb3VnaFNjYWxlKHNjYWxlLCBvZmZzZXRTaXplLCBtaW5TdGVwU2l6ZSk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFNjYWxlID0gZ2V0Tm9ybWFsaXplZFNjYWxlKHJvdWdoU2NhbGUsIHNjYWxlKTtcbiAgICBjb25zdCBvdmVyZmxvd2VkID0gdXNlU3BlY3RydW1MZWdlbmRcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogaXNTZXJpZXNPdmVyZmxvd2VkKG5vcm1hbGl6ZWRTY2FsZSwgc2NhbGUsIHNjYWxlT3B0aW9uKTtcbiAgICBpZiAob3ZlcmZsb3dlZCkge1xuICAgICAgICBjb25zdCB7IHN0ZXBTaXplLCBsaW1pdCB9ID0gbm9ybWFsaXplZFNjYWxlO1xuICAgICAgICBub3JtYWxpemVkU2NhbGUubGltaXQgPSBhZGp1c3RMaW1pdEZvck92ZXJmbG93KGxpbWl0LCBzdGVwU2l6ZSwgb3ZlcmZsb3dlZCk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkU2NhbGU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhY2tTY2FsZURhdGEodHlwZSkge1xuICAgIGlmICh0eXBlID09PSAnbWludXNQZXJjZW50U3RhY2snKSB7XG4gICAgICAgIHJldHVybiB7IGxpbWl0OiB7IG1pbjogLTEwMCwgbWF4OiAwIH0sIHN0ZXBTaXplOiAyNSwgc3RlcENvdW50OiA1IH07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnZHVhbFBlcmNlbnRTdGFjaycpIHtcbiAgICAgICAgcmV0dXJuIHsgbGltaXQ6IHsgbWluOiAtMTAwLCBtYXg6IDEwMCB9LCBzdGVwU2l6ZTogMjUsIHN0ZXBDb3VudDogOSB9O1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2RpdmVyZ2luZ1BlcmNlbnRTdGFjaycpIHtcbiAgICAgICAgcmV0dXJuIHsgbGltaXQ6IHsgbWluOiAtMTAwLCBtYXg6IDEwMCB9LCBzdGVwU2l6ZTogMjUsIHN0ZXBDb3VudDogOSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBsaW1pdDogeyBtaW46IDAsIG1heDogMTAwIH0sIHN0ZXBTaXplOiAyNSwgc3RlcENvdW50OiA1IH07XG59XG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlWEF4aXNTY2FsZUZvckNvb3JkaW5hdGVMaW5lVHlwZShzY2FsZSwgb3B0aW9ucywgY2F0ZWdvcmllcykge1xuICAgIGNvbnN0IGRhdGVUeXBlID0gaXNEYXRlVHlwZShvcHRpb25zLCBBeGlzVHlwZS5YKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBjYXRlZ29yaWVzLm1hcCgodmFsdWUpID0+IChkYXRlVHlwZSA/IE51bWJlcihuZXcgRGF0ZSh2YWx1ZSkpIDogTnVtYmVyKHZhbHVlKSkpO1xuICAgIGNvbnN0IHsgbGltaXQsIHN0ZXBTaXplIH0gPSBzY2FsZTtcbiAgICBjb25zdCBtaW4gPSBNYXRoLm1pbiguLi52YWx1ZXMpO1xuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLnZhbHVlcyk7XG4gICAgY29uc3QgbmV3TGltaXQgPSBPYmplY3QuYXNzaWduKHt9LCBsaW1pdCk7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBtYXggLSBtaW47XG4gICAgbGV0IHBvc2l0aW9uUmF0aW8gPSAwO1xuICAgIGxldCBzaXplUmF0aW8gPSAxO1xuICAgIGlmIChkaXN0YW5jZSkge1xuICAgICAgICBpZiAobGltaXQubWluIDwgbWluKSB7XG4gICAgICAgICAgICBuZXdMaW1pdC5taW4gKz0gc3RlcFNpemU7XG4gICAgICAgICAgICBwb3NpdGlvblJhdGlvID0gKG5ld0xpbWl0Lm1pbiAtIG1pbikgLyBkaXN0YW5jZTtcbiAgICAgICAgICAgIHNpemVSYXRpbyAtPSBwb3NpdGlvblJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdC5tYXggPiBtYXgpIHtcbiAgICAgICAgICAgIG5ld0xpbWl0Lm1heCAtPSBzdGVwU2l6ZTtcbiAgICAgICAgICAgIHNpemVSYXRpbyAtPSAobWF4IC0gbmV3TGltaXQubWF4KSAvIGRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0U2l6ZSA9IE1hdGguYWJzKG5ld0xpbWl0Lm1heCAtIG5ld0xpbWl0Lm1pbik7XG4gICAgY29uc3QgbmV3U3RlcENvdW50ID0gZ2V0Tm9ybWFsaXplZFN0ZXBDb3VudChsaW1pdFNpemUsIHN0ZXBTaXplKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsaW1pdDogbmV3TGltaXQsXG4gICAgICAgIHN0ZXBDb3VudDogbmV3U3RlcENvdW50LFxuICAgICAgICBzdGVwU2l6ZSxcbiAgICAgICAgcG9zaXRpb25SYXRpbyxcbiAgICAgICAgc2l6ZVJhdGlvLFxuICAgIH07XG59XG4iLCJpbXBvcnQgeyBpc0V4aXN0LCBvbWl0IH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmltcG9ydCB7IGFkZCwgbXVsdGlwbHksIGRpdmlkZSB9IGZyb20gXCIuLi9oZWxwZXJzL2NhbGN1bGF0b3JcIjtcbmltcG9ydCB7IGNhbGN1bGF0ZUNvb3JkaW5hdGVTY2FsZSwgbWFrZVNjYWxlT3B0aW9uIH0gZnJvbSBcIi4vY29vcmRpbmF0ZVNjYWxlQ2FsY3VsYXRvclwiO1xuY29uc3QgbXNNYXAgPSB7XG4gICAgeWVhcjogMzE1MzYwMDAwMDAsXG4gICAgbW9udGg6IDI2Nzg0MDAwMDAsXG4gICAgd2VlazogNjA0ODAwMDAwLFxuICAgIGRhdGU6IDg2NDAwMDAwLFxuICAgIGhvdXI6IDM2MDAwMDAsXG4gICAgbWludXRlOiA2MDAwMCxcbiAgICBzZWNvbmQ6IDEwMDAsXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZURhdGV0aW1lU2NhbGUob3B0aW9ucykge1xuICAgIGNvbnN0IHsgZGF0YVJhbmdlLCByYXdDYXRlZ29yaWVzU2l6ZSwgc2NhbGVPcHRpb24gfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZGF0ZXRpbWVJbmZvID0gbWFrZURhdGV0aW1lSW5mbyhkYXRhUmFuZ2UsIHJhd0NhdGVnb3JpZXNTaXplLCBzY2FsZU9wdGlvbik7XG4gICAgY29uc3QgeyBtaW5EYXRlLCBkaXZpc2lvbk51bWJlciwgbGltaXQgfSA9IGRhdGV0aW1lSW5mbztcbiAgICBjb25zdCBzY2FsZSA9IGNhbGN1bGF0ZUNvb3JkaW5hdGVTY2FsZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9taXQob3B0aW9ucywgJ3NjYWxlT3B0aW9uJykpLCB7IGRhdGFSYW5nZTogbGltaXQsIG1pblN0ZXBTaXplOiAxIH0pKTtcbiAgICByZXR1cm4gcmVzdG9yZVNjYWxlVG9EYXRldGltZVR5cGUoc2NhbGUsIG1pbkRhdGUsIGRpdmlzaW9uTnVtYmVyKTtcbn1cbmNvbnN0IG1zVHlwZXMgPSBbJ3llYXInLCAnbW9udGgnLCAnd2VlaycsICdkYXRlJywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCddO1xuZnVuY3Rpb24gcmVzdG9yZVNjYWxlVG9EYXRldGltZVR5cGUoc2NhbGUsIG1pbkRhdGUsIGRpdmlzaW9uTnVtYmVyKSB7XG4gICAgY29uc3QgeyBsaW1pdCwgc3RlcFNpemUgfSA9IHNjYWxlO1xuICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IGxpbWl0O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNjYWxlKSwgeyBzdGVwU2l6ZTogbXVsdGlwbHkoc3RlcFNpemUsIGRpdmlzaW9uTnVtYmVyKSwgbGltaXQ6IHtcbiAgICAgICAgICAgIG1pbjogbXVsdGlwbHkoYWRkKG1pbiwgbWluRGF0ZSksIGRpdmlzaW9uTnVtYmVyKSxcbiAgICAgICAgICAgIG1heDogbXVsdGlwbHkoYWRkKG1heCwgbWluRGF0ZSksIGRpdmlzaW9uTnVtYmVyKSxcbiAgICAgICAgfSB9KTtcbn1cbmZ1bmN0aW9uIG1ha2VEYXRldGltZUluZm8obGltaXQsIGNvdW50LCBzY2FsZU9wdGlvbikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZGF0ZVR5cGUgPSBmaW5kRGF0ZVR5cGUobGltaXQsIGNvdW50KTtcbiAgICBjb25zdCBkaXZpc2lvbk51bWJlciA9IChfYiA9IChfYSA9IHNjYWxlT3B0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RlcFNpemUsIChfYiAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBtc01hcFtkYXRlVHlwZV0pKTtcbiAgICBjb25zdCBzY2FsZSA9IG1ha2VTY2FsZU9wdGlvbihsaW1pdCwgc2NhbGVPcHRpb24pO1xuICAgIGNvbnN0IG1pbkRhdGUgPSBkaXZpZGUoTnVtYmVyKG5ldyBEYXRlKHNjYWxlLm1pbikpLCBkaXZpc2lvbk51bWJlcik7XG4gICAgY29uc3QgbWF4RGF0ZSA9IGRpdmlkZShOdW1iZXIobmV3IERhdGUoc2NhbGUubWF4KSksIGRpdmlzaW9uTnVtYmVyKTtcbiAgICByZXR1cm4geyBkaXZpc2lvbk51bWJlciwgbWluRGF0ZSwgbGltaXQ6IHsgbWluOiAwLCBtYXg6IG1heERhdGUgLSBtaW5EYXRlIH0gfTtcbn1cbmZ1bmN0aW9uIGZpbmREYXRlVHlwZSh7IG1heCwgbWluIH0sIGNvdW50KSB7XG4gICAgY29uc3QgZGlmZiA9IG1heCAtIG1pbjtcbiAgICBjb25zdCBsYXN0VHlwZUluZGV4ID0gbXNUeXBlcy5sZW5ndGggLSAxO1xuICAgIGxldCBmb3VuZFR5cGU7XG4gICAgaWYgKGRpZmYpIHtcbiAgICAgICAgbXNUeXBlcy5ldmVyeSgodHlwZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kID0gbXNNYXBbdHlwZV07XG4gICAgICAgICAgICBjb25zdCBkaXZpZGVkQ291bnQgPSBNYXRoLmZsb29yKGRpZmYgLyBtaWxsaXNlY29uZCk7XG4gICAgICAgICAgICBsZXQgZm91bmRJbmRleDtcbiAgICAgICAgICAgIGlmIChkaXZpZGVkQ291bnQpIHtcbiAgICAgICAgICAgICAgICBmb3VuZEluZGV4ID1cbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPCBsYXN0VHlwZUluZGV4ICYmIGRpdmlkZWRDb3VudCA8IDIgJiYgZGl2aWRlZENvdW50IDwgY291bnQgPyBpbmRleCArIDEgOiBpbmRleDtcbiAgICAgICAgICAgICAgICBmb3VuZFR5cGUgPSBtc1R5cGVzW2ZvdW5kSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFpc0V4aXN0KGZvdW5kSW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvdW5kVHlwZSA9ICdzZWNvbmQnO1xuICAgIH1cbiAgICByZXR1cm4gZm91bmRUeXBlO1xufVxuIiwiaW1wb3J0IHsgZ2V0QXhpc0Zvcm1hdHRlciwgZ2V0QXhpc05hbWUsIGdldEF4aXNUaGVtZSwgZ2V0SW5pdEF4aXNJbnRlcnZhbERhdGEsIGdldExhYmVsc0FwcGxpZWRGb3JtYXR0ZXIsIGdldExhYmVsWE1hcmdpbiwgZ2V0TWF4TGFiZWxTaXplLCBnZXRSb3RhdGFibGVPcHRpb24sIGdldFNpemVLZXksIGdldFZpZXdBeGlzTGFiZWxzLCBnZXRZQXhpc09wdGlvbiwgaGFzQXhlc0xheW91dENoYW5nZWQsIGhhc0JveFR5cGVTZXJpZXMsIGlzRGF0ZVR5cGUsIGlzTGFiZWxBeGlzT25ZQXhpcywgaXNQb2ludE9uQ29sdW1uLCBtYWtlUm90YXRpb25EYXRhLCBtYWtlVGl0bGVPcHRpb24sIH0gZnJvbSBcIi4uL2hlbHBlcnMvYXhlc1wiO1xuaW1wb3J0IHsgZ2V0QXhpc0xhYmVsQW5jaG9yUG9pbnQsIG1ha2VMYWJlbHNGcm9tTGltaXQgfSBmcm9tIFwiLi4vaGVscGVycy9jYWxjdWxhdG9yXCI7XG5pbXBvcnQgeyBkZWVwTWVyZ2VkQ29weSwgaGFzTmVnYXRpdmVPbmx5LCBpc051bWJlciwgcGlja1Byb3BlcnR5IH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmltcG9ydCB7IGlzQ29vcmRpbmF0ZVNlcmllcyB9IGZyb20gXCIuLi9oZWxwZXJzL2Nvb3JkaW5hdGVcIjtcbmltcG9ydCB7IEF4aXNUeXBlIH0gZnJvbSBcIi4uL2NvbXBvbmVudC9heGlzXCI7XG5pbXBvcnQgeyBnZXRUaXRsZUZvbnRTdHJpbmcgfSBmcm9tIFwiLi4vaGVscGVycy9zdHlsZVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2VudGVyWUF4aXMob3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZGl2ZXJnaW5nID0gISFwaWNrUHJvcGVydHkob3B0aW9ucywgWydzZXJpZXMnLCAnZGl2ZXJnaW5nJ10pO1xuICAgIGNvbnN0IGFsaWduQ2VudGVyID0gKChfYiA9IChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS55QXhpcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFsaWduKSA9PT0gJ2NlbnRlcic7XG4gICAgcmV0dXJuIGRpdmVyZ2luZyAmJiBhbGlnbkNlbnRlcjtcbn1cbmZ1bmN0aW9uIGlzRGl2ZXJnaW5nQm94U2VyaWVzKHNlcmllcywgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gaGFzQm94VHlwZVNlcmllcyhzZXJpZXMpICYmICEhKChfYSA9IG9wdGlvbnMuc2VyaWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGl2ZXJnaW5nKTtcbn1cbmZ1bmN0aW9uIGdldFplcm9Qb3NpdGlvbihsaW1pdCwgYXhpc1NpemUsIGxhYmVsQXhpc09uWUF4aXMsIGlzRGl2ZXJnaW5nU2VyaWVzKSB7XG4gICAgY29uc3QgeyBtaW4sIG1heCB9ID0gbGltaXQ7XG4gICAgY29uc3QgaGFzWmVyb1ZhbHVlID0gbWluIDw9IDAgJiYgbWF4ID49IDA7XG4gICAgaWYgKCFoYXNaZXJvVmFsdWUgfHwgaXNEaXZlcmdpbmdTZXJpZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uID0gKCgwIC0gbWluKSAvIChtYXggLSBtaW4pKSAqIGF4aXNTaXplO1xuICAgIHJldHVybiBsYWJlbEF4aXNPbllBeGlzID8gcG9zaXRpb24gOiBheGlzU2l6ZSAtIHBvc2l0aW9uO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldExhYmVsQXhpc0RhdGEoc3RhdGVQcm9wKSB7XG4gICAgY29uc3QgeyBheGlzU2l6ZSwgY2F0ZWdvcmllcywgc2VyaWVzLCBvcHRpb25zLCB0aGVtZSwgc2NhbGUsIGluaXRpYWxBeGlzRGF0YSwgaXNDb29yZGluYXRlVHlwZUNoYXJ0LCBheGlzTmFtZSwgfSA9IHN0YXRlUHJvcDtcbiAgICBjb25zdCBoYXNMaW5lU2VyaWVzID0gISFzZXJpZXMubGluZTtcbiAgICBjb25zdCBwb2ludE9uQ29sdW1uID0gaXNQb2ludE9uQ29sdW1uKHNlcmllcywgb3B0aW9ucyk7XG4gICAgY29uc3QgZGF0ZVR5cGUgPSBpc0RhdGVUeXBlKG9wdGlvbnMsIGF4aXNOYW1lKTtcbiAgICBjb25zdCBsYWJlbHNCZWZvcmVGb3JtYXR0aW5nID0gaXNDb29yZGluYXRlVHlwZUNoYXJ0XG4gICAgICAgID8gbWFrZUxhYmVsc0Zyb21MaW1pdChzY2FsZS5saW1pdCwgc2NhbGUuc3RlcFNpemUsIGRhdGVUeXBlKVxuICAgICAgICA6IGNhdGVnb3JpZXM7XG4gICAgY29uc3QgbGFiZWxzID0gZ2V0TGFiZWxzQXBwbGllZEZvcm1hdHRlcihsYWJlbHNCZWZvcmVGb3JtYXR0aW5nLCBvcHRpb25zLCBkYXRlVHlwZSwgYXhpc05hbWUpO1xuICAgIGxldCBsYWJlbFJhbmdlO1xuICAgIGlmIChzY2FsZSAmJiBoYXNMaW5lU2VyaWVzKSB7XG4gICAgICAgIGNvbnN0IGJhc2VMYWJlbHMgPSBwb2ludE9uQ29sdW1uID8gbGFiZWxzQmVmb3JlRm9ybWF0dGluZyA6IGNhdGVnb3JpZXM7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGJhc2VMYWJlbHMubWFwKCh2YWx1ZSkgPT4gKGRhdGVUeXBlID8gTnVtYmVyKG5ldyBEYXRlKHZhbHVlKSkgOiBOdW1iZXIodmFsdWUpKSk7XG4gICAgICAgIGxhYmVsUmFuZ2UgPSB7IG1pbjogTWF0aC5taW4oLi4udmFsdWVzKSwgbWF4OiBNYXRoLm1heCguLi52YWx1ZXMpIH07XG4gICAgfVxuICAgIGNvbnN0IHJlY3RSZXNwb25kZXJDb3VudCA9IGNhdGVnb3JpZXMubGVuZ3RoO1xuICAgIGNvbnN0IHRpY2tJbnRlcnZhbENvdW50ID0gcmVjdFJlc3BvbmRlckNvdW50IC0gKHBvaW50T25Db2x1bW4gPyAwIDogMSk7XG4gICAgY29uc3QgdGlja0Rpc3RhbmNlID0gdGlja0ludGVydmFsQ291bnQgPyBheGlzU2l6ZSAvIHRpY2tJbnRlcnZhbENvdW50IDogYXhpc1NpemU7XG4gICAgY29uc3QgbGFiZWxEaXN0YW5jZSA9IGF4aXNTaXplIC8gKGxhYmVscy5sZW5ndGggLSAocG9pbnRPbkNvbHVtbiA/IDAgOiAxKSk7XG4gICAgbGV0IHRpY2tDb3VudCA9IGxhYmVscy5sZW5ndGg7XG4gICAgaWYgKHBvaW50T25Db2x1bW4gJiYgIWlzQ29vcmRpbmF0ZVR5cGVDaGFydCkge1xuICAgICAgICB0aWNrQ291bnQgKz0gMTtcbiAgICB9XG4gICAgY29uc3Qgdmlld0xhYmVscyA9IGdldFZpZXdBeGlzTGFiZWxzKE9iamVjdC5hc3NpZ24oeyBsYWJlbHMsXG4gICAgICAgIHBvaW50T25Db2x1bW4sXG4gICAgICAgIHRpY2tEaXN0YW5jZSxcbiAgICAgICAgdGlja0NvdW50LFxuICAgICAgICBzY2FsZSB9LCBpbml0aWFsQXhpc0RhdGEpLCBheGlzU2l6ZSk7XG4gICAgY29uc3QgYXhpc0xhYmVsTWFyZ2luID0gZ2V0TGFiZWxYTWFyZ2luKGF4aXNOYW1lLCBvcHRpb25zKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbGFiZWxzLFxuICAgICAgICB2aWV3TGFiZWxzLFxuICAgICAgICBwb2ludE9uQ29sdW1uLFxuICAgICAgICBsYWJlbERpc3RhbmNlLFxuICAgICAgICB0aWNrRGlzdGFuY2UsXG4gICAgICAgIHRpY2tDb3VudCxcbiAgICAgICAgbGFiZWxSYW5nZSxcbiAgICAgICAgcmVjdFJlc3BvbmRlckNvdW50LCBpc0xhYmVsQXhpczogdHJ1ZSB9LCBpbml0aWFsQXhpc0RhdGEpLCBnZXRNYXhMYWJlbFNpemUobGFiZWxzLCBheGlzTGFiZWxNYXJnaW4sIGdldFRpdGxlRm9udFN0cmluZyh0aGVtZS5sYWJlbCkpKTtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlQXhpc0RhdGEoc3RhdGVQcm9wKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgc2NhbGUsIGF4aXNTaXplLCBzZXJpZXMsIG9wdGlvbnMsIGNlbnRlcllBeGlzLCBpbml0aWFsQXhpc0RhdGEsIHRoZW1lLCBsYWJlbE9uWUF4aXMsIGF4aXNOYW1lLCB9ID0gc3RhdGVQcm9wO1xuICAgIGNvbnN0IHsgbGltaXQsIHN0ZXBTaXplIH0gPSBzY2FsZTtcbiAgICBjb25zdCBzaXplID0gY2VudGVyWUF4aXMgPyAoX2EgPSBjZW50ZXJZQXhpcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnhBeGlzSGFsZlNpemUgOiBheGlzU2l6ZTtcbiAgICBjb25zdCBkaXZlcmdpbmdCb3hTZXJpZXMgPSBpc0RpdmVyZ2luZ0JveFNlcmllcyhzZXJpZXMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IGdldEF4aXNGb3JtYXR0ZXIob3B0aW9ucywgYXhpc05hbWUpO1xuICAgIGNvbnN0IHplcm9Qb3NpdGlvbiA9IGdldFplcm9Qb3NpdGlvbihsaW1pdCwgYXhpc1NpemUsIGlzTGFiZWxBeGlzT25ZQXhpcyh7IHNlcmllcywgb3B0aW9ucyB9KSwgZGl2ZXJnaW5nQm94U2VyaWVzKTtcbiAgICBsZXQgdmFsdWVMYWJlbHMgPSBtYWtlTGFiZWxzRnJvbUxpbWl0KGxpbWl0LCBzdGVwU2l6ZSk7XG4gICAgaWYgKCFjZW50ZXJZQXhpcyAmJiBkaXZlcmdpbmdCb3hTZXJpZXMpIHtcbiAgICAgICAgdmFsdWVMYWJlbHMgPSBnZXREaXZlcmdpbmdWYWx1ZXModmFsdWVMYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSB2YWx1ZUxhYmVscy5tYXAoKGxhYmVsLCBpbmRleCkgPT4gZm9ybWF0dGVyKGxhYmVsLCB7IGluZGV4LCBsYWJlbHM6IHZhbHVlTGFiZWxzLCBheGlzTmFtZSB9KSk7XG4gICAgY29uc3QgdGlja0Rpc3RhbmNlID0gc2l6ZSAvIE1hdGgubWF4KHZhbHVlTGFiZWxzLmxlbmd0aCwgMSk7XG4gICAgY29uc3QgdGlja0NvdW50ID0gdmFsdWVMYWJlbHMubGVuZ3RoO1xuICAgIGNvbnN0IHBvaW50T25Db2x1bW4gPSBmYWxzZTtcbiAgICBjb25zdCB2aWV3TGFiZWxzID0gZ2V0Vmlld0F4aXNMYWJlbHMoT2JqZWN0LmFzc2lnbih7IGxhYmVsczogbGFiZWxPbllBeGlzID8gbGFiZWxzIDogWy4uLmxhYmVsc10ucmV2ZXJzZSgpLCBwb2ludE9uQ29sdW1uLFxuICAgICAgICB0aWNrRGlzdGFuY2UsXG4gICAgICAgIHRpY2tDb3VudCB9LCBpbml0aWFsQXhpc0RhdGEpLCBzaXplKTtcbiAgICBjb25zdCBheGlzTGFiZWxNYXJnaW4gPSBnZXRMYWJlbFhNYXJnaW4oYXhpc05hbWUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGF4aXNEYXRhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbGFiZWxzLFxuICAgICAgICB2aWV3TGFiZWxzLFxuICAgICAgICBwb2ludE9uQ29sdW1uLCBpc0xhYmVsQXhpczogZmFsc2UsIHRpY2tDb3VudCxcbiAgICAgICAgdGlja0Rpc3RhbmNlIH0sIGluaXRpYWxBeGlzRGF0YSksIGdldE1heExhYmVsU2l6ZShsYWJlbHMsIGF4aXNMYWJlbE1hcmdpbiwgZ2V0VGl0bGVGb250U3RyaW5nKHRoZW1lLmxhYmVsKSkpO1xuICAgIGlmIChpc051bWJlcih6ZXJvUG9zaXRpb24pKSB7XG4gICAgICAgIGF4aXNEYXRhLnplcm9Qb3NpdGlvbiA9IHplcm9Qb3NpdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIGF4aXNEYXRhO1xufVxuZnVuY3Rpb24gZ2V0RGl2ZXJnaW5nVmFsdWVzKHZhbHVlTGFiZWxzKSB7XG4gICAgcmV0dXJuIGhhc05lZ2F0aXZlT25seSh2YWx1ZUxhYmVscylcbiAgICAgICAgPyB2YWx1ZUxhYmVscy5yZXZlcnNlKCkuc2xpY2UoMSkuY29uY2F0KHZhbHVlTGFiZWxzKVxuICAgICAgICA6IHZhbHVlTGFiZWxzLnNsaWNlKDEpLnJldmVyc2UoKS5jb25jYXQodmFsdWVMYWJlbHMpO1xufVxuZnVuY3Rpb24gbWFrZURlZmF1bHRBeGlzRGF0YShpc0xhYmVsQXhpcywgcGFyYW1zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBheGlzRGF0YSA9IGdldEluaXRBeGlzSW50ZXJ2YWxEYXRhKGlzTGFiZWxBeGlzLCBwYXJhbXMpO1xuICAgIGNvbnN0IHRpdGxlID0gbWFrZVRpdGxlT3B0aW9uKChfYiA9IChfYSA9IHBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF4aXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50aXRsZSk7XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIGF4aXNEYXRhLnRpdGxlID0gdGl0bGU7XG4gICAgfVxuICAgIHJldHVybiBheGlzRGF0YTtcbn1cbmZ1bmN0aW9uIGdldEluaXRpYWxBeGlzRGF0YShvcHRpb25zLCBsYWJlbE9uWUF4aXMsIGNhdGVnb3JpZXMsIGxheW91dCwgaXNDb29yZGluYXRlVHlwZUNoYXJ0KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgeyB5QXhpcywgc2Vjb25kYXJ5WUF4aXMgfSA9IGdldFlBeGlzT3B0aW9uKG9wdGlvbnMpO1xuICAgIGNvbnN0IHNoaWZ0ID0gKF9iID0gKF9hID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlcmllcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNoaWZ0O1xuICAgIHJldHVybiB7XG4gICAgICAgIHhBeGlzOiBtYWtlRGVmYXVsdEF4aXNEYXRhKCFsYWJlbE9uWUF4aXMsIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXMsXG4gICAgICAgICAgICBheGlzOiAoX2MgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MueEF4aXMsXG4gICAgICAgICAgICBsYXlvdXQsXG4gICAgICAgICAgICBzaGlmdCxcbiAgICAgICAgICAgIGlzQ29vcmRpbmF0ZVR5cGVDaGFydCxcbiAgICAgICAgfSksXG4gICAgICAgIHlBeGlzOiBtYWtlRGVmYXVsdEF4aXNEYXRhKGxhYmVsT25ZQXhpcywgeyBheGlzOiB5QXhpcyB9KSxcbiAgICAgICAgc2Vjb25kYXJ5WUF4aXM6IHNlY29uZGFyeVlBeGlzXG4gICAgICAgICAgICA/IG1ha2VEZWZhdWx0QXhpc0RhdGEobGFiZWxPbllBeGlzLCB7IGF4aXM6IHNlY29uZGFyeVlBeGlzIH0pXG4gICAgICAgICAgICA6IG51bGwsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFNlY29uZGFyeVlBeGlzRGF0YSh7IHN0YXRlLCBsYWJlbE9uWUF4aXMsIHZhbHVlQXhpc1NpemUsIGxhYmVsQXhpc1NpemUsIGluaXRpYWxBeGlzRGF0YSwgaXNDb29yZGluYXRlVHlwZUNoYXJ0LCB9KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IHNjYWxlLCBvcHRpb25zLCBzZXJpZXMsIHRoZW1lIH0gPSBzdGF0ZTtcbiAgICBjb25zdCBjYXRlZ29yaWVzID0gc3RhdGUuY2F0ZWdvcmllcztcbiAgICByZXR1cm4gbGFiZWxPbllBeGlzXG4gICAgICAgID8gZ2V0TGFiZWxBeGlzRGF0YSh7XG4gICAgICAgICAgICBzY2FsZTogc2NhbGUuc2Vjb25kYXJ5WUF4aXMsXG4gICAgICAgICAgICBheGlzU2l6ZTogbGFiZWxBeGlzU2l6ZSxcbiAgICAgICAgICAgIGNhdGVnb3JpZXM6IChfYiA9IChfYSA9IGdldFlBeGlzT3B0aW9uKG9wdGlvbnMpLnNlY29uZGFyeVlBeGlzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2F0ZWdvcmllcywgKF9iICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNhdGVnb3JpZXMpKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBzZXJpZXMsXG4gICAgICAgICAgICB0aGVtZTogZ2V0QXhpc1RoZW1lKHRoZW1lLCBBeGlzVHlwZS5TRUNPTkRBUllfWSksXG4gICAgICAgICAgICBpbml0aWFsQXhpc0RhdGEsXG4gICAgICAgICAgICBpc0Nvb3JkaW5hdGVUeXBlQ2hhcnQsXG4gICAgICAgICAgICBheGlzTmFtZTogQXhpc1R5cGUuU0VDT05EQVJZX1ksXG4gICAgICAgIH0pXG4gICAgICAgIDogZ2V0VmFsdWVBeGlzRGF0YSh7XG4gICAgICAgICAgICBzY2FsZTogc2NhbGUuc2Vjb25kYXJ5WUF4aXMsXG4gICAgICAgICAgICBheGlzU2l6ZTogdmFsdWVBeGlzU2l6ZSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBzZXJpZXMsXG4gICAgICAgICAgICB0aGVtZTogZ2V0QXhpc1RoZW1lKHRoZW1lLCBBeGlzVHlwZS5TRUNPTkRBUllfWSksXG4gICAgICAgICAgICBjZW50ZXJZQXhpczogbnVsbCxcbiAgICAgICAgICAgIGluaXRpYWxBeGlzRGF0YSxcbiAgICAgICAgICAgIGF4aXNOYW1lOiBBeGlzVHlwZS5TRUNPTkRBUllfWSxcbiAgICAgICAgfSk7XG59XG5mdW5jdGlvbiBtYWtlWEF4aXNEYXRhKHsgYXhpc0RhdGEsIGF4aXNTaXplLCBheGlzTGF5b3V0LCBjZW50ZXJZQXhpcywgcm90YXRhYmxlLCBsYWJlbE1hcmdpbiA9IDAsIH0pIHtcbiAgICBjb25zdCB7IHZpZXdMYWJlbHMsIHBvaW50T25Db2x1bW4sIG1heExhYmVsV2lkdGgsIG1heExhYmVsSGVpZ2h0IH0gPSBheGlzRGF0YTtcbiAgICBjb25zdCBvZmZzZXRZID0gZ2V0QXhpc0xhYmVsQW5jaG9yUG9pbnQobWF4TGFiZWxIZWlnaHQpICsgbGFiZWxNYXJnaW47XG4gICAgY29uc3Qgc2l6ZSA9IGNlbnRlcllBeGlzID8gY2VudGVyWUF4aXMueEF4aXNIYWxmU2l6ZSA6IGF4aXNTaXplO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gc2l6ZSAvICh2aWV3TGFiZWxzLmxlbmd0aCAtIChwb2ludE9uQ29sdW1uID8gMCA6IDEpKTtcbiAgICBjb25zdCByb3RhdGlvbkRhdGEgPSBtYWtlUm90YXRpb25EYXRhKG1heExhYmVsV2lkdGgsIG1heExhYmVsSGVpZ2h0LCBkaXN0YW5jZSwgcm90YXRhYmxlLCBheGlzTGF5b3V0KTtcbiAgICBjb25zdCB7IG5lZWRSb3RhdGVMYWJlbCwgcm90YXRpb25IZWlnaHQgfSA9IHJvdGF0aW9uRGF0YTtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSAobmVlZFJvdGF0ZUxhYmVsID8gcm90YXRpb25IZWlnaHQgOiBtYXhMYWJlbEhlaWdodCkgKyBvZmZzZXRZO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXhpc0RhdGEpLCByb3RhdGlvbkRhdGEpLCB7IG1heEhlaWdodCxcbiAgICAgICAgb2Zmc2V0WSB9KTtcbn1cbmZ1bmN0aW9uIGdldEF4aXNJbmZvKGxhYmVsT25ZQXhpcywgcGxvdCwgc2VyaWVzKSB7XG4gICAgY29uc3QgeyB2YWx1ZUF4aXNOYW1lLCBsYWJlbEF4aXNOYW1lIH0gPSBnZXRBeGlzTmFtZShsYWJlbE9uWUF4aXMsIHNlcmllcyk7XG4gICAgY29uc3QgeyB2YWx1ZVNpemVLZXksIGxhYmVsU2l6ZUtleSB9ID0gZ2V0U2l6ZUtleShsYWJlbE9uWUF4aXMpO1xuICAgIGNvbnN0IHZhbHVlQXhpc1NpemUgPSBwbG90W3ZhbHVlU2l6ZUtleV07XG4gICAgY29uc3QgbGFiZWxBeGlzU2l6ZSA9IHBsb3RbbGFiZWxTaXplS2V5XTtcbiAgICByZXR1cm4geyB2YWx1ZUF4aXNOYW1lLCB2YWx1ZUF4aXNTaXplLCBsYWJlbEF4aXNOYW1lLCBsYWJlbEF4aXNTaXplIH07XG59XG5mdW5jdGlvbiBnZXRDYXRlZ29yaWVzV2l0aFR5cGVzKGNhdGVnb3JpZXMsIHJhd0NhdGVnb3JpZXMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNhdGVnb3JpZXM6IChfYSA9IGNhdGVnb3JpZXMsIChfYSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkpLFxuICAgICAgICByYXdDYXRlZ29yaWVzOiAoX2IgPSByYXdDYXRlZ29yaWVzLCAoX2IgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pKSxcbiAgICB9O1xufVxuY29uc3QgYXhlcyA9IHtcbiAgICBuYW1lOiAnYXhlcycsXG4gICAgc3RhdGU6ICh7IHNlcmllcywgb3B0aW9ucyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2Vjb25kYXJ5WUF4aXMgfSA9IGdldFlBeGlzT3B0aW9uKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBheGVzU3RhdGUgPSB7XG4gICAgICAgICAgICB4QXhpczoge30sXG4gICAgICAgICAgICB5QXhpczoge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmICghIXNlcmllcy5iYXIgJiYgaXNDZW50ZXJZQXhpcyhvcHRpb25zKSkge1xuICAgICAgICAgICAgYXhlc1N0YXRlLmNlbnRlcllBeGlzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY29uZGFyeVlBeGlzKSB7XG4gICAgICAgICAgICBheGVzU3RhdGUuc2Vjb25kYXJ5WUF4aXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXhlczogYXhlc1N0YXRlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWN0aW9uOiB7XG4gICAgICAgIHNldEF4ZXNEYXRhKHsgc3RhdGUsIGluaXRTdG9yZVN0YXRlIH0pIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCB7IHNjYWxlLCBvcHRpb25zLCBzZXJpZXMsIGxheW91dCwgdGhlbWUgfSA9IHN0YXRlO1xuICAgICAgICAgICAgY29uc3QgeyB4QXhpcywgeUF4aXMsIHBsb3QgfSA9IGxheW91dDtcbiAgICAgICAgICAgIGNvbnN0IGlzQ29vcmRpbmF0ZVR5cGVDaGFydCA9IGlzQ29vcmRpbmF0ZVNlcmllcyhpbml0U3RvcmVTdGF0ZS5zZXJpZXMpO1xuICAgICAgICAgICAgY29uc3QgbGFiZWxPbllBeGlzID0gaXNMYWJlbEF4aXNPbllBeGlzKHsgc2VyaWVzLCBvcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBjYXRlZ29yaWVzIH0gPSBnZXRDYXRlZ29yaWVzV2l0aFR5cGVzKHN0YXRlLmNhdGVnb3JpZXMsIHN0YXRlLnJhd0NhdGVnb3JpZXMpO1xuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZUF4aXNOYW1lLCB2YWx1ZUF4aXNTaXplLCBsYWJlbEF4aXNOYW1lLCBsYWJlbEF4aXNTaXplIH0gPSBnZXRBeGlzSW5mbyhsYWJlbE9uWUF4aXMsIHBsb3QsIHNlcmllcyk7XG4gICAgICAgICAgICBjb25zdCBoYXNDZW50ZXJZQXhpcyA9IHN0YXRlLmF4ZXMuY2VudGVyWUF4aXM7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsQXhpc0RhdGEgPSBnZXRJbml0aWFsQXhpc0RhdGEob3B0aW9ucywgbGFiZWxPbllBeGlzLCBjYXRlZ29yaWVzLCBsYXlvdXQsIGlzQ29vcmRpbmF0ZVR5cGVDaGFydCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUF4aXNEYXRhID0gZ2V0VmFsdWVBeGlzRGF0YSh7XG4gICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlW3ZhbHVlQXhpc05hbWVdLFxuICAgICAgICAgICAgICAgIGF4aXNTaXplOiB2YWx1ZUF4aXNTaXplLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc2VyaWVzLFxuICAgICAgICAgICAgICAgIHRoZW1lOiBnZXRBeGlzVGhlbWUodGhlbWUsIHZhbHVlQXhpc05hbWUpLFxuICAgICAgICAgICAgICAgIGNlbnRlcllBeGlzOiBoYXNDZW50ZXJZQXhpc1xuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhBeGlzSGFsZlNpemU6ICh4QXhpcy53aWR0aCAtIHlBeGlzLndpZHRoKSAvIDIsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIGluaXRpYWxBeGlzRGF0YTogaW5pdGlhbEF4aXNEYXRhW3ZhbHVlQXhpc05hbWVdLFxuICAgICAgICAgICAgICAgIGxhYmVsT25ZQXhpcyxcbiAgICAgICAgICAgICAgICBheGlzTmFtZTogdmFsdWVBeGlzTmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbGFiZWxBeGlzRGF0YSA9IGdldExhYmVsQXhpc0RhdGEoe1xuICAgICAgICAgICAgICAgIHNjYWxlOiBzY2FsZVtsYWJlbEF4aXNOYW1lXSxcbiAgICAgICAgICAgICAgICBheGlzU2l6ZTogbGFiZWxBeGlzU2l6ZSxcbiAgICAgICAgICAgICAgICBjYXRlZ29yaWVzLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc2VyaWVzLFxuICAgICAgICAgICAgICAgIHRoZW1lOiBnZXRBeGlzVGhlbWUodGhlbWUsIGxhYmVsQXhpc05hbWUpLFxuICAgICAgICAgICAgICAgIGluaXRpYWxBeGlzRGF0YTogaW5pdGlhbEF4aXNEYXRhW2xhYmVsQXhpc05hbWVdLFxuICAgICAgICAgICAgICAgIGlzQ29vcmRpbmF0ZVR5cGVDaGFydCxcbiAgICAgICAgICAgICAgICBsYWJlbE9uWUF4aXMsXG4gICAgICAgICAgICAgICAgYXhpc05hbWU6IGxhYmVsQXhpc05hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBzZWNvbmRhcnlZQXhpcywgY2VudGVyWUF4aXM7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYXhlcy5zZWNvbmRhcnlZQXhpcykge1xuICAgICAgICAgICAgICAgIHNlY29uZGFyeVlBeGlzID0gZ2V0U2Vjb25kYXJ5WUF4aXNEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsT25ZQXhpcyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVBeGlzU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxBeGlzU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxBeGlzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVBeGlzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbEF4aXNEYXRhOiBpbml0aWFsQXhpc0RhdGEuc2Vjb25kYXJ5WUF4aXMsXG4gICAgICAgICAgICAgICAgICAgIGlzQ29vcmRpbmF0ZVR5cGVDaGFydCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNDZW50ZXJZQXhpcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHhBeGlzSGFsZlNpemUgPSAoeEF4aXMud2lkdGggLSB5QXhpcy53aWR0aCkgLyAyO1xuICAgICAgICAgICAgICAgIGNlbnRlcllBeGlzID0gZGVlcE1lcmdlZENvcHkodmFsdWVBeGlzRGF0YSwge1xuICAgICAgICAgICAgICAgICAgICB4OiB4QXhpcy54ICsgeEF4aXNIYWxmU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgeEF4aXNIYWxmU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kU3RhcnRYOiAoeEF4aXMud2lkdGggKyB5QXhpcy53aWR0aCkgLyAyLFxuICAgICAgICAgICAgICAgICAgICB5QXhpc0xhYmVsQW5jaG9yUG9pbnQ6IHlBeGlzLndpZHRoIC8gMixcbiAgICAgICAgICAgICAgICAgICAgeUF4aXNIZWlnaHQ6IHlBeGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF4ZXNTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICB4QXhpczogbWFrZVhBeGlzRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNEYXRhOiBsYWJlbE9uWUF4aXMgPyB2YWx1ZUF4aXNEYXRhIDogbGFiZWxBeGlzRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgYXhpc1NpemU6IGxhYmVsT25ZQXhpcyA/IHZhbHVlQXhpc1NpemUgOiBsYWJlbEF4aXNTaXplLFxuICAgICAgICAgICAgICAgICAgICBheGlzTGF5b3V0OiBsYXlvdXQueEF4aXMsXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlcllBeGlzLFxuICAgICAgICAgICAgICAgICAgICByb3RhdGFibGU6IGdldFJvdGF0YWJsZU9wdGlvbihvcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxNYXJnaW46IChfYiA9IChfYSA9IG9wdGlvbnMueEF4aXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYWJlbCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1hcmdpbixcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB5QXhpczogbGFiZWxPbllBeGlzID8gbGFiZWxBeGlzRGF0YSA6IHZhbHVlQXhpc0RhdGEsXG4gICAgICAgICAgICAgICAgc2Vjb25kYXJ5WUF4aXMsXG4gICAgICAgICAgICAgICAgY2VudGVyWUF4aXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGhhc0F4ZXNMYXlvdXRDaGFuZ2VkKHN0YXRlLmF4ZXMsIGF4ZXNTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeShzdGF0ZSwgJ2xheW91dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUuYXhlcyA9IGF4ZXNTdGF0ZTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7fSxcbiAgICBvYnNlcnZlOiB7XG4gICAgICAgIHVwZGF0ZUF4ZXMoKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCdzZXRBeGVzRGF0YScpO1xuICAgICAgICB9LFxuICAgIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgYXhlcztcbiIsImltcG9ydCB7IGlzTnVsbCwgaXNOdW1iZXIsIGlzVW5kZWZpbmVkLCBzb3J0Q2F0ZWdvcmllcyB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXRDb29yZGluYXRlWFZhbHVlIH0gZnJvbSBcIi4uL2hlbHBlcnMvY29vcmRpbmF0ZVwiO1xuaW1wb3J0IHsgZ2V0RGF0YUluUmFuZ2UgfSBmcm9tIFwiLi4vaGVscGVycy9yYW5nZVwiO1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VSYXdDYXRlZ29yaWVzKHNlcmllcywgY2F0ZWdvcmllcykge1xuICAgIGlmIChjYXRlZ29yaWVzKSB7XG4gICAgICAgIHJldHVybiBjYXRlZ29yaWVzO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFZhbHVlcyA9IG5ldyBTZXQoKTtcbiAgICBPYmplY3Qua2V5cyhzZXJpZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChrZXkgPT09ICdwaWUnIHx8IGtleSA9PT0gJ2dhdWdlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHNlcmllc1trZXldLmRhdGEsIChfYSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzZXJpZXNba2V5XSkpLmZvckVhY2goKHsgZGF0YSwgbmFtZSwgdmlzaWJsZSB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwoZGF0dW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdYVmFsdWUgPSBnZXRDb29yZGluYXRlWFZhbHVlKGRhdHVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0VmFsdWVzLmFkZChpc051bWJlcihyYXdYVmFsdWUpID8gcmF3WFZhbHVlIDogcmF3WFZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoa2V5ID09PSAnYnVsbGV0JyAmJiBpc1VuZGVmaW5lZCh2aXNpYmxlKSkgfHwgdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGZpcnN0VmFsdWVzLmFkZChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZmlyc3RWYWx1ZXMpXG4gICAgICAgIC5zb3J0KHNvcnRDYXRlZ29yaWVzKVxuICAgICAgICAubWFwKChjYXRlZ29yeSkgPT4gU3RyaW5nKGNhdGVnb3J5KSk7XG59XG5jb25zdCBjYXRlZ29yeSA9IHtcbiAgICBuYW1lOiAnY2F0ZWdvcnknLFxuICAgIHN0YXRlOiAoeyBjYXRlZ29yaWVzLCBzZXJpZXMgfSkgPT4gKHtcbiAgICAgICAgY2F0ZWdvcmllczogbWFrZVJhd0NhdGVnb3JpZXMoc2VyaWVzLCBjYXRlZ29yaWVzKSxcbiAgICB9KSxcbiAgICBhY3Rpb246IHtcbiAgICAgICAgc2V0Q2F0ZWdvcnkoeyBzdGF0ZSwgY29tcHV0ZWQgfSkge1xuICAgICAgICAgICAgY29uc3QgeyB2aWV3UmFuZ2UgfSA9IGNvbXB1dGVkO1xuICAgICAgICAgICAgbGV0IGNhdGVnb3JpZXMgPSBzdGF0ZS5yYXdDYXRlZ29yaWVzO1xuICAgICAgICAgICAgaWYgKHZpZXdSYW5nZSkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNhdGVnb3JpZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3JpZXMgPSBnZXREYXRhSW5SYW5nZShjYXRlZ29yaWVzLCB2aWV3UmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2F0ZWdvcmllcyksIHsgeDogZ2V0RGF0YUluUmFuZ2UoY2F0ZWdvcmllcy54LCB2aWV3UmFuZ2UpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLmNhdGVnb3JpZXMgPSBjYXRlZ29yaWVzO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoc3RhdGUsICdjYXRlZ29yaWVzJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRDYXRlZ29yeSh7IGluaXRTdG9yZVN0YXRlLCBzdGF0ZSB9KSB7XG4gICAgICAgICAgICBjb25zdCB7IHpvb21SYW5nZSB9ID0gc3RhdGU7XG4gICAgICAgICAgICBsZXQgY2F0ZWdvcmllcyA9IG1ha2VSYXdDYXRlZ29yaWVzKGluaXRTdG9yZVN0YXRlLnNlcmllcyk7XG4gICAgICAgICAgICBpZiAoem9vbVJhbmdlICYmIEFycmF5LmlzQXJyYXkoY2F0ZWdvcmllcykpIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yaWVzID0gZ2V0RGF0YUluUmFuZ2UoY2F0ZWdvcmllcywgem9vbVJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLmNhdGVnb3JpZXMgPSBjYXRlZ29yaWVzO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoc3RhdGUsICdjYXRlZ29yaWVzJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNhdGVnb3J5QnlOYW1lKHsgc3RhdGUgfSwgbmFtZSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzdGF0ZS5jYXRlZ29yaWVzLmZpbmRJbmRleCgoc2VyaWVzTmFtZSkgPT4gc2VyaWVzTmFtZSA9PT0gbmFtZSk7XG4gICAgICAgICAgICBzdGF0ZS5jYXRlZ29yaWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeShzdGF0ZSwgJ2F4ZXMnKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIG9ic2VydmU6IHtcbiAgICAgICAgdXBkYXRlQ2F0ZWdvcnkoKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCdzZXRDYXRlZ29yeScpO1xuICAgICAgICB9LFxuICAgIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgY2F0ZWdvcnk7XG4iLCJpbXBvcnQgeyBleHRlbmQgfSBmcm9tIFwiLi9zdG9yZVwiO1xuaW1wb3J0IHsgY2FsY3VsYXRlQ29vcmRpbmF0ZVNjYWxlIH0gZnJvbSBcIi4uL3NjYWxlL2Nvb3JkaW5hdGVTY2FsZUNhbGN1bGF0b3JcIjtcbmltcG9ydCB7IGdldExpbWl0U2FmZWx5IH0gZnJvbSBcIi4vZGF0YVJhbmdlXCI7XG5pbXBvcnQgeyBpc1ZlcnRpY2FsQWxpZ24gfSBmcm9tIFwiLi9sYXlvdXRcIjtcbmltcG9ydCB7IFRSRUVNQVBfUk9PVF9JRCB9IGZyb20gXCIuL3RyZWVtYXBTZXJpZXNEYXRhXCI7XG5jb25zdCBjb2xvclZhbHVlU2NhbGUgPSB7XG4gICAgbmFtZTogJ2NvbG9yVmFsdWVTY2FsZScsXG4gICAgc3RhdGU6ICgpID0+ICh7XG4gICAgICAgIHRyZWVtYXBab29tSWQ6IHtcbiAgICAgICAgICAgIHByZXY6IFRSRUVNQVBfUk9PVF9JRCxcbiAgICAgICAgICAgIGN1cjogVFJFRU1BUF9ST09UX0lELFxuICAgICAgICB9LFxuICAgICAgICBjb2xvclZhbHVlU2NhbGU6IHt9LFxuICAgIH0pLFxuICAgIGFjdGlvbjoge1xuICAgICAgICBzZXRDb2xvclZhbHVlU2NhbGUoeyBzdGF0ZSB9KSB7XG4gICAgICAgICAgICBjb25zdCB7IGxheW91dCwgdHJlZW1hcFNlcmllcywgbGVnZW5kLCBoZWF0bWFwU2VyaWVzIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGlmICghbGVnZW5kLnVzZVNwZWN0cnVtTGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VyaWVzID0gKHRyZWVtYXBTZXJpZXMgIT09IG51bGwgJiYgdHJlZW1hcFNlcmllcyAhPT0gdm9pZCAwID8gdHJlZW1hcFNlcmllcyA6IGhlYXRtYXBTZXJpZXMuZmxhdE1hcCgodmFsdWUpID0+IHZhbHVlKSk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBzZXJpZXMucmVkdWNlKChhY2MsIHsgY29sb3JWYWx1ZSB9KSA9PiAoY29sb3JWYWx1ZSA/IFsuLi5hY2MsIGNvbG9yVmFsdWVdIDogYWNjKSwgW10pO1xuICAgICAgICAgICAgY29uc3QgZGF0YVJhbmdlID0gZ2V0TGltaXRTYWZlbHkoWy4uLm5ldyBTZXQodmFsdWVzKV0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0U2l6ZSA9IGlzVmVydGljYWxBbGlnbihsZWdlbmQuYWxpZ24pID8gbGF5b3V0LnBsb3Qud2lkdGggLyAyIDogbGF5b3V0LnBsb3QuaGVpZ2h0O1xuICAgICAgICAgICAgZXh0ZW5kKHN0YXRlLmNvbG9yVmFsdWVTY2FsZSwgY2FsY3VsYXRlQ29vcmRpbmF0ZVNjYWxlKHtcbiAgICAgICAgICAgICAgICBkYXRhUmFuZ2UsXG4gICAgICAgICAgICAgICAgb2Zmc2V0U2l6ZSxcbiAgICAgICAgICAgICAgICB1c2VTcGVjdHJ1bUxlZ2VuZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzY2FsZU9wdGlvbjoge30sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFRyZWVtYXBab29tSWQoeyBzdGF0ZSB9LCBpZCkge1xuICAgICAgICAgICAgc3RhdGUudHJlZW1hcFpvb21JZC5wcmV2ID0gc3RhdGUudHJlZW1hcFpvb21JZC5jdXI7XG4gICAgICAgICAgICBzdGF0ZS50cmVlbWFwWm9vbUlkLmN1ciA9IGlkO1xuICAgICAgICB9LFxuICAgICAgICB6b29tQmFjayh7IHN0YXRlIH0pIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCB7IHRyZWVtYXBTZXJpZXMsIHRyZWVtYXBab29tSWQgfSA9IHN0YXRlO1xuICAgICAgICAgICAgY29uc3QgeyBwcmV2IH0gPSB0cmVlbWFwWm9vbUlkO1xuICAgICAgICAgICAgY29uc3QgcHJldlNlcmllcyA9IHRyZWVtYXBTZXJpZXMuZmluZCgoeyBpZCB9KSA9PiBpZCA9PT0gcHJldik7XG4gICAgICAgICAgICBzdGF0ZS50cmVlbWFwWm9vbUlkLnByZXYgPSAoX2IgPSAoX2EgPSBwcmV2U2VyaWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50SWQsIChfYiAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBUUkVFTUFQX1JPT1RfSUQpKTtcbiAgICAgICAgICAgIHN0YXRlLnRyZWVtYXBab29tSWQuY3VyID0gcHJldjtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIG9ic2VydmU6IHtcbiAgICAgICAgdXBkYXRlQ29sb3JWYWx1ZVNjYWxlKCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgnc2V0Q29sb3JWYWx1ZVNjYWxlJyk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBpc1RyZWVtYXBTZXJpZXNab29taW5nOiAoeyB0cmVlbWFwWm9vbUlkIH0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cmVlbWFwWm9vbUlkICYmIHRyZWVtYXBab29tSWQuY3VyICE9PSB0cmVlbWFwWm9vbUlkLnByZXY7XG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5leHBvcnQgZGVmYXVsdCBjb2xvclZhbHVlU2NhbGU7XG4iLCJpbXBvcnQgeyBnZXRGaXJzdFZhbGlkVmFsdWUsIGlzTnVsbCwgaW5jbHVkZXMgfSBmcm9tIFwiLi4vaGVscGVycy91dGlsc1wiO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSBcIi4vc3RvcmVcIjtcbmltcG9ydCB7IGdldEF4aXNOYW1lLCBpc0xhYmVsQXhpc09uWUF4aXMsIGdldFZhbHVlQXhpc05hbWVzLCBnZXRZQXhpc09wdGlvbiwgaGFzU2Vjb25kYXJ5WUF4aXMsIH0gZnJvbSBcIi4uL2hlbHBlcnMvYXhlc1wiO1xuaW1wb3J0IHsgZ2V0Q29vcmRpbmF0ZVlWYWx1ZSwgaXNDb29yZGluYXRlU2VyaWVzIH0gZnJvbSBcIi4uL2hlbHBlcnMvY29vcmRpbmF0ZVwiO1xuaW1wb3J0IHsgaXNSYW5nZVZhbHVlIH0gZnJvbSBcIi4uL2hlbHBlcnMvcmFuZ2VcIjtcbmltcG9ydCB7IEF4aXNUeXBlIH0gZnJvbSBcIi4uL2NvbXBvbmVudC9heGlzXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0TGltaXRTYWZlbHkoYmFzZVZhbHVlcywgaXNYQXhpcyA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGltaXQgPSB7XG4gICAgICAgIG1pbjogTWF0aC5taW4oLi4uYmFzZVZhbHVlcyksXG4gICAgICAgIG1heDogTWF0aC5tYXgoLi4uYmFzZVZhbHVlcyksXG4gICAgfTtcbiAgICBpZiAoYmFzZVZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgW2ZpcnN0VmFsdWVdID0gYmFzZVZhbHVlcztcbiAgICAgICAgaWYgKGlzWEF4aXMpIHtcbiAgICAgICAgICAgIGxpbWl0Lm1pbiA9IGZpcnN0VmFsdWU7XG4gICAgICAgICAgICBsaW1pdC5tYXggPSBmaXJzdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpcnN0VmFsdWUgPiAwKSB7XG4gICAgICAgICAgICBsaW1pdC5taW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpcnN0VmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIGxpbWl0Lm1heCA9IDEwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGltaXQubWF4ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChsaW1pdC5taW4gPT09IDAgJiYgbGltaXQubWF4ID09PSAwKSB7XG4gICAgICAgIGxpbWl0Lm1heCA9IDEwO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaW1pdC5taW4gPT09IGxpbWl0Lm1heCkge1xuICAgICAgICBsaW1pdC5taW4gLT0gbGltaXQubWluIC8gMTA7XG4gICAgICAgIGxpbWl0Lm1heCArPSBsaW1pdC5tYXggLyAxMDtcbiAgICB9XG4gICAgcmV0dXJuIGxpbWl0O1xufVxuZnVuY3Rpb24gaW5pdERhdGFSYW5nZShhY2NEYXRhUmFuZ2VWYWx1ZSwgY3VyRGF0YVJhbmdlVmFsdWUsIGF4aXNOYW1lKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IGRlZmF1bHREYXRhUmFuZ2UgPSB7XG4gICAgICAgIG1pbjogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgIG1heDogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtaW46IE1hdGgubWluKGN1ckRhdGFSYW5nZVZhbHVlW2F4aXNOYW1lXS5taW4sIChfYiA9IChfYSA9IGFjY0RhdGFSYW5nZVZhbHVlW2F4aXNOYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1pbiwgKF9iICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRlZmF1bHREYXRhUmFuZ2UubWluKSkpLFxuICAgICAgICBtYXg6IE1hdGgubWF4KGN1ckRhdGFSYW5nZVZhbHVlW2F4aXNOYW1lXS5tYXgsIChfZCA9IChfYyA9IGFjY0RhdGFSYW5nZVZhbHVlW2F4aXNOYW1lXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1heCwgKF9kICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRlZmF1bHREYXRhUmFuZ2UubWF4KSkpLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRUb3RhbERhdGFSYW5nZShzZXJpZXNEYXRhUmFuZ2UpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhzZXJpZXNEYXRhUmFuZ2UpLnJlZHVjZSgoYWNjLCBjdXIpID0+IHtcbiAgICAgICAgaWYgKGN1ci54QXhpcykge1xuICAgICAgICAgICAgYWNjLnhBeGlzID0gaW5pdERhdGFSYW5nZShhY2MsIGN1ciwgJ3hBeGlzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci55QXhpcykge1xuICAgICAgICAgICAgYWNjLnlBeGlzID0gaW5pdERhdGFSYW5nZShhY2MsIGN1ciwgJ3lBeGlzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci5zZWNvbmRhcnlZQXhpcykge1xuICAgICAgICAgICAgYWNjLnNlY29uZGFyeVlBeGlzID0gaW5pdERhdGFSYW5nZShhY2MsIGN1ciwgJ3NlY29uZGFyeVlBeGlzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci5jaXJjdWxhckF4aXMpIHtcbiAgICAgICAgICAgIGFjYy5jaXJjdWxhckF4aXMgPSBpbml0RGF0YVJhbmdlKGFjYywgY3VyLCAnY2lyY3VsYXJBeGlzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci52ZXJ0aWNhbEF4aXMpIHtcbiAgICAgICAgICAgIGFjYy52ZXJ0aWNhbEF4aXMgPSBpbml0RGF0YVJhbmdlKGFjYywgY3VyLCAndmVydGljYWxBeGlzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBzZXRTZXJpZXNEYXRhUmFuZ2UoeyBvcHRpb25zLCBzZXJpZXNOYW1lLCB2YWx1ZXMsIHZhbHVlQXhpc05hbWUsIHNlcmllc0RhdGFSYW5nZSwgfSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgYXhpc05hbWVzO1xuICAgIGlmIChpbmNsdWRlcyhbQXhpc1R5cGUuWCwgQXhpc1R5cGUuQ0lSQ1VMQVIsIEF4aXNUeXBlLlZFUlRJQ0FMXSwgdmFsdWVBeGlzTmFtZSkpIHtcbiAgICAgICAgYXhpc05hbWVzID0gW3ZhbHVlQXhpc05hbWVdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uc1VzaW5nWUF4aXMgPSBvcHRpb25zO1xuICAgICAgICBjb25zdCB7IHNlY29uZGFyeVlBeGlzIH0gPSBnZXRZQXhpc09wdGlvbihvcHRpb25zVXNpbmdZQXhpcyk7XG4gICAgICAgIGF4aXNOYW1lcyA9XG4gICAgICAgICAgICBoYXNTZWNvbmRhcnlZQXhpcyhvcHRpb25zVXNpbmdZQXhpcykgJiYgKChfYSA9IHNlY29uZGFyeVlBeGlzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2hhcnRUeXBlKVxuICAgICAgICAgICAgICAgID8gW3NlY29uZGFyeVlBeGlzLmNoYXJ0VHlwZSA9PT0gc2VyaWVzTmFtZSA/ICdzZWNvbmRhcnlZQXhpcycgOiAneUF4aXMnXVxuICAgICAgICAgICAgICAgIDogZ2V0VmFsdWVBeGlzTmFtZXMob3B0aW9uc1VzaW5nWUF4aXMsIHZhbHVlQXhpc05hbWUpO1xuICAgIH1cbiAgICBheGlzTmFtZXMuZm9yRWFjaCgoYXhpc05hbWUpID0+IHtcbiAgICAgICAgc2VyaWVzRGF0YVJhbmdlW3Nlcmllc05hbWVdW2F4aXNOYW1lXSA9IGdldExpbWl0U2FmZWx5KFsuLi5uZXcgU2V0KHZhbHVlcyldKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2VyaWVzRGF0YVJhbmdlO1xufVxuZnVuY3Rpb24gZ2V0Qm94UGxvdFZhbHVlcyhzZXJpZXMsIHNlcmllc05hbWUpIHtcbiAgICByZXR1cm4gc2VyaWVzW3Nlcmllc05hbWVdLmRhdGEuZmxhdE1hcCgoeyBkYXRhLCBvdXRsaWVycyA9IFtdIH0pID0+IFtcbiAgICAgICAgLi4uKChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHZvaWQgMCA/IGRhdGEgOiBbXSkpLmZsYXRNYXAoKGRhdHVtKSA9PiBkYXR1bSksXG4gICAgICAgIC4uLigob3V0bGllcnMgIT09IG51bGwgJiYgb3V0bGllcnMgIT09IHZvaWQgMCA/IG91dGxpZXJzIDogW10pKS5mbGF0TWFwKChkYXR1bSkgPT4gZGF0dW0pLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gZ2V0QnVsbGV0VmFsdWVzKHNlcmllcywgc2VyaWVzTmFtZSkge1xuICAgIHJldHVybiBzZXJpZXNbc2VyaWVzTmFtZV0uZGF0YS5mbGF0TWFwKCh7IGRhdGEsIG1hcmtlcnMsIHJhbmdlcyB9KSA9PiBbXG4gICAgICAgIGRhdGEsXG4gICAgICAgIC4uLigobWFya2VycyAhPT0gbnVsbCAmJiBtYXJrZXJzICE9PSB2b2lkIDAgPyBtYXJrZXJzIDogW10pKS5mbGF0TWFwKChkYXR1bSkgPT4gZGF0dW0pLFxuICAgICAgICAuLi4oKHJhbmdlcyAhPT0gbnVsbCAmJiByYW5nZXMgIT09IHZvaWQgMCA/IHJhbmdlcyA6IFtdKSkuZmxhdE1hcCgocmFuZ2UpID0+IHJhbmdlKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIGdldENvb3JkaW5hdGVEYXRhVmFsdWVzKHZhbHVlcywgY2F0ZWdvcmllcywgaGFzRGF0ZVZhbHVlKSB7XG4gICAgY29uc3QgeUF4aXNWYWx1ZXMgPSB2YWx1ZXNcbiAgICAgICAgLmZpbHRlcigodmFsdWUpID0+ICFpc051bGwodmFsdWUpKVxuICAgICAgICAubWFwKCh2YWx1ZSkgPT4gZ2V0Q29vcmRpbmF0ZVlWYWx1ZSh2YWx1ZSkpO1xuICAgIGNvbnN0IHhBeGlzVmFsdWVzID0gY2F0ZWdvcmllcy5tYXAoKHZhbHVlKSA9PiBoYXNEYXRlVmFsdWUgPyBOdW1iZXIobmV3IERhdGUodmFsdWUpKSA6IE51bWJlcih2YWx1ZSkpO1xuICAgIHJldHVybiB7IHhBeGlzVmFsdWVzLCB5QXhpc1ZhbHVlcyB9O1xufVxuY29uc3QgZGF0YVJhbmdlID0ge1xuICAgIG5hbWU6ICdkYXRhUmFuZ2UnLFxuICAgIHN0YXRlOiAoKSA9PiAoe1xuICAgICAgICBkYXRhUmFuZ2U6IHt9LFxuICAgIH0pLFxuICAgIGFjdGlvbjoge1xuICAgICAgICBzZXREYXRhUmFuZ2UoeyBzdGF0ZSwgaW5pdFN0b3JlU3RhdGUgfSkge1xuICAgICAgICAgICAgY29uc3QgeyBzZXJpZXMsIGRpc2FibGVkU2VyaWVzLCBzdGFja1NlcmllcywgY2F0ZWdvcmllcywgb3B0aW9ucyB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBzZXJpZXNEYXRhUmFuZ2UgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsQXhpc09uWUF4aXMgPSBpc0xhYmVsQXhpc09uWUF4aXMoeyBzZXJpZXMsIG9wdGlvbnMsIGNhdGVnb3JpZXMgfSk7XG4gICAgICAgICAgICBjb25zdCB7IGxhYmVsQXhpc05hbWUsIHZhbHVlQXhpc05hbWUgfSA9IGdldEF4aXNOYW1lKGxhYmVsQXhpc09uWUF4aXMsIHNlcmllcyk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzZXJpZXMpLmZvckVhY2goKHNlcmllc05hbWUpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIHNlcmllc0RhdGFSYW5nZVtzZXJpZXNOYW1lXSA9IHt9O1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBzZXJpZXNbc2VyaWVzTmFtZV0uZGF0YS5mbGF0TWFwKCh7IGRhdGEsIG5hbWUgfSkgPT4gZGlzYWJsZWRTZXJpZXMuaW5jbHVkZXMobmFtZSkgPyBbXSA6IGRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0RXhpc3RWYWx1ZSA9IGdldEZpcnN0VmFsaWRWYWx1ZSh2YWx1ZXMpO1xuICAgICAgICAgICAgICAgIGlmIChpc0Nvb3JkaW5hdGVTZXJpZXMoaW5pdFN0b3JlU3RhdGUuc2VyaWVzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNEYXRlVmFsdWUgPSAhISgoX2EgPSBvcHRpb25zLnhBeGlzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgeUF4aXNWYWx1ZXMsIHhBeGlzVmFsdWVzIH0gPSBnZXRDb29yZGluYXRlRGF0YVZhbHVlcyh2YWx1ZXMsIGNhdGVnb3JpZXMsIGhhc0RhdGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHlBeGlzVmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNEYXRhUmFuZ2Vbc2VyaWVzTmFtZV1bbGFiZWxBeGlzTmFtZV0gPSBnZXRMaW1pdFNhZmVseShbLi4ueEF4aXNWYWx1ZXNdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNlcmllc1tzZXJpZXNOYW1lXS5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNSYW5nZVZhbHVlKGZpcnN0RXhpc3RWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLnJlZHVjZSgoYXJyLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gWy4uLmFyciwgLi4udmFsdWVdIDogWy4uLnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFja1NlcmllcyAmJiAoKF9iID0gc3RhY2tTZXJpZXNbc2VyaWVzTmFtZV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gc3RhY2tTZXJpZXNbc2VyaWVzTmFtZV0uZGF0YVJhbmdlVmFsdWVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzZXJpZXNOYW1lID09PSAnYm94UGxvdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gZ2V0Qm94UGxvdFZhbHVlcyhzZXJpZXMsIHNlcmllc05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzZXJpZXNOYW1lID09PSAnYnVsbGV0Jykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBnZXRCdWxsZXRWYWx1ZXMoc2VyaWVzLCBzZXJpZXNOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVzKFsnYmFyJywgJ2NvbHVtbicsICdyYWRhcicsICdidWxsZXQnXSwgc2VyaWVzTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFNlcmllc0RhdGFSYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHNlcmllc05hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVBeGlzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzRGF0YVJhbmdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXdEYXRhUmFuZ2UgPSBnZXRUb3RhbERhdGFSYW5nZShzZXJpZXNEYXRhUmFuZ2UpO1xuICAgICAgICAgICAgZXh0ZW5kKHN0YXRlLmRhdGFSYW5nZSwgbmV3RGF0YVJhbmdlKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIG9ic2VydmU6IHtcbiAgICAgICAgdXBkYXRlRGF0YVJhbmdlKCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgnc2V0RGF0YVJhbmdlJyk7XG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5leHBvcnQgZGVmYXVsdCBkYXRhUmFuZ2U7XG4iLCJpbXBvcnQgeyBnZXRJbml0QXhpc0ludGVydmFsRGF0YSwgZ2V0TWF4TGFiZWxTaXplLCBpc0xhYmVsQXhpc09uWUF4aXMsIG1ha2VUaXRsZU9wdGlvbiwgZ2V0RGVmYXVsdFJhZGlhbEF4aXNEYXRhLCB9IGZyb20gXCIuLi9oZWxwZXJzL2F4ZXNcIjtcbmltcG9ydCB7IG1ha2VMYWJlbHNGcm9tTGltaXQsIGdldEZvbnRIZWlnaHQgfSBmcm9tIFwiLi4vaGVscGVycy9jYWxjdWxhdG9yXCI7XG5pbXBvcnQgeyBnZXRUaXRsZUZvbnRTdHJpbmcgfSBmcm9tIFwiLi4vaGVscGVycy9zdHlsZVwiO1xuaW1wb3J0IHsgREVHUkVFXzM2MCwgREVHUkVFXzAgfSBmcm9tIFwiLi4vaGVscGVycy9zZWN0b3JcIjtcbmltcG9ydCB7IGlzT2JqZWN0LCBjYWxjdWxhdGVTaXplV2l0aFBlcmNlbnRTdHJpbmcgfSBmcm9tIFwiLi4vaGVscGVycy91dGlsc1wiO1xuaW1wb3J0IHsgUmFkaWFsQXhpc1R5cGUgfSBmcm9tIFwiLi9yYWRpYWxBeGVzXCI7XG5pbXBvcnQgeyBpc0V4aXN0UGxvdElkIH0gZnJvbSBcIi4uL2hlbHBlcnMvcGxvdFwiO1xuY29uc3QgREVGQVVMVF9MQUJFTF9QQURESU5HID0gMTU7XG5jb25zdCBSQU5HRV9CQVJfTUFSR0lOID0gMTA7XG5jb25zdCBDTE9DS19IQU5EX01BUkdJTiA9IDEwO1xuZXhwb3J0IGNvbnN0IERBVEFfTEFCRUxfTUFSR0lOID0gMzA7XG5mdW5jdGlvbiBtYWtlU29saWREYXRhKG91dGVyUmFkaXVzLCBiYXJXaWR0aCwgc29saWRPcHRpb25zKSB7XG4gICAgY29uc3QgaW5pdGlhbFNvbGlkT3B0aW9ucyA9IChzb2xpZE9wdGlvbnMgIT09IG51bGwgJiYgc29saWRPcHRpb25zICE9PSB2b2lkIDAgPyBzb2xpZE9wdGlvbnMgOiBmYWxzZSk7XG4gICAgY29uc3Qgc29saWRCYXJXaWR0aCA9IGNhbGN1bGF0ZVNpemVXaXRoUGVyY2VudFN0cmluZyhvdXRlclJhZGl1cywgYmFyV2lkdGgpO1xuICAgIGNvbnN0IGRlZmF1bHRTb2xpZE9wdGlvbnMgPSB7XG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgIHJhZGl1c1JhbmdlOiB7XG4gICAgICAgICAgICBpbm5lcjogb3V0ZXJSYWRpdXMgLSBzb2xpZEJhcldpZHRoLFxuICAgICAgICAgICAgb3V0ZXI6IG91dGVyUmFkaXVzLFxuICAgICAgICB9LFxuICAgICAgICBiYXJXaWR0aDogc29saWRCYXJXaWR0aCxcbiAgICAgICAgY2xvY2tIYW5kOiBmYWxzZSxcbiAgICB9O1xuICAgIGlmICghaW5pdGlhbFNvbGlkT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0U29saWRPcHRpb25zKSwgeyB2aXNpYmxlOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGlzT2JqZWN0KGluaXRpYWxTb2xpZE9wdGlvbnMpXG4gICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0U29saWRPcHRpb25zKSwgaW5pdGlhbFNvbGlkT3B0aW9ucykgOiBkZWZhdWx0U29saWRPcHRpb25zO1xufVxuZnVuY3Rpb24gZ2V0Q2lyY3VsYXJBeGlzRGF0YSh7IGxhYmVscywgaW50ZXJ2YWxEYXRhLCBjaXJjdWxhckF4aXNMYWJlbE1hcmdpbiwgY2lyY3VsYXJBeGlzTGFiZWxGb250LCBkZWZhdWx0QXhpc0RhdGEsIGJhbmRXaWR0aCwgb3B0aW9ucywgc29saWRCYXJXaWR0aCwgfSkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCB7IG1heExhYmVsV2lkdGgsIG1heExhYmVsSGVpZ2h0IH0gPSBnZXRNYXhMYWJlbFNpemUobGFiZWxzLCBjaXJjdWxhckF4aXNMYWJlbE1hcmdpbiwgY2lyY3VsYXJBeGlzTGFiZWxGb250KTtcbiAgICBjb25zdCB7IHRvdGFsQW5nbGUsIGF4aXNTaXplLCBjZW50ZXJYLCBjZW50ZXJZLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZHJhd2luZ1N0YXJ0QW5nbGUsIGNsb2Nrd2lzZSwgfSA9IGRlZmF1bHRBeGlzRGF0YTtcbiAgICBjb25zdCB7IHRpY2tJbnRlcnZhbCwgbGFiZWxJbnRlcnZhbCB9ID0gaW50ZXJ2YWxEYXRhO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gYXhpc1NpemUgLSBiYW5kV2lkdGggLSBSQU5HRV9CQVJfTUFSR0lOO1xuICAgIGNvbnN0IHNvbGlkQmFyV2lkdGhWYWx1ZSA9IChzb2xpZEJhcldpZHRoICE9PSBudWxsICYmIHNvbGlkQmFyV2lkdGggIT09IHZvaWQgMCA/IHNvbGlkQmFyV2lkdGggOiBvdXRlclJhZGl1cyAqIDAuMSk7XG4gICAgY29uc3Qgc29saWREYXRhID0gbWFrZVNvbGlkRGF0YShvdXRlclJhZGl1cyAtIGNpcmN1bGFyQXhpc0xhYmVsTWFyZ2luIC0gbWF4TGFiZWxIZWlnaHQgLSAoY2lyY3VsYXJBeGlzTGFiZWxNYXJnaW4gLSA1KSwgc29saWRCYXJXaWR0aFZhbHVlLCAoX2IgPSAoX2EgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VyaWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc29saWQpO1xuICAgIGNvbnN0IGNlbnRyYWxBbmdsZSA9IHRvdGFsQW5nbGUgLyAobGFiZWxzLmxlbmd0aCArICh0b3RhbEFuZ2xlIDwgREVHUkVFXzM2MCA/IC0xIDogREVHUkVFXzApKTtcbiAgICBjb25zdCBtYXhDbG9ja0hhbmRTaXplID0gb3V0ZXJSYWRpdXMgLVxuICAgICAgICBjaXJjdWxhckF4aXNMYWJlbE1hcmdpbiAtXG4gICAgICAgIG1heExhYmVsSGVpZ2h0IC1cbiAgICAgICAgQ0xPQ0tfSEFORF9NQVJHSU4gK1xuICAgICAgICAoc29saWREYXRhLnZpc2libGUgPyAtc29saWREYXRhLmJhcldpZHRoIC0gQ0xPQ0tfSEFORF9NQVJHSU4gOiAwKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBheGlzU2l6ZSxcbiAgICAgICAgY2VudGVyWCxcbiAgICAgICAgY2VudGVyWSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIGxhYmVscyxcbiAgICAgICAgICAgIGludGVydmFsOiBsYWJlbEludGVydmFsLFxuICAgICAgICAgICAgbWFyZ2luOiBjaXJjdWxhckF4aXNMYWJlbE1hcmdpbixcbiAgICAgICAgICAgIG1heFdpZHRoOiBtYXhMYWJlbFdpZHRoLFxuICAgICAgICAgICAgbWF4SGVpZ2h0OiBtYXhMYWJlbEhlaWdodCxcbiAgICAgICAgfSxcbiAgICAgICAgcmFkaXVzOiB7XG4gICAgICAgICAgICBpbm5lcjogMCxcbiAgICAgICAgICAgIG91dGVyOiBvdXRlclJhZGl1cyxcbiAgICAgICAgfSxcbiAgICAgICAgYW5nbGU6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgZW5kOiBlbmRBbmdsZSxcbiAgICAgICAgICAgIHRvdGFsOiB0b3RhbEFuZ2xlLFxuICAgICAgICAgICAgY2VudHJhbDogY2VudHJhbEFuZ2xlLFxuICAgICAgICAgICAgZHJhd2luZ1N0YXJ0OiBkcmF3aW5nU3RhcnRBbmdsZSxcbiAgICAgICAgfSxcbiAgICAgICAgYmFuZDoge1xuICAgICAgICAgICAgd2lkdGg6IGJhbmRXaWR0aCxcbiAgICAgICAgICAgIG1hcmdpbjogUkFOR0VfQkFSX01BUkdJTixcbiAgICAgICAgfSxcbiAgICAgICAgdGlja0ludGVydmFsLFxuICAgICAgICBjbG9ja3dpc2UsXG4gICAgICAgIG1heENsb2NrSGFuZFNpemUsXG4gICAgICAgIHRpdGxlOiBtYWtlVGl0bGVPcHRpb24oKF9kID0gKF9jID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNpcmN1bGFyQXhpcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnRpdGxlKSxcbiAgICAgICAgc29saWREYXRhLFxuICAgIH07XG59XG5mdW5jdGlvbiBtYWtlTGFiZWxzKG9wdGlvbnMsIHJhd0xhYmVscywgYXhpc05hbWUpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSAoX2MgPSAoX2IgPSAoX2EgPSBvcHRpb25zW2F4aXNOYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhYmVsKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZm9ybWF0dGVyLCAoX2MgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogKCh2YWx1ZSkgPT4gdmFsdWUpKSk7XG4gICAgcmV0dXJuIHJhd0xhYmVscy5tYXAoKGxhYmVsLCBpbmRleCkgPT4gZm9ybWF0dGVyKGxhYmVsLCB7IGluZGV4LCBsYWJlbHM6IHJhd0xhYmVscywgYXhpc05hbWUgfSkpO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0xhYmVscyhpc0xhYmVsT25WZXJ0aWNhbEF4aXMsIG9wdGlvbnMsIGNhdGVnb3JpZXMsIHNjYWxlKSB7XG4gICAgY29uc3QgdmFsdWVBeGlzTmFtZSA9IGlzTGFiZWxPblZlcnRpY2FsQXhpc1xuICAgICAgICA/IFJhZGlhbEF4aXNUeXBlLkNJUkNVTEFSXG4gICAgICAgIDogUmFkaWFsQXhpc1R5cGUuVkVSVElDQUw7XG4gICAgY29uc3QgeyBsaW1pdCwgc3RlcFNpemUgfSA9IHNjYWxlW3ZhbHVlQXhpc05hbWVdO1xuICAgIGNvbnN0IHZhbHVlTGFiZWxzID0gbWFrZUxhYmVscyhvcHRpb25zLCBtYWtlTGFiZWxzRnJvbUxpbWl0KGxpbWl0LCBzdGVwU2l6ZSksIHZhbHVlQXhpc05hbWUpO1xuICAgIGNvbnN0IGNhdGVnb3J5TGFiZWxzID0gbWFrZUxhYmVscyhvcHRpb25zLCBjYXRlZ29yaWVzLCBpc0xhYmVsT25WZXJ0aWNhbEF4aXMgPyBSYWRpYWxBeGlzVHlwZS5WRVJUSUNBTCA6IFJhZGlhbEF4aXNUeXBlLkNJUkNVTEFSKTtcbiAgICByZXR1cm4gaXNMYWJlbE9uVmVydGljYWxBeGlzID8gdmFsdWVMYWJlbHMgOiBjYXRlZ29yeUxhYmVscztcbn1cbmZ1bmN0aW9uIGdldEF4aXNMYWJlbE1hcmdpbihvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIHJldHVybiBfZCA9IChfYyA9IChfYiA9IChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jaXJjdWxhckF4aXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sYWJlbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1hcmdpbiwgKF9kICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IERFRkFVTFRfTEFCRUxfUEFERElORyk7XG59XG5mdW5jdGlvbiBoYXNBeGVzTGF5b3V0Q2hhbmdlZChwcmV2aW91c0F4ZXMsIGN1cnJlbnRBeGVzKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHByZXZNYXhXaWR0aCA9IChfYiA9IChfYSA9IHByZXZpb3VzQXhlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhYmVsKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWF4V2lkdGg7XG4gICAgY29uc3QgcHJldk1heEhlaWdodCA9IChfZCA9IChfYyA9IHByZXZpb3VzQXhlcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxhYmVsKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubWF4SGVpZ2h0O1xuICAgIGNvbnN0IGN1ck1heFdpZHRoID0gY3VycmVudEF4ZXMubGFiZWwubWF4V2lkdGg7XG4gICAgY29uc3QgY3VyTWF4SGVpZ2h0ID0gY3VycmVudEF4ZXMubGFiZWwubWF4SGVpZ2h0O1xuICAgIHJldHVybiBwcmV2TWF4SGVpZ2h0ICE9PSBjdXJNYXhIZWlnaHQgfHwgcHJldk1heFdpZHRoICE9PSBjdXJNYXhXaWR0aDtcbn1cbmNvbnN0IGF4ZXMgPSB7XG4gICAgbmFtZTogJ2dhdWdlQXhlcycsXG4gICAgc3RhdGU6ICgpID0+ICh7XG4gICAgICAgIHJhZGlhbEF4ZXM6IHtcbiAgICAgICAgICAgIGNpcmN1bGFyQXhpczoge30sXG4gICAgICAgIH0sXG4gICAgfSksXG4gICAgYWN0aW9uOiB7XG4gICAgICAgIHNldENpcmN1bGFyQXhpc0RhdGEoeyBzdGF0ZSB9KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX287XG4gICAgICAgICAgICBjb25zdCB7IHNlcmllcywgbGF5b3V0LCBzY2FsZSB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gc3RhdGUuY2F0ZWdvcmllcztcbiAgICAgICAgICAgIGNvbnN0IHsgcGxvdCB9ID0gbGF5b3V0O1xuICAgICAgICAgICAgY29uc3QgaXNMYWJlbE9uVmVydGljYWxBeGlzID0gaXNMYWJlbEF4aXNPbllBeGlzKHsgc2VyaWVzLCBjYXRlZ29yaWVzIH0pO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHN0YXRlLm9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCB0aGVtZSA9IHN0YXRlLnRoZW1lO1xuICAgICAgICAgICAgY29uc3QgY2lyY3VsYXJBeGlzTGFiZWxGb250ID0gZ2V0VGl0bGVGb250U3RyaW5nKHRoZW1lLmNpcmN1bGFyQXhpcy5sYWJlbCk7XG4gICAgICAgICAgICBjb25zdCBjaXJjdWxhckF4aXNMYWJlbE1hcmdpbiA9IGdldEF4aXNMYWJlbE1hcmdpbihvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGNpcmN1bGFyQXhpc0xhYmVscyA9IGdldEF4aXNMYWJlbHMoaXNMYWJlbE9uVmVydGljYWxBeGlzLCBvcHRpb25zLCBjYXRlZ29yaWVzLCBzY2FsZSk7XG4gICAgICAgICAgICBjb25zdCB7IG1heExhYmVsV2lkdGgsIG1heExhYmVsSGVpZ2h0IH0gPSBnZXRNYXhMYWJlbFNpemUoY2lyY3VsYXJBeGlzTGFiZWxzLCBjaXJjdWxhckF4aXNMYWJlbE1hcmdpbiwgY2lyY3VsYXJBeGlzTGFiZWxGb250KTtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRBeGlzRGF0YSA9IGdldERlZmF1bHRSYWRpYWxBeGlzRGF0YShvcHRpb25zLCBwbG90LCBtYXhMYWJlbFdpZHRoLCBtYXhMYWJlbEhlaWdodCwgaXNMYWJlbE9uVmVydGljYWxBeGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFMYWJlbEhlaWdodCA9IGdldEZvbnRIZWlnaHQoZ2V0VGl0bGVGb250U3RyaW5nKHRoZW1lLnNlcmllcy5nYXVnZS5kYXRhTGFiZWxzKSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhTGFiZWxPZmZzZXRZID0gKF9kID0gKF9jID0gKF9iID0gKF9hID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlcmllcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRhdGFMYWJlbHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5vZmZzZXRZLCAoX2QgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogREFUQV9MQUJFTF9NQVJHSU4pKTtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0QXhpc0RhdGEuaXNTZW1pQ2lyY3VsYXIpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0QXhpc0RhdGEuY2VudGVyWSA9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRBeGlzRGF0YS5jZW50ZXJZIC0gKGRhdGFMYWJlbE9mZnNldFkgPiAwID8gZGF0YUxhYmVsT2Zmc2V0WSArIGRhdGFMYWJlbEhlaWdodCA6IDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpZmZIZWlnaHQgPSBkZWZhdWx0QXhpc0RhdGEuY2VudGVyWSAtIGRlZmF1bHRBeGlzRGF0YS5heGlzU2l6ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0QXhpc0RhdGEuYXhpc1NpemUgKz0gZGlmZkhlaWdodCA8IDAgPyBkaWZmSGVpZ2h0IDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlZnVhbHRCYW5kV2lkdGggPSAoKF9nID0gKF9mID0gKF9lID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnBsb3QpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5iYW5kcykgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmxlbmd0aCkgPyBkZWZhdWx0QXhpc0RhdGEuYXhpc1NpemUgLyAyIC0gUkFOR0VfQkFSX01BUkdJTlxuICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGJhbmRXaWR0aCA9IChfayA9IChfaiA9IChfaCA9IHRoZW1lLnBsb3QpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5iYW5kcykgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmJhcldpZHRoLCAoX2sgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogZGVmdWFsdEJhbmRXaWR0aCkpO1xuICAgICAgICAgICAgY29uc3QgY2lyY3VsYXJBeGlzRGF0YSA9IGdldENpcmN1bGFyQXhpc0RhdGEoe1xuICAgICAgICAgICAgICAgIGxhYmVsczogY2lyY3VsYXJBeGlzTGFiZWxzLFxuICAgICAgICAgICAgICAgIGludGVydmFsRGF0YTogZ2V0SW5pdEF4aXNJbnRlcnZhbERhdGEodHJ1ZSwge1xuICAgICAgICAgICAgICAgICAgICBheGlzOiBvcHRpb25zLmNpcmN1bGFyQXhpcyxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllcyxcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRBeGlzRGF0YSxcbiAgICAgICAgICAgICAgICBjaXJjdWxhckF4aXNMYWJlbE1hcmdpbixcbiAgICAgICAgICAgICAgICBjaXJjdWxhckF4aXNMYWJlbEZvbnQsXG4gICAgICAgICAgICAgICAgYmFuZFdpZHRoLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc29saWRCYXJXaWR0aDogKF9tID0gKF9sID0gdGhlbWUuc2VyaWVzLmdhdWdlKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wuc29saWQpID09PSBudWxsIHx8IF9tID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbS5iYXJXaWR0aCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGhhc0F4ZXNMYXlvdXRDaGFuZ2VkKChfbyA9IHN0YXRlLnJhZGlhbEF4ZXMpID09PSBudWxsIHx8IF9vID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfby5jaXJjdWxhckF4aXMsIGNpcmN1bGFyQXhpc0RhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoc3RhdGUsICdsYXlvdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLnJhZGlhbEF4ZXMgPSB7XG4gICAgICAgICAgICAgICAgY2lyY3VsYXJBeGlzOiBjaXJjdWxhckF4aXNEYXRhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkR2F1Z2VQbG90QmFuZCh7IHN0YXRlIH0sIHsgZGF0YSB9KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGJhbmRzID0gKF9jID0gKF9iID0gKF9hID0gc3RhdGUub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBsb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5iYW5kcywgKF9jICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdKSk7XG4gICAgICAgICAgICBpZiAoIWlzRXhpc3RQbG90SWQoYmFuZHMsIGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgndXBkYXRlT3B0aW9ucycsIHsgb3B0aW9uczogeyBwbG90OiB7IGJhbmRzOiBbLi4uYmFuZHMsIGRhdGFdIH0gfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlR2F1Z2VQbG90QmFuZCh7IHN0YXRlIH0sIHsgaWQgfSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBiYW5kcyA9IChfYyA9IChfYiA9IChfYSA9IHN0YXRlLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wbG90KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmFuZHMsIChfYyAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXSkpLmZpbHRlcigoeyBpZDogYmFuZElkIH0pID0+IGJhbmRJZCAhPT0gaWQpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgndXBkYXRlT3B0aW9ucycsIHsgb3B0aW9uczogeyBwbG90OiB7IGJhbmRzIH0gfSB9KTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIG9ic2VydmU6IHtcbiAgICAgICAgdXBkYXRlUmFkaWFsQXhlcygpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goJ3NldENpcmN1bGFyQXhpc0RhdGEnKTtcbiAgICAgICAgfSxcbiAgICB9LFxufTtcbmV4cG9ydCBkZWZhdWx0IGF4ZXM7XG4iLCJpbXBvcnQgeyBBeGlzVHlwZSB9IGZyb20gXCIuLi9jb21wb25lbnQvYXhpc1wiO1xuaW1wb3J0IHsgZ2V0QXhpc1RoZW1lLCBnZXRWaWV3QXhpc0xhYmVscywgbWFrZVJvdGF0aW9uRGF0YSwgZ2V0Um90YXRhYmxlT3B0aW9uLCBoYXNBeGVzTGF5b3V0Q2hhbmdlZCwgbWFrZVRpdGxlT3B0aW9uLCBnZXRNYXhMYWJlbFNpemUsIGdldExhYmVsWE1hcmdpbiwgZ2V0TGFiZWxzQXBwbGllZEZvcm1hdHRlciwgaXNEYXRlVHlwZSwgfSBmcm9tIFwiLi4vaGVscGVycy9heGVzXCI7XG5pbXBvcnQgeyBnZXRBeGlzTGFiZWxBbmNob3JQb2ludCB9IGZyb20gXCIuLi9oZWxwZXJzL2NhbGN1bGF0b3JcIjtcbmltcG9ydCB7IGdldFRpdGxlRm9udFN0cmluZyB9IGZyb20gXCIuLi9oZWxwZXJzL3N0eWxlXCI7XG5mdW5jdGlvbiBnZXRIZWF0bWFwQXhpc0RhdGEoc3RhdGVQcm9wLCBheGlzVHlwZSkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaztcbiAgICBjb25zdCB7IGNhdGVnb3JpZXMsIGF4aXNTaXplLCBheGlzTGF5b3V0LCBvcHRpb25zLCB0aGVtZSB9ID0gc3RhdGVQcm9wO1xuICAgIGNvbnN0IGlzTGFiZWxBeGlzID0gYXhpc1R5cGUgPT09IEF4aXNUeXBlLlg7XG4gICAgY29uc3QgYXhpc05hbWUgPSBpc0xhYmVsQXhpcyA/ICd4JyA6ICd5JztcbiAgICBjb25zdCBkYXRlVHlwZSA9IGlzRGF0ZVR5cGUob3B0aW9ucywgYXhpc1R5cGUpO1xuICAgIGNvbnN0IGxhYmVscyA9IGdldExhYmVsc0FwcGxpZWRGb3JtYXR0ZXIoY2F0ZWdvcmllc1theGlzTmFtZV0sIG9wdGlvbnMsIGRhdGVUeXBlLCBheGlzVHlwZSk7XG4gICAgY29uc3QgdGlja0ludGVydmFsQ291bnQgPSBsYWJlbHMubGVuZ3RoO1xuICAgIGNvbnN0IHRpY2tEaXN0YW5jZSA9IHRpY2tJbnRlcnZhbENvdW50ID8gYXhpc1NpemUgLyB0aWNrSW50ZXJ2YWxDb3VudCA6IGF4aXNTaXplO1xuICAgIGNvbnN0IGxhYmVsRGlzdGFuY2UgPSBheGlzU2l6ZSAvIHRpY2tJbnRlcnZhbENvdW50O1xuICAgIGNvbnN0IHBvaW50T25Db2x1bW4gPSB0cnVlO1xuICAgIGNvbnN0IHRpY2tDb3VudCA9IHRpY2tJbnRlcnZhbENvdW50ICsgMTtcbiAgICBjb25zdCB0aWNrSW50ZXJ2YWwgPSAoX2MgPSAoX2IgPSAoX2EgPSBvcHRpb25zW2F4aXNUeXBlXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRpY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbnRlcnZhbCwgKF9jICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDEpKTtcbiAgICBjb25zdCBsYWJlbEludGVydmFsID0gKF9mID0gKF9lID0gKF9kID0gb3B0aW9uc1theGlzVHlwZV0pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sYWJlbCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmludGVydmFsLCAoX2YgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogMSkpO1xuICAgIGNvbnN0IHZpZXdMYWJlbHMgPSBnZXRWaWV3QXhpc0xhYmVscyh7XG4gICAgICAgIGxhYmVscyxcbiAgICAgICAgcG9pbnRPbkNvbHVtbixcbiAgICAgICAgdGlja0Rpc3RhbmNlLFxuICAgICAgICB0aWNrQ291bnQsXG4gICAgICAgIHRpY2tJbnRlcnZhbCxcbiAgICAgICAgbGFiZWxJbnRlcnZhbCxcbiAgICB9LCBheGlzU2l6ZSk7XG4gICAgY29uc3QgbGFiZWxYTWFyZ2luID0gZ2V0TGFiZWxYTWFyZ2luKGF4aXNUeXBlLCBvcHRpb25zKTtcbiAgICBjb25zdCB7IG1heExhYmVsV2lkdGgsIG1heExhYmVsSGVpZ2h0IH0gPSBnZXRNYXhMYWJlbFNpemUobGFiZWxzLCBsYWJlbFhNYXJnaW4sIGdldFRpdGxlRm9udFN0cmluZyh0aGVtZS5sYWJlbCkpO1xuICAgIGNvbnN0IGF4aXNEYXRhID0ge1xuICAgICAgICBsYWJlbHMsXG4gICAgICAgIHZpZXdMYWJlbHMsXG4gICAgICAgIHBvaW50T25Db2x1bW4sXG4gICAgICAgIGlzTGFiZWxBeGlzLFxuICAgICAgICB0aWNrQ291bnQsXG4gICAgICAgIHRpY2tEaXN0YW5jZSxcbiAgICAgICAgbGFiZWxEaXN0YW5jZSxcbiAgICAgICAgdGlja0ludGVydmFsLFxuICAgICAgICBsYWJlbEludGVydmFsLFxuICAgICAgICB0aXRsZTogbWFrZVRpdGxlT3B0aW9uKChfZyA9IG9wdGlvbnNbYXhpc1R5cGVdKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cudGl0bGUpLFxuICAgICAgICBtYXhMYWJlbFdpZHRoLFxuICAgICAgICBtYXhMYWJlbEhlaWdodCxcbiAgICB9O1xuICAgIGlmIChheGlzVHlwZSA9PT0gQXhpc1R5cGUuWCkge1xuICAgICAgICBjb25zdCBsYWJlbE1hcmdpbiA9IChfayA9IChfaiA9IChfaCA9IG9wdGlvbnMueEF4aXMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5sYWJlbCkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLm1hcmdpbiwgKF9rICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IDApKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IGdldEF4aXNMYWJlbEFuY2hvclBvaW50KG1heExhYmVsSGVpZ2h0KSArIGxhYmVsTWFyZ2luO1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGF4aXNTaXplIC8gdmlld0xhYmVscy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uRGF0YSA9IG1ha2VSb3RhdGlvbkRhdGEobWF4TGFiZWxXaWR0aCwgbWF4TGFiZWxIZWlnaHQsIGRpc3RhbmNlLCBnZXRSb3RhdGFibGVPcHRpb24ob3B0aW9ucyksIGF4aXNMYXlvdXQpO1xuICAgICAgICBjb25zdCB7IG5lZWRSb3RhdGVMYWJlbCwgcm90YXRpb25IZWlnaHQgfSA9IHJvdGF0aW9uRGF0YTtcbiAgICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gKG5lZWRSb3RhdGVMYWJlbCA/IHJvdGF0aW9uSGVpZ2h0IDogbWF4TGFiZWxIZWlnaHQpICsgb2Zmc2V0WTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBheGlzRGF0YSksIHJvdGF0aW9uRGF0YSksIHsgbWF4SGVpZ2h0LFxuICAgICAgICAgICAgb2Zmc2V0WSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGF4aXNEYXRhO1xufVxuY29uc3QgYXhlcyA9IHtcbiAgICBuYW1lOiAnYXhlcycsXG4gICAgc3RhdGU6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF4ZXM6IHtcbiAgICAgICAgICAgICAgICB4QXhpczoge30sXG4gICAgICAgICAgICAgICAgeUF4aXM6IHt9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFjdGlvbjoge1xuICAgICAgICBzZXRBeGVzRGF0YSh7IHN0YXRlIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbGF5b3V0LCB0aGVtZSB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGxheW91dC5wbG90O1xuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IHN0YXRlLmNhdGVnb3JpZXM7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gc3RhdGUub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHhBeGlzRGF0YSA9IGdldEhlYXRtYXBBeGlzRGF0YSh7XG4gICAgICAgICAgICAgICAgYXhpc1NpemU6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGNhdGVnb3JpZXMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICB0aGVtZTogZ2V0QXhpc1RoZW1lKHRoZW1lLCBBeGlzVHlwZS5YKSxcbiAgICAgICAgICAgICAgICBheGlzTGF5b3V0OiBsYXlvdXRbQXhpc1R5cGUuWF0sXG4gICAgICAgICAgICB9LCBBeGlzVHlwZS5YKTtcbiAgICAgICAgICAgIGNvbnN0IHlBeGlzRGF0YSA9IGdldEhlYXRtYXBBeGlzRGF0YSh7XG4gICAgICAgICAgICAgICAgYXhpc1NpemU6IGhlaWdodCxcbiAgICAgICAgICAgICAgICBjYXRlZ29yaWVzLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgdGhlbWU6IGdldEF4aXNUaGVtZSh0aGVtZSwgQXhpc1R5cGUuWSksXG4gICAgICAgICAgICB9LCBBeGlzVHlwZS5ZKTtcbiAgICAgICAgICAgIGNvbnN0IGF4ZXNTdGF0ZSA9IHsgeEF4aXM6IHhBeGlzRGF0YSwgeUF4aXM6IHlBeGlzRGF0YSB9O1xuICAgICAgICAgICAgaWYgKGhhc0F4ZXNMYXlvdXRDaGFuZ2VkKHN0YXRlLmF4ZXMsIGF4ZXNTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeShzdGF0ZSwgJ2xheW91dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUuYXhlcyA9IGF4ZXNTdGF0ZTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7fSxcbiAgICBvYnNlcnZlOiB7XG4gICAgICAgIHVwZGF0ZUF4ZXMoKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCdzZXRBeGVzRGF0YScpO1xuICAgICAgICB9LFxuICAgIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgYXhlcztcbiIsImltcG9ydCB7IGdldERhdGFJblJhbmdlIH0gZnJvbSBcIi4uL2hlbHBlcnMvcmFuZ2VcIjtcbmZ1bmN0aW9uIG1ha2VIZWF0bWFwU2VyaWVzKHNlcmllcywgY2F0ZWdvcmllcywgdmlld1JhbmdlKSB7XG4gICAgaWYgKCFzZXJpZXMuaGVhdG1hcCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBzZXJpZXMuaGVhdG1hcC5kYXRhLm1hcCgocm93U2VyaWVzLCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgeUNhdGVnb3J5LCBkYXRhIH0gPSByb3dTZXJpZXM7XG4gICAgICAgIHJldHVybiBnZXREYXRhSW5SYW5nZShkYXRhLCB2aWV3UmFuZ2UpLm1hcCgoY29sb3JWYWx1ZSwgeCkgPT4gKHtcbiAgICAgICAgICAgIGNvbG9yVmFsdWUsXG4gICAgICAgICAgICBjYXRlZ29yeToge1xuICAgICAgICAgICAgICAgIHg6IGNhdGVnb3JpZXMueFt4XSxcbiAgICAgICAgICAgICAgICB5OiB5Q2F0ZWdvcnksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5kZXhlczogW3gsIHldLFxuICAgICAgICB9KSk7XG4gICAgfSk7XG59XG5jb25zdCBoZWF0bWFwU2VyaWVzRGF0YSA9IHtcbiAgICBuYW1lOiAnaGVhdG1hcFNlcmllc0RhdGEnLFxuICAgIHN0YXRlOiAoKSA9PiAoe1xuICAgICAgICBoZWF0bWFwU2VyaWVzOiBbXSxcbiAgICB9KSxcbiAgICBhY3Rpb246IHtcbiAgICAgICAgc2V0SGVhdG1hcFNlcmllc0RhdGEoeyBzdGF0ZSwgY29tcHV0ZWQgfSkge1xuICAgICAgICAgICAgc3RhdGUuaGVhdG1hcFNlcmllcyA9IG1ha2VIZWF0bWFwU2VyaWVzKHN0YXRlLnNlcmllcywgc3RhdGUuY2F0ZWdvcmllcywgY29tcHV0ZWQudmlld1JhbmdlKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIG9ic2VydmU6IHtcbiAgICAgICAgdXBkYXRlVHJlZW1hcFNlcmllc0RhdGEoKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCdzZXRIZWF0bWFwU2VyaWVzRGF0YScpO1xuICAgICAgICB9LFxuICAgIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgaGVhdG1hcFNlcmllc0RhdGE7XG4iLCJpbXBvcnQgeyBleHRlbmQgfSBmcm9tIFwiLi9zdG9yZVwiO1xuaW1wb3J0IHsgaXNVbmRlZmluZWQsIHBpY2ssIGlzTnVtYmVyIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmltcG9ydCB7IGlzQ2VudGVyWUF4aXMgfSBmcm9tIFwiLi9heGVzXCI7XG5pbXBvcnQgeyBCVVRUT05fUkVDVF9TSVpFIH0gZnJvbSBcIi4uL2NvbXBvbmVudC9leHBvcnRNZW51XCI7XG5pbXBvcnQgeyBUSUNLX1NJWkUgfSBmcm9tIFwiLi4vYnJ1c2hlcy9heGlzXCI7XG5pbXBvcnQgeyBTUEVDVFJVTV9MRUdFTkRfTEFCRUxfSEVJR0hULCBzcGVjdHJ1bUxlZ2VuZEJhciwgc3BlY3RydW1MZWdlbmRUb29sdGlwLCB9IGZyb20gXCIuLi9icnVzaGVzL3NwZWN0cnVtTGVnZW5kXCI7XG5pbXBvcnQgeyBnZXRZQXhpc09wdGlvbiB9IGZyb20gXCIuLi9oZWxwZXJzL2F4ZXNcIjtcbmV4cG9ydCBjb25zdCBwYWRkaW5nID0geyBYOiAxMCwgWTogMTUgfTtcbmV4cG9ydCBjb25zdCBYX0FYSVNfSEVJR0hUID0gMjA7XG5jb25zdCBZX0FYSVNfTUlOX1dJRFRIID0gNDA7XG5leHBvcnQgZnVuY3Rpb24gaXNWZXJ0aWNhbEFsaWduKGFsaWduKSB7XG4gICAgcmV0dXJuIGFsaWduID09PSAndG9wJyB8fCBhbGlnbiA9PT0gJ2JvdHRvbSc7XG59XG5mdW5jdGlvbiBnZXRWYWxpZFJlY3RTaXplKHNpemUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiAoX2IgPSAoX2EgPSBzaXplKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVpZ2h0LCAoX2IgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogaGVpZ2h0KSksXG4gICAgICAgIHdpZHRoOiAoX2QgPSAoX2MgPSBzaXplKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mud2lkdGgsIChfZCAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB3aWR0aCkpLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0WEF4aXNIZWlnaHQoc2l6ZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHNpemUueEF4aXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWlnaHQpICYmICFzaXplLnlBeGlzID8gc2l6ZS54QXhpcy5oZWlnaHQgOiBYX0FYSVNfSEVJR0hUO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdFlBeGlzWFBvaW50KHlBeGlzUmVjdFBhcmFtKSB7XG4gICAgY29uc3QgeyB5QXhpc1RpdGxlLCBpc1JpZ2h0U2lkZSwgdmlzaWJsZVNlY29uZGFyeVlBeGlzIH0gPSB5QXhpc1JlY3RQYXJhbTtcbiAgICBjb25zdCB5QXhpc1dpZHRoID0gZ2V0RGVmYXVsdFlBeGlzV2lkdGgoeUF4aXNSZWN0UGFyYW0pO1xuICAgIHJldHVybiBpc1JpZ2h0U2lkZSAmJiB2aXNpYmxlU2Vjb25kYXJ5WUF4aXNcbiAgICAgICAgPyBNYXRoLm1heCh5QXhpc1RpdGxlLnggKyB5QXhpc1RpdGxlLndpZHRoIC0geUF4aXNXaWR0aCwgMClcbiAgICAgICAgOiB5QXhpc1RpdGxlLng7XG59XG5mdW5jdGlvbiBnZXRZQXhpc1hQb2ludCh5QXhpc1JlY3RQYXJhbSkge1xuICAgIGNvbnN0IHsgY2hhcnRTaXplLCBsZWdlbmQsIGNpcmNsZUxlZ2VuZCwgaGFzQ2VudGVyWUF4aXMsIG1heExhYmVsV2lkdGggfSA9IHlBeGlzUmVjdFBhcmFtO1xuICAgIGNvbnN0IHsgd2lkdGggfSA9IGNoYXJ0U2l6ZTtcbiAgICBjb25zdCB7IGFsaWduIH0gPSBsZWdlbmQ7XG4gICAgbGV0IHlBeGlzV2lkdGggPSBnZXREZWZhdWx0WUF4aXNXaWR0aCh5QXhpc1JlY3RQYXJhbSk7XG4gICAgbGV0IHggPSBnZXREZWZhdWx0WUF4aXNYUG9pbnQoeUF4aXNSZWN0UGFyYW0pO1xuICAgIGlmIChoYXNDZW50ZXJZQXhpcykge1xuICAgICAgICB5QXhpc1dpZHRoID0gbWF4TGFiZWxXaWR0aCArIChUSUNLX1NJWkUgKyBwYWRkaW5nLlgpICogMjtcbiAgICAgICAgeCA9ICh3aWR0aCAtIGxlZ2VuZC53aWR0aCAtIHlBeGlzV2lkdGggKyBwYWRkaW5nLlggKiAyKSAvIDI7XG4gICAgfVxuICAgIGlmIChsZWdlbmQudmlzaWJsZSAmJiBhbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHggPSBnZXREZWZhdWx0WUF4aXNYUG9pbnQoeUF4aXNSZWN0UGFyYW0pO1xuICAgIH1cbiAgICBpZiAoY2lyY2xlTGVnZW5kLnZpc2libGUgJiYgYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4ID0gTWF0aC5tYXgoY2lyY2xlTGVnZW5kLndpZHRoICsgcGFkZGluZy5YLCB4KTtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBnZXRZQXhpc1lQb2ludCh7IHlBeGlzVGl0bGUgfSkge1xuICAgIHJldHVybiB5QXhpc1RpdGxlLnkgKyB5QXhpc1RpdGxlLmhlaWdodDtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRZQXhpc1dpZHRoKHsgbWF4TGFiZWxXaWR0aCwgc2l6ZSwgaXNSaWdodFNpZGUgfSkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiBfYyA9IChfYiA9IChfYSA9IHNpemUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtpc1JpZ2h0U2lkZSA/ICdzZWNvbmRhcnlZQXhpcycgOiAneUF4aXMnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLndpZHRoLCAoX2MgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbWF4TGFiZWxXaWR0aCk7XG59XG5mdW5jdGlvbiBnZXRZQXhpc1dpZHRoKHlBeGlzUmVjdFBhcmFtKSB7XG4gICAgY29uc3QgeyBoYXNDZW50ZXJZQXhpcywgaGFzWFlBeGlzLCBtYXhMYWJlbFdpZHRoLCB2aXNpYmxlU2Vjb25kYXJ5WUF4aXMgPSBmYWxzZSwgaXNSaWdodFNpZGUgPSBmYWxzZSwgfSA9IHlBeGlzUmVjdFBhcmFtO1xuICAgIGxldCB5QXhpc1dpZHRoID0gZ2V0RGVmYXVsdFlBeGlzV2lkdGgoeUF4aXNSZWN0UGFyYW0pO1xuICAgIGlmIChoYXNDZW50ZXJZQXhpcyAmJiAhaXNSaWdodFNpZGUpIHtcbiAgICAgICAgeUF4aXNXaWR0aCA9IG1heExhYmVsV2lkdGggKyAoVElDS19TSVpFICsgcGFkZGluZy5YKSAqIDI7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFoYXNYWUF4aXMgfHwgKGlzUmlnaHRTaWRlICYmICF2aXNpYmxlU2Vjb25kYXJ5WUF4aXMpKSB7XG4gICAgICAgIHlBeGlzV2lkdGggPSAwO1xuICAgIH1cbiAgICByZXR1cm4geUF4aXNXaWR0aDtcbn1cbmZ1bmN0aW9uIGdldFlBeGlzSGVpZ2h0KHsgY2hhcnRTaXplLCBsZWdlbmQsIHlBeGlzVGl0bGUsIGhhc1hZQXhpcywgc2l6ZSwgeEF4aXNUaXRsZUhlaWdodCwgfSkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCB7IGhlaWdodCB9ID0gY2hhcnRTaXplO1xuICAgIGNvbnN0IHsgYWxpZ24sIGhlaWdodDogbGVnZW5kSGVpZ2h0IH0gPSBsZWdlbmQ7XG4gICAgY29uc3QgeEF4aXNIZWlnaHQgPSBnZXREZWZhdWx0WEF4aXNIZWlnaHQoc2l6ZSk7XG4gICAgY29uc3QgeSA9IHlBeGlzVGl0bGUueSArIHlBeGlzVGl0bGUuaGVpZ2h0O1xuICAgIGxldCB5QXhpc0hlaWdodCA9IGhlaWdodCAtIHkgLSB4QXhpc0hlaWdodCAtIHhBeGlzVGl0bGVIZWlnaHQ7XG4gICAgaWYgKCFoYXNYWUF4aXMpIHtcbiAgICAgICAgeUF4aXNIZWlnaHQgPSBoZWlnaHQgLSB5O1xuICAgIH1cbiAgICBpZiAobGVnZW5kLnZpc2libGUpIHtcbiAgICAgICAgY29uc3QgdG9wQXJlYSA9IE1hdGgubWF4KHksIGxlZ2VuZEhlaWdodCk7XG4gICAgICAgIGlmIChhbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIHlBeGlzSGVpZ2h0ID0gaGVpZ2h0IC0gdG9wQXJlYSAtIChoYXNYWUF4aXMgPyBYX0FYSVNfSEVJR0hUICsgeEF4aXNUaXRsZUhlaWdodCA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgeUF4aXNIZWlnaHQgPSBoZWlnaHQgLSB5IC0gWF9BWElTX0hFSUdIVCAtIHhBeGlzVGl0bGVIZWlnaHQgLSBsZWdlbmRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEoKF9iID0gKF9hID0gc2l6ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnlBeGlzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVpZ2h0KSAmJiAoKF9kID0gKF9jID0gc2l6ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBsb3QpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5oZWlnaHQpKSB7XG4gICAgICAgIHlBeGlzSGVpZ2h0ID0gc2l6ZS5wbG90LmhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIHlBeGlzSGVpZ2h0O1xufVxuZnVuY3Rpb24gZ2V0WUF4aXNSZWN0KHlBeGlzUmVjdFBhcmFtKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IHNpemUsIGlzUmlnaHRTaWRlID0gZmFsc2UgfSA9IHlBeGlzUmVjdFBhcmFtO1xuICAgIGNvbnN0IHggPSBnZXRZQXhpc1hQb2ludCh5QXhpc1JlY3RQYXJhbSk7XG4gICAgY29uc3QgeSA9IGdldFlBeGlzWVBvaW50KHlBeGlzUmVjdFBhcmFtKTtcbiAgICBjb25zdCB5QXhpc1dpZHRoID0gZ2V0WUF4aXNXaWR0aCh5QXhpc1JlY3RQYXJhbSk7XG4gICAgY29uc3QgeUF4aXNIZWlnaHQgPSBnZXRZQXhpc0hlaWdodCh5QXhpc1JlY3RQYXJhbSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB4LFxuICAgICAgICB5IH0sIGdldFZhbGlkUmVjdFNpemUoaXNSaWdodFNpZGUgPyAoX2EgPSBzaXplKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2Vjb25kYXJ5WUF4aXMgOiAoX2IgPSBzaXplKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IueUF4aXMsIHlBeGlzV2lkdGgsIHlBeGlzSGVpZ2h0KSk7XG59XG5mdW5jdGlvbiBnZXRYQXhpc1dpZHRoKHsgY2hhcnRTaXplLCB5QXhpcywgaGFzQ2VudGVyWUF4aXMsIGxlZ2VuZCwgY2lyY2xlTGVnZW5kLCBzZWNvbmRhcnlZQXhpcywgeEF4aXNEYXRhLCB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgd2lkdGggfSA9IGNoYXJ0U2l6ZTtcbiAgICBjb25zdCB7IGFsaWduLCB3aWR0aDogbGVnZW5kV2lkdGggfSA9IGxlZ2VuZDtcbiAgICBjb25zdCBsZWdlbmRWZXJ0aWNhbEFsaWduID0gaXNWZXJ0aWNhbEFsaWduKGFsaWduKTtcbiAgICBsZXQgeEF4aXNXaWR0aDtcbiAgICBpZiAobGVnZW5kVmVydGljYWxBbGlnbikge1xuICAgICAgICB4QXhpc1dpZHRoID0gd2lkdGggLSAoeUF4aXMueCArIHlBeGlzLndpZHRoICsgcGFkZGluZy5YKTtcbiAgICAgICAgaWYgKGNpcmNsZUxlZ2VuZC52aXNpYmxlKSB7XG4gICAgICAgICAgICB4QXhpc1dpZHRoIC09IGNpcmNsZUxlZ2VuZC53aWR0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgeEF4aXNXaWR0aCA9XG4gICAgICAgICAgICB3aWR0aCAtICh5QXhpcy53aWR0aCArIE1hdGgubWF4KGxlZ2VuZFdpZHRoLCBjaXJjbGVMZWdlbmQudmlzaWJsZSA/IGNpcmNsZUxlZ2VuZC53aWR0aCA6IDApKTtcbiAgICB9XG4gICAgaWYgKGhhc0NlbnRlcllBeGlzKSB7XG4gICAgICAgIHhBeGlzV2lkdGggPSB3aWR0aCAtIChsZWdlbmRWZXJ0aWNhbEFsaWduID8gMCA6IGxlZ2VuZFdpZHRoKSAtIHBhZGRpbmcuWCAqIDI7XG4gICAgfVxuICAgIGlmIChzZWNvbmRhcnlZQXhpcy53aWR0aCkge1xuICAgICAgICB4QXhpc1dpZHRoIC09IHNlY29uZGFyeVlBeGlzLndpZHRoO1xuICAgIH1cbiAgICBpZiAoKF9hID0geEF4aXNEYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF4TGFiZWxXaWR0aCkge1xuICAgICAgICAvLyBzdWJ0cmFjdCBoYWxmIG9mIHRoZSBtYXhpbXVtIGxhYmVsIGxlbmd0aCB0byBzZWN1cmUgbWFyZ2luIHNpemVcbiAgICAgICAgeEF4aXNXaWR0aCAtPSB4QXhpc0RhdGEubWF4TGFiZWxXaWR0aCAqIDAuNTtcbiAgICB9XG4gICAgcmV0dXJuIHhBeGlzV2lkdGg7XG59XG5mdW5jdGlvbiBnZXRYQXhpc0hlaWdodCh4QXhpc0RhdGEsIGhhc1hZQXhpcyA9IGZhbHNlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIWhhc1hZQXhpcykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIF9iID0gKF9hID0geEF4aXNEYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF4SGVpZ2h0LCAoX2IgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogWF9BWElTX0hFSUdIVCk7XG59XG5mdW5jdGlvbiBnZXRYQXhpc1JlY3QoeEF4aXNSZWN0UGFyYW0pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBoYXNYWUF4aXMsIGhhc0NlbnRlcllBeGlzLCB5QXhpcywgc2l6ZSwgeEF4aXNEYXRhIH0gPSB4QXhpc1JlY3RQYXJhbTtcbiAgICBjb25zdCB4ID0gaGFzQ2VudGVyWUF4aXMgPyBwYWRkaW5nLlggKiAyIDogeUF4aXMueCArIHlBeGlzLndpZHRoO1xuICAgIGNvbnN0IHkgPSB5QXhpcy55ICsgeUF4aXMuaGVpZ2h0O1xuICAgIGNvbnN0IHhBeGlzV2lkdGggPSBnZXRYQXhpc1dpZHRoKHhBeGlzUmVjdFBhcmFtKTtcbiAgICBjb25zdCB4QXhpc0hlaWdodCA9IGdldFhBeGlzSGVpZ2h0KHhBeGlzRGF0YSwgaGFzWFlBeGlzKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHgsXG4gICAgICAgIHkgfSwgZ2V0VmFsaWRSZWN0U2l6ZSgoX2EgPSBzaXplKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EueEF4aXMsIHhBeGlzV2lkdGgsIHhBeGlzSGVpZ2h0KSk7XG59XG5mdW5jdGlvbiBnZXRMZWdlbmRSZWN0KGxlZ2VuZFJlY3RQYXJhbXMpIHtcbiAgICBjb25zdCB7IGxlZ2VuZCwgeEF4aXMsIHlBeGlzLCBjaGFydFNpemUsIHRpdGxlLCBoYXNYWUF4aXMsIHNlY29uZGFyeVlBeGlzLCB4QXhpc1RpdGxlSGVpZ2h0LCB9ID0gbGVnZW5kUmVjdFBhcmFtcztcbiAgICBpZiAoIWxlZ2VuZC52aXNpYmxlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7IGFsaWduLCB3aWR0aDogbGVnZW5kV2lkdGgsIGhlaWdodDogbGVnZW5kSGVpZ2h0IH0gPSBsZWdlbmQ7XG4gICAgY29uc3QgeyB3aWR0aCB9ID0gY2hhcnRTaXplO1xuICAgIGNvbnN0IHZlcnRpY2FsQWxpZ24gPSBpc1ZlcnRpY2FsQWxpZ24oYWxpZ24pO1xuICAgIGxldCB4ID0geEF4aXMueCArIHhBeGlzLndpZHRoICsgc2Vjb25kYXJ5WUF4aXMud2lkdGggKyBwYWRkaW5nLlg7XG4gICAgbGV0IHkgPSBNYXRoLm1heCh5QXhpcy55LCBCVVRUT05fUkVDVF9TSVpFKTtcbiAgICBpZiAodmVydGljYWxBbGlnbikge1xuICAgICAgICB4ID0gKHdpZHRoIC0gbGVnZW5kV2lkdGgpIC8gMjtcbiAgICAgICAgaWYgKGFsaWduID09PSAndG9wJykge1xuICAgICAgICAgICAgeSA9IHRpdGxlLnkgKyB0aXRsZS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5ID0geUF4aXMueSArIHlBeGlzLmhlaWdodCArIChoYXNYWUF4aXMgPyB4QXhpcy5oZWlnaHQgKyB4QXhpc1RpdGxlSGVpZ2h0IDogcGFkZGluZy5ZKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHggPSBwYWRkaW5nLlg7XG4gICAgfVxuICAgIHJldHVybiB7IHdpZHRoOiBsZWdlbmRXaWR0aCwgaGVpZ2h0OiBsZWdlbmRIZWlnaHQsIHgsIHkgfTtcbn1cbmZ1bmN0aW9uIGdldENpcmNsZUxlZ2VuZFJlY3QoeEF4aXMsIHlBeGlzLCBhbGlnbiwgd2lkdGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB5QXhpcy5oZWlnaHQsXG4gICAgICAgIHg6IGFsaWduID09PSAnbGVmdCcgPyBwYWRkaW5nLlggOiB4QXhpcy54ICsgeEF4aXMud2lkdGggKyBwYWRkaW5nLlgsXG4gICAgICAgIHk6IHlBeGlzLnksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFBsb3RSZWN0KHhBeGlzLCB5QXhpcywgc2l6ZSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgeDogeEF4aXMueCwgeTogeUF4aXMueSB9LCBnZXRWYWxpZFJlY3RTaXplKHNpemUsIHhBeGlzLndpZHRoLCB5QXhpcy5oZWlnaHQpKTtcbn1cbmZ1bmN0aW9uIGdldFRpdGxlUmVjdChjaGFydFNpemUsIGV4cG9ydE1lbnUsIHZpc2libGUsIHRpdGxlSGVpZ2h0KSB7XG4gICAgY29uc3QgcG9pbnQgPSB7IHg6IHBhZGRpbmcuWCwgeTogcGFkZGluZy5ZIH07XG4gICAgY29uc3QgbWFyZ2luQm90dG9tID0gNTtcbiAgICBjb25zdCB3aWR0aCA9IHZpc2libGUgPyBjaGFydFNpemUud2lkdGggLSBleHBvcnRNZW51LndpZHRoIDogMDtcbiAgICBjb25zdCBoZWlnaHQgPSB2aXNpYmxlXG4gICAgICAgID8gTWF0aC5tYXgodGl0bGVIZWlnaHQgKyBtYXJnaW5Cb3R0b20sIGV4cG9ydE1lbnUuaGVpZ2h0KVxuICAgICAgICA6IGV4cG9ydE1lbnUuaGVpZ2h0O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgd2lkdGgsIGhlaWdodCB9LCBwb2ludCk7XG59XG5mdW5jdGlvbiBnZXRUb3BMZWdlbmRBcmVhSGVpZ2h0KHVzZVNwZWN0cnVtTGVnZW5kLCBsZWdlbmRIZWlnaHQpIHtcbiAgICByZXR1cm4gdXNlU3BlY3RydW1MZWdlbmRcbiAgICAgICAgPyBTUEVDVFJVTV9MRUdFTkRfTEFCRUxfSEVJR0hUICtcbiAgICAgICAgICAgIHNwZWN0cnVtTGVnZW5kQmFyLlBBRERJTkcgKiAyICtcbiAgICAgICAgICAgIHNwZWN0cnVtTGVnZW5kVG9vbHRpcC5QT0lOVF9IRUlHSFQgK1xuICAgICAgICAgICAgc3BlY3RydW1MZWdlbmRUb29sdGlwLkhFSUdIVCArXG4gICAgICAgICAgICBwYWRkaW5nLllcbiAgICAgICAgOiBsZWdlbmRIZWlnaHQgKyBwYWRkaW5nLlk7XG59XG5mdW5jdGlvbiBnZXRZQXhpc1RpdGxlUmVjdCh7IGNoYXJ0U2l6ZSwgdmlzaWJsZSwgdGl0bGUsIGxlZ2VuZDogeyBhbGlnbjogbGVnZW5kQWxpZ24sIHdpZHRoOiBsZWdlbmRXaWR0aCwgaGVpZ2h0OiBsZWdlbmRIZWlnaHQsIHZpc2libGU6IGxlZ2VuZFZpc2libGUsIHVzZVNwZWN0cnVtTGVnZW5kLCB9LCBoYXNDZW50ZXJZQXhpcywgdmlzaWJsZVNlY29uZGFyeVlBeGlzLCBpc1JpZ2h0U2lkZSA9IGZhbHNlLCB5QXhpc1RpdGxlSGVpZ2h0LCB9KSB7XG4gICAgY29uc3QgbWFyZ2luQm90dG9tID0gNTtcbiAgICBjb25zdCBoZWlnaHQgPSB2aXNpYmxlID8geUF4aXNUaXRsZUhlaWdodCArIG1hcmdpbkJvdHRvbSA6IDA7XG4gICAgY29uc3QgdmVydGljYWxMZWdlbmRBbGlnbiA9IGlzVmVydGljYWxBbGlnbihsZWdlbmRBbGlnbik7XG4gICAgY29uc3Qgd2lkdGggPSAoY2hhcnRTaXplLndpZHRoIC0gKHZlcnRpY2FsTGVnZW5kQWxpZ24gPyBwYWRkaW5nLlggKiAyIDogbGVnZW5kV2lkdGgpKSAvXG4gICAgICAgICh2aXNpYmxlU2Vjb25kYXJ5WUF4aXMgPyAyIDogMSk7XG4gICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IGlzUmlnaHRTaWRlID8gdGl0bGUueCArIHdpZHRoIDogdGl0bGUueCxcbiAgICAgICAgeTogdGl0bGUueSArIHRpdGxlLmhlaWdodCxcbiAgICB9O1xuICAgIGlmIChsZWdlbmRWaXNpYmxlKSB7XG4gICAgICAgIGlmIChsZWdlbmRBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICBwb2ludC54ICs9IGxlZ2VuZFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlZ2VuZEFsaWduID09PSAndG9wJykge1xuICAgICAgICAgICAgcG9pbnQueSArPSBnZXRUb3BMZWdlbmRBcmVhSGVpZ2h0KHVzZVNwZWN0cnVtTGVnZW5kLCBsZWdlbmRIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNDZW50ZXJZQXhpcykge1xuICAgICAgICBwb2ludC54ID0gKHdpZHRoICsgcGFkZGluZy5YICogMikgLyAyO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IGhlaWdodCwgd2lkdGggfSwgcG9pbnQpO1xufVxuZnVuY3Rpb24gZ2V0WEF4aXNUaXRsZVJlY3QodmlzaWJsZSwgeEF4aXMsIHhBeGlzVGl0bGVIZWlnaHQpIHtcbiAgICBjb25zdCBwb2ludCA9IHsgeDogeEF4aXMueCwgeTogeEF4aXMueSArIHhBeGlzLmhlaWdodCB9O1xuICAgIGNvbnN0IGhlaWdodCA9IHZpc2libGUgPyB4QXhpc1RpdGxlSGVpZ2h0IDogMDtcbiAgICBjb25zdCB3aWR0aCA9IHZpc2libGUgPyB4QXhpcy53aWR0aCA6IDA7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBoZWlnaHQsIHdpZHRoIH0sIHBvaW50KTtcbn1cbmZ1bmN0aW9uIGdldEV4cG9ydE1lbnVSZWN0KGNoYXJ0U2l6ZSwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1hcmdpblkgPSA1O1xuICAgIGNvbnN0IHggPSB2aXNpYmxlID8gcGFkZGluZy5YICsgY2hhcnRTaXplLndpZHRoIC0gQlVUVE9OX1JFQ1RfU0laRSA6IHBhZGRpbmcuWCArIGNoYXJ0U2l6ZS53aWR0aDtcbiAgICBjb25zdCB5ID0gcGFkZGluZy5ZO1xuICAgIGNvbnN0IGhlaWdodCA9IHZpc2libGUgPyBCVVRUT05fUkVDVF9TSVpFICsgbWFyZ2luWSA6IDA7XG4gICAgY29uc3Qgd2lkdGggPSB2aXNpYmxlID8gQlVUVE9OX1JFQ1RfU0laRSA6IDA7XG4gICAgcmV0dXJuIHsgeCwgeSwgaGVpZ2h0LCB3aWR0aCB9O1xufVxuZnVuY3Rpb24gZ2V0UmVzZXRCdXR0b25SZWN0KGV4cG9ydE1lbnUsIHVzZVJlc2V0QnV0dG9uKSB7XG4gICAgY29uc3QgbWFyZ2luWSA9IDU7XG4gICAgY29uc3QgeCA9IHVzZVJlc2V0QnV0dG9uID8gZXhwb3J0TWVudS54IC0gQlVUVE9OX1JFQ1RfU0laRSAtIHBhZGRpbmcuWCA6IDA7XG4gICAgY29uc3QgeSA9IHVzZVJlc2V0QnV0dG9uID8gZXhwb3J0TWVudS55IDogMDtcbiAgICBjb25zdCBoZWlnaHQgPSB1c2VSZXNldEJ1dHRvbiA/IEJVVFRPTl9SRUNUX1NJWkUgKyBtYXJnaW5ZIDogMDtcbiAgICBjb25zdCB3aWR0aCA9IHVzZVJlc2V0QnV0dG9uID8gQlVUVE9OX1JFQ1RfU0laRSA6IDA7XG4gICAgcmV0dXJuIHsgeCwgeSwgaGVpZ2h0LCB3aWR0aCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVXNpbmdSZXNldEJ1dHRvbihvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAhISgoX2EgPSBvcHRpb25zLnNlcmllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnpvb21hYmxlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0V4cG9ydE1lbnVWaXNpYmxlKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdmlzaWJsZSA9IChfYSA9IG9wdGlvbnMuZXhwb3J0TWVudSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZpc2libGU7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKHZpc2libGUpID8gdHJ1ZSA6IHZpc2libGU7XG59XG5mdW5jdGlvbiBnZXRZQXhpc01heExhYmVsV2lkdGgobWF4TGFiZWxMZW5ndGgpIHtcbiAgICByZXR1cm4gbWF4TGFiZWxMZW5ndGggPyBtYXhMYWJlbExlbmd0aCArIHBhZGRpbmcuWCA6IFlfQVhJU19NSU5fV0lEVEg7XG59XG5mdW5jdGlvbiBwaWNrT3B0aW9uU2l6ZShvcHRpb24pIHtcbiAgICBpZiAoIW9wdGlvbiB8fCAoaXNVbmRlZmluZWQob3B0aW9uLndpZHRoKSAmJiBpc1VuZGVmaW5lZChvcHRpb24uaGVpZ2h0KSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwaWNrKG9wdGlvbiwgJ3dpZHRoJywgJ2hlaWdodCcpO1xufVxuZnVuY3Rpb24gdmFsaWRPZmZzZXRWYWx1ZShheGlzLCBwbG90LCBzaXplS2V5KSB7XG4gICAgY29uc3QgYXhpc1NpemUgPSBheGlzW3NpemVLZXldO1xuICAgIGNvbnN0IHBsb3RTaXplID0gcGxvdFtzaXplS2V5XTtcbiAgICBpZiAoaXNOdW1iZXIoYXhpc1NpemUpICYmIGlzTnVtYmVyKHBsb3RTaXplKSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoYXhpc1NpemUsIHBsb3RTaXplKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRPcHRpb25TaXplKG9wdGlvbnMpIHtcbiAgICBjb25zdCB4QXhpcyA9IHBpY2tPcHRpb25TaXplKG9wdGlvbnMueEF4aXMpO1xuICAgIGNvbnN0IHlBeGlzT3B0aW9ucyA9IGdldFlBeGlzT3B0aW9uKG9wdGlvbnMpO1xuICAgIGNvbnN0IHlBeGlzID0gcGlja09wdGlvblNpemUoeUF4aXNPcHRpb25zLnlBeGlzKTtcbiAgICBjb25zdCBzZWNvbmRhcnlZQXhpcyA9IHBpY2tPcHRpb25TaXplKHlBeGlzT3B0aW9ucy5zZWNvbmRhcnlZQXhpcyk7XG4gICAgY29uc3QgcGxvdCA9IHBpY2tPcHRpb25TaXplKG9wdGlvbnMucGxvdCk7XG4gICAgaWYgKHBsb3QpIHtcbiAgICAgICAgLypcbiAgICAgICAgSWYgYm90aCB0aGUgd2lkdGggb2YgdGhlIHgtYXhpcyBhbmQgdGhlIHdpZHRoIG9mIHRoZSBwbG90IGFyZSBlbnRlcmVkLFxuICAgICAgICBzZXQgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICAqL1xuICAgICAgICBpZiAoeEF4aXMpIHtcbiAgICAgICAgICAgIHhBeGlzLndpZHRoID0gcGxvdC53aWR0aCA9IHZhbGlkT2Zmc2V0VmFsdWUoeEF4aXMsIHBsb3QsICd3aWR0aCcpO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgIElmIGJvdGggdGhlIGhlaWdodCBvZiB0aGUgeS1heGlzIGFuZCB0aGUgaGVpZ2h0IG9mIHRoZSBwbG90IGFyZSBlbnRlcmVkLFxuICAgICAgICBzZXQgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICAqL1xuICAgICAgICBpZiAoeUF4aXMpIHtcbiAgICAgICAgICAgIHlBeGlzLmhlaWdodCA9IHBsb3QuaGVpZ2h0ID0gdmFsaWRPZmZzZXRWYWx1ZSh5QXhpcywgcGxvdCwgJ2hlaWdodCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWNvbmRhcnlZQXhpcykge1xuICAgICAgICAgICAgc2Vjb25kYXJ5WUF4aXMuaGVpZ2h0ID0gcGxvdC5oZWlnaHQgPSB2YWxpZE9mZnNldFZhbHVlKHNlY29uZGFyeVlBeGlzLCBwbG90LCAnaGVpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeEF4aXMsXG4gICAgICAgIHlBeGlzLFxuICAgICAgICBwbG90LFxuICAgICAgICBzZWNvbmRhcnlZQXhpcyxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0QXhpc1RpdGxlSGVpZ2h0KGF4aXNUaGVtZSwgb2Zmc2V0WSA9IDApIHtcbiAgICBjb25zdCBmb250U2l6ZSA9IEFycmF5LmlzQXJyYXkoYXhpc1RoZW1lKVxuICAgICAgICA/IE1hdGgubWF4KGF4aXNUaGVtZVswXS50aXRsZS5mb250U2l6ZSwgYXhpc1RoZW1lWzFdLnRpdGxlLmZvbnRTaXplKVxuICAgICAgICA6IGF4aXNUaGVtZS50aXRsZS5mb250U2l6ZTtcbiAgICByZXR1cm4gZm9udFNpemUgKyBvZmZzZXRZO1xufVxuZnVuY3Rpb24gYWRqdXN0QXhpc1NpemUoeyB3aWR0aCwgaGVpZ2h0IH0sIGxheW91dCwgbGVnZW5kU3RhdGUpIHtcbiAgICBpZiAod2lkdGggPCAwIHx8IGhlaWdodCA8IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHRpdGxlLCB5QXhpc1RpdGxlLCB5QXhpcywgeEF4aXMsIHhBeGlzVGl0bGUsIGxlZ2VuZCwgc2Vjb25kYXJ5WUF4aXMgfSA9IGxheW91dDtcbiAgICBjb25zdCB7IGFsaWduIH0gPSBsZWdlbmRTdGF0ZTtcbiAgICBjb25zdCBoYXNWZXJ0aWNhbExlZ2VuZCA9IGlzVmVydGljYWxBbGlnbihhbGlnbik7XG4gICAgY29uc3QgbGVnZW5kSGVpZ2h0ID0gaGFzVmVydGljYWxMZWdlbmQgPyBsZWdlbmQuaGVpZ2h0IDogMDtcbiAgICBjb25zdCBkaWZmSGVpZ2h0ID0geEF4aXMuaGVpZ2h0ICtcbiAgICAgICAgeEF4aXNUaXRsZS5oZWlnaHQgK1xuICAgICAgICB5QXhpcy5oZWlnaHQgK1xuICAgICAgICB5QXhpc1RpdGxlLmhlaWdodCArXG4gICAgICAgIHRpdGxlLmhlaWdodCArXG4gICAgICAgIGxlZ2VuZEhlaWdodCAtXG4gICAgICAgIGhlaWdodDtcbiAgICBpZiAoZGlmZkhlaWdodCA+IDApIHtcbiAgICAgICAgeUF4aXMuaGVpZ2h0IC09IGRpZmZIZWlnaHQ7XG4gICAgICAgIHhBeGlzLnkgLT0gZGlmZkhlaWdodDtcbiAgICAgICAgeEF4aXNUaXRsZS55IC09IGRpZmZIZWlnaHQ7XG4gICAgICAgIGlmIChoYXNWZXJ0aWNhbExlZ2VuZCkge1xuICAgICAgICAgICAgbGVnZW5kLnkgLT0gZGlmZkhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWNvbmRhcnlZQXhpcy54ID0geEF4aXMueCArIHhBeGlzLndpZHRoO1xuICAgIHNlY29uZGFyeVlBeGlzLmhlaWdodCA9IHlBeGlzLmhlaWdodDtcbn1cbmZ1bmN0aW9uIGdldENpcmN1bGFyQXhpc1RpdGxlUmVjdChwbG90LCBheGlzVGhlbWUsIGNpcmN1bGFyQXhpcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCFjaXJjdWxhckF4aXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHBsb3QpO1xuICAgIH1cbiAgICBjb25zdCB7IHgsIHkgfSA9IHBsb3Q7XG4gICAgY29uc3QgeyBjZW50ZXJYLCBjZW50ZXJZLCBheGlzU2l6ZSwgdGl0bGUsIHJhZGl1czogeyBvdXRlciB9LCB9ID0gY2lyY3VsYXJBeGlzO1xuICAgIGNvbnN0IG9mZnNldFkgPSAoX2IgPSAoX2EgPSB0aXRsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9mZnNldFksIChfYiAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogY2VudGVyWCArIHggLSBheGlzU2l6ZSAvIDIsXG4gICAgICAgIHk6IGNlbnRlclkgKyB5IC0gb3V0ZXIgLyAyLFxuICAgICAgICB3aWR0aDogYXhpc1NpemUsXG4gICAgICAgIGhlaWdodDogYXhpc1RoZW1lLnRpdGxlLmZvbnRTaXplICsgb2Zmc2V0WSxcbiAgICB9O1xufVxuZnVuY3Rpb24gaGFzWFlBeGVzKHNlcmllcykge1xuICAgIHJldHVybiAhKHNlcmllcy5waWUgfHwgc2VyaWVzLnJhZGFyIHx8IHNlcmllcy50cmVlbWFwIHx8IHNlcmllcy5yYWRpYWxCYXIgfHwgc2VyaWVzLmdhdWdlKTtcbn1cbmZ1bmN0aW9uIGdldFlBeGlzT3B0aW9ucyhvcHRpb25zLCBoYXNYWUF4aXMpIHtcbiAgICByZXR1cm4gaGFzWFlBeGlzXG4gICAgICAgID8gZ2V0WUF4aXNPcHRpb24ob3B0aW9ucylcbiAgICAgICAgOiB7XG4gICAgICAgICAgICB5QXhpczogbnVsbCxcbiAgICAgICAgICAgIHNlY29uZGFyeVlBeGlzOiBudWxsLFxuICAgICAgICB9O1xufVxuY29uc3QgbGF5b3V0ID0ge1xuICAgIG5hbWU6ICdsYXlvdXQnLFxuICAgIHN0YXRlOiAoKSA9PiAoe1xuICAgICAgICBsYXlvdXQ6IHt9LFxuICAgIH0pLFxuICAgIGFjdGlvbjoge1xuICAgICAgICBzZXRMYXlvdXQoeyBzdGF0ZSB9KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wLCBfcSwgX3IsIF9zO1xuICAgICAgICAgICAgY29uc3QgeyBsZWdlbmQ6IGxlZ2VuZFN0YXRlLCB0aGVtZSwgY2lyY2xlTGVnZW5kOiBjaXJjbGVMZWdlbmRTdGF0ZSwgc2VyaWVzLCBvcHRpb25zLCBjaGFydCwgYXhlcywgcmFkaWFsQXhlcywgfSA9IHN0YXRlO1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjaGFydDtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJ0U2l6ZSA9IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCAtIHBhZGRpbmcuWSAqIDIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoIC0gcGFkZGluZy5YICogMixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBoYXNDZW50ZXJZQXhpcyA9IHNlcmllcy5iYXIgPyBpc0NlbnRlcllBeGlzKG9wdGlvbnMpIDogZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBoYXNYWUF4aXMgPSBoYXNYWUF4ZXMoc2VyaWVzKTtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvblNpemUgPSBnZXRPcHRpb25TaXplKG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgeyB5QXhpczogeUF4aXNPcHRpb24sIHNlY29uZGFyeVlBeGlzOiBzZWNvbmRhcnlZQXhpc09wdGlvbiB9ID0gZ2V0WUF4aXNPcHRpb25zKG9wdGlvbnMsIGhhc1hZQXhpcyk7XG4gICAgICAgICAgICBjb25zdCB2aXNpYmxlU2Vjb25kYXJ5WUF4aXMgPSAhIXNlY29uZGFyeVlBeGlzT3B0aW9uO1xuICAgICAgICAgICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGVtZS50aXRsZS5mb250U2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IHlBeGlzVGl0bGVIZWlnaHQgPSAoX2QgPSBnZXRBeGlzVGl0bGVIZWlnaHQodGhlbWUueUF4aXMsIChfYyA9IChfYiA9IChfYSA9IGF4ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS55QXhpcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRpdGxlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mub2Zmc2V0WSksIChfZCAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwKSk7XG4gICAgICAgICAgICBjb25zdCB4QXhpc1RpdGxlSGVpZ2h0ID0gKF9oID0gZ2V0QXhpc1RpdGxlSGVpZ2h0KHRoZW1lLnhBeGlzLCAoX2cgPSAoX2YgPSAoX2UgPSBheGVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UueEF4aXMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi50aXRsZSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLm9mZnNldFkpLCAoX2ggIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogMCkpO1xuICAgICAgICAgICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBvcmRlciFcbiAgICAgICAgICAgIC8vIGV4cG9ydE1lbnUgLT4gcmVzZXRCdXR0b24gLT4gdGl0bGUgLT4geUF4aXMudGl0bGUgLT4geUF4aXMgLT4gc2Vjb25kYXJ5WUF4aXNUaXRsZSAtPiBzZWNvbmRhcnlZQXhpcyAtPiB4QXhpcyAtPiB4QXhpcy50aXRsZSAtPiBsZWdlbmQgLT4gY2lyY2xlTGVnZW5kIC0+IHBsb3QgLT4gY2lyY3VsYXJBeGlzLnRpdGxlXG4gICAgICAgICAgICBjb25zdCBleHBvcnRNZW51ID0gZ2V0RXhwb3J0TWVudVJlY3QoY2hhcnRTaXplLCBpc0V4cG9ydE1lbnVWaXNpYmxlKG9wdGlvbnMpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2V0QnV0dG9uID0gZ2V0UmVzZXRCdXR0b25SZWN0KGV4cG9ydE1lbnUsIGlzVXNpbmdSZXNldEJ1dHRvbihvcHRpb25zKSk7XG4gICAgICAgICAgICBjb25zdCBidG5BcmVhUmVjdCA9IGV4cG9ydE1lbnUuaGVpZ2h0ID8gZXhwb3J0TWVudSA6IHJlc2V0QnV0dG9uO1xuICAgICAgICAgICAgY29uc3QgdGl0bGUgPSBnZXRUaXRsZVJlY3QoY2hhcnRTaXplLCBidG5BcmVhUmVjdCwgISEoKF9qID0gb3B0aW9ucy5jaGFydCkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLnRpdGxlKSwgdGl0bGVIZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgeUF4aXNUaXRsZVZpc2libGUgPSAhISgoX2sgPSB5QXhpc09wdGlvbikgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLnRpdGxlKSB8fCAhISgoX2wgPSBzZWNvbmRhcnlZQXhpc09wdGlvbikgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLnRpdGxlKTtcbiAgICAgICAgICAgIGNvbnN0IHlBeGlzVGl0bGUgPSBnZXRZQXhpc1RpdGxlUmVjdCh7XG4gICAgICAgICAgICAgICAgY2hhcnRTaXplLFxuICAgICAgICAgICAgICAgIHZpc2libGU6IHlBeGlzVGl0bGVWaXNpYmxlLFxuICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgIGxlZ2VuZDogbGVnZW5kU3RhdGUsXG4gICAgICAgICAgICAgICAgaGFzQ2VudGVyWUF4aXMsXG4gICAgICAgICAgICAgICAgdmlzaWJsZVNlY29uZGFyeVlBeGlzLFxuICAgICAgICAgICAgICAgIHlBeGlzVGl0bGVIZWlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHlBeGlzID0gZ2V0WUF4aXNSZWN0KHtcbiAgICAgICAgICAgICAgICBjaGFydFNpemUsXG4gICAgICAgICAgICAgICAgbGVnZW5kOiBsZWdlbmRTdGF0ZSxcbiAgICAgICAgICAgICAgICBjaXJjbGVMZWdlbmQ6IGNpcmNsZUxlZ2VuZFN0YXRlLFxuICAgICAgICAgICAgICAgIHlBeGlzVGl0bGUsXG4gICAgICAgICAgICAgICAgaGFzQ2VudGVyWUF4aXMsXG4gICAgICAgICAgICAgICAgaGFzWFlBeGlzLFxuICAgICAgICAgICAgICAgIG1heExhYmVsV2lkdGg6IGdldFlBeGlzTWF4TGFiZWxXaWR0aCgoX20gPSBheGVzKSA9PT0gbnVsbCB8fCBfbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX20ueUF4aXMubWF4TGFiZWxXaWR0aCksXG4gICAgICAgICAgICAgICAgc2l6ZTogb3B0aW9uU2l6ZSxcbiAgICAgICAgICAgICAgICB4QXhpc1RpdGxlSGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzZWNvbmRhcnlZQXhpc1RpdGxlID0gZ2V0WUF4aXNUaXRsZVJlY3Qoe1xuICAgICAgICAgICAgICAgIGNoYXJ0U2l6ZSxcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiB5QXhpc1RpdGxlVmlzaWJsZSxcbiAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgICAgICBsZWdlbmQ6IGxlZ2VuZFN0YXRlLFxuICAgICAgICAgICAgICAgIGhhc0NlbnRlcllBeGlzLFxuICAgICAgICAgICAgICAgIGlzUmlnaHRTaWRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZpc2libGVTZWNvbmRhcnlZQXhpcyxcbiAgICAgICAgICAgICAgICB5QXhpc1RpdGxlSGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzZWNvbmRhcnlZQXhpcyA9IGdldFlBeGlzUmVjdCh7XG4gICAgICAgICAgICAgICAgY2hhcnRTaXplLFxuICAgICAgICAgICAgICAgIGxlZ2VuZDogbGVnZW5kU3RhdGUsXG4gICAgICAgICAgICAgICAgY2lyY2xlTGVnZW5kOiBjaXJjbGVMZWdlbmRTdGF0ZSxcbiAgICAgICAgICAgICAgICB5QXhpc1RpdGxlOiBzZWNvbmRhcnlZQXhpc1RpdGxlLFxuICAgICAgICAgICAgICAgIGhhc0NlbnRlcllBeGlzLFxuICAgICAgICAgICAgICAgIGhhc1hZQXhpcyxcbiAgICAgICAgICAgICAgICBtYXhMYWJlbFdpZHRoOiBnZXRZQXhpc01heExhYmVsV2lkdGgoKF9wID0gKF9vID0gYXhlcykgPT09IG51bGwgfHwgX28gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vLnNlY29uZGFyeVlBeGlzKSA9PT0gbnVsbCB8fCBfcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3AubWF4TGFiZWxXaWR0aCksXG4gICAgICAgICAgICAgICAgc2l6ZTogb3B0aW9uU2l6ZSxcbiAgICAgICAgICAgICAgICBpc1JpZ2h0U2lkZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2aXNpYmxlU2Vjb25kYXJ5WUF4aXMsXG4gICAgICAgICAgICAgICAgeEF4aXNUaXRsZUhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeEF4aXMgPSBnZXRYQXhpc1JlY3Qoe1xuICAgICAgICAgICAgICAgIGNoYXJ0U2l6ZSxcbiAgICAgICAgICAgICAgICB5QXhpcyxcbiAgICAgICAgICAgICAgICBzZWNvbmRhcnlZQXhpcyxcbiAgICAgICAgICAgICAgICBsZWdlbmQ6IGxlZ2VuZFN0YXRlLFxuICAgICAgICAgICAgICAgIGNpcmNsZUxlZ2VuZDogY2lyY2xlTGVnZW5kU3RhdGUsXG4gICAgICAgICAgICAgICAgaGFzQ2VudGVyWUF4aXMsXG4gICAgICAgICAgICAgICAgaGFzWFlBeGlzLFxuICAgICAgICAgICAgICAgIHNpemU6IG9wdGlvblNpemUsXG4gICAgICAgICAgICAgICAgeEF4aXNEYXRhOiAoX3EgPSBheGVzKSA9PT0gbnVsbCB8fCBfcSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3EueEF4aXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHhBeGlzVGl0bGUgPSBnZXRYQXhpc1RpdGxlUmVjdCghISgoX3IgPSBvcHRpb25zLnhBeGlzKSA9PT0gbnVsbCB8fCBfciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3IudGl0bGUpLCB4QXhpcywgeEF4aXNUaXRsZUhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCBsZWdlbmQgPSBnZXRMZWdlbmRSZWN0KHtcbiAgICAgICAgICAgICAgICBjaGFydFNpemUsXG4gICAgICAgICAgICAgICAgeEF4aXMsXG4gICAgICAgICAgICAgICAgeUF4aXMsXG4gICAgICAgICAgICAgICAgc2Vjb25kYXJ5WUF4aXMsXG4gICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgbGVnZW5kOiBsZWdlbmRTdGF0ZSxcbiAgICAgICAgICAgICAgICBoYXNYWUF4aXMsXG4gICAgICAgICAgICAgICAgeEF4aXNUaXRsZUhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWRqdXN0QXhpc1NpemUoY2hhcnRTaXplLCB7IHRpdGxlLCB5QXhpc1RpdGxlLCB5QXhpcywgeEF4aXMsIHhBeGlzVGl0bGUsIGxlZ2VuZCwgc2Vjb25kYXJ5WUF4aXMgfSwgbGVnZW5kU3RhdGUpO1xuICAgICAgICAgICAgY29uc3QgY2lyY2xlTGVnZW5kID0gZ2V0Q2lyY2xlTGVnZW5kUmVjdCh4QXhpcywgeUF4aXMsIGxlZ2VuZFN0YXRlLmFsaWduLCBjaXJjbGVMZWdlbmRTdGF0ZS53aWR0aCk7XG4gICAgICAgICAgICBjb25zdCBwbG90ID0gZ2V0UGxvdFJlY3QoeEF4aXMsIHlBeGlzLCBvcHRpb25TaXplLnBsb3QpO1xuICAgICAgICAgICAgY29uc3QgY2lyY3VsYXJBeGlzVGl0bGUgPSBnZXRDaXJjdWxhckF4aXNUaXRsZVJlY3QocGxvdCwgdGhlbWUuY2lyY3VsYXJBeGlzLCAoX3MgPSByYWRpYWxBeGVzKSA9PT0gbnVsbCB8fCBfcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3MuY2lyY3VsYXJBeGlzKTtcbiAgICAgICAgICAgIGV4dGVuZChzdGF0ZS5sYXlvdXQsIHtcbiAgICAgICAgICAgICAgICBjaGFydDogeyB4OiAwLCB5OiAwLCB3aWR0aCwgaGVpZ2h0IH0sXG4gICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgcGxvdCxcbiAgICAgICAgICAgICAgICBsZWdlbmQsXG4gICAgICAgICAgICAgICAgY2lyY2xlTGVnZW5kLFxuICAgICAgICAgICAgICAgIHhBeGlzLFxuICAgICAgICAgICAgICAgIHhBeGlzVGl0bGUsXG4gICAgICAgICAgICAgICAgeUF4aXMsXG4gICAgICAgICAgICAgICAgeUF4aXNUaXRsZSxcbiAgICAgICAgICAgICAgICBleHBvcnRNZW51LFxuICAgICAgICAgICAgICAgIHJlc2V0QnV0dG9uLFxuICAgICAgICAgICAgICAgIHNlY29uZGFyeVlBeGlzVGl0bGUsXG4gICAgICAgICAgICAgICAgc2Vjb25kYXJ5WUF4aXMsXG4gICAgICAgICAgICAgICAgY2lyY3VsYXJBeGlzVGl0bGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIG9ic2VydmU6IHtcbiAgICAgICAgdXBkYXRlTGF5b3V0T2JzZXJ2ZSgpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goJ3NldExheW91dCcpO1xuICAgICAgICB9LFxuICAgIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgbGF5b3V0O1xuIiwiaW1wb3J0IHsgaXNVbmRlZmluZWQsIHN1bSwgZGVlcE1lcmdlZENvcHksIHJhbmdlLCBpc051bWJlciB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXRMZWdlbmRJdGVtSGVpZ2h0LCBMRUdFTkRfQ0hFQ0tCT1hfU0laRSwgTEVHRU5EX0lDT05fU0laRSwgTEVHRU5EX0lURU1fTUFSR0lOX1gsIExFR0VORF9NQVJHSU5fWCwgfSBmcm9tIFwiLi4vYnJ1c2hlcy9sZWdlbmRcIjtcbmltcG9ydCB7IGdldFRleHRXaWR0aCB9IGZyb20gXCIuLi9oZWxwZXJzL2NhbGN1bGF0b3JcIjtcbmltcG9ydCB7IGlzVmVydGljYWxBbGlnbiwgcGFkZGluZyB9IGZyb20gXCIuL2xheW91dFwiO1xuaW1wb3J0IHsgU1BFQ1RSVU1fTEVHRU5EX0xBQkVMX0hFSUdIVCwgc3BlY3RydW1MZWdlbmRCYXIsIHNwZWN0cnVtTGVnZW5kVG9vbHRpcCwgfSBmcm9tIFwiLi4vYnJ1c2hlcy9zcGVjdHJ1bUxlZ2VuZFwiO1xuaW1wb3J0IHsgaGFzTmVzdGVkUGllU2VyaWVzIH0gZnJvbSBcIi4uL2hlbHBlcnMvcGllU2VyaWVzXCI7XG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tIFwiLi9zdG9yZVwiO1xuaW1wb3J0IHsgZ2V0VGl0bGVGb250U3RyaW5nIH0gZnJvbSBcIi4uL2hlbHBlcnMvc3R5bGVcIjtcbmltcG9ydCB7IG1ha2VEZWZhdWx0VGhlbWUgfSBmcm9tIFwiLi4vaGVscGVycy90aGVtZVwiO1xuaW1wb3J0IHsgaXNOb0RhdGEgfSBmcm9tIFwiLi4vaGVscGVycy92YWxpZGF0aW9uXCI7XG5pbXBvcnQgeyBnZXRJY29uVHlwZSwgZ2V0TGVnZW5kQWxpZ24sIHNob3dDaGVja2JveCwgc2hvd0NpcmNsZUxlZ2VuZCwgc2hvd0xlZ2VuZCwgfSBmcm9tIFwiLi4vaGVscGVycy9sZWdlbmRcIjtcbmNvbnN0IElOSVRJQUxfTEVHRU5EX1dJRFRIID0gMTAwO1xuY29uc3QgSU5JVElBTF9DSVJDTEVfTEVHRU5EX1dJRFRIID0gMTUwO1xuY29uc3QgQ09NUE9ORU5UX0hFSUdIVF9FWENFUFRfWV9BWElTID0gMTAwO1xuY29uc3QgRUxMSVBTSVNfRE9UX1RFWFQgPSAnLi4uJztcbmNvbnN0IFdJREVTVF9URVhUID0gJ1cnOyAvLyBUaGUgd2lkZXN0IHRleHQgd2lkdGggaW4gQXJpYWwgZm9udC5cbmNvbnN0IE5VTUJFUl9PRl9CT1RIX1NJREVTID0gMjtcbmZ1bmN0aW9uIHJlY2FsY3VsYXRlTGVnZW5kV2hlbkhlaWdodE92ZXJmbG93cyhwYXJhbXMsIGxlZ2VuZEhlaWdodCkge1xuICAgIGNvbnN0IHsgbGVnZW5kV2lkdGhzLCBpdGVtSGVpZ2h0IH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdG90YWxIZWlnaHQgPSBsZWdlbmRXaWR0aHMubGVuZ3RoICogaXRlbUhlaWdodDtcbiAgICBjb25zdCBjb2x1bW5Db3VudCA9IE1hdGguY2VpbCh0b3RhbEhlaWdodCAvIGxlZ2VuZEhlaWdodCk7XG4gICAgY29uc3Qgcm93Q291bnQgPSBsZWdlbmRXaWR0aHMubGVuZ3RoIC8gY29sdW1uQ291bnQ7XG4gICAgbGV0IGxlZ2VuZFdpZHRoID0gMDtcbiAgICByYW5nZSgwLCBjb2x1bW5Db3VudCkuZm9yRWFjaCgoY291bnQpID0+IHtcbiAgICAgICAgbGVnZW5kV2lkdGggKz0gTWF0aC5tYXgoLi4ubGVnZW5kV2lkdGhzLnNsaWNlKGNvdW50ICogcm93Q291bnQsIChjb3VudCArIDEpICogcm93Q291bnQpKTtcbiAgICB9KTtcbiAgICBsZWdlbmRXaWR0aCArPSBMRUdFTkRfSVRFTV9NQVJHSU5fWCAqIChjb2x1bW5Db3VudCAtIDEpO1xuICAgIHJldHVybiB7IGxlZ2VuZFdpZHRoLCBsZWdlbmRIZWlnaHQ6IHJvd0NvdW50ICogaXRlbUhlaWdodCArIHBhZGRpbmcuWSwgY29sdW1uQ291bnQsIHJvd0NvdW50IH07XG59XG5mdW5jdGlvbiByZWNhbGN1bGF0ZUxlZ2VuZFdoZW5XaWR0aE92ZXJmbG93cyhwYXJhbXMsIHByZXZMZWdlbmRXaWR0aCkge1xuICAgIGNvbnN0IHsgbGVnZW5kV2lkdGhzLCBpdGVtSGVpZ2h0IH0gPSBwYXJhbXM7XG4gICAgbGV0IGNvbHVtbkNvdW50ID0gMDtcbiAgICBsZXQgbGVnZW5kV2lkdGggPSAwO1xuICAgIGNvbnN0IHsgcm93Q291bnQgfSA9IGxlZ2VuZFdpZHRocy5yZWR1Y2UoKGFjYywgd2lkdGgpID0+IHtcbiAgICAgICAgY29uc3Qgd2lkdGhXaXRoTWFyZ2luID0gTEVHRU5EX0lURU1fTUFSR0lOX1ggKyB3aWR0aDtcbiAgICAgICAgaWYgKGFjYy50b3RhbFdpZHRoICsgd2lkdGggPiBwcmV2TGVnZW5kV2lkdGgpIHtcbiAgICAgICAgICAgIGFjYy50b3RhbFdpZHRoID0gd2lkdGhXaXRoTWFyZ2luO1xuICAgICAgICAgICAgYWNjLnJvd0NvdW50ICs9IDE7XG4gICAgICAgICAgICBhY2MuY29sdW1uQ291bnQgPSAxO1xuICAgICAgICAgICAgY29sdW1uQ291bnQgPSBNYXRoLm1heChjb2x1bW5Db3VudCwgYWNjLmNvbHVtbkNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjYy50b3RhbFdpZHRoICs9IHdpZHRoV2l0aE1hcmdpbjtcbiAgICAgICAgICAgIGFjYy5jb2x1bW5Db3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGxlZ2VuZFdpZHRoID0gTWF0aC5tYXgobGVnZW5kV2lkdGgsIGFjYy50b3RhbFdpZHRoKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7IHRvdGFsV2lkdGg6IDAsIHJvd0NvdW50OiAxLCBjb2x1bW5Db3VudDogMCB9KTtcbiAgICByZXR1cm4geyBsZWdlbmRIZWlnaHQ6IGl0ZW1IZWlnaHQgKiByb3dDb3VudCwgcm93Q291bnQsIGNvbHVtbkNvdW50LCBsZWdlbmRXaWR0aCB9O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlTGVnZW5kU2l6ZShwYXJhbXMpIHtcbiAgICBpZiAoIXBhcmFtcy52aXNpYmxlKSB7XG4gICAgICAgIHJldHVybiB7IGxlZ2VuZFdpZHRoOiAwLCBsZWdlbmRIZWlnaHQ6IDAsIHJvd0NvdW50OiAwLCBjb2x1bW5Db3VudDogMCB9O1xuICAgIH1cbiAgICBjb25zdCB7IGNoYXJ0LCB2ZXJ0aWNhbEFsaWduLCBsZWdlbmRXaWR0aHMgfSA9IHBhcmFtcztcbiAgICBjb25zdCB7IGxlZ2VuZFdpZHRoLCBpc092ZXJmbG93OiB3aWR0aE92ZXJmbG93IH0gPSBjYWxjdWxhdGVMZWdlbmRXaWR0aChwYXJhbXMpO1xuICAgIGNvbnN0IHsgbGVnZW5kSGVpZ2h0LCBpc092ZXJmbG93OiBoZWlnaHRPdmVyZmxvdyB9ID0gY2FsY3VsYXRlTGVnZW5kSGVpZ2h0KHBhcmFtcyk7XG4gICAgY29uc3QgY29sdW1uQ291bnQgPSB2ZXJ0aWNhbEFsaWduID8gbGVnZW5kV2lkdGhzLmxlbmd0aCA6IDE7XG4gICAgY29uc3Qgcm93Q291bnQgPSB2ZXJ0aWNhbEFsaWduID8gTWF0aC5jZWlsKGxlZ2VuZFdpZHRoIC8gY2hhcnQud2lkdGgpIDogbGVnZW5kV2lkdGhzLmxlbmd0aDtcbiAgICBpZiAod2lkdGhPdmVyZmxvdykge1xuICAgICAgICByZXR1cm4gcmVjYWxjdWxhdGVMZWdlbmRXaGVuV2lkdGhPdmVyZmxvd3MocGFyYW1zLCBsZWdlbmRXaWR0aCAvIHJvd0NvdW50KTtcbiAgICB9XG4gICAgaWYgKGhlaWdodE92ZXJmbG93KSB7XG4gICAgICAgIHJldHVybiByZWNhbGN1bGF0ZUxlZ2VuZFdoZW5IZWlnaHRPdmVyZmxvd3MocGFyYW1zLCBsZWdlbmRIZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4geyBsZWdlbmRXaWR0aCwgbGVnZW5kSGVpZ2h0LCBjb2x1bW5Db3VudCwgcm93Q291bnQgfTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUxlZ2VuZEhlaWdodChwYXJhbXMpIHtcbiAgICBjb25zdCB7IHZlcnRpY2FsQWxpZ24sIGl0ZW1IZWlnaHQsIGxlZ2VuZFdpZHRocyB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHsgaGVpZ2h0OiBjaGFydEhlaWdodCB9ID0gZ2V0RGVmYXVsdExlZ2VuZFNpemUocGFyYW1zKTtcbiAgICBsZXQgbGVnZW5kSGVpZ2h0O1xuICAgIGxldCBpc092ZXJmbG93ID0gZmFsc2U7XG4gICAgaWYgKHZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgbGVnZW5kSGVpZ2h0ID0gY2hhcnRIZWlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0b3RhbEhlaWdodCA9IGxlZ2VuZFdpZHRocy5sZW5ndGggKiBpdGVtSGVpZ2h0O1xuICAgICAgICBpc092ZXJmbG93ID0gY2hhcnRIZWlnaHQgPCB0b3RhbEhlaWdodDtcbiAgICAgICAgbGVnZW5kSGVpZ2h0ID0gaXNPdmVyZmxvdyA/IGNoYXJ0SGVpZ2h0IDogdG90YWxIZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiB7IGxlZ2VuZEhlaWdodCwgaXNPdmVyZmxvdyB9O1xufVxuZnVuY3Rpb24gZ2V0U3BlY3RydW1MZWdlbmRXaWR0aChsZWdlbmRXaWR0aHMsIGNoYXJ0V2lkdGgsIHZlcnRpY2FsQWxpZ24pIHtcbiAgICBpZiAodmVydGljYWxBbGlnbikge1xuICAgICAgICBjb25zdCBsYWJlbEFyZWFXaWR0aCA9IHN1bShsZWdlbmRXaWR0aHMpO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoY2hhcnRXaWR0aCAvIDQsIGxhYmVsQXJlYVdpZHRoKTtcbiAgICB9XG4gICAgY29uc3Qgc3BlY3RydW1BcmVhV2lkdGggPSAoc3BlY3RydW1MZWdlbmRUb29sdGlwLlBBRERJTkcgKyBzcGVjdHJ1bUxlZ2VuZEJhci5QQURESU5HICsgcGFkZGluZy5YKSAqIE5VTUJFUl9PRl9CT1RIX1NJREVTICtcbiAgICAgICAgc3BlY3RydW1MZWdlbmRUb29sdGlwLlBPSU5UX0hFSUdIVCArXG4gICAgICAgIHNwZWN0cnVtTGVnZW5kQmFyLkhFSUdIVDtcbiAgICByZXR1cm4gTWF0aC5tYXgoLi4ubGVnZW5kV2lkdGhzKSArIHNwZWN0cnVtQXJlYVdpZHRoO1xufVxuZnVuY3Rpb24gZ2V0U3BlY3RydW1MZWdlbmRIZWlnaHQoaXRlbUhlaWdodCwgY2hhcnRIZWlnaHQsIHZlcnRpY2FsQWxpZ24pIHtcbiAgICByZXR1cm4gdmVydGljYWxBbGlnblxuICAgICAgICA/IFNQRUNUUlVNX0xFR0VORF9MQUJFTF9IRUlHSFQgK1xuICAgICAgICAgICAgc3BlY3RydW1MZWdlbmRCYXIuUEFERElORyAqIE5VTUJFUl9PRl9CT1RIX1NJREVTICtcbiAgICAgICAgICAgIHNwZWN0cnVtTGVnZW5kVG9vbHRpcC5QT0lOVF9IRUlHSFQgK1xuICAgICAgICAgICAgc3BlY3RydW1MZWdlbmRUb29sdGlwLkhFSUdIVCArXG4gICAgICAgICAgICBwYWRkaW5nLllcbiAgICAgICAgOiAoY2hhcnRIZWlnaHQgKiAzKSAvIDQ7XG59XG5mdW5jdGlvbiBnZXROb3JtYWxMZWdlbmRXaWR0aChwYXJhbXMpIHtcbiAgICBjb25zdCB7IGluaXRpYWxXaWR0aCwgbGVnZW5kV2lkdGhzLCBjaGVja2JveCwgdmVydGljYWxBbGlnbiB9ID0gcGFyYW1zO1xuICAgIGxldCBpc092ZXJmbG93ID0gZmFsc2U7XG4gICAgbGV0IGxlZ2VuZFdpZHRoO1xuICAgIGlmICh2ZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGg6IGNoYXJ0V2lkdGggfSA9IGdldERlZmF1bHRMZWdlbmRTaXplKHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHRvdGFsV2lkdGggPSBzdW0obGVnZW5kV2lkdGhzKSArIExFR0VORF9JVEVNX01BUkdJTl9YICogKGxlZ2VuZFdpZHRocy5sZW5ndGggLSAxKTtcbiAgICAgICAgaXNPdmVyZmxvdyA9IHRvdGFsV2lkdGggPiBjaGFydFdpZHRoO1xuICAgICAgICBsZWdlbmRXaWR0aCA9IHRvdGFsV2lkdGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBsYWJlbEFyZWFXaWR0aCA9IE1hdGgubWF4KC4uLmxlZ2VuZFdpZHRocyk7XG4gICAgICAgIGxlZ2VuZFdpZHRoID1cbiAgICAgICAgICAgIChjaGVja2JveCA/IExFR0VORF9DSEVDS0JPWF9TSVpFICsgTEVHRU5EX01BUkdJTl9YIDogMCkgK1xuICAgICAgICAgICAgICAgIExFR0VORF9JQ09OX1NJWkUgK1xuICAgICAgICAgICAgICAgIExFR0VORF9NQVJHSU5fWCArXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgobGFiZWxBcmVhV2lkdGgsIGluaXRpYWxXaWR0aCk7XG4gICAgfVxuICAgIHJldHVybiB7IGxlZ2VuZFdpZHRoLCBpc092ZXJmbG93IH07XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVMZWdlbmRXaWR0aChwYXJhbXMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgb3B0aW9ucywgdmlzaWJsZSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGxlZ2VuZE9wdGlvbnMgPSAoX2EgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVnZW5kO1xuICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICByZXR1cm4geyBsZWdlbmRXaWR0aDogMCwgaXNPdmVyZmxvdzogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKChfYiA9IGxlZ2VuZE9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi53aWR0aCkge1xuICAgICAgICByZXR1cm4geyBsZWdlbmRXaWR0aDogbGVnZW5kT3B0aW9ucy53aWR0aCwgaXNPdmVyZmxvdzogZmFsc2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIGdldE5vcm1hbExlZ2VuZFdpZHRoKHBhcmFtcyk7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0TGVnZW5kU2l6ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7IHZlcnRpY2FsQWxpZ24sIGNoYXJ0LCBpdGVtSGVpZ2h0LCBpbml0aWFsV2lkdGgsIGNpcmNsZUxlZ2VuZFZpc2libGUgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXN0QXJlYUhlaWdodCA9IENPTVBPTkVOVF9IRUlHSFRfRVhDRVBUX1lfQVhJUyArIChjaXJjbGVMZWdlbmRWaXNpYmxlID8gSU5JVElBTF9DSVJDTEVfTEVHRU5EX1dJRFRIIDogMCk7IC8vIHJlc3QgYXJlYSB0ZW1wb3JhcnkgdmFsdWUgKHlBeGlzVGl0bGUuaGVpZ2h0ICsgeEF4aXMuaGVpZ2h0ICsgY2lyY2xlTGVnZW5kLmhlaWdodClcbiAgICByZXR1cm4gdmVydGljYWxBbGlnblxuICAgICAgICA/IHsgd2lkdGg6IGNoYXJ0LndpZHRoIC0gcGFkZGluZy5YICogTlVNQkVSX09GX0JPVEhfU0lERVMsIGhlaWdodDogaXRlbUhlaWdodCB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgd2lkdGg6IGluaXRpYWxXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY2hhcnQuaGVpZ2h0IC0gcmVzdEFyZWFIZWlnaHQsXG4gICAgICAgIH07XG59XG5mdW5jdGlvbiBnZXROZXN0ZWRQaWVMZWdlbmRMYWJlbHNJbmZvKHNlcmllcywgbGVnZW5kSW5mbykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IG1heFRleHRMZW5ndGhXaXRoRWxsaXBzaXMgPSBnZXRNYXhUZXh0TGVuZ3RoV2l0aEVsbGlwc2lzKGxlZ2VuZEluZm8pO1xuICAgIHNlcmllcy5waWUuZm9yRWFjaCgoeyBkYXRhIH0pID0+IHtcbiAgICAgICAgZGF0YS5mb3JFYWNoKCh7IG5hbWUsIHBhcmVudE5hbWUsIHZpc2libGUgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwYXJlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgdmlld0xhYmVsIH0gPSBnZXRWaWV3TGFiZWxJbmZvKGxlZ2VuZEluZm8sIG5hbWUsIG1heFRleHRMZW5ndGhXaXRoRWxsaXBzaXMpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwaWUnLFxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiAodmlzaWJsZSAhPT0gbnVsbCAmJiB2aXNpYmxlICE9PSB2b2lkIDAgPyB2aXNpYmxlIDogdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIHZpZXdMYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRNYXhUZXh0TGVuZ3RoV2l0aEVsbGlwc2lzKGxlZ2VuZEluZm8pIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgbGVnZW5kT3B0aW9ucywgZm9udCwgY2hlY2tib3hWaXNpYmxlIH0gPSBsZWdlbmRJbmZvO1xuICAgIGNvbnN0IHdpZHRoID0gKF9iID0gKF9hID0gbGVnZW5kT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLml0ZW0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi53aWR0aDtcbiAgICBpZiAoaXNVbmRlZmluZWQod2lkdGgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hlY2tib3hXaWR0aCA9IGNoZWNrYm94VmlzaWJsZSA/IExFR0VORF9DSEVDS0JPWF9TSVpFICsgTEVHRU5EX01BUkdJTl9YIDogMDtcbiAgICBjb25zdCBpY29uV2lkdGggPSBMRUdFTkRfSUNPTl9TSVpFICsgTEVHRU5EX01BUkdJTl9YO1xuICAgIGNvbnN0IGVsbGlwc2lzRG90V2lkdGggPSBnZXRUZXh0V2lkdGgoRUxMSVBTSVNfRE9UX1RFWFQsIGZvbnQpO1xuICAgIGNvbnN0IHdpZGVzdFRleHRXaWR0aCA9IGdldFRleHRXaWR0aChXSURFU1RfVEVYVCwgZm9udCk7XG4gICAgY29uc3QgbWF4VGV4dENvdW50ID0gTWF0aC5mbG9vcigod2lkdGggLSBlbGxpcHNpc0RvdFdpZHRoIC0gY2hlY2tib3hXaWR0aCAtIGljb25XaWR0aCkgLyB3aWRlc3RUZXh0V2lkdGgpO1xuICAgIHJldHVybiBtYXhUZXh0Q291bnQgPiAwID8gbWF4VGV4dENvdW50IDogMDtcbn1cbmZ1bmN0aW9uIGdldFZpZXdMYWJlbEluZm8obGVnZW5kSW5mbywgbGFiZWwsIG1heFRleHRMZW5ndGgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgY2hlY2tib3hWaXNpYmxlLCB1c2VTcGVjdHJ1bUxlZ2VuZCwgZm9udCwgbGVnZW5kT3B0aW9ucyB9ID0gbGVnZW5kSW5mbztcbiAgICBsZXQgdmlld0xhYmVsID0gbGFiZWw7XG4gICAgY29uc3QgaXRlbVdpZHRoID0gKF9iID0gKF9hID0gbGVnZW5kT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLml0ZW0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi53aWR0aDtcbiAgICBjb25zdCBpdGVtV2lkdGhXaXRoRnVsbFRleHQgPSBnZXRJdGVtV2lkdGgodmlld0xhYmVsLCBjaGVja2JveFZpc2libGUsIHVzZVNwZWN0cnVtTGVnZW5kLCBmb250KTtcbiAgICBpZiAoaXNOdW1iZXIoaXRlbVdpZHRoKSAmJiBpc051bWJlcihtYXhUZXh0TGVuZ3RoKSAmJiBpdGVtV2lkdGggPCBpdGVtV2lkdGhXaXRoRnVsbFRleHQpIHtcbiAgICAgICAgdmlld0xhYmVsID0gYCR7bGFiZWwuc2xpY2UoMCwgbWF4VGV4dExlbmd0aCl9JHtFTExJUFNJU19ET1RfVEVYVH1gO1xuICAgIH1cbiAgICByZXR1cm4geyB2aWV3TGFiZWwsIHdpZHRoOiAoaXRlbVdpZHRoICE9PSBudWxsICYmIGl0ZW1XaWR0aCAhPT0gdm9pZCAwID8gaXRlbVdpZHRoIDogaXRlbVdpZHRoV2l0aEZ1bGxUZXh0KSB9O1xufVxuZnVuY3Rpb24gZ2V0TGVnZW5kTGFiZWxzSW5mbyhzZXJpZXMsIGxlZ2VuZEluZm8sIGNhdGVnb3JpZXMpIHtcbiAgICBjb25zdCBtYXhUZXh0TGVuZ3RoV2l0aEVsbGlwc2lzID0gZ2V0TWF4VGV4dExlbmd0aFdpdGhFbGxpcHNpcyhsZWdlbmRJbmZvKTtcbiAgICBsZXQgY29sb3JJbmRleCA9IDA7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNlcmllcykuZmxhdE1hcCgodHlwZSkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbEluZm8gPSBzZXJpZXNbdHlwZV0ubWFwKCh7IG5hbWUsIGNvbG9yVmFsdWUsIHZpc2libGUsIGNvbG9yQnlDYXRlZ29yaWVzIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gY29sb3JWYWx1ZSA/IGNvbG9yVmFsdWUgOiBuYW1lO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudENvbG9ySW5kZXggPSBjb2xvckluZGV4O1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgdmlld0xhYmVsIH0gPSBnZXRWaWV3TGFiZWxJbmZvKGxlZ2VuZEluZm8sIGxhYmVsLCBtYXhUZXh0TGVuZ3RoV2l0aEVsbGlwc2lzKTtcbiAgICAgICAgICAgIGNvbG9ySW5kZXggKz0gY29sb3JCeUNhdGVnb3JpZXMgPyBjYXRlZ29yaWVzLmxlbmd0aCA6IDE7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgY29sb3JCeUNhdGVnb3JpZXM6ICEhY29sb3JCeUNhdGVnb3JpZXMsXG4gICAgICAgICAgICAgICAgY29sb3JJbmRleDogY3VycmVudENvbG9ySW5kZXgsXG4gICAgICAgICAgICAgICAgY2hlY2tlZDogKHZpc2libGUgIT09IG51bGwgJiYgdmlzaWJsZSAhPT0gdm9pZCAwID8gdmlzaWJsZSA6IHRydWUpLFxuICAgICAgICAgICAgICAgIHZpZXdMYWJlbCxcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjb2xvckluZGV4ICs9IHNlcmllc1t0eXBlXS5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gbGFiZWxJbmZvO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0SXRlbVdpZHRoKGxhYmVsLCBjaGVja2JveFZpc2libGUsIHVzZVNwZWN0cnVtTGVnZW5kLCBmb250KSB7XG4gICAgcmV0dXJuICgodXNlU3BlY3RydW1MZWdlbmRcbiAgICAgICAgPyAwXG4gICAgICAgIDogKGNoZWNrYm94VmlzaWJsZSA/IExFR0VORF9DSEVDS0JPWF9TSVpFICsgTEVHRU5EX01BUkdJTl9YIDogMCkgK1xuICAgICAgICAgICAgTEVHRU5EX0lDT05fU0laRSArXG4gICAgICAgICAgICBMRUdFTkRfTUFSR0lOX1gpICsgZ2V0VGV4dFdpZHRoKGxhYmVsLCBmb250KSk7XG59XG5mdW5jdGlvbiBnZXRMZWdlbmREYXRhQXBwbGllZFRoZW1lKGRhdGEsIHNlcmllcykge1xuICAgIGNvbnN0IGNvbG9ycyA9IE9iamVjdC52YWx1ZXMoc2VyaWVzKS5yZWR1Y2UoKGFjYywgY3VyKSA9PiAoY3VyICYmIGN1ci5jb2xvcnMgPyBbLi4uYWNjLCAuLi5jdXIuY29sb3JzXSA6IGFjYyksIFtdKTtcbiAgICBjb25zdCBoYXNDb2xvckJ5Q2F0ZWdvcmllcyA9IGRhdGEuc29tZSgobGVnZW5kKSA9PiBsZWdlbmQuY29sb3JCeUNhdGVnb3JpZXMpO1xuICAgIHJldHVybiBkYXRhLm1hcCgoZGF0dW0sIGlkeCkgPT4ge1xuICAgICAgICBjb25zdCB7IGNvbG9yQnlDYXRlZ29yaWVzLCBjb2xvckluZGV4IH0gPSBkYXR1bTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBoYXNDb2xvckJ5Q2F0ZWdvcmllcyA/IGNvbG9ySW5kZXggfHwgaWR4IDogaWR4O1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXR1bSksIHsgY29sb3I6IGNvbG9yQnlDYXRlZ29yaWVzID8gJyNhYWEnIDogY29sb3JzW2luZGV4ICUgY29sb3JzLmxlbmd0aF0gfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRMZWdlbmRTdGF0ZShvcHRpb25zLCBzZXJpZXMsIGNhdGVnb3JpZXMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcbiAgICBjb25zdCB1c2VTcGVjdHJ1bUxlZ2VuZCA9IChfYyA9IChfYiA9IChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXJpZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi51c2VDb2xvclZhbHVlLCAoX2MgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogISFzZXJpZXMuaGVhdG1hcCkpO1xuICAgIGNvbnN0IHVzZVNjYXR0ZXJDaGFydEljb24gPSAhISgoX2QgPSBzZXJpZXMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zY2F0dGVyKTtcbiAgICBjb25zdCBjaGVja2JveFZpc2libGUgPSB1c2VTcGVjdHJ1bUxlZ2VuZFxuICAgICAgICA/IGZhbHNlXG4gICAgICAgIDogc2hvd0NoZWNrYm94KG9wdGlvbnMpO1xuICAgIGNvbnN0IGRlZmF1bHRUaGVtZSA9IG1ha2VEZWZhdWx0VGhlbWUoc2VyaWVzLCAoX2cgPSAoX2YgPSAoX2UgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UudGhlbWUpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jaGFydCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmZvbnRGYW1pbHkpO1xuICAgIGNvbnN0IGZvbnQgPSBnZXRUaXRsZUZvbnRTdHJpbmcoZGVlcE1lcmdlZENvcHkoZGVmYXVsdFRoZW1lLmxlZ2VuZC5sYWJlbCwgT2JqZWN0LmFzc2lnbih7fSwgKF9qID0gKF9oID0gb3B0aW9ucy50aGVtZSkgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmxlZ2VuZCkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmxhYmVsKSkpO1xuICAgIGNvbnN0IGxlZ2VuZEluZm8gPSB7XG4gICAgICAgIGNoZWNrYm94VmlzaWJsZSxcbiAgICAgICAgZm9udCxcbiAgICAgICAgdXNlU3BlY3RydW1MZWdlbmQsXG4gICAgICAgIGxlZ2VuZE9wdGlvbnM6IG9wdGlvbnMubGVnZW5kLFxuICAgIH07XG4gICAgY29uc3QgbGVnZW5kTGFiZWxzSW5mbyA9IGhhc05lc3RlZFBpZVNlcmllcyhzZXJpZXMpXG4gICAgICAgID8gZ2V0TmVzdGVkUGllTGVnZW5kTGFiZWxzSW5mbyhzZXJpZXMsIGxlZ2VuZEluZm8pXG4gICAgICAgIDogZ2V0TGVnZW5kTGFiZWxzSW5mbyhzZXJpZXMsIGxlZ2VuZEluZm8sIGNhdGVnb3JpZXMpO1xuICAgIGNvbnN0IGRhdGEgPSBsZWdlbmRMYWJlbHNJbmZvLm1hcCgoeyBsYWJlbCwgdHlwZSwgY2hlY2tlZCwgd2lkdGgsIHZpZXdMYWJlbCwgY29sb3JCeUNhdGVnb3JpZXMsIGNvbG9ySW5kZXggfSkgPT4gKHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgY2hlY2tlZCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGljb25UeXBlOiBnZXRJY29uVHlwZSh0eXBlKSxcbiAgICAgICAgY2hhcnRUeXBlOiB0eXBlLFxuICAgICAgICByb3dJbmRleDogMCxcbiAgICAgICAgY29sdW1uSW5kZXg6IDAsXG4gICAgICAgIHZpZXdMYWJlbCxcbiAgICAgICAgY29sb3JCeUNhdGVnb3JpZXMsXG4gICAgICAgIGNvbG9ySW5kZXgsXG4gICAgfSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVNwZWN0cnVtTGVnZW5kLFxuICAgICAgICB1c2VTY2F0dGVyQ2hhcnRJY29uLFxuICAgICAgICBkYXRhLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXROZXh0Q29sdW1uUm93SW5kZXgocGFyYW1zKSB7XG4gICAgY29uc3QgeyB2ZXJ0aWNhbEFsaWduLCBjb2x1bW5Db3VudCwgcm93Q291bnQsIGxlZ2VuZENvdW50IH0gPSBwYXJhbXM7XG4gICAgbGV0IHsgcm93SW5kZXgsIGNvbHVtbkluZGV4IH0gPSBwYXJhbXM7XG4gICAgaWYgKHZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgY29uc3QgbWF4TGVuID0gbGVnZW5kQ291bnQgLyByb3dDb3VudDtcbiAgICAgICAgaWYgKG1heExlbiAtIDEgPiBjb2x1bW5JbmRleCkge1xuICAgICAgICAgICAgY29sdW1uSW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvd0luZGV4ICs9IDE7XG4gICAgICAgICAgICBjb2x1bW5JbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1heExlbiA9IGxlZ2VuZENvdW50IC8gY29sdW1uQ291bnQ7XG4gICAgICAgIGlmIChtYXhMZW4gLSAxID4gcm93SW5kZXgpIHtcbiAgICAgICAgICAgIHJvd0luZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW5JbmRleCArPSAxO1xuICAgICAgICAgICAgcm93SW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbcm93SW5kZXgsIGNvbHVtbkluZGV4XTtcbn1cbmZ1bmN0aW9uIHNldEluZGV4VG9MZWdlbmREYXRhKGxlZ2VuZERhdGEsIHJvd0NvdW50LCBjb2x1bW5Db3VudCwgbGVnZW5kQ291bnQsIHZlcnRpY2FsQWxpZ24pIHtcbiAgICBsZXQgY29sdW1uSW5kZXggPSAwO1xuICAgIGxldCByb3dJbmRleCA9IDA7XG4gICAgbGVnZW5kRGF0YS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICBkYXR1bS5yb3dJbmRleCA9IHJvd0luZGV4O1xuICAgICAgICBkYXR1bS5jb2x1bW5JbmRleCA9IGNvbHVtbkluZGV4O1xuICAgICAgICBbcm93SW5kZXgsIGNvbHVtbkluZGV4XSA9IGdldE5leHRDb2x1bW5Sb3dJbmRleCh7XG4gICAgICAgICAgICByb3dDb3VudCxcbiAgICAgICAgICAgIGNvbHVtbkNvdW50LFxuICAgICAgICAgICAgdmVydGljYWxBbGlnbixcbiAgICAgICAgICAgIGxlZ2VuZENvdW50LFxuICAgICAgICAgICAgcm93SW5kZXgsXG4gICAgICAgICAgICBjb2x1bW5JbmRleCxcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5jb25zdCBsZWdlbmQgPSB7XG4gICAgbmFtZTogJ2xlZ2VuZCcsXG4gICAgc3RhdGU6ICh7IG9wdGlvbnMsIHNlcmllcywgY2F0ZWdvcmllcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWdlbmQ6IGdldExlZ2VuZFN0YXRlKG9wdGlvbnMsIHNlcmllcywgY2F0ZWdvcmllcyksXG4gICAgICAgICAgICBjaXJjbGVMZWdlbmQ6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWN0aW9uOiB7XG4gICAgICAgIGluaXRMZWdlbmRTdGF0ZSh7IHN0YXRlLCBpbml0U3RvcmVTdGF0ZSB9KSB7XG4gICAgICAgICAgICBleHRlbmQoc3RhdGUubGVnZW5kLCBnZXRMZWdlbmRTdGF0ZShpbml0U3RvcmVTdGF0ZS5vcHRpb25zLCBpbml0U3RvcmVTdGF0ZS5zZXJpZXMsIGluaXRTdG9yZVN0YXRlLmNhdGVnb3JpZXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TGVnZW5kTGF5b3V0KHsgc3RhdGUgfSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmxlZ2VuZC51c2VTcGVjdHJ1bUxlZ2VuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goJ3NldFNwZWN0cnVtTGVnZW5kTGF5b3V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCdzZXROb3JtYWxMZWdlbmRMYXlvdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0U3BlY3RydW1MZWdlbmRMYXlvdXQoeyBzdGF0ZSB9KSB7XG4gICAgICAgICAgICBjb25zdCB7IGxlZ2VuZDogeyBkYXRhOiBsZWdlbmREYXRhIH0sIHNlcmllcywgb3B0aW9ucywgY2hhcnQsIHRoZW1lLCB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBhbGlnbiA9IGdldExlZ2VuZEFsaWduKG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgdmlzaWJsZSA9IHNob3dMZWdlbmQob3B0aW9ucywgc2VyaWVzKTtcbiAgICAgICAgICAgIGNvbnN0IHZlcnRpY2FsQWxpZ24gPSBpc1ZlcnRpY2FsQWxpZ24oYWxpZ24pO1xuICAgICAgICAgICAgY29uc3QgbGVnZW5kV2lkdGhzID0gbGVnZW5kRGF0YS5tYXAoKHsgd2lkdGggfSkgPT4gd2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgaXRlbUhlaWdodCA9IGdldExlZ2VuZEl0ZW1IZWlnaHQodGhlbWUubGVnZW5kLmxhYmVsLmZvbnRTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gZ2V0U3BlY3RydW1MZWdlbmRXaWR0aChsZWdlbmRXaWR0aHMsIGNoYXJ0LndpZHRoLCB2ZXJ0aWNhbEFsaWduKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGdldFNwZWN0cnVtTGVnZW5kSGVpZ2h0KGl0ZW1IZWlnaHQsIGNoYXJ0LmhlaWdodCwgdmVydGljYWxBbGlnbik7XG4gICAgICAgICAgICBleHRlbmQoc3RhdGUubGVnZW5kLCB7IHZpc2libGUsIGFsaWduLCB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXROb3JtYWxMZWdlbmRMYXlvdXQoeyBzdGF0ZSwgaW5pdFN0b3JlU3RhdGUgfSkge1xuICAgICAgICAgICAgY29uc3QgeyBsZWdlbmQ6IHsgZGF0YTogbGVnZW5kRGF0YSB9LCBzZXJpZXMsIG9wdGlvbnMsIGNoYXJ0LCB0aGVtZSwgfSA9IHN0YXRlO1xuICAgICAgICAgICAgY29uc3QgYWxpZ24gPSBnZXRMZWdlbmRBbGlnbihvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHZpc2libGUgPSBzaG93TGVnZW5kKG9wdGlvbnMsIHNlcmllcyk7XG4gICAgICAgICAgICBjb25zdCBjaGVja2JveCA9IHNob3dDaGVja2JveChvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxXaWR0aCA9IE1hdGgubWluKGNoYXJ0LndpZHRoIC8gNSwgSU5JVElBTF9MRUdFTkRfV0lEVEgpO1xuICAgICAgICAgICAgY29uc3QgdmVydGljYWxBbGlnbiA9IGlzVmVydGljYWxBbGlnbihhbGlnbik7XG4gICAgICAgICAgICBjb25zdCBpc05lc3RlZFBpZUNoYXJ0ID0gaGFzTmVzdGVkUGllU2VyaWVzKGluaXRTdG9yZVN0YXRlLnNlcmllcyk7XG4gICAgICAgICAgICBjb25zdCBpc1NjYXR0ZXJDaGFydCA9ICEhc2VyaWVzLnNjYXR0ZXI7XG4gICAgICAgICAgICBjb25zdCBpc0J1YmJsZUNoYXJ0ID0gISFzZXJpZXMuYnViYmxlO1xuICAgICAgICAgICAgY29uc3QgY2lyY2xlTGVnZW5kVmlzaWJsZSA9IGlzQnViYmxlQ2hhcnRcbiAgICAgICAgICAgICAgICA/IHNob3dDaXJjbGVMZWdlbmQob3B0aW9ucylcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgbGVnZW5kV2lkdGhzID0gbGVnZW5kRGF0YS5tYXAoKHsgd2lkdGggfSkgPT4gd2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgaXRlbUhlaWdodCA9IGdldExlZ2VuZEl0ZW1IZWlnaHQodGhlbWUubGVnZW5kLmxhYmVsLmZvbnRTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbGVnZW5kV2lkdGgsIGxlZ2VuZEhlaWdodCwgcm93Q291bnQsIGNvbHVtbkNvdW50IH0gPSBjYWxjdWxhdGVMZWdlbmRTaXplKHtcbiAgICAgICAgICAgICAgICBpbml0aWFsV2lkdGgsXG4gICAgICAgICAgICAgICAgbGVnZW5kV2lkdGhzLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgdmVydGljYWxBbGlnbixcbiAgICAgICAgICAgICAgICB2aXNpYmxlLFxuICAgICAgICAgICAgICAgIGNoZWNrYm94LFxuICAgICAgICAgICAgICAgIGNoYXJ0LFxuICAgICAgICAgICAgICAgIGl0ZW1IZWlnaHQsXG4gICAgICAgICAgICAgICAgY2lyY2xlTGVnZW5kVmlzaWJsZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0SW5kZXhUb0xlZ2VuZERhdGEobGVnZW5kRGF0YSwgcm93Q291bnQsIGNvbHVtbkNvdW50LCBsZWdlbmRXaWR0aHMubGVuZ3RoLCB2ZXJ0aWNhbEFsaWduKTtcbiAgICAgICAgICAgIGV4dGVuZChzdGF0ZS5sZWdlbmQsIHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlLFxuICAgICAgICAgICAgICAgIGFsaWduLFxuICAgICAgICAgICAgICAgIHNob3dDaGVja2JveDogY2hlY2tib3gsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGxlZ2VuZFdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogbGVnZW5kSGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaXNCdWJibGVDaGFydCAmJiBjaXJjbGVMZWdlbmRWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgndXBkYXRlQ2lyY2xlTGVnZW5kTGF5b3V0JywgeyBsZWdlbmRXaWR0aCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNOZXN0ZWRQaWVDaGFydCAmJiAhaXNOb0RhdGEoc2VyaWVzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goJ3VwZGF0ZUxlZ2VuZENvbG9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTY2F0dGVyQ2hhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCd1cGRhdGVMZWdlbmRJY29uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUNpcmNsZUxlZ2VuZExheW91dCh7IHN0YXRlIH0sIHsgbGVnZW5kV2lkdGggfSkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBsZWdlbmRXaWR0aCA9PT0gMFxuICAgICAgICAgICAgICAgID8gSU5JVElBTF9DSVJDTEVfTEVHRU5EX1dJRFRIXG4gICAgICAgICAgICAgICAgOiBNYXRoLm1pbihsZWdlbmRXaWR0aCwgSU5JVElBTF9DSVJDTEVfTEVHRU5EX1dJRFRIKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IE1hdGgubWF4KCh3aWR0aCAtIExFR0VORF9NQVJHSU5fWCkgLyAyLCAwKTtcbiAgICAgICAgICAgIGV4dGVuZChzdGF0ZS5jaXJjbGVMZWdlbmQsIHsgdmlzaWJsZTogdHJ1ZSwgd2lkdGgsIHJhZGl1cyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TGVnZW5kQWN0aXZlU3RhdGUoeyBzdGF0ZSB9LCB7IG5hbWUsIGFjdGl2ZSB9KSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEgfSA9IHN0YXRlLmxlZ2VuZDtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gZGF0YS5maW5kKCh7IGxhYmVsIH0pID0+IGxhYmVsID09PSBuYW1lKTtcbiAgICAgICAgICAgIG1vZGVsLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KHN0YXRlLCAnbGVnZW5kJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEFsbExlZ2VuZEFjdGl2ZVN0YXRlKHsgc3RhdGUgfSwgYWN0aXZlKSB7XG4gICAgICAgICAgICBzdGF0ZS5sZWdlbmQuZGF0YS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICAgICAgICAgIGRhdHVtLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoc3RhdGUsICdsZWdlbmQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TGVnZW5kQ2hlY2tlZFN0YXRlKHsgc3RhdGUgfSwgeyBuYW1lLCBjaGVja2VkIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gc3RhdGUubGVnZW5kLmRhdGEuZmluZCgoeyBsYWJlbCB9KSA9PiBsYWJlbCA9PT0gbmFtZSk7XG4gICAgICAgICAgICBtb2RlbC5jaGVja2VkID0gY2hlY2tlZDtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KHN0YXRlLCAnbGVnZW5kJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUxlZ2VuZENvbG9yKHsgc3RhdGUgfSkge1xuICAgICAgICAgICAgY29uc3QgeyBsZWdlbmQ6IGxlZ2VuZERhdGEsIHNlcmllcyB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZ2V0TGVnZW5kRGF0YUFwcGxpZWRUaGVtZShsZWdlbmREYXRhLmRhdGEsIHNlcmllcyk7XG4gICAgICAgICAgICBleHRlbmQoc3RhdGUubGVnZW5kLCB7IGRhdGEgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUxlZ2VuZEljb24oeyBzdGF0ZSB9KSB7XG4gICAgICAgICAgICBjb25zdCB7IGxlZ2VuZDogbGVnZW5kRGF0YSwgc2VyaWVzIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBsZWdlbmREYXRhLmRhdGEucmVkdWNlKChhY2MsIGN1cikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLmNoYXJ0VHlwZSA9PT0gJ3NjYXR0ZXInICYmICgoX2EgPSBzZXJpZXMuc2NhdHRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gc2VyaWVzLnNjYXR0ZXIuZGF0YS5maW5kKCh7IG5hbWUgfSkgPT4gbmFtZSA9PT0gY3VyLmxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWNvblR5cGUgPSBtb2RlbCA/IG1vZGVsLmljb25UeXBlIDogY3VyLmljb25UeXBlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWy4uLmFjYywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjdXIpLCB7IGljb25UeXBlIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5hY2MsIGN1cl07XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICBleHRlbmQoc3RhdGUubGVnZW5kLCB7IGRhdGEgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZU5lc3RlZFBpZUNoYXJ0TGVnZW5kKHsgc3RhdGUgfSkge1xuICAgICAgICAgICAgY29uc3QgeyBsZWdlbmQ6IGxlZ2VuZERhdGEsIG5lc3RlZFBpZVNlcmllcyB9ID0gc3RhdGU7XG4gICAgICAgICAgICBleHRlbmQoc3RhdGUubGVnZW5kLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogZ2V0TGVnZW5kRGF0YUFwcGxpZWRUaGVtZShsZWdlbmREYXRhLmRhdGEsIG5lc3RlZFBpZVNlcmllcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIG9ic2VydmU6IHtcbiAgICAgICAgdXBkYXRlTGVnZW5kTGF5b3V0KCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgnc2V0TGVnZW5kTGF5b3V0Jyk7XG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5leHBvcnQgZGVmYXVsdCBsZWdlbmQ7XG4iLCJmdW5jdGlvbiBmaW5kUm9vdE5hbWUocmF3U2VyaWVzLCBzZXJpZXNJbmRleCwgcGFyZW50TmFtZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgaXRlbSA9IChfYSA9IHJhd1Nlcmllcy5waWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtzZXJpZXNJbmRleF0uZGF0YS5maW5kKCh7IG5hbWUgfSkgPT4gbmFtZSA9PT0gcGFyZW50TmFtZSk7XG4gICAgcmV0dXJuICgoX2IgPSBpdGVtKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGFyZW50TmFtZSkgPyBmaW5kUm9vdE5hbWUocmF3U2VyaWVzLCBzZXJpZXNJbmRleCAtIDEsIGl0ZW0ucGFyZW50TmFtZSkgOiBwYXJlbnROYW1lO1xufVxuY29uc3QgbmVzdGVkUGllU2VyaWVzRGF0YSA9IHtcbiAgICBuYW1lOiAnc2VyaWVzRGF0YScsXG4gICAgc3RhdGU6ICgpID0+ICh7XG4gICAgICAgIG5lc3RlZFBpZVNlcmllczoge30sXG4gICAgfSksXG4gICAgYWN0aW9uOiB7XG4gICAgICAgIHNldE5lc3RlZFBpZVNlcmllc0RhdGEoeyBzdGF0ZSwgaW5pdFN0b3JlU3RhdGUgfSkge1xuICAgICAgICAgICAgY29uc3QgeyB0aGVtZSwgZGlzYWJsZWRTZXJpZXMgfSA9IHN0YXRlO1xuICAgICAgICAgICAgY29uc3QgcmF3U2VyaWVzID0gaW5pdFN0b3JlU3RhdGUuc2VyaWVzO1xuICAgICAgICAgICAgY29uc3QgbmV3U2VyaWVzRGF0YSA9IHt9O1xuICAgICAgICAgICAgY29uc3QgY29sb3JNYXAgPSB7fTtcbiAgICAgICAgICAgIHJhd1Nlcmllcy5waWUuZm9yRWFjaCgoeyBuYW1lOiBhbGlhcywgZGF0YSB9LCBzZXJpZXNJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29sb3JzIH0gPSB0aGVtZS5zZXJpZXMucGllW2FsaWFzXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvckxpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5TZXJpZXNEYXRhID0gZGF0YS5tYXAoKG0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwYXJlbnROYW1lLCBuYW1lOiBkYXRhTmFtZSB9ID0gbTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBwYXJlbnROYW1lICYmIHNlcmllc0luZGV4ID8gY29sb3JNYXBbcGFyZW50TmFtZV0gOiAoX2EgPSBjb2xvcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yTGlzdC5wdXNoKGNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JNYXBbZGF0YU5hbWVdID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvb3RQYXJlbnROYW1lID0gcGFyZW50TmFtZSAmJiBzZXJpZXNJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBmaW5kUm9vdE5hbWUocmF3U2VyaWVzLCBzZXJpZXNJbmRleCAtIDEsIHBhcmVudE5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGRhdGFOYW1lO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyBkYXRhOiBtLmRhdGEsIHJvb3RQYXJlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbmV3U2VyaWVzRGF0YVthbGlhc10gPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG9yaWdpblNlcmllc0RhdGEuZmlsdGVyKCh7IHJvb3RQYXJlbnROYW1lIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhZGlzYWJsZWRTZXJpZXMuaW5jbHVkZXMocm9vdFBhcmVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzOiBjb2xvckxpc3QsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdGUubmVzdGVkUGllU2VyaWVzID0gbmV3U2VyaWVzRGF0YTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goJ3VwZGF0ZU5lc3RlZFBpZUNoYXJ0TGVnZW5kJyk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBvYnNlcnZlOiB7XG4gICAgICAgIHVwZGF0ZU5lc3RlZFBpZVNlcmllc0RhdGEoKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCdzZXROZXN0ZWRQaWVTZXJpZXNEYXRhJyk7XG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5leHBvcnQgZGVmYXVsdCBuZXN0ZWRQaWVTZXJpZXNEYXRhO1xuIiwiaW1wb3J0IHsgZGVlcENvcHksIGRlZXBNZXJnZWRDb3B5IH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmZ1bmN0aW9uIGdldE9wdGlvbnNCeVNpemUoc2l6ZSwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBydWxlcyA9IChfYSA9IG9wdGlvbnMucmVzcG9uc2l2ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJ1bGVzO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJ1bGVzKVxuICAgICAgICA/IHJ1bGVzLnJlZHVjZSgoYWNjLCBjdXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjdXIuY29uZGl0aW9uKHNpemUpID8gZGVlcE1lcmdlZENvcHkoYWNjLCBjdXIub3B0aW9ucykgOiBhY2M7XG4gICAgICAgIH0sIG9wdGlvbnMpXG4gICAgICAgIDogb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGdldFNpemUodXNpbmdDb250YWluZXJTaXplLCBjb250YWluZXJTaXplLCBjaGFydFNpemUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgd2lkdGg6IHVzaW5nQ29udGFpbmVyV2lkdGgsIGhlaWdodDogdXNpbmdDb250YWluZXJIZWlnaHQgfSA9IHVzaW5nQ29udGFpbmVyU2l6ZTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogdXNpbmdDb250YWluZXJXaWR0aCA/IGNvbnRhaW5lclNpemUud2lkdGggOiAoX2EgPSBjaGFydFNpemUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB1c2luZ0NvbnRhaW5lckhlaWdodCA/IGNvbnRhaW5lclNpemUuaGVpZ2h0IDogKF9iID0gY2hhcnRTaXplKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVpZ2h0LFxuICAgIH07XG59XG5jb25zdCBvcHRpb25zRGF0YSA9IHtcbiAgICBuYW1lOiAnb3B0aW9ucycsXG4gICAgc3RhdGU6ICh7IG9wdGlvbnMgfSkgPT4gKHtcbiAgICAgICAgb3JpZ2luYWxPcHRpb25zOiBkZWVwQ29weShvcHRpb25zKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICB9KSxcbiAgICBhY3Rpb246IHtcbiAgICAgICAgc2V0T3B0aW9ucyh7IHN0YXRlIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc3RhdGUuY2hhcnQ7XG4gICAgICAgICAgICBpZiAod2lkdGggPCAwIHx8IGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS5vcHRpb25zID0gZ2V0T3B0aW9uc0J5U2l6ZSh7IHdpZHRoLCBoZWlnaHQgfSwgc3RhdGUub3JpZ2luYWxPcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdE9wdGlvbnMoeyBpbml0U3RvcmVTdGF0ZSwgc3RhdGUgfSwgeyBvcHRpb25zLCBjb250YWluZXJTaXplIH0pIHtcbiAgICAgICAgICAgIGluaXRTdG9yZVN0YXRlLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgc3RhdGUub3JpZ2luYWxPcHRpb25zID0gZGVlcENvcHkob3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCB7IHVzaW5nQ29udGFpbmVyU2l6ZSwgb3JpZ2luYWxPcHRpb25zIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBnZXRTaXplKHVzaW5nQ29udGFpbmVyU2l6ZSwgY29udGFpbmVyU2l6ZSwge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBvcmlnaW5hbE9wdGlvbnMuY2hhcnQud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBvcmlnaW5hbE9wdGlvbnMuY2hhcnQuaGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCdzZXRDaGFydFNpemUnLCBzaXplKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlT3B0aW9ucyh7IHN0YXRlLCBpbml0U3RvcmVTdGF0ZSB9LCB7IG9wdGlvbnMsIGNvbnRhaW5lclNpemUgfSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGluaXRTdG9yZVN0YXRlLm9wdGlvbnMgPSBkZWVwTWVyZ2VkQ29weShpbml0U3RvcmVTdGF0ZS5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHN0YXRlLm9yaWdpbmFsT3B0aW9ucyA9IGRlZXBNZXJnZWRDb3B5KHN0YXRlLm9yaWdpbmFsT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCB7IHVzaW5nQ29udGFpbmVyU2l6ZSwgb3JpZ2luYWxPcHRpb25zIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBnZXRTaXplKHVzaW5nQ29udGFpbmVyU2l6ZSwgY29udGFpbmVyU2l6ZSwge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAoX2EgPSBvcmlnaW5hbE9wdGlvbnMuY2hhcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IChfYiA9IG9yaWdpbmFsT3B0aW9ucy5jaGFydCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgnc2V0Q2hhcnRTaXplJywgc2l6ZSk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCdpbml0VGhlbWVTdGF0ZScpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgb2JzZXJ2ZToge1xuICAgICAgICB1cGRhdGVPcHRpb25zKCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgnc2V0T3B0aW9ucycpO1xuICAgICAgICB9LFxuICAgIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgb3B0aW9uc0RhdGE7XG4iLCJpbXBvcnQgeyBleHRlbmQgfSBmcm9tIFwiLi9zdG9yZVwiO1xuaW1wb3J0IHsgcmdiYSB9IGZyb20gXCIuLi9oZWxwZXJzL2NvbG9yXCI7XG5pbXBvcnQgeyBpc1JhbmdlVmFsdWUgfSBmcm9tIFwiLi4vaGVscGVycy9yYW5nZVwiO1xuaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tIFwiLi4vaGVscGVycy91dGlsc1wiO1xuaW1wb3J0IHsgaXNFeGlzdFBsb3RJZCB9IGZyb20gXCIuLi9oZWxwZXJzL3Bsb3RcIjtcbmZ1bmN0aW9uIGdldE92ZXJsYXBwaW5nUmFuZ2UocmFuZ2VzKSB7XG4gICAgY29uc3Qgb3ZlcmxhcHBpbmdSYW5nZXMgPSByYW5nZXMucmVkdWNlKChhY2MsIHsgcmFuZ2UgfSkgPT4ge1xuICAgICAgICBjb25zdCBbYWNjU3RhcnQsIGFjY0VuZF0gPSBhY2M7XG4gICAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHJhbmdlO1xuICAgICAgICByZXR1cm4gW01hdGgubWluKGFjY1N0YXJ0LCBzdGFydCksIE1hdGgubWF4KGFjY0VuZCwgZW5kKV07XG4gICAgfSwgW051bWJlci5NQVhfU0FGRV9JTlRFR0VSLCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUl0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJhbmdlOiBvdmVybGFwcGluZ1JhbmdlcyxcbiAgICAgICAgY29sb3I6IHJhbmdlc1swXS5jb2xvcixcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2F0ZWdvcnlJbmRleCh2YWx1ZSwgY2F0ZWdvcmllcykge1xuICAgIHJldHVybiBjYXRlZ29yaWVzLmZpbmRJbmRleCgoY2F0ZWdvcnkpID0+IGNhdGVnb3J5ID09PSBTdHJpbmcodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGdldFZhbGlkVmFsdWUodmFsdWUsIGNhdGVnb3JpZXMsIGlzRGF0ZVR5cGUgPSBmYWxzZSkge1xuICAgIGlmIChpc0RhdGVUeXBlKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIobmV3IERhdGUodmFsdWUpKTtcbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZ2V0Q2F0ZWdvcnlJbmRleCh2YWx1ZSwgY2F0ZWdvcmllcyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIG1ha2VQbG90TGluZXMoY2F0ZWdvcmllcywgaXNEYXRlVHlwZSwgcGxvdExpbmVzID0gW10pIHtcbiAgICByZXR1cm4gcGxvdExpbmVzLm1hcCgoeyB2YWx1ZSwgY29sb3IsIG9wYWNpdHkgfSkgPT4gKHtcbiAgICAgICAgdmFsdWU6IGdldFZhbGlkVmFsdWUodmFsdWUsIGNhdGVnb3JpZXMsIGlzRGF0ZVR5cGUpLFxuICAgICAgICBjb2xvcjogcmdiYShjb2xvciwgb3BhY2l0eSksXG4gICAgfSkpO1xufVxuZnVuY3Rpb24gbWFrZVBsb3RCYW5kcyhjYXRlZ29yaWVzLCBpc0RhdGVUeXBlLCBwbG90QmFuZHMgPSBbXSkge1xuICAgIHJldHVybiBwbG90QmFuZHMuZmxhdE1hcCgoeyByYW5nZSwgbWVyZ2VPdmVybGFwcGluZ1JhbmdlcyA9IGZhbHNlLCBjb2xvcjogYmdDb2xvciwgb3BhY2l0eSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gcmdiYShiZ0NvbG9yLCBvcGFjaXR5KTtcbiAgICAgICAgY29uc3QgcmFuZ2VBcnJheSA9IChpc1JhbmdlVmFsdWUocmFuZ2VbMF0pID8gcmFuZ2UgOiBbcmFuZ2VdKTtcbiAgICAgICAgY29uc3QgcmFuZ2VzID0gcmFuZ2VBcnJheS5tYXAoKHJhbmdlRGF0YSkgPT4gKHtcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZURhdGEubWFwKCh2YWx1ZSkgPT4gZ2V0VmFsaWRWYWx1ZSh2YWx1ZSwgY2F0ZWdvcmllcywgaXNEYXRlVHlwZSkpLFxuICAgICAgICAgICAgY29sb3IsXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG1lcmdlT3ZlcmxhcHBpbmdSYW5nZXMgPyBnZXRPdmVybGFwcGluZ1JhbmdlKHJhbmdlcykgOiByYW5nZXM7XG4gICAgfSk7XG59XG5jb25zdCBwbG90ID0ge1xuICAgIG5hbWU6ICdwbG90JyxcbiAgICBzdGF0ZTogKHsgb3B0aW9ucyB9KSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgIHBsb3Q6IHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiAoX2MgPSAoX2IgPSAoX2EgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGxvdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnZpc2libGUsIChfYyAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0cnVlKSksXG4gICAgICAgICAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICAgICAgICAgIGJhbmRzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgYWN0aW9uOiB7XG4gICAgICAgIHNldFBsb3QoeyBzdGF0ZSB9KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICAgICAgY29uc3QgeyBzZXJpZXMsIG9wdGlvbnMgfSA9IHN0YXRlO1xuICAgICAgICAgICAgaWYgKCEoc2VyaWVzLmFyZWEgfHwgc2VyaWVzLmxpbmUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmF3Q2F0ZWdvcmllcyA9IHN0YXRlLnJhd0NhdGVnb3JpZXM7XG4gICAgICAgICAgICBjb25zdCBsaW5lQXJlYU9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBtYWtlUGxvdExpbmVzKHJhd0NhdGVnb3JpZXMsICEhKChfYiA9IChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS54QXhpcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRhdGUpLCAoX2QgPSAoX2MgPSBsaW5lQXJlYU9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wbG90KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGluZXMpO1xuICAgICAgICAgICAgY29uc3QgYmFuZHMgPSBtYWtlUGxvdEJhbmRzKHJhd0NhdGVnb3JpZXMsICEhKChfZiA9IChfZSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS54QXhpcykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmRhdGUpLCAoX2ggPSAoX2cgPSBsaW5lQXJlYU9wdGlvbnMpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wbG90KSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guYmFuZHMpO1xuICAgICAgICAgICAgZXh0ZW5kKHN0YXRlLnBsb3QsIHsgbGluZXMsIGJhbmRzIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhZGRQbG90TGluZSh7IHN0YXRlIH0sIHsgZGF0YSB9KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gKF9jID0gKF9iID0gKF9hID0gc3RhdGUub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBsb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5saW5lcywgKF9jICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdKSk7XG4gICAgICAgICAgICBpZiAoIWlzRXhpc3RQbG90SWQobGluZXMsIGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgndXBkYXRlT3B0aW9ucycsIHsgb3B0aW9uczogeyBwbG90OiB7IGxpbmVzOiBbLi4ubGluZXMsIGRhdGFdIH0gfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkUGxvdEJhbmQoeyBzdGF0ZSB9LCB7IGRhdGEgfSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBiYW5kcyA9IChfYyA9IChfYiA9IChfYSA9IHN0YXRlLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wbG90KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmFuZHMsIChfYyAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXSkpO1xuICAgICAgICAgICAgaWYgKCFpc0V4aXN0UGxvdElkKGJhbmRzLCBkYXRhKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goJ3VwZGF0ZU9wdGlvbnMnLCB7IG9wdGlvbnM6IHsgcGxvdDogeyBiYW5kczogWy4uLmJhbmRzLCBkYXRhXSB9IH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVBsb3RMaW5lKHsgc3RhdGUgfSwgeyBpZCB9KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gKF9jID0gKF9iID0gKF9hID0gc3RhdGUub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBsb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5saW5lcywgKF9jICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdKSkuZmlsdGVyKCh7IGlkOiBsaW5lSWQgfSkgPT4gbGluZUlkICE9PSBpZCk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCd1cGRhdGVPcHRpb25zJywgeyBvcHRpb25zOiB7IHBsb3Q6IHsgbGluZXMgfSB9IH0pO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVQbG90QmFuZCh7IHN0YXRlIH0sIHsgaWQgfSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBiYW5kcyA9IChfYyA9IChfYiA9IChfYSA9IHN0YXRlLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wbG90KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmFuZHMsIChfYyAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXSkpLmZpbHRlcigoeyBpZDogYmFuZElkIH0pID0+IGJhbmRJZCAhPT0gaWQpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgndXBkYXRlT3B0aW9ucycsIHsgb3B0aW9uczogeyBwbG90OiB7IGJhbmRzIH0gfSB9KTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIG9ic2VydmU6IHtcbiAgICAgICAgdXBkYXRlUGxvdCgpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goJ3NldFBsb3QnKTtcbiAgICAgICAgfSxcbiAgICB9LFxufTtcbmV4cG9ydCBkZWZhdWx0IHBsb3Q7XG4iLCJpbXBvcnQgeyBnZXRJbml0QXhpc0ludGVydmFsRGF0YSwgZ2V0TWF4TGFiZWxTaXplLCBpc0xhYmVsQXhpc09uWUF4aXMsIGdldERlZmF1bHRSYWRpYWxBeGlzRGF0YSwgZ2V0UmFkaXVzSW5mbywgfSBmcm9tIFwiLi4vaGVscGVycy9heGVzXCI7XG5pbXBvcnQgeyBtYWtlTGFiZWxzRnJvbUxpbWl0LCBtYWtlVGlja1BpeGVsUG9zaXRpb25zIH0gZnJvbSBcIi4uL2hlbHBlcnMvY2FsY3VsYXRvclwiO1xuaW1wb3J0IHsgZ2V0VGl0bGVGb250U3RyaW5nIH0gZnJvbSBcIi4uL2hlbHBlcnMvc3R5bGVcIjtcbmltcG9ydCB7IERFR1JFRV8zNjAsIERFR1JFRV8wIH0gZnJvbSBcIi4uL2hlbHBlcnMvc2VjdG9yXCI7XG5jb25zdCBZX0xBQkVMX1BBRERJTkcgPSA1O1xuZXhwb3J0IGNvbnN0IFJBRElBTF9MQUJFTF9QQURESU5HID0gMjU7XG5leHBvcnQgdmFyIFJhZGlhbEF4aXNUeXBlO1xuKGZ1bmN0aW9uIChSYWRpYWxBeGlzVHlwZSkge1xuICAgIFJhZGlhbEF4aXNUeXBlW1wiQ0lSQ1VMQVJcIl0gPSBcImNpcmN1bGFyQXhpc1wiO1xuICAgIFJhZGlhbEF4aXNUeXBlW1wiVkVSVElDQUxcIl0gPSBcInZlcnRpY2FsQXhpc1wiO1xufSkoUmFkaWFsQXhpc1R5cGUgfHwgKFJhZGlhbEF4aXNUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldFlBeGlzTGFiZWxBbGlnbihjbG9ja3dpc2UgPSB0cnVlLCBpc0xhYmVsT25WZXJ0aWNhbEF4aXMgPSBmYWxzZSkge1xuICAgIGxldCBhbGlnbiA9ICdjZW50ZXInO1xuICAgIGlmIChpc0xhYmVsT25WZXJ0aWNhbEF4aXMpIHtcbiAgICAgICAgYWxpZ24gPSBjbG9ja3dpc2UgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgIH1cbiAgICByZXR1cm4gYWxpZ247XG59XG5mdW5jdGlvbiBnZXRWZXJ0aWNhbEF4aXNEYXRhKHsgbGFiZWxzLCBwb2ludE9uQ29sdW1uLCBpbnRlcnZhbERhdGEsIGlzTGFiZWxPblZlcnRpY2FsQXhpcywgdmVydGljYWxBeGlzTGFiZWxNYXJnaW4sIHZlcnRpY2FsQXhpc0xhYmVsRm9udCwgZGVmYXVsdEF4aXNEYXRhLCByYWRpdXNEYXRhLCB9KSB7XG4gICAgY29uc3QgeyBjbG9ja3dpc2UsIGF4aXNTaXplLCBjZW50ZXJYLCBjZW50ZXJZLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSB9ID0gZGVmYXVsdEF4aXNEYXRhO1xuICAgIGNvbnN0IHsgcmFkaXVzUmFuZ2VzLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHJhZGl1c0RhdGE7XG4gICAgY29uc3QgeyBsYWJlbEludGVydmFsIH0gPSBpbnRlcnZhbERhdGE7XG4gICAgLypcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWxzLFxuICAgICAgdGlja0Rpc3RhbmNlOiAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyBsYWJlbHMubGVuZ3RoLFxuICAgICAgLi4ucGljayhkZWZhdWx0QXhpc0RhdGEsICdheGlzU2l6ZScsICdjZW50ZXJYJywgJ2NlbnRlclknLCAnc3RhcnRBbmdsZScsICdlbmRBbmdsZScpLFxuICAgICAgcG9pbnRPbkNvbHVtbixcbiAgICAgIHJhZGl1c1JhbmdlcyxcbiAgICAgIGlubmVyUmFkaXVzLFxuICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICBsYWJlbEludGVydmFsLFxuICAgICAgbGFiZWxNYXJnaW46IHZlcnRpY2FsQXhpc0xhYmVsTWFyZ2luLFxuICAgICAgbGFiZWxBbGlnbjogZ2V0WUF4aXNMYWJlbEFsaWduKGNsb2Nrd2lzZSwgaXNMYWJlbE9uVmVydGljYWxBeGlzKSxcbiAgICAgIC4uLmdldE1heExhYmVsU2l6ZShsYWJlbHMsIHZlcnRpY2FsQXhpc0xhYmVsTWFyZ2luLCB2ZXJ0aWNhbEF4aXNMYWJlbEZvbnQpLFxuICAgIH07XG4gICAgKi9cbiAgICBjb25zdCB7IG1heExhYmVsV2lkdGgsIG1heExhYmVsSGVpZ2h0IH0gPSBnZXRNYXhMYWJlbFNpemUobGFiZWxzLCB2ZXJ0aWNhbEF4aXNMYWJlbE1hcmdpbiwgdmVydGljYWxBeGlzTGFiZWxGb250KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBheGlzU2l6ZSxcbiAgICAgICAgY2VudGVyWCxcbiAgICAgICAgY2VudGVyWSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIGxhYmVscyxcbiAgICAgICAgICAgIGludGVydmFsOiBsYWJlbEludGVydmFsLFxuICAgICAgICAgICAgbWFyZ2luOiB2ZXJ0aWNhbEF4aXNMYWJlbE1hcmdpbixcbiAgICAgICAgICAgIG1heFdpZHRoOiBtYXhMYWJlbFdpZHRoLFxuICAgICAgICAgICAgbWF4SGVpZ2h0OiBtYXhMYWJlbEhlaWdodCxcbiAgICAgICAgICAgIGFsaWduOiBnZXRZQXhpc0xhYmVsQWxpZ24oY2xvY2t3aXNlLCBpc0xhYmVsT25WZXJ0aWNhbEF4aXMpLFxuICAgICAgICB9LFxuICAgICAgICByYWRpdXM6IHtcbiAgICAgICAgICAgIGlubmVyOiBpbm5lclJhZGl1cyxcbiAgICAgICAgICAgIG91dGVyOiBvdXRlclJhZGl1cyxcbiAgICAgICAgICAgIHJhbmdlczogcmFkaXVzUmFuZ2VzLFxuICAgICAgICB9LFxuICAgICAgICBhbmdsZToge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0QW5nbGUsXG4gICAgICAgICAgICBlbmQ6IGVuZEFuZ2xlLFxuICAgICAgICB9LFxuICAgICAgICB0aWNrRGlzdGFuY2U6IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIGxhYmVscy5sZW5ndGgsXG4gICAgICAgIHBvaW50T25Db2x1bW4sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldENpcmN1bGFyQXhpc0RhdGEoeyBsYWJlbHMsIGludGVydmFsRGF0YSwgY2lyY3VsYXJBeGlzTGFiZWxNYXJnaW4sIGNpcmN1bGFyQXhpc0xhYmVsRm9udCwgZGVmYXVsdEF4aXNEYXRhLCByYWRpdXNEYXRhLCB9KSB7XG4gICAgY29uc3QgeyBtYXhMYWJlbFdpZHRoLCBtYXhMYWJlbEhlaWdodCB9ID0gZ2V0TWF4TGFiZWxTaXplKGxhYmVscywgY2lyY3VsYXJBeGlzTGFiZWxNYXJnaW4sIGNpcmN1bGFyQXhpc0xhYmVsRm9udCk7XG4gICAgY29uc3QgeyB0b3RhbEFuZ2xlLCBjbG9ja3dpc2UsIGF4aXNTaXplLCBjZW50ZXJYLCBjZW50ZXJZLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZHJhd2luZ1N0YXJ0QW5nbGUsIH0gPSBkZWZhdWx0QXhpc0RhdGE7XG4gICAgY29uc3QgeyB0aWNrSW50ZXJ2YWwsIGxhYmVsSW50ZXJ2YWwgfSA9IGludGVydmFsRGF0YTtcbiAgICBjb25zdCB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gcmFkaXVzRGF0YTtcbiAgICBjb25zdCBjZW50cmFsQW5nbGUgPSB0b3RhbEFuZ2xlIC8gKGxhYmVscy5sZW5ndGggKyAodG90YWxBbmdsZSA8IERFR1JFRV8zNjAgPyAtMSA6IERFR1JFRV8wKSk7XG4gICAgLypcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWxzLFxuICAgICAgLi4uZGVmYXVsdEF4aXNEYXRhLFxuICAgICAgY2VudHJhbEFuZ2xlLFxuICAgICAgdGlja0ludGVydmFsLFxuICAgICAgbGFiZWxJbnRlcnZhbCxcbiAgICAgIGxhYmVsTWFyZ2luOiBjaXJjdWxhckF4aXNMYWJlbE1hcmdpbixcbiAgICAgIG1heExhYmVsV2lkdGgsXG4gICAgICBtYXhMYWJlbEhlaWdodCxcbiAgICAgIGlubmVyUmFkaXVzLFxuICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgfTtcbiAgICAqL1xuICAgIHJldHVybiB7XG4gICAgICAgIGF4aXNTaXplLFxuICAgICAgICBjZW50ZXJYLFxuICAgICAgICBjZW50ZXJZLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgbGFiZWxzLFxuICAgICAgICAgICAgaW50ZXJ2YWw6IGxhYmVsSW50ZXJ2YWwsXG4gICAgICAgICAgICBtYXJnaW46IGNpcmN1bGFyQXhpc0xhYmVsTWFyZ2luLFxuICAgICAgICAgICAgbWF4V2lkdGg6IG1heExhYmVsV2lkdGgsXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IG1heExhYmVsSGVpZ2h0LFxuICAgICAgICB9LFxuICAgICAgICByYWRpdXM6IHtcbiAgICAgICAgICAgIGlubmVyOiBpbm5lclJhZGl1cyxcbiAgICAgICAgICAgIG91dGVyOiBvdXRlclJhZGl1cyxcbiAgICAgICAgfSxcbiAgICAgICAgYW5nbGU6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgZW5kOiBlbmRBbmdsZSxcbiAgICAgICAgICAgIHRvdGFsOiB0b3RhbEFuZ2xlLFxuICAgICAgICAgICAgY2VudHJhbDogY2VudHJhbEFuZ2xlLFxuICAgICAgICAgICAgZHJhd2luZ1N0YXJ0OiBkcmF3aW5nU3RhcnRBbmdsZSxcbiAgICAgICAgfSxcbiAgICAgICAgdGlja0ludGVydmFsLFxuICAgICAgICBjbG9ja3dpc2UsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VMYWJlbHMob3B0aW9ucywgcmF3TGFiZWxzLCBheGlzTmFtZSkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IChfYyA9IChfYiA9IChfYSA9IG9wdGlvbnNbYXhpc05hbWVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFiZWwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mb3JtYXR0ZXIsIChfYyAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoKHZhbHVlKSA9PiB2YWx1ZSkpKTtcbiAgICByZXR1cm4gcmF3TGFiZWxzLm1hcCgobGFiZWwsIGluZGV4KSA9PiBmb3JtYXR0ZXIobGFiZWwsIHsgaW5kZXgsIGxhYmVsczogcmF3TGFiZWxzLCBheGlzTmFtZSB9KSk7XG59XG5mdW5jdGlvbiBnZXRBeGlzTGFiZWxzKGlzTGFiZWxPblZlcnRpY2FsQXhpcywgb3B0aW9ucywgY2F0ZWdvcmllcywgc2NhbGUpIHtcbiAgICBjb25zdCB2YWx1ZUF4aXNOYW1lID0gaXNMYWJlbE9uVmVydGljYWxBeGlzXG4gICAgICAgID8gUmFkaWFsQXhpc1R5cGUuQ0lSQ1VMQVJcbiAgICAgICAgOiBSYWRpYWxBeGlzVHlwZS5WRVJUSUNBTDtcbiAgICBjb25zdCB7IGxpbWl0LCBzdGVwU2l6ZSB9ID0gc2NhbGVbdmFsdWVBeGlzTmFtZV07XG4gICAgY29uc3QgdmFsdWVMYWJlbHMgPSBtYWtlTGFiZWxzKG9wdGlvbnMsIG1ha2VMYWJlbHNGcm9tTGltaXQobGltaXQsIHN0ZXBTaXplKSwgdmFsdWVBeGlzTmFtZSk7XG4gICAgY29uc3QgY2F0ZWdvcnlMYWJlbHMgPSBtYWtlTGFiZWxzKG9wdGlvbnMsIGNhdGVnb3JpZXMsIGlzTGFiZWxPblZlcnRpY2FsQXhpcyA/IFJhZGlhbEF4aXNUeXBlLlZFUlRJQ0FMIDogUmFkaWFsQXhpc1R5cGUuQ0lSQ1VMQVIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJhZGlhbEF4aXNMYWJlbHM6IGlzTGFiZWxPblZlcnRpY2FsQXhpcyA/IHZhbHVlTGFiZWxzIDogY2F0ZWdvcnlMYWJlbHMsXG4gICAgICAgIHlBeGlzTGFiZWxzOiBpc0xhYmVsT25WZXJ0aWNhbEF4aXMgPyBjYXRlZ29yeUxhYmVscyA6IHZhbHVlTGFiZWxzLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRBeGlzTGFiZWxNYXJnaW4oaXNMYWJlbE9uVmVydGljYWxBeGlzLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJ0aWNhbEF4aXNMYWJlbE1hcmdpbjogKF9kID0gKF9jID0gKF9iID0gKF9hID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZlcnRpY2FsQXhpcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxhYmVsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubWFyZ2luLCAoX2QgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogKGlzTGFiZWxPblZlcnRpY2FsQXhpcyA/IFlfTEFCRUxfUEFERElORyA6IDApKSksXG4gICAgICAgIGNpcmN1bGFyQXhpc0xhYmVsTWFyZ2luOiAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2lyY3VsYXJBeGlzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YubGFiZWwpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5tYXJnaW4sIChfaCAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBSQURJQUxfTEFCRUxfUEFERElORykpLFxuICAgIH07XG59XG5jb25zdCBheGVzID0ge1xuICAgIG5hbWU6ICdyYWRpYWxBeGVzJyxcbiAgICBzdGF0ZTogKCkgPT4gKHtcbiAgICAgICAgcmFkaWFsQXhlczoge30sXG4gICAgfSksXG4gICAgYWN0aW9uOiB7XG4gICAgICAgIHNldFJhZGlhbEF4ZXNEYXRhKHsgc3RhdGUgfSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VyaWVzLCBsYXlvdXQsIHNjYWxlIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBzdGF0ZS5jYXRlZ29yaWVzO1xuICAgICAgICAgICAgY29uc3QgeyBwbG90IH0gPSBsYXlvdXQ7XG4gICAgICAgICAgICBjb25zdCBpc0xhYmVsT25WZXJ0aWNhbEF4aXMgPSBpc0xhYmVsQXhpc09uWUF4aXMoeyBzZXJpZXMsIGNhdGVnb3JpZXMgfSk7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gc3RhdGUub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHRoZW1lID0gc3RhdGUudGhlbWU7XG4gICAgICAgICAgICBjb25zdCBjaXJjdWxhckF4aXNMYWJlbEZvbnQgPSBnZXRUaXRsZUZvbnRTdHJpbmcodGhlbWUuY2lyY3VsYXJBeGlzLmxhYmVsKTtcbiAgICAgICAgICAgIGNvbnN0IHZlcnRpY2FsQXhpc0xhYmVsRm9udCA9IGdldFRpdGxlRm9udFN0cmluZyh0aGVtZS52ZXJ0aWNhbEF4aXMubGFiZWwpO1xuICAgICAgICAgICAgY29uc3QgeyB2ZXJ0aWNhbEF4aXNMYWJlbE1hcmdpbiwgY2lyY3VsYXJBeGlzTGFiZWxNYXJnaW4gfSA9IGdldEF4aXNMYWJlbE1hcmdpbihpc0xhYmVsT25WZXJ0aWNhbEF4aXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgeyByYWRpYWxBeGlzTGFiZWxzLCB5QXhpc0xhYmVscyB9ID0gZ2V0QXhpc0xhYmVscyhpc0xhYmVsT25WZXJ0aWNhbEF4aXMsIG9wdGlvbnMsIGNhdGVnb3JpZXMsIHNjYWxlKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbWF4TGFiZWxXaWR0aCwgbWF4TGFiZWxIZWlnaHQgfSA9IGdldE1heExhYmVsU2l6ZShyYWRpYWxBeGlzTGFiZWxzLCBjaXJjdWxhckF4aXNMYWJlbE1hcmdpbiwgY2lyY3VsYXJBeGlzTGFiZWxGb250KTtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRBeGlzRGF0YSA9IGdldERlZmF1bHRSYWRpYWxBeGlzRGF0YShvcHRpb25zLCBwbG90LCBtYXhMYWJlbFdpZHRoLCBtYXhMYWJlbEhlaWdodCArIGNpcmN1bGFyQXhpc0xhYmVsTWFyZ2luLCBpc0xhYmVsT25WZXJ0aWNhbEF4aXMpO1xuICAgICAgICAgICAgY29uc3QgeyBheGlzU2l6ZSB9ID0gZGVmYXVsdEF4aXNEYXRhO1xuICAgICAgICAgICAgY29uc3QgcmFkaXVzRGF0YSA9IGlzTGFiZWxPblZlcnRpY2FsQXhpc1xuICAgICAgICAgICAgICAgID8gZ2V0UmFkaXVzSW5mbyhheGlzU2l6ZSwgKF9iID0gKF9hID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlcmllcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJhZGl1c1JhbmdlLCB5QXhpc0xhYmVscy5sZW5ndGggKyAxKVxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICByYWRpdXNSYW5nZXM6IG1ha2VUaWNrUGl4ZWxQb3NpdGlvbnMoYXhpc1NpemUsIHlBeGlzTGFiZWxzLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIGlubmVyUmFkaXVzOiAwLFxuICAgICAgICAgICAgICAgICAgICBvdXRlclJhZGl1czogYXhpc1NpemUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHZlcnRpY2FsQXhpc0RhdGEgPSBnZXRWZXJ0aWNhbEF4aXNEYXRhKHtcbiAgICAgICAgICAgICAgICBsYWJlbHM6IHlBeGlzTGFiZWxzLFxuICAgICAgICAgICAgICAgIHBvaW50T25Db2x1bW46IGlzTGFiZWxPblZlcnRpY2FsQXhpcyxcbiAgICAgICAgICAgICAgICBpc0xhYmVsT25WZXJ0aWNhbEF4aXMsXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWxEYXRhOiBnZXRJbml0QXhpc0ludGVydmFsRGF0YShpc0xhYmVsT25WZXJ0aWNhbEF4aXMsIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpczogb3B0aW9ucy52ZXJ0aWNhbEF4aXMsXG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3JpZXMsXG4gICAgICAgICAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEF4aXNMYWJlbE1hcmdpbixcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEF4aXNMYWJlbEZvbnQsXG4gICAgICAgICAgICAgICAgZGVmYXVsdEF4aXNEYXRhLFxuICAgICAgICAgICAgICAgIHJhZGl1c0RhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YXRlLnJhZGlhbEF4ZXMgPSB7XG4gICAgICAgICAgICAgICAgY2lyY3VsYXJBeGlzOiBnZXRDaXJjdWxhckF4aXNEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxzOiByYWRpYWxBeGlzTGFiZWxzLFxuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbERhdGE6IGdldEluaXRBeGlzSW50ZXJ2YWxEYXRhKHRydWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXM6IG9wdGlvbnMuY2lyY3VsYXJBeGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRBeGlzRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgY2lyY3VsYXJBeGlzTGFiZWxNYXJnaW4sXG4gICAgICAgICAgICAgICAgICAgIGNpcmN1bGFyQXhpc0xhYmVsRm9udCxcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzRGF0YSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEF4aXM6IHZlcnRpY2FsQXhpc0RhdGEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgb2JzZXJ2ZToge1xuICAgICAgICB1cGRhdGVSYWRpYWxBeGVzKCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgnc2V0UmFkaWFsQXhlc0RhdGEnKTtcbiAgICAgICAgfSxcbiAgICB9LFxufTtcbmV4cG9ydCBkZWZhdWx0IGF4ZXM7XG4iLCJpbXBvcnQgeyBpc051bGwsIHBpY2tQcm9wZXJ0eSB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBtZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2VcIjtcbmxldCBjdXJyZW50Q29sbGVjdG9yT2JzZXJ2ZXIgPSBudWxsO1xubGV0IGN1cnJlbnRSdW5uaW5nT2JzZXJ2ZXIgPSBudWxsO1xuY29uc3Qgb2JzZXJ2ZXJDYWxsQ3VlID0gW107XG5sZXQgZG9pbmdJbnZpc2libGVXb3JrID0gZmFsc2U7XG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZShmbikge1xuICAgIGNvbnN0IG9ic2VydmVyID0gKCkgPT4ge1xuICAgICAgICBpZiAoY3VycmVudFJ1bm5pbmdPYnNlcnZlciA9PT0gb2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBvYnNlcnZlciBydW5uaW5nIG9yIGRvaW5nIGludmlzaWJsZSB3b3JrXG4gICAgICAgIGlmIChkb2luZ0ludmlzaWJsZVdvcmsgfHwgIWlzTnVsbChjdXJyZW50UnVubmluZ09ic2VydmVyKSkge1xuICAgICAgICAgICAgaWYgKG9ic2VydmVyQ2FsbEN1ZS5pbmNsdWRlcyhvYnNlcnZlcikpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlckNhbGxDdWUuc3BsaWNlKG9ic2VydmVyQ2FsbEN1ZS5pbmRleE9mKG9ic2VydmVyKSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSB1c2Ugb2JzZXJ2ZXIgY2FsbCBjdWUgYmVjYXVzZSBhdm9pZCBuZXN0ZWQgb2JzZXJ2ZXIgY2FsbC5cbiAgICAgICAgICAgIG9ic2VydmVyQ2FsbEN1ZS5wdXNoKG9ic2VydmVyKTtcbiAgICAgICAgICAgIC8vIG9yIElmIHRoZXJlIGFyZSBubyBvYnNlcnZlcnMgcnVubmluZy4gUnVuIHRoZSBvYnNlcnZlciBhbmQgcnVuIHRoZSBuZXh0IG9ic2VydmVyIGluIHRoZSBjYWxsIHF1ZXVlLlxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTnVsbChjdXJyZW50UnVubmluZ09ic2VydmVyKSkge1xuICAgICAgICAgICAgY3VycmVudFJ1bm5pbmdPYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIGN1cnJlbnRSdW5uaW5nT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICAgICAgZGlnZXN0T2JzZXJ2ZXJDYWxsQ3VlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIG9ic2VydmVyLmRlcHMgPSBbXTtcbiAgICAvLyBmaXJzdCBvYnNlcnZlciBleGN1dGlvbiBmb3IgY29sbGVjdCBkZXBlbmRlbmNpZXNcbiAgICBjdXJyZW50Q29sbGVjdG9yT2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICBjdXJyZW50Q29sbGVjdG9yT2JzZXJ2ZXIoKTtcbiAgICBjdXJyZW50Q29sbGVjdG9yT2JzZXJ2ZXIgPSBudWxsO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIG9ic2VydmVyLmRlcHMuZm9yRWFjaCgoZGVwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGRlcC5maW5kSW5kZXgoKG9iKSA9PiBvYiA9PT0gb2JzZXJ2ZXIpO1xuICAgICAgICAgICAgZGVwLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvYnNlcnZlci5kZXBzID0gW107XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRpZ2VzdE9ic2VydmVyQ2FsbEN1ZSgpIHtcbiAgICBpZiAob2JzZXJ2ZXJDYWxsQ3VlLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBuZXh0T2JzZXJ2ZXIgPSBvYnNlcnZlckNhbGxDdWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKG5leHRPYnNlcnZlcikge1xuICAgICAgICAgICAgbmV4dE9ic2VydmVyKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNPYnNlcnZhYmxlKHRhcmdldCkge1xuICAgIHJldHVybiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJiB0YXJnZXQuX190b2FzdFVJQ2hhcnRPYl9fO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmFibGUodGFyZ2V0LCBzb3VyY2UgPSB0YXJnZXQpIHtcbiAgICBpZiAoaXNPYnNlcnZhYmxlKHNvdXJjZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UuQUxSRUFEWV9PQlNFUlZBQkxFX0VSUk9SKTtcbiAgICB9XG4gICAgaWYgKCFpc09ic2VydmFibGUodGFyZ2V0KSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCAnX190b2FzdFVJQ2hhcnRPYl9fJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2JzID0gW107XG4gICAgICAgIGxldCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSk7XG4gICAgICAgIGNvbnN0IHByZUdldHRlciA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5nZXQ7XG4gICAgICAgIGNvbnN0IHByZVNldHRlciA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5zZXQ7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIHNvbWUga2luZCBhIHRyaWNrIHRvIGdldCBvYnNlcnZhYmxlIGluZm9ybWF0aW9uIGZyb20gY2xvc3VyZSB1c2luZyBnZXR0ZXIgZm9yIG5vdGlmeSgpXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDb2xsZWN0b3JPYnNlcnZlciA9PT0gb2JzZXJ2YWJsZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGFyZ2V0LCBrZXksIHZhbHVlLCBvYnMgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkb2luZ0ludmlzaWJsZVdvcmsgJiZcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbGxlY3Rvck9ic2VydmVyICYmXG4gICAgICAgICAgICAgICAgICAgICFvYnMuaW5jbHVkZXMoY3VycmVudENvbGxlY3Rvck9ic2VydmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBjb2xsZWN0b3Igb2JzZXJ2ZXIgaW4gcnVubmluZywgY29sbGVjdCBjdXJyZW50IGRhdGEgYXMgZGVwZW5kZW5jeVxuICAgICAgICAgICAgICAgICAgICBvYnMucHVzaChjdXJyZW50Q29sbGVjdG9yT2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29sbGVjdG9yT2JzZXJ2ZXIuZGVwcy5wdXNoKG9icyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHByZVNldHRlcikge1xuICAgICAgICAgICAgICAgICAgICBwcmVTZXR0ZXIuY2FsbCh0YXJnZXQsIHYpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByZUdldHRlciA/IHByZUdldHRlci5jYWxsKHRhcmdldCkgOiB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZXZWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUnVuIG9ic2VydmVyc1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VPYnMob2JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRba2V5XSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodGFyZ2V0W2tleV0pKSB7XG4gICAgICAgICAgICBvYnNlcnZhYmxlKHRhcmdldFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldFZhbHVlKHRhcmdldCwga2V5LCBzb3VyY2UpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZSh0YXJnZXQsIHtcbiAgICAgICAgW2tleV06IHNvdXJjZSxcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAoaXNPYnNlcnZhYmxlKHNvdXJjZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UuQUxSRUFEWV9PQlNFUlZBQkxFX0VSUk9SKTtcbiAgICB9XG4gICAgcmV0dXJuIG9ic2VydmFibGUodGFyZ2V0LCBzb3VyY2UpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG5vdGlmeSh0YXJnZXQsIGtleSkge1xuICAgIGNvbnN0IG9iSW5mbyA9IG9ic2VydmFibGVJbmZvKHRhcmdldCwga2V5KTtcbiAgICBpZiAob2JJbmZvKSB7XG4gICAgICAgIGludm9rZU9icyhvYkluZm8ub2JzKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaW52aXNpYmxlV29yayhmbikge1xuICAgIGRvaW5nSW52aXNpYmxlV29yayA9IHRydWU7XG4gICAgZm4oKTtcbiAgICBkb2luZ0ludmlzaWJsZVdvcmsgPSBmYWxzZTtcbiAgICBkaWdlc3RPYnNlcnZlckNhbGxDdWUoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBub3RpZnlCeVBhdGgoaG9sZGVyLCBuYW1lUGF0aCkge1xuICAgIGNvbnN0IHNwbGl0ZWQgPSBuYW1lUGF0aC5zcGxpdCgnLicpO1xuICAgIGNvbnN0IGtleSA9IHNwbGl0ZWQuc3BsaWNlKHNwbGl0ZWQubGVuZ3RoIC0gMSwgMSlbMF07XG4gICAgY29uc3QgdGFyZ2V0ID0gcGlja1Byb3BlcnR5KGhvbGRlciwgc3BsaXRlZCk7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICBub3RpZnkodGFyZ2V0LCBrZXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGludm9rZU9icyhvYnMpIHtcbiAgICBvYnMuZm9yRWFjaCgob2IpID0+IG9iKCkpO1xufVxuZnVuY3Rpb24gb2JzZXJ2YWJsZUluZm8odGFyZ2V0LCBrZXkpIHtcbiAgICBjdXJyZW50Q29sbGVjdG9yT2JzZXJ2ZXIgPSBvYnNlcnZhYmxlSW5mbztcbiAgICBjb25zdCBvYkluZm8gPSB0YXJnZXRba2V5XTtcbiAgICBjdXJyZW50Q29sbGVjdG9yT2JzZXJ2ZXIgPSBudWxsO1xuICAgIGlmICh0eXBlb2Ygb2JJbmZvID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBvYkluZm8uaGFzT3duUHJvcGVydHkoJ3RhcmdldCcpICYmXG4gICAgICAgIG9iSW5mby5oYXNPd25Qcm9wZXJ0eSgnb2JzJykpIHtcbiAgICAgICAgcmV0dXJuIG9iSW5mbztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZWQodGFyZ2V0LCBrZXksIGZuKSB7XG4gICAgbGV0IGNhY2hlZFZhbHVlO1xuICAgIGNvbnN0IGNvbXB1dGVkQm94ID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbXB1dGVkQm94LCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IGNhY2hlZFZhbHVlLFxuICAgIH0pO1xuICAgIGV4dGVuZCh0YXJnZXQsIGNvbXB1dGVkQm94KTtcbiAgICBvYnNlcnZlKCgpID0+IHtcbiAgICAgICAgY29uc3QgcHJldlZhbHVlID0gY2FjaGVkVmFsdWU7XG4gICAgICAgIGNhY2hlZFZhbHVlID0gZm4oKTtcbiAgICAgICAgaWYgKHByZXZWYWx1ZSAhPT0gY2FjaGVkVmFsdWUpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gY2FjaGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3YXRjaChob2xkZXIsIHBhdGgsIGZuKSB7XG4gICAgY29uc3Qgc3BsaXRlZCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICBjb25zdCBrZXkgPSBzcGxpdGVkLnNwbGljZShzcGxpdGVkLmxlbmd0aCAtIDEsIDEpWzBdO1xuICAgIGNvbnN0IHRhcmdldCA9IHBpY2tQcm9wZXJ0eShob2xkZXIsIHNwbGl0ZWQpO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvYkluZm8gPSBvYnNlcnZhYmxlSW5mbyh0YXJnZXQsIGtleSk7XG4gICAgaWYgKCFvYkluZm8pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHdhdGNoZXIgPSAoKSA9PiB7XG4gICAgICAgIGZuKHRhcmdldFtrZXldKTtcbiAgICB9O1xuICAgIG9iSW5mby5vYnMucHVzaCh3YXRjaGVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IG9iSW5mby5vYnMuZmluZEluZGV4KChvYikgPT4gb2IgPT09IHdhdGNoZXIpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgb2JJbmZvLm9icy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYWtlT2JzZXJ2YWJsZU9iamVjdFRvTm9ybWFsKG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufVxuIiwiaW1wb3J0IHsgZ2V0SW5pdGlhbFNpemUsIGlzQXV0b1ZhbHVlIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmZ1bmN0aW9uIGluaXRpYWxTaXplKGNvbnRhaW5lckVsLCB7IHdpZHRoLCBoZWlnaHQgfSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCA9PT0gMCA/IGNvbnRhaW5lckVsLm9mZnNldFdpZHRoIDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ID09PSAwID8gY29udGFpbmVyRWwub2Zmc2V0SGVpZ2h0IDogaGVpZ2h0LFxuICAgIH07XG59XG5jb25zdCByb290ID0ge1xuICAgIG5hbWU6ICdyb290JyxcbiAgICBzdGF0ZTogKHsgb3B0aW9ucyB9KSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgY2hhcnQ6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5jaGFydCksIHsgd2lkdGg6IGdldEluaXRpYWxTaXplKChfYiA9IChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jaGFydCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLndpZHRoKSwgaGVpZ2h0OiBnZXRJbml0aWFsU2l6ZSgoX2QgPSAoX2MgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2hhcnQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5oZWlnaHQpIH0pLFxuICAgICAgICAgICAgdXNpbmdDb250YWluZXJTaXplOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGlzQXV0b1ZhbHVlKChfZiA9IChfZSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jaGFydCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLndpZHRoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGlzQXV0b1ZhbHVlKChfaCA9IChfZyA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5jaGFydCkgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmhlaWdodCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGFpbmVyOiB7fSxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBhY3Rpb246IHtcbiAgICAgICAgc2V0Q2hhcnRTaXplKHsgc3RhdGUgfSwgc2l6ZSkge1xuICAgICAgICAgICAgc3RhdGUuY2hhcnQud2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICAgICAgc3RhdGUuY2hhcnQuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeShzdGF0ZSwgJ2NoYXJ0Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRDaGFydFNpemUoeyBzdGF0ZSB9LCBjb250YWluZXJFbCkge1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBzdGF0ZS5jaGFydDtcbiAgICAgICAgICAgIGlmICh3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyRWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCdzZXRDaGFydFNpemUnLCBpbml0aWFsU2l6ZShjb250YWluZXJFbCwgeyB3aWR0aCwgaGVpZ2h0IH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgnc2V0Q2hhcnRTaXplJywgaW5pdGlhbFNpemUoY29udGFpbmVyRWwsIHsgd2lkdGgsIGhlaWdodCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0VXNpbmdDb250YWluZXJTaXplKHsgc3RhdGUgfSwgeyB3aWR0aCwgaGVpZ2h0IH0pIHtcbiAgICAgICAgICAgIHN0YXRlLnVzaW5nQ29udGFpbmVyU2l6ZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgc3RhdGUudXNpbmdDb250YWluZXJTaXplLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfSxcbiAgICB9LFxufTtcbmV4cG9ydCBkZWZhdWx0IHJvb3Q7XG4iLCJpbXBvcnQgeyBnZXRBeGlzTmFtZSwgZ2V0U2l6ZUtleSwgaXNMYWJlbEF4aXNPbllBeGlzLCBnZXRZQXhpc09wdGlvbiwgZ2V0VmFsdWVBeGlzTmFtZXMsIGlzU2VyaWVzVXNpbmdSYWRpYWxBeGVzLCB9IGZyb20gXCIuLi9oZWxwZXJzL2F4ZXNcIjtcbmltcG9ydCB7IGNhbGN1bGF0ZUNvb3JkaW5hdGVTY2FsZSwgY2FsY3VsYXRlWEF4aXNTY2FsZUZvckNvb3JkaW5hdGVMaW5lVHlwZSwgZ2V0U3RhY2tTY2FsZURhdGEsIH0gZnJvbSBcIi4uL3NjYWxlL2Nvb3JkaW5hdGVTY2FsZUNhbGN1bGF0b3JcIjtcbmltcG9ydCB7IGNhbGN1bGF0ZURhdGV0aW1lU2NhbGUgfSBmcm9tIFwiLi4vc2NhbGUvZGF0ZXRpbWVTY2FsZUNhbGN1bGF0b3JcIjtcbmltcG9ydCB7IGlzQ29vcmRpbmF0ZVNlcmllcyB9IGZyb20gXCIuLi9oZWxwZXJzL2Nvb3JkaW5hdGVcIjtcbmltcG9ydCB7IGhhc1BlcmNlbnRTdGFja1NlcmllcyB9IGZyb20gXCIuL3N0YWNrU2VyaWVzRGF0YVwiO1xuaW1wb3J0IHsgaXNFeGlzdCB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5jb25zdCBNSU5fT0ZGU0VUX1NJWkUgPSAxO1xuZnVuY3Rpb24gZ2V0TGFiZWxTY2FsZURhdGEoc3RhdGUsIGxhYmVsQXhpc09uWUF4aXMsIHNjYWxlT3B0aW9ucywgbGFiZWxBeGlzTmFtZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyBkYXRhUmFuZ2UsIGxheW91dCwgc2VyaWVzLCBvcHRpb25zIH0gPSBzdGF0ZTtcbiAgICBjb25zdCBjYXRlZ29yaWVzID0gc3RhdGUuY2F0ZWdvcmllcztcbiAgICBjb25zdCByYXdDYXRlZ29yaWVzID0gc3RhdGUucmF3Q2F0ZWdvcmllcztcbiAgICBjb25zdCB7IGxhYmVsU2l6ZUtleSB9ID0gZ2V0U2l6ZUtleShsYWJlbEF4aXNPbllBeGlzKTtcbiAgICBjb25zdCBkYXRlVHlwZUxhYmVsID0gaXNFeGlzdCgoX2EgPSBvcHRpb25zLnhBeGlzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0ZSk7XG4gICAgY29uc3QgbGFiZWxPcHRpb25zID0ge1xuICAgICAgICBkYXRhUmFuZ2U6IGRhdGFSYW5nZVtsYWJlbEF4aXNOYW1lXSxcbiAgICAgICAgb2Zmc2V0U2l6ZTogTWF0aC5tYXgobGF5b3V0LnBsb3RbbGFiZWxTaXplS2V5XSwgTUlOX09GRlNFVF9TSVpFKSxcbiAgICAgICAgc2NhbGVPcHRpb246IHNjYWxlT3B0aW9uc1tsYWJlbEF4aXNOYW1lXSxcbiAgICAgICAgcmF3Q2F0ZWdvcmllc1NpemU6IHJhd0NhdGVnb3JpZXMubGVuZ3RoLFxuICAgIH07XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoZGF0YVJhbmdlW2xhYmVsQXhpc05hbWVdKSB7XG4gICAgICAgIHJlc3VsdCA9IGRhdGVUeXBlTGFiZWxcbiAgICAgICAgICAgID8gY2FsY3VsYXRlRGF0ZXRpbWVTY2FsZShsYWJlbE9wdGlvbnMpXG4gICAgICAgICAgICA6IGNhbGN1bGF0ZUNvb3JkaW5hdGVTY2FsZShsYWJlbE9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoc2VyaWVzLmxpbmUgJiYgY2F0ZWdvcmllcyAmJiAhKChfYiA9IG9wdGlvbnMueEF4aXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wb2ludE9uQ29sdW1uKSkge1xuICAgICAgICByZXN1bHQgPSBjYWxjdWxhdGVYQXhpc1NjYWxlRm9yQ29vcmRpbmF0ZUxpbmVUeXBlKHJlc3VsdCwgb3B0aW9ucywgY2F0ZWdvcmllcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZVNjYWxlRGF0YShzdGF0ZSwgbGFiZWxBeGlzT25ZQXhpcywgc2NhbGVPcHRpb25zLCB2YWx1ZUF4aXNOYW1lLCBpc0Nvb3JkaW5hdGVUeXBlQ2hhcnQpIHtcbiAgICBjb25zdCB7IGRhdGFSYW5nZSwgbGF5b3V0LCBzZXJpZXMsIHN0YWNrU2VyaWVzIH0gPSBzdGF0ZTtcbiAgICBjb25zdCB7IHZhbHVlU2l6ZUtleSB9ID0gZ2V0U2l6ZUtleShsYWJlbEF4aXNPbllBeGlzKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChoYXNQZXJjZW50U3RhY2tTZXJpZXMoc3RhY2tTZXJpZXMpKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHNlcmllcykuZm9yRWFjaCgoc2VyaWVzTmFtZSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0ID0gZ2V0U3RhY2tTY2FsZURhdGEoc3RhY2tTZXJpZXNbc2VyaWVzTmFtZV0uc2NhbGVUeXBlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQ29vcmRpbmF0ZVR5cGVDaGFydCkge1xuICAgICAgICBjb25zdCB2YWx1ZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBkYXRhUmFuZ2U6IGRhdGFSYW5nZVt2YWx1ZUF4aXNOYW1lXSxcbiAgICAgICAgICAgIG9mZnNldFNpemU6IE1hdGgubWF4KGxheW91dC5wbG90W3ZhbHVlU2l6ZUtleV0sIE1JTl9PRkZTRVRfU0laRSksXG4gICAgICAgICAgICBzY2FsZU9wdGlvbjogc2NhbGVPcHRpb25zW3ZhbHVlQXhpc05hbWVdLFxuICAgICAgICB9O1xuICAgICAgICByZXN1bHQgPSBjYWxjdWxhdGVDb29yZGluYXRlU2NhbGUodmFsdWVPcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGNhbGN1bGF0ZUNvb3JkaW5hdGVTY2FsZSh7XG4gICAgICAgICAgICBkYXRhUmFuZ2U6IGRhdGFSYW5nZVt2YWx1ZUF4aXNOYW1lXSxcbiAgICAgICAgICAgIG9mZnNldFNpemU6IE1hdGgubWF4KGxheW91dC5wbG90W3ZhbHVlU2l6ZUtleV0sIE1JTl9PRkZTRVRfU0laRSksXG4gICAgICAgICAgICBzY2FsZU9wdGlvbjogc2NhbGVPcHRpb25zW3ZhbHVlQXhpc05hbWVdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFNjYWxlT3B0aW9ucyhvcHRpb25zLCBzZXJpZXMsIHZhbHVlQXhpc05hbWUpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICBjb25zdCBzY2FsZU9wdGlvbnMgPSB7fTtcbiAgICBpZiAoaXNTZXJpZXNVc2luZ1JhZGlhbEF4ZXMoc2VyaWVzKSkge1xuICAgICAgICBzY2FsZU9wdGlvbnNbdmFsdWVBeGlzTmFtZV0gPSAoX2IgPSAoX2EgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbdmFsdWVBeGlzTmFtZV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zY2FsZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgeUF4aXMsIHNlY29uZGFyeVlBeGlzIH0gPSBnZXRZQXhpc09wdGlvbihvcHRpb25zKTtcbiAgICAgICAgc2NhbGVPcHRpb25zLnhBeGlzID0gKF9kID0gKF9jID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnhBeGlzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2NhbGU7XG4gICAgICAgIHNjYWxlT3B0aW9ucy55QXhpcyA9IChfZSA9IHlBeGlzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Uuc2NhbGU7XG4gICAgICAgIGlmIChzZWNvbmRhcnlZQXhpcykge1xuICAgICAgICAgICAgc2NhbGVPcHRpb25zLnNlY29uZGFyeVlBeGlzID0gKF9mID0gc2Vjb25kYXJ5WUF4aXMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5zY2FsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2NhbGVPcHRpb25zO1xufVxuY29uc3Qgc2NhbGUgPSB7XG4gICAgbmFtZTogJ3NjYWxlJyxcbiAgICBzdGF0ZTogKCkgPT4gKHtcbiAgICAgICAgc2NhbGU6IHt9LFxuICAgIH0pLFxuICAgIGFjdGlvbjoge1xuICAgICAgICBzZXRTY2FsZSh7IHN0YXRlLCBpbml0U3RvcmVTdGF0ZSB9KSB7XG4gICAgICAgICAgICBjb25zdCB7IHNlcmllcywgb3B0aW9ucywgY2F0ZWdvcmllcyB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBsYWJlbEF4aXNPbllBeGlzID0gaXNMYWJlbEF4aXNPbllBeGlzKHsgc2VyaWVzLCBvcHRpb25zLCBjYXRlZ29yaWVzIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBsYWJlbEF4aXNOYW1lLCB2YWx1ZUF4aXNOYW1lIH0gPSBnZXRBeGlzTmFtZShsYWJlbEF4aXNPbllBeGlzLCBzZXJpZXMpO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gZ2V0U2NhbGVPcHRpb25zKG9wdGlvbnMsIHNlcmllcywgdmFsdWVBeGlzTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBpc0Nvb3JkaW5hdGVUeXBlQ2hhcnQgPSBpc0Nvb3JkaW5hdGVTZXJpZXMoaW5pdFN0b3JlU3RhdGUuc2VyaWVzKTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlRGF0YSA9IHt9O1xuICAgICAgICAgICAgZ2V0VmFsdWVBeGlzTmFtZXMob3B0aW9ucywgdmFsdWVBeGlzTmFtZSkuZm9yRWFjaCgoYXhpc05hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBzY2FsZURhdGFbYXhpc05hbWVdID0gZ2V0VmFsdWVTY2FsZURhdGEoc3RhdGUsIGxhYmVsQXhpc09uWUF4aXMsIHNjYWxlT3B0aW9ucywgYXhpc05hbWUsIGlzQ29vcmRpbmF0ZVR5cGVDaGFydCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc0Nvb3JkaW5hdGVUeXBlQ2hhcnQpIHtcbiAgICAgICAgICAgICAgICBzY2FsZURhdGFbbGFiZWxBeGlzTmFtZV0gPSBnZXRMYWJlbFNjYWxlRGF0YShzdGF0ZSwgbGFiZWxBeGlzT25ZQXhpcywgc2NhbGVPcHRpb25zLCBsYWJlbEF4aXNOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLnNjYWxlID0gc2NhbGVEYXRhO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgb2JzZXJ2ZToge1xuICAgICAgICB1cGRhdGVTY2FsZSgpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goJ3NldFNjYWxlJyk7XG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5leHBvcnQgZGVmYXVsdCBzY2FsZTtcbiIsImltcG9ydCB7IGRlZXBDb3B5LCBnZXRGaXJzdFZhbGlkVmFsdWUsIGluY2x1ZGVzLCBpc0Jvb2xlYW4sIGlzTnVtYmVyLCBpc1VuZGVmaW5lZCwgcmFuZ2UsIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmltcG9ydCB7IG1ha2VSYXdDYXRlZ29yaWVzIH0gZnJvbSBcIi4vY2F0ZWdvcnlcIjtcbmltcG9ydCB7IGdldENvb3JkaW5hdGVYVmFsdWUsIGlzQ29vcmRpbmF0ZVNlcmllcyB9IGZyb20gXCIuLi9oZWxwZXJzL2Nvb3JkaW5hdGVcIjtcbmltcG9ydCB7IGlzWm9vbWluZyB9IGZyb20gXCIuLi9oZWxwZXJzL3JhbmdlXCI7XG5pbXBvcnQgeyBtZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2VcIjtcbmltcG9ydCB7IGhhc05lc3RlZFBpZVNlcmllcyB9IGZyb20gXCIuLi9oZWxwZXJzL3BpZVNlcmllc1wiO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSBcIi4vc3RvcmVcIjtcbmZ1bmN0aW9uIGluaXRSYW5nZShzZXJpZXMsIGNhdGVnb3JpZXMpIHtcbiAgICBsZXQgcmF3Q2F0ZWdvcmllc0xlbmd0aDtcbiAgICBpZiAoY2F0ZWdvcmllcykge1xuICAgICAgICByYXdDYXRlZ29yaWVzTGVuZ3RoID0gQXJyYXkuaXNBcnJheShjYXRlZ29yaWVzKSA/IGNhdGVnb3JpZXMubGVuZ3RoIDogY2F0ZWdvcmllcy54Lmxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJhd0NhdGVnb3JpZXNMZW5ndGggPSBPYmplY3Qua2V5cyhtYWtlUmF3Q2F0ZWdvcmllcyhzZXJpZXMsIGNhdGVnb3JpZXMpKS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBbMCwgcmF3Q2F0ZWdvcmllc0xlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gaW5pdFNlbGVjdGlvblJhbmdlKHNlcmllcywgb3B0aW9ucywgY2F0ZWdvcmllcykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIShzZXJpZXMubGluZSB8fCBzZXJpZXMuYXJlYSB8fCBzZXJpZXMuY29sdW1uKSB8fFxuICAgICAgICAhKChfYSA9IG9wdGlvbnMuc2VyaWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmFuZ2VTZWxlY3RhYmxlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBpbml0UmFuZ2Uoc2VyaWVzLCBjYXRlZ29yaWVzKTtcbn1cbmZ1bmN0aW9uIGluaXRab29tUmFuZ2Uoc2VyaWVzLCBvcHRpb25zLCBjYXRlZ29yaWVzKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghKHNlcmllcy5saW5lIHx8IHNlcmllcy5hcmVhKSB8fCAhKChfYSA9IG9wdGlvbnMuc2VyaWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euem9vbWFibGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGluaXRSYW5nZShzZXJpZXMsIGNhdGVnb3JpZXMpO1xufVxuZnVuY3Rpb24gaW5pdFNoaWZ0UmFuZ2Uoc2VyaWVzLCBvcHRpb25zLCBjYXRlZ29yaWVzKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghKHNlcmllcy5saW5lIHx8IHNlcmllcy5hcmVhIHx8IHNlcmllcy5jb2x1bW4gfHwgc2VyaWVzLmhlYXRtYXApIHx8XG4gICAgICAgICEoKF9hID0gb3B0aW9ucy5zZXJpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaGlmdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdFJhbmdlKHNlcmllcywgY2F0ZWdvcmllcyk7XG59XG5mdW5jdGlvbiBnZXRDb29yZGluYXRlRGF0YVJhbmdlKGRhdGEsIHJhd0NhdGVnb3JpZXMsIHpvb21SYW5nZSkge1xuICAgIGNvbnN0IFt6b29tU3RhcnQsIHpvb21FbmRdID0gem9vbVJhbmdlO1xuICAgIGxldCBzdGFydCwgZW5kO1xuICAgIHJhbmdlKHpvb21TdGFydCwgem9vbUVuZCArIDEpLmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgY29uc3QgaWR4ID0gZGF0YS5maW5kSW5kZXgoKGRhdHVtKSA9PiBnZXRDb29yZGluYXRlWFZhbHVlKGRhdHVtKS50b1N0cmluZygpID09PSByYXdDYXRlZ29yaWVzW2ldKTtcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChzdGFydCkpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gTWF0aC5tYXgoaWR4LCAoZW5kICE9PSBudWxsICYmIGVuZCAhPT0gdm9pZCAwID8gZW5kIDogMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFtzdGFydCwgZW5kXTtcbn1cbmZ1bmN0aW9uIGdldFNlcmllc0NvbG9ycyhjb2xvcnMsIGNvbG9ySW5kZXgsIHNpemUsIGlzQ29sb3JCeUNhdGVnb3JpZXMpIHtcbiAgICByZXR1cm4gaXNDb2xvckJ5Q2F0ZWdvcmllcyA/IGNvbG9ycy5zbGljZSgwLCBzaXplICsgMSkgOiBjb2xvcnNbY29sb3JJbmRleCAlIGNvbG9ycy5sZW5ndGhdO1xufVxuZnVuY3Rpb24gZ2V0U2VyaWVzRGF0YUluUmFuZ2UoZGF0YSwgcmF3Q2F0ZWdvcmllcywgY2hhcnRUeXBlLCB6b29tUmFuZ2UpIHtcbiAgICBpZiAoIXpvb21SYW5nZSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgbGV0IFtzdGFydElkeCwgZW5kSWR4XSA9IHpvb21SYW5nZTtcbiAgICBjb25zdCBmaXJzdFZhbGlkVmFsdWUgPSBnZXRGaXJzdFZhbGlkVmFsdWUoZGF0YSk7XG4gICAgY29uc3QgaXNDb29yZGluYXRlQ2hhcnQgPSBjaGFydFR5cGUgIT09ICdhcmVhJyAmJiAhaXNVbmRlZmluZWQoZmlyc3RWYWxpZFZhbHVlKSAmJiAhaXNOdW1iZXIoZmlyc3RWYWxpZFZhbHVlKTtcbiAgICBpZiAoaXNDb29yZGluYXRlQ2hhcnQpIHtcbiAgICAgICAgW3N0YXJ0SWR4LCBlbmRJZHhdID0gZ2V0Q29vcmRpbmF0ZURhdGFSYW5nZShkYXRhLCByYXdDYXRlZ29yaWVzLCB6b29tUmFuZ2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhcnRJZHggPSBzdGFydElkeCA+IDEgPyBzdGFydElkeCAtIDEgOiBzdGFydElkeDtcbiAgICAgICAgZW5kSWR4ID0gZW5kSWR4IDwgcmF3Q2F0ZWdvcmllcy5sZW5ndGggLSAxID8gZW5kSWR4ICsgMSA6IGVuZElkeDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEuc2xpY2Uoc3RhcnRJZHgsIGVuZElkeCArIDEpO1xufVxuZnVuY3Rpb24gaXNDb29yZGluYXRlVHlwZVNlcmllcyhzZXJpZXMsIGNoYXJ0VHlwZSkge1xuICAgIHJldHVybiAoaXNDb29yZGluYXRlU2VyaWVzKHNlcmllcykgJiZcbiAgICAgICAgKGlzVW5kZWZpbmVkKGNoYXJ0VHlwZSkgfHwgY2hhcnRUeXBlID09PSAnbGluZScgfHwgY2hhcnRUeXBlID09PSAnc2NhdHRlcicpKTtcbn1cbmZ1bmN0aW9uIGlzU2VyaWVzQWxyZWFkeUV4aXN0KHNlcmllcywgc2VyaWVzTmFtZSwgZGF0YSkge1xuICAgIHJldHVybiBzZXJpZXNbc2VyaWVzTmFtZV0uc29tZSgoeyBsYWJlbCB9KSA9PiBsYWJlbCA9PT0gZGF0YS5uYW1lKTtcbn1cbmZ1bmN0aW9uIGlzVHJlZW1hcFNlcmllc0FscmVhZHlFeGlzdChzZXJpZXMsIGRhdGEpIHtcbiAgICByZXR1cm4gc2VyaWVzLnRyZWVtYXAuc29tZSgoeyBsYWJlbCB9KSA9PiBsYWJlbCA9PT0gZGF0YS5sYWJlbCk7XG59XG5mdW5jdGlvbiBpc0hlYXRtYXBTZXJpZXNBbHJlYWR5RXhpc3QoY2F0ZWdvcmllcywgY2F0ZWdvcnkpIHtcbiAgICByZXR1cm4gaW5jbHVkZXMoY2F0ZWdvcmllcy55LCBjYXRlZ29yeSk7XG59XG5mdW5jdGlvbiBpbml0RGlzYWJsZWRTZXJpZXMoc2VyaWVzKSB7XG4gICAgY29uc3QgbmVzdGVkUGllQ2hhcnQgPSBoYXNOZXN0ZWRQaWVTZXJpZXMoc2VyaWVzKTtcbiAgICBjb25zdCBkaXNhYmxlZFNlcmllcyA9IFtdO1xuICAgIGlmIChuZXN0ZWRQaWVDaGFydCkge1xuICAgICAgICBzZXJpZXMucGllLmZvckVhY2goKHsgZGF0YSB9KSA9PiB7XG4gICAgICAgICAgICBkYXRhLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQm9vbGVhbihkYXR1bS52aXNpYmxlKSAmJiAhZGF0dW0udmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZFNlcmllcy5wdXNoKGRhdHVtLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHNlcmllcykuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICAgICAgc2VyaWVzW3R5cGVdLmZvckVhY2goKHsgbmFtZSwgdmlzaWJsZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQm9vbGVhbih2aXNpYmxlKSAmJiAhdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZFNlcmllcy5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRpc2FibGVkU2VyaWVzO1xufVxuY29uc3Qgc2VyaWVzRGF0YSA9IHtcbiAgICBuYW1lOiAnc2VyaWVzRGF0YScsXG4gICAgc3RhdGU6ICh7IHNlcmllcywgY2F0ZWdvcmllcywgb3B0aW9ucyB9KSA9PiAoe1xuICAgICAgICByYXdDYXRlZ29yaWVzOiBtYWtlUmF3Q2F0ZWdvcmllcyhzZXJpZXMsIGNhdGVnb3JpZXMpLFxuICAgICAgICBzZXJpZXM6IE9iamVjdC5hc3NpZ24oe30sIHNlcmllcyksXG4gICAgICAgIHNlbGVjdGlvblJhbmdlOiBpbml0U2VsZWN0aW9uUmFuZ2Uoc2VyaWVzLCBvcHRpb25zLCBjYXRlZ29yaWVzKSxcbiAgICAgICAgem9vbVJhbmdlOiBpbml0Wm9vbVJhbmdlKHNlcmllcywgb3B0aW9ucywgY2F0ZWdvcmllcyksXG4gICAgICAgIHNoaWZ0UmFuZ2U6IGluaXRTaGlmdFJhbmdlKHNlcmllcywgb3B0aW9ucywgY2F0ZWdvcmllcyksXG4gICAgICAgIGRpc2FibGVkU2VyaWVzOiBpbml0RGlzYWJsZWRTZXJpZXMoc2VyaWVzKSxcbiAgICB9KSxcbiAgICBhY3Rpb246IHtcbiAgICAgICAgc2V0U2VyaWVzRGF0YSh7IHN0YXRlLCBpbml0U3RvcmVTdGF0ZSB9KSB7XG4gICAgICAgICAgICBjb25zdCByYXdTZXJpZXMgPSBkZWVwQ29weShpbml0U3RvcmVTdGF0ZS5zZXJpZXMpO1xuICAgICAgICAgICAgY29uc3QgeyBkaXNhYmxlZFNlcmllcywgdGhlbWUsIHpvb21SYW5nZSwgcmF3Q2F0ZWdvcmllcyB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBuZXdTZXJpZXNEYXRhID0ge307XG4gICAgICAgICAgICBsZXQgY29sb3JJbmRleCA9IDA7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhyYXdTZXJpZXMpLmZvckVhY2goKHNlcmllc05hbWUpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvbG9ycywgaWNvblR5cGVzIH0gPSB0aGVtZS5zZXJpZXNbc2VyaWVzTmFtZV07XG4gICAgICAgICAgICAgICAgbGV0IG9yaWdpblNlcmllc0RhdGEgPSByYXdTZXJpZXNbc2VyaWVzTmFtZV0ubWFwKChzZXJpZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDb2xvckJ5Q2F0ZWdvcmllcyA9ICEhc2VyaWVzLmNvbG9yQnlDYXRlZ29yaWVzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gaXNDb2xvckJ5Q2F0ZWdvcmllcyA/IHJhd0NhdGVnb3JpZXMubGVuZ3RoIDogMTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBjb2xvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZ2V0U2VyaWVzQ29sb3JzKGNvbG9ycywgY29sb3JJbmRleCwgc2l6ZSwgaXNDb2xvckJ5Q2F0ZWdvcmllcylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9ySW5kZXggKz0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VyaWVzKSwgeyByYXdEYXRhOiBzZXJpZXMuZGF0YSwgZGF0YTogZ2V0U2VyaWVzRGF0YUluUmFuZ2Uoc2VyaWVzLmRhdGEsIHJhd0NhdGVnb3JpZXMsIHNlcmllc05hbWUsIHpvb21SYW5nZSksIGNvbG9yIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzZXJpZXNOYW1lID09PSAnc2NhdHRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luU2VyaWVzRGF0YSA9IG9yaWdpblNlcmllc0RhdGEubWFwKChzZXJpZXMsIGlkeCkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VyaWVzKSwgeyBpY29uVHlwZTogaWNvblR5cGVzID8gaWNvblR5cGVzW2lkeF0gOiAnY2lyY2xlJyB9KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzZXJpZXNDb3VudCA9IG9yaWdpblNlcmllc0RhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmllc0dyb3VwQ291bnQgPSAoX2MgPSAoX2IgPSAoX2EgPSBvcmlnaW5TZXJpZXNEYXRhWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxlbmd0aCwgKF9jICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDApKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gb3JpZ2luU2VyaWVzRGF0YS5maWx0ZXIoKHsgbmFtZSB9KSA9PiAhZGlzYWJsZWRTZXJpZXMuaW5jbHVkZXMobmFtZSkpO1xuICAgICAgICAgICAgICAgIG5ld1Nlcmllc0RhdGFbc2VyaWVzTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllc0NvdW50LFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNHcm91cENvdW50LFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcnMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXh0ZW5kKHN0YXRlLnNlcmllcywgbmV3U2VyaWVzRGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc2FibGVTZXJpZXMoeyBzdGF0ZSB9LCBuYW1lKSB7XG4gICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZFNlcmllcy5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoc3RhdGUsICdkaXNhYmxlZFNlcmllcycpO1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNlcmllcy5idWxsZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCdyZW1vdmVDYXRlZ29yeUJ5TmFtZScsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbmFibGVTZXJpZXMoeyBzdGF0ZSB9LCBuYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN0YXRlLmRpc2FibGVkU2VyaWVzLmZpbmRJbmRleCgoZGlzYWJsZWQpID0+IGRpc2FibGVkID09PSBuYW1lKTtcbiAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkU2VyaWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeShzdGF0ZSwgJ2Rpc2FibGVkU2VyaWVzJyk7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2VyaWVzLmJ1bGxldCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmNhdGVnb3JpZXMgPSBzdGF0ZS5zZXJpZXMuYnVsbGV0LmRhdGEubWFwKCh7IG5hbWU6IHNlcmllc05hbWUgfSkgPT4gc2VyaWVzTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoc3RhdGUsICdheGVzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdGlvbih7IHN0YXRlIH0sIHJhbmdlQ2F0ZWdvcmllcykge1xuICAgICAgICAgICAgY29uc3QgcmF3Q2F0ZWdvcmllcyA9IHN0YXRlLnJhd0NhdGVnb3JpZXM7XG4gICAgICAgICAgICBzdGF0ZS5zZWxlY3Rpb25SYW5nZSA9IHJhbmdlQ2F0ZWdvcmllcy5tYXAoKHJhbmdlQ2F0ZWdvcnkpID0+IHJhd0NhdGVnb3JpZXMuZmluZEluZGV4KChjYXRlZ29yeSkgPT4gY2F0ZWdvcnkgPT09IHJhbmdlQ2F0ZWdvcnkpKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KHN0YXRlLCAnc2VsZWN0aW9uUmFuZ2UnKTtcbiAgICAgICAgfSxcbiAgICAgICAgem9vbSh7IHN0YXRlIH0sIHJhbmdlQ2F0ZWdvcmllcykge1xuICAgICAgICAgICAgY29uc3QgcmF3Q2F0ZWdvcmllcyA9IHN0YXRlLnJhd0NhdGVnb3JpZXM7XG4gICAgICAgICAgICBzdGF0ZS56b29tUmFuZ2UgPSByYW5nZUNhdGVnb3JpZXMubWFwKChyYW5nZUNhdGVnb3J5KSA9PiByYXdDYXRlZ29yaWVzLmZpbmRJbmRleCgoY2F0ZWdvcnkpID0+IGNhdGVnb3J5ID09PSByYW5nZUNhdGVnb3J5KSk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeShzdGF0ZSwgJ3pvb21SYW5nZScpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldFpvb20oeyBzdGF0ZSwgaW5pdFN0b3JlU3RhdGUgfSkge1xuICAgICAgICAgICAgY29uc3QgeyBzZXJpZXMsIG9wdGlvbnMgfSA9IGluaXRTdG9yZVN0YXRlO1xuICAgICAgICAgICAgY29uc3QgcmF3Q2F0ZWdvcmllcyA9IHN0YXRlLnJhd0NhdGVnb3JpZXM7XG4gICAgICAgICAgICBzdGF0ZS56b29tUmFuZ2UgPSBpbml0Wm9vbVJhbmdlKHNlcmllcywgb3B0aW9ucywgcmF3Q2F0ZWdvcmllcyk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeShzdGF0ZSwgJ3pvb21SYW5nZScpO1xuICAgICAgICB9LFxuICAgICAgICBhZGREYXRhKHsgc3RhdGUsIGluaXRTdG9yZVN0YXRlIH0sIHsgZGF0YSwgY2F0ZWdvcnksIGNoYXJ0VHlwZSB9KSB7XG4gICAgICAgICAgICBjb25zdCB7IHNlcmllcyB9ID0gaW5pdFN0b3JlU3RhdGU7XG4gICAgICAgICAgICBjb25zdCBjb29yZGluYXRlQ2hhcnQgPSBpc0Nvb3JkaW5hdGVUeXBlU2VyaWVzKHN0YXRlLnNlcmllcywgY2hhcnRUeXBlKTtcbiAgICAgICAgICAgIGxldCB7IGNhdGVnb3JpZXMgfSA9IGluaXRTdG9yZVN0YXRlO1xuICAgICAgICAgICAgY2F0ZWdvcmllcyA9IHNlcmllcy5oZWF0bWFwID8gY2F0ZWdvcmllcy54IDogY2F0ZWdvcmllcztcbiAgICAgICAgICAgIGlmIChjYXRlZ29yeSAmJiBBcnJheS5pc0FycmF5KGNhdGVnb3JpZXMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNFeGlzdCA9IGNhdGVnb3JpZXMuc29tZSgoYykgPT4gYyA9PT0gY2F0ZWdvcnkpO1xuICAgICAgICAgICAgICAgIGlmICghaXNFeGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzLnB1c2goY2F0ZWdvcnkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZS5zaGlmdFJhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gc3RhdGUuc2hpZnRSYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnNoaWZ0UmFuZ2UgPSBbc3RhcnQgKyAxLCBlbmQgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFydFR5cGUpIHtcbiAgICAgICAgICAgICAgICBzZXJpZXNbY2hhcnRUeXBlXS5mb3JFYWNoKChkYXR1bSwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdHVtLmRhdGEucHVzaChkYXRhW2lkeF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3Nlcmllc05hbWVdID0gT2JqZWN0LmtleXMoaW5pdFN0b3JlU3RhdGUuc2VyaWVzKTtcbiAgICAgICAgICAgICAgICBzZXJpZXNbc2VyaWVzTmFtZV0uZm9yRWFjaCgoZGF0dW0sIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkYXR1bS5kYXRhLnB1c2goZGF0YVtpZHhdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubm90aWZ5KHN0YXRlLCAnc2VyaWVzJyk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeShzdGF0ZSwgJ3Jhd0NhdGVnb3JpZXMnKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0YXRlLnpvb21SYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCdyZXNldFpvb20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb29yZGluYXRlQ2hhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCdpbml0Q2F0ZWdvcnknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkU2VyaWVzKHsgc3RhdGUsIGluaXRTdG9yZVN0YXRlIH0sIHsgZGF0YSwgY2hhcnRUeXBlLCBjYXRlZ29yeSwgfSkge1xuICAgICAgICAgICAgY29uc3QgeyBzZXJpZXMsIGNhdGVnb3JpZXMgfSA9IGluaXRTdG9yZVN0YXRlO1xuICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZUNoYXJ0ID0gaXNDb29yZGluYXRlVHlwZVNlcmllcyhzdGF0ZS5zZXJpZXMsIGNoYXJ0VHlwZSk7XG4gICAgICAgICAgICBjb25zdCBzZXJpZXNOYW1lID0gY2hhcnRUeXBlIHx8IE9iamVjdC5rZXlzKHNlcmllcylbMF07XG4gICAgICAgICAgICBjb25zdCBpc0V4aXN0ID0gaXNTZXJpZXNBbHJlYWR5RXhpc3Qoc2VyaWVzLCBzZXJpZXNOYW1lLCBkYXRhKTtcbiAgICAgICAgICAgIGlmICghaXNFeGlzdCkge1xuICAgICAgICAgICAgICAgIHNlcmllc1tzZXJpZXNOYW1lXS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNhdGVnb3JpZXMpICYmIGNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3JpZXMucHVzaChjYXRlZ29yeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgnaW5pdFRoZW1lU3RhdGUnKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goJ2luaXRMZWdlbmRTdGF0ZScpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoc3RhdGUsICdzZXJpZXMnKTtcbiAgICAgICAgICAgIGlmIChjb29yZGluYXRlQ2hhcnQgfHwgc2VyaWVzTmFtZSA9PT0gJ2J1bGxldCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCdpbml0Q2F0ZWdvcnknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkSGVhdG1hcFNlcmllcyh7IHN0YXRlLCBpbml0U3RvcmVTdGF0ZSB9LCB7IGRhdGEsIGNhdGVnb3J5IH0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VyaWVzLCBjYXRlZ29yaWVzIH0gPSBpbml0U3RvcmVTdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGlzRXhpc3QgPSBpc0hlYXRtYXBTZXJpZXNBbHJlYWR5RXhpc3QoY2F0ZWdvcmllcywgY2F0ZWdvcnkpO1xuICAgICAgICAgICAgaWYgKCFpc0V4aXN0KSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzLmhlYXRtYXAucHVzaCh7IGRhdGEsIHlDYXRlZ29yeTogY2F0ZWdvcnkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzRXhpc3QgJiYgY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yaWVzLnkucHVzaChjYXRlZ29yeSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoc3RhdGUsICdyYXdDYXRlZ29yaWVzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5vdGlmeShzdGF0ZSwgJ3NlcmllcycpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgnaW5pdFRoZW1lU3RhdGUnKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goJ2luaXRMZWdlbmRTdGF0ZScpO1xuICAgICAgICB9LFxuICAgICAgICBhZGRUcmVlbWFwU2VyaWVzKHsgc3RhdGUsIGluaXRTdG9yZVN0YXRlIH0sIHsgZGF0YSB9KSB7XG4gICAgICAgICAgICBjb25zdCB7IHNlcmllcyB9ID0gaW5pdFN0b3JlU3RhdGU7XG4gICAgICAgICAgICBjb25zdCBpc0V4aXN0ID0gaXNUcmVlbWFwU2VyaWVzQWxyZWFkeUV4aXN0KHNlcmllcywgZGF0YSk7XG4gICAgICAgICAgICBpZiAoIWlzRXhpc3QpIHtcbiAgICAgICAgICAgICAgICBzZXJpZXMudHJlZW1hcC5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ub3RpZnkoc3RhdGUsICdzZXJpZXMnKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KHN0YXRlLCAndHJlZW1hcFNlcmllcycpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgnaW5pdFRoZW1lU3RhdGUnKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goJ2luaXRMZWdlbmRTdGF0ZScpO1xuICAgICAgICB9LFxuICAgICAgICBzZXREYXRhKHsgc3RhdGUsIGluaXRTdG9yZVN0YXRlIH0sIHsgc2VyaWVzLCBjYXRlZ29yaWVzIH0pIHtcbiAgICAgICAgICAgIGluaXRTdG9yZVN0YXRlLnNlcmllcyA9IHNlcmllcztcbiAgICAgICAgICAgIGNvbnN0IGlzTmVzdGVkUGllQ2hhcnQgPSBoYXNOZXN0ZWRQaWVTZXJpZXMoc2VyaWVzKTtcbiAgICAgICAgICAgIGlmICghaXNOZXN0ZWRQaWVDaGFydCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnJhd0NhdGVnb3JpZXMgPSBtYWtlUmF3Q2F0ZWdvcmllcyhzZXJpZXMsIGNhdGVnb3JpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgnaW5pdFRoZW1lU3RhdGUnKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goJ2luaXRMZWdlbmRTdGF0ZScpO1xuICAgICAgICB9LFxuICAgICAgICBhZGRPdXRsaWVyKHsgc3RhdGUsIGluaXRTdG9yZVN0YXRlIH0sIHsgc2VyaWVzSW5kZXgsIG91dGxpZXJzIH0pIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VyaWVzIH0gPSBpbml0U3RvcmVTdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHNlcmllc1Jhd0RhdGEgPSBzZXJpZXMuYm94UGxvdFtzZXJpZXNJbmRleF07XG4gICAgICAgICAgICBpZiAoIXNlcmllc1Jhd0RhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZS5TRVJJRVNfSU5ERVhfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VyaWVzUmF3RGF0YS5vdXRsaWVycyA9IFsuLi4oX2EgPSBzZXJpZXNSYXdEYXRhLm91dGxpZXJzLCAoX2EgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pKSwgLi4ub3V0bGllcnNdO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoc3RhdGUsICdzZXJpZXMnKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIG9ic2VydmU6IHtcbiAgICAgICAgdXBkYXRlU2VyaWVzRGF0YSgpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goJ3NldFNlcmllc0RhdGEnKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGlzTGluZVR5cGVTZXJpZXNab29taW5nOiAoeyB6b29tUmFuZ2UsIHJhd0NhdGVnb3JpZXMgfSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGlzWm9vbWluZyhyYXdDYXRlZ29yaWVzLCB6b29tUmFuZ2UpO1xuICAgICAgICB9LFxuICAgICAgICB2aWV3UmFuZ2U6ICh7IHpvb21SYW5nZSwgc2hpZnRSYW5nZSB9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gem9vbVJhbmdlIHx8IHNoaWZ0UmFuZ2U7XG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5leHBvcnQgZGVmYXVsdCBzZXJpZXNEYXRhO1xuIiwiaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSBcIi4vc3RvcmVcIjtcbmltcG9ydCB7IHBpY2tQcm9wZXJ0eSwgaXNPYmplY3QsIHN1bSB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5leHBvcnQgZnVuY3Rpb24gaXNQZXJjZW50U3RhY2soc3RhY2spIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICEhKCgoX2EgPSBzdGFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSAncGVyY2VudCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzR3JvdXBTdGFjayhyYXdEYXRhKSB7XG4gICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHJhd0RhdGEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc1BlcmNlbnRTdGFja1NlcmllcyhzdGFja1Nlcmllcykge1xuICAgIGlmICghc3RhY2tTZXJpZXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc3RhY2tTZXJpZXMpLnNvbWUoKHNlcmllc05hbWUpID0+IGlzUGVyY2VudFN0YWNrKHN0YWNrU2VyaWVzW3Nlcmllc05hbWVdLnN0YWNrKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGlja1N0YWNrT3B0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKHBpY2tQcm9wZXJ0eShvcHRpb25zLCBbJ3NlcmllcycsICdzdGFjayddKSB8fFxuICAgICAgICBwaWNrUHJvcGVydHkob3B0aW9ucywgWydzZXJpZXMnLCAnY29sdW1uJywgJ3N0YWNrJ10pIHx8XG4gICAgICAgIHBpY2tQcm9wZXJ0eShvcHRpb25zLCBbJ3NlcmllcycsICdhcmVhJywgJ3N0YWNrJ10pKTtcbn1cbmZ1bmN0aW9uIG1ha2VTdGFja0RhdGEoc2VyaWVzRGF0YSkge1xuICAgIGNvbnN0IHNlcmllc0NvdW50ID0gc2VyaWVzRGF0YS5sZW5ndGg7XG4gICAgY29uc3QgZ3JvdXBDb3VudExlbmd0aHMgPSBzZXJpZXNEYXRhLm1hcCgoeyByYXdEYXRhIH0pID0+IHJhd0RhdGEubGVuZ3RoKTtcbiAgICBjb25zdCBzZXJpZXNHcm91cENvdW50ID0gTWF0aC5tYXgoLi4uZ3JvdXBDb3VudExlbmd0aHMpO1xuICAgIGNvbnN0IHN0YWNrRGF0YSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VyaWVzR3JvdXBDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHN0YWNrVmFsdWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2VyaWVzQ291bnQ7IGogKz0gMSkge1xuICAgICAgICAgICAgc3RhY2tWYWx1ZXMucHVzaChzZXJpZXNEYXRhW2pdLnJhd0RhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrRGF0YVtpXSA9IHtcbiAgICAgICAgICAgIHZhbHVlczogc3RhY2tWYWx1ZXMsXG4gICAgICAgICAgICBzdW06IHN1bShzdGFja1ZhbHVlcyksXG4gICAgICAgICAgICB0b3RhbDoge1xuICAgICAgICAgICAgICAgIHBvc2l0aXZlOiBzdW0oc3RhY2tWYWx1ZXMuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUgPj0gMCkpLFxuICAgICAgICAgICAgICAgIG5lZ2F0aXZlOiBzdW0oc3RhY2tWYWx1ZXMuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUgPCAwKSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2tEYXRhO1xufVxuZnVuY3Rpb24gbWFrZVN0YWNrR3JvdXBEYXRhKHNlcmllc0RhdGEpIHtcbiAgICBjb25zdCBzdGFja0RhdGEgPSB7fTtcbiAgICBjb25zdCBzdGFja0dyb3VwSWRzID0gWy4uLm5ldyBTZXQoc2VyaWVzRGF0YS5tYXAoKHsgc3RhY2tHcm91cCB9KSA9PiBzdGFja0dyb3VwKSldO1xuICAgIHN0YWNrR3JvdXBJZHMuZm9yRWFjaCgoZ3JvdXBJZCkgPT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IHNlcmllc0RhdGEuZmlsdGVyKCh7IHN0YWNrR3JvdXAgfSkgPT4gZ3JvdXBJZCA9PT0gc3RhY2tHcm91cCk7XG4gICAgICAgIHN0YWNrRGF0YVtncm91cElkXSA9IG1ha2VTdGFja0RhdGEoZmlsdGVyZWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBzdGFja0RhdGE7XG59XG5mdW5jdGlvbiBpbml0aWFsaXplU3RhY2soc3RhY2tPcHRpb24pIHtcbiAgICBpZiAoIXN0YWNrT3B0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFN0YWNrT3B0aW9uID0ge1xuICAgICAgICB0eXBlOiAnbm9ybWFsJyxcbiAgICAgICAgY29ubmVjdG9yOiBmYWxzZSxcbiAgICB9O1xuICAgIGlmIChpc1N0YWNrT2JqZWN0KHN0YWNrT3B0aW9uKSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0U3RhY2tPcHRpb24pLCBzdGFja09wdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RhY2tPcHRpb247XG59XG5mdW5jdGlvbiBpc1N0YWNrT2JqZWN0KHN0YWNrT3B0aW9uKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHN0YWNrT3B0aW9uKTtcbn1cbmZ1bmN0aW9uIGhhc1N0YWNrR3JvdXBlZChzZXJpZXNSYXdEYXRhKSB7XG4gICAgcmV0dXJuIHNlcmllc1Jhd0RhdGEuc29tZSgocmF3RGF0YSkgPT4gcmF3RGF0YS5oYXNPd25Qcm9wZXJ0eSgnc3RhY2tHcm91cCcpKTtcbn1cbmZ1bmN0aW9uIGdldFN0YWNrRGF0YVJhbmdlVmFsdWVzKHN0YWNrRGF0YSkge1xuICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdGFja0RhdGEpKSB7XG4gICAgICAgIHZhbHVlcyA9IFswLCAuLi5nZXRTdW1WYWx1ZXMoc3RhY2tEYXRhKV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwSWQgaW4gc3RhY2tEYXRhKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YWNrRGF0YSwgZ3JvdXBJZCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBbMCwgLi4udmFsdWVzLCAuLi5nZXRTdW1WYWx1ZXMoc3RhY2tEYXRhW2dyb3VwSWRdKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbmZ1bmN0aW9uIGdldFN1bVZhbHVlcyhzdGFja0RhdGEpIHtcbiAgICBjb25zdCBwb3NpdGl2ZVN1bSA9IHN0YWNrRGF0YS5tYXAoKHsgdG90YWwgfSkgPT4gdG90YWwucG9zaXRpdmUpO1xuICAgIGNvbnN0IG5lZ2F0aXZlU3VtID0gc3RhY2tEYXRhLm1hcCgoeyB0b3RhbCB9KSA9PiB0b3RhbC5uZWdhdGl2ZSk7XG4gICAgcmV0dXJuIFsuLi5uZWdhdGl2ZVN1bSwgLi4ucG9zaXRpdmVTdW1dO1xufVxuZnVuY3Rpb24gZ2V0U3RhY2tEYXRhVmFsdWVzKHN0YWNrRGF0YSkge1xuICAgIGlmICghaXNHcm91cFN0YWNrKHN0YWNrRGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrRGF0YTtcbiAgICB9XG4gICAgbGV0IHN0YWNrRGF0YVZhbHVlcyA9IFtdO1xuICAgIGlmIChpc0dyb3VwU3RhY2soc3RhY2tEYXRhKSkge1xuICAgICAgICBPYmplY3Qua2V5cyhzdGFja0RhdGEpLmZvckVhY2goKGdyb3VwSWQpID0+IHtcbiAgICAgICAgICAgIHN0YWNrRGF0YVZhbHVlcyA9IFsuLi5zdGFja0RhdGFWYWx1ZXMsIC4uLnN0YWNrRGF0YVtncm91cElkXV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2tEYXRhVmFsdWVzO1xufVxuZnVuY3Rpb24gY2hlY2tJZk5lZ2F0aXZlQW5kUG9zaXRpdmVWYWx1ZXMoc3RhY2tEYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzTmVnYXRpdmU6IHN0YWNrRGF0YS5tYXAoKHsgdG90YWwgfSkgPT4gdG90YWwubmVnYXRpdmUpLnNvbWUoKHRvdGFsKSA9PiB0b3RhbCA8IDApLFxuICAgICAgICBoYXNQb3NpdGl2ZTogc3RhY2tEYXRhLm1hcCgoeyB0b3RhbCB9KSA9PiB0b3RhbC5wb3NpdGl2ZSkuc29tZSgodG90YWwpID0+IHRvdGFsID49IDApLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRTY2FsZVR5cGUoc3RhY2tEYXRhLCBzdGFja1R5cGUsIGRpdmVyZ2luZykge1xuICAgIGNvbnN0IHsgaGFzUG9zaXRpdmUsIGhhc05lZ2F0aXZlIH0gPSBjaGVja0lmTmVnYXRpdmVBbmRQb3NpdGl2ZVZhbHVlcyhzdGFja0RhdGEpO1xuICAgIGlmIChzdGFja1R5cGUgPT09ICdwZXJjZW50Jykge1xuICAgICAgICBpZiAoZGl2ZXJnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2RpdmVyZ2luZ1BlcmNlbnRTdGFjayc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc05lZ2F0aXZlICYmIGhhc1Bvc2l0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2R1YWxQZXJjZW50U3RhY2snO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzTmVnYXRpdmUgJiYgaGFzUG9zaXRpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiAncGVyY2VudFN0YWNrJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzTmVnYXRpdmUgJiYgIWhhc1Bvc2l0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21pbnVzUGVyY2VudFN0YWNrJztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGluaXRTdGFja1NlcmllcyhzZXJpZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdGFja1NlcmllcyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKHNlcmllcykuZm9yRWFjaCgoc2VyaWVzTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBjaGFydFR5cGUgPSBzZXJpZXNOYW1lO1xuICAgICAgICBjb25zdCBzdGFja09wdGlvbiA9IHBpY2tTdGFja09wdGlvbihvcHRpb25zKTtcbiAgICAgICAgaWYgKHN0YWNrT3B0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXN0YWNrU2VyaWVzW2NoYXJ0VHlwZV0pIHtcbiAgICAgICAgICAgICAgICBzdGFja1Nlcmllc1tjaGFydFR5cGVdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFja1Nlcmllc1tjaGFydFR5cGVdLnN0YWNrID0gaW5pdGlhbGl6ZVN0YWNrKHN0YWNrT3B0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZXJpZXNOYW1lID09PSAncmFkaWFsQmFyJykge1xuICAgICAgICAgICAgc3RhY2tTZXJpZXNbc2VyaWVzTmFtZV0gPSB7IHN0YWNrOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3RhY2tTZXJpZXM7XG59XG5jb25zdCBzdGFja1Nlcmllc0RhdGEgPSB7XG4gICAgbmFtZTogJ3N0YWNrU2VyaWVzRGF0YScsXG4gICAgc3RhdGU6ICh7IHNlcmllcywgb3B0aW9ucyB9KSA9PiAoe1xuICAgICAgICBzdGFja1NlcmllczogaW5pdFN0YWNrU2VyaWVzKHNlcmllcywgb3B0aW9ucyksXG4gICAgfSksXG4gICAgYWN0aW9uOiB7XG4gICAgICAgIHNldFN0YWNrU2VyaWVzRGF0YSh7IHN0YXRlIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VyaWVzLCBzdGFja1Nlcmllcywgb3B0aW9ucyB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBzdGFja09wdGlvbiA9IHBpY2tTdGFja09wdGlvbihvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YWNrU2VyaWVzID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzZXJpZXMpLmZvckVhY2goKHNlcmllc05hbWUpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmllc0RhdGEgPSBzZXJpZXNbc2VyaWVzTmFtZV07XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBzZXJpZXNDb3VudCwgc2VyaWVzR3JvdXBDb3VudCB9ID0gc2VyaWVzRGF0YTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JhZGlhbEJhciA9IHNlcmllc05hbWUgPT09ICdyYWRpYWxCYXInO1xuICAgICAgICAgICAgICAgIGlmIChzdGFja09wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YWNrU2VyaWVzW3Nlcmllc05hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFja1Nlcmllc1tzZXJpZXNOYW1lXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrU2VyaWVzW3Nlcmllc05hbWVdLnN0YWNrID0gaW5pdGlhbGl6ZVN0YWNrKHN0YWNrT3B0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzUmFkaWFsQmFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrU2VyaWVzW3Nlcmllc05hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0YWNrU2VyaWVzW3Nlcmllc05hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHN0YWNrIH0gPSBzdGFja1Nlcmllc1tzZXJpZXNOYW1lXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXZlcmdpbmcgPSAhISgoX2EgPSBvcHRpb25zLnNlcmllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpdmVyZ2luZyk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YWNrRGF0YSA9IGhhc1N0YWNrR3JvdXBlZChkYXRhKSA/IG1ha2VTdGFja0dyb3VwRGF0YShkYXRhKSA6IG1ha2VTdGFja0RhdGEoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YWNrVHlwZSA9IChfYiA9IHN0YWNrLnR5cGUsIChfYiAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnbm9ybWFsJykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhUmFuZ2VWYWx1ZXMgPSBnZXRTdGFja0RhdGFSYW5nZVZhbHVlcyhzdGFja0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGFja1Nlcmllc1tzZXJpZXNOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0dyb3VwQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFja0RhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUmFuZ2VWYWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVR5cGU6IGdldFNjYWxlVHlwZShnZXRTdGFja0RhdGFWYWx1ZXMoc3RhY2tEYXRhKSwgc3RhY2tUeXBlLCBkaXZlcmdpbmcpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zdGFja1Nlcmllc1tzZXJpZXNOYW1lXS5zdGFja0RhdGEgPSBzdGFja0RhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4dGVuZChzdGF0ZS5zdGFja1NlcmllcywgbmV3U3RhY2tTZXJpZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBvYnNlcnZlOiB7XG4gICAgICAgIHVwZGF0ZVN0YWNrU2VyaWVzRGF0YSgpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goJ3NldFN0YWNrU2VyaWVzRGF0YScpO1xuICAgICAgICB9LFxuICAgIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgc3RhY2tTZXJpZXNEYXRhO1xuIiwiaW1wb3J0IHsgb2JzZXJ2YWJsZSwgb2JzZXJ2ZSwgbm90aWZ5LCBub3RpZnlCeVBhdGgsIGNvbXB1dGVkLCB3YXRjaCwgZXh0ZW5kIGFzIHJlYWN0aXZlRXh0ZW5kLCBpbnZpc2libGVXb3JrLCB9IGZyb20gXCIuL3JlYWN0aXZlXCI7XG5pbXBvcnQgeyBpc1VuZGVmaW5lZCwgZm9yRWFjaCwgcGlja1Byb3BlcnR5V2l0aE1ha2V1cCwgZGVlcENvcHkgfSBmcm9tIFwiLi4vaGVscGVycy91dGlsc1wiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKGluaXRTdG9yZVN0YXRlKSB7XG4gICAgICAgIHRoaXMuY29tcHV0ZWQgPSB7fTtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0ge307XG4gICAgICAgIHRoaXMuaW5pdFN0b3JlU3RhdGUgPSBkZWVwQ29weShpbml0U3RvcmVTdGF0ZSk7XG4gICAgICAgIHRoaXMuc2V0Um9vdFN0YXRlKHt9KTtcbiAgICB9XG4gICAgc2V0Um9vdFN0YXRlKHN0YXRlKSB7XG4gICAgICAgIG9ic2VydmFibGUoc3RhdGUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgfVxuICAgIHNldENvbXB1dGVkKG5hbWVQYXRoLCBmbiwgaG9sZGVyID0gdGhpcy5jb21wdXRlZCkge1xuICAgICAgICBjb25zdCBzcGxpdGVkID0gbmFtZVBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgY29uc3Qga2V5ID0gc3BsaXRlZC5zcGxpY2Uoc3BsaXRlZC5sZW5ndGggLSAxLCAxKVswXTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gcGlja1Byb3BlcnR5V2l0aE1ha2V1cChob2xkZXIsIHNwbGl0ZWQpO1xuICAgICAgICBjb21wdXRlZCh0YXJnZXQsIGtleSwgZm4uYmluZChudWxsLCB0aGlzLnN0YXRlLCB0aGlzLmNvbXB1dGVkKSk7XG4gICAgfVxuICAgIHNldFdhdGNoKG5hbWVQYXRoLCBmbikge1xuICAgICAgICByZXR1cm4gd2F0Y2godGhpcywgbmFtZVBhdGgsIGZuKTtcbiAgICB9XG4gICAgc2V0QWN0aW9uKG5hbWUsIGZuKSB7XG4gICAgICAgIHRoaXMuYWN0aW9uc1tuYW1lXSA9IGZuO1xuICAgIH1cbiAgICBkaXNwYXRjaChuYW1lLCBwYXlsb2FkLCBpc0ludmlzaWJsZSkge1xuICAgICAgICAvLyBvYnNlcnZlLnNldGxheW91dCDslYjsl5DshJwgc2V0TGF5b3V0IOyVoeyFmOydtCDsi6TtlonrkJjri4jquYwg7Jes6riw7IScIHN0YXRlLmxheW91dCBnZXR0ZXLqsIAg7Iuk7ZaJ65CY6rOgXG4gICAgICAgIC8vIHN0YXRlLmxheW91dOydmCDsmLXsoLjrsoTroZwgb2JzZXJ2ZS5zZXRMYXlvdXTsnbQg65Ox66Gd65Cc64ukLiDsl6zquLDshJwg66y07ZWc66Oo7ZSEXG4gICAgICAgIC8vIOymiSBvYnNlcnZl7ZWY6rOgIOyViOyXkOyEnCDtirnsoJUg64yA7IOB7J2EIOyTuOuVjFxuICAgICAgICAvLyBleHRlbmQoc3RhdGUubGF5b3V0LCBsYXlvdXRzKTsg7J2065+w7Iud7Jy866GcIO2VmOqyjOuQmOuptCBsYXlvdXTsnZggZ2V0dGVy7Iuk7ZaJ65CY7Ja0XG4gICAgICAgIC8vIGxheW91dOydhCDsl4XrjbDsnbTtirjtlZjroKTqs6Ag66eM65OgIG9ic2VydmXrpbwg7Ji17KCA67KE66GcIOuTseuhne2VtOyEnCDrrLTtlZzro6jtlIRcbiAgICAgICAgaWYgKGlzSW52aXNpYmxlKSB7XG4gICAgICAgICAgICBpbnZpc2libGVXb3JrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZGlzcGF0Y2gnLCBuYW1lLCAuLi5hcmdzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnNbbmFtZV0uY2FsbCh0aGlzLCB0aGlzLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZGlzcGF0Y2ggZW5kJywgbmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uc1tuYW1lXS5jYWxsKHRoaXMsIHRoaXMsIHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9ic2VydmUoZm4pIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmUoZm4uYmluZCh0aGlzLCB0aGlzLnN0YXRlLCB0aGlzLmNvbXB1dGVkKSk7XG4gICAgfVxuICAgIG9ic2VydmFibGUodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlKHRhcmdldCk7XG4gICAgfVxuICAgIG5vdGlmeUJ5UGF0aChuYW1lUGF0aCkge1xuICAgICAgICBub3RpZnlCeVBhdGgodGhpcywgbmFtZVBhdGgpO1xuICAgIH1cbiAgICBub3RpZnkodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgbm90aWZ5KHRhcmdldCwga2V5KTtcbiAgICB9XG4gICAgc2V0TW9kdWxlKG5hbWUsIHBhcmFtKSB7XG4gICAgICAgIGlmICghcGFyYW0pIHtcbiAgICAgICAgICAgIHBhcmFtID0gbmFtZTtcbiAgICAgICAgICAgIG5hbWUgPSBwYXJhbS5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbS5zdGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlU3RhdGUgPSB0eXBlb2YgcGFyYW0uc3RhdGUgPT09ICdmdW5jdGlvbicgPyBwYXJhbS5zdGF0ZSh0aGlzLmluaXRTdG9yZVN0YXRlKSA6IHBhcmFtLnN0YXRlO1xuICAgICAgICAgICAgZXh0ZW5kKHRoaXMuc3RhdGUsIG1vZHVsZVN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW0uY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGZvckVhY2gocGFyYW0uY29tcHV0ZWQsIChpdGVtLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvbXB1dGVkKGtleSwgaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW0ud2F0Y2gpIHtcbiAgICAgICAgICAgIGZvckVhY2gocGFyYW0ud2F0Y2gsIChpdGVtLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFdhdGNoKGtleSwgaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW0uYWN0aW9uKSB7XG4gICAgICAgICAgICBmb3JFYWNoKHBhcmFtLmFjdGlvbiwgKGl0ZW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QWN0aW9uKGtleSwgaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW0ub2JzZXJ2ZSkge1xuICAgICAgICAgICAgZm9yRWFjaChwYXJhbS5vYnNlcnZlLCAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFZhbHVlKHRhcmdldCwga2V5LCBzb3VyY2UpIHtcbiAgICAgICAgZXh0ZW5kKHRhcmdldCwge1xuICAgICAgICAgICAgW2tleV06IHNvdXJjZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGNvbnN0IG5ld0l0ZW1zID0ge307XG4gICAgZm9yIChjb25zdCBrIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoIXNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh0YXJnZXRba10pKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVtrXSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoc291cmNlW2tdKSkge1xuICAgICAgICAgICAgICAgIGV4dGVuZCh0YXJnZXRba10sIHNvdXJjZVtrXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba10gPSBzb3VyY2Vba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdJdGVtc1trXSA9IHNvdXJjZVtrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMobmV3SXRlbXMpLmxlbmd0aCkge1xuICAgICAgICByZWFjdGl2ZUV4dGVuZCh0YXJnZXQsIG5ld0l0ZW1zKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBkZWVwTWVyZ2VkQ29weSwgb21pdCB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXROZXN0ZWRQaWVDaGFydEFsaWFzTmFtZXMsIGhhc05lc3RlZFBpZVNlcmllcywgaGFzT3V0ZXJEYXRhTGFiZWwsIGhhc091dGVyUGllU2VyaWVzTmFtZSwgfSBmcm9tIFwiLi4vaGVscGVycy9waWVTZXJpZXNcIjtcbmltcG9ydCB7IG1ha2VBeGlzVGl0bGVUaGVtZSwgZGVmYXVsdFNlcmllc1RoZW1lLCBnZXREZWZhdWx0VGhlbWUgfSBmcm9tIFwiLi4vaGVscGVycy90aGVtZVwiO1xuZnVuY3Rpb24gZ2V0Q29tbW9uU2VyaWVzT3B0aW9ucyhvcHRpb25zLCBzZXJpZXMsIGlzTmVzdGVkUGllQ2hhcnQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHRoZW1lID0gKF9hID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRoZW1lO1xuICAgIGlmICghKChfYiA9IHRoZW1lKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2VyaWVzKSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHNlcmllc05hbWVzID0gaXNOZXN0ZWRQaWVDaGFydCA/IGdldE5lc3RlZFBpZUNoYXJ0QWxpYXNOYW1lcyhzZXJpZXMpIDogT2JqZWN0LmtleXMoc2VyaWVzKTtcbiAgICByZXR1cm4gc2VyaWVzTmFtZXMucmVkdWNlKChhY2MsIHNlcmllc05hbWUpID0+IHtcbiAgICAgICAgZGVsZXRlIGFjY1tzZXJpZXNOYW1lXTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBPYmplY3QuYXNzaWduKHt9LCB0aGVtZS5zZXJpZXMpKTtcbn1cbmZ1bmN0aW9uIGdldFRoZW1lQXBwbGllZFNlY29uZGFyeVlBeGlzKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCB0aGVtZSA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMudGhlbWUpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGVtZS55QXhpcykpIHtcbiAgICAgICAgcmV0dXJuIHRoZW1lO1xuICAgIH1cbiAgICBjb25zdCBheGlzVGl0bGVUaGVtZSA9IG1ha2VBeGlzVGl0bGVUaGVtZSgoX2MgPSAoX2IgPSAoX2EgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGhlbWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jaGFydCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZvbnRGYW1pbHkpO1xuICAgIGNvbnN0IHlBeGlzID0gdGhlbWUueUF4aXMubWFwKCh5QXhpc1RoZW1lKSA9PiBkZWVwTWVyZ2VkQ29weSh7IHRpdGxlOiBPYmplY3QuYXNzaWduKHt9LCBheGlzVGl0bGVUaGVtZSkgfSwgT2JqZWN0LmFzc2lnbih7fSwgeUF4aXNUaGVtZSkpKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGVtZSksIHsgeUF4aXMgfSk7XG59XG5mdW5jdGlvbiBnZXRUaGVtZU9wdGlvbnNXaXRoU2VyaWVzTmFtZShvcHRpb25zLCBzZXJpZXMsIGNvbW1vblNlcmllc09wdGlvbnMsIGlzTmVzdGVkUGllQ2hhcnQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdGhlbWUgPSBnZXRUaGVtZUFwcGxpZWRTZWNvbmRhcnlZQXhpcyhvcHRpb25zKTtcbiAgICBpZiAoISgoX2EgPSB0aGVtZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlcmllcykpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoZW1lKTtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWVzVGhlbWUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoZW1lKSwgeyBzZXJpZXM6IHt9IH0pO1xuICAgIGNvbnN0IHNlcmllc05hbWVzID0gT2JqZWN0LmtleXMoc2VyaWVzKTtcbiAgICBjb25zdCBpc0NvbWJvQ2hhcnQgPSBzZXJpZXNOYW1lcy5sZW5ndGggPiAxO1xuICAgIGlmIChpc05lc3RlZFBpZUNoYXJ0KSB7XG4gICAgICAgIGNvbnN0IGFsaWFzTmFtZXMgPSBnZXROZXN0ZWRQaWVDaGFydEFsaWFzTmFtZXMoc2VyaWVzKTtcbiAgICAgICAgc2VyaWVzVGhlbWUuc2VyaWVzID0ge1xuICAgICAgICAgICAgcGllOiBhbGlhc05hbWVzLnJlZHVjZSgoYWNjLCBhbGlhc05hbWUpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHsgW2FsaWFzTmFtZV06IGRlZXBNZXJnZWRDb3B5KChfYSA9IHRoZW1lLnNlcmllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2FsaWFzTmFtZV0sIG9taXQoY29tbW9uU2VyaWVzT3B0aW9ucywgJ2NvbG9ycycpKSB9KSk7XG4gICAgICAgICAgICB9LCB7fSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQ29tYm9DaGFydCkge1xuICAgICAgICBzZXJpZXNUaGVtZS5zZXJpZXMgPSBPYmplY3QuYXNzaWduKHt9LCBzZXJpZXNOYW1lcy5yZWR1Y2UoKGFjYywgc2VyaWVzTmFtZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHsgW3Nlcmllc05hbWVdOiBkZWVwTWVyZ2VkQ29weSgoX2EgPSB0aGVtZS5zZXJpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtzZXJpZXNOYW1lXSwgb21pdChjb21tb25TZXJpZXNPcHRpb25zLCAnY29sb3JzJykpIH0pKTtcbiAgICAgICAgfSwge30pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNlcmllc1RoZW1lLnNlcmllcyA9IHtcbiAgICAgICAgICAgIFtzZXJpZXNOYW1lc1swXV06IHRoZW1lLnNlcmllcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmllc1RoZW1lO1xufVxuZnVuY3Rpb24gc2V0Q29sb3JzKHRoZW1lLCBzZXJpZXMsIGNvbW1vblNlcmllc09wdGlvbnMsIGlzTmVzdGVkUGllQ2hhcnQsIGNhdGVnb3JpZXMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgY29tbW9uQ29sb3JzT3B0aW9uID0gW1xuICAgICAgICAuLi4oX2IgPSAoX2EgPSBjb21tb25TZXJpZXNPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29sb3JzLCAoX2IgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pKSxcbiAgICAgICAgLi4uZGVmYXVsdFNlcmllc1RoZW1lLmNvbG9ycyxcbiAgICBdO1xuICAgIGNvbnN0IHRoZW1lTmFtZXMgPSBpc05lc3RlZFBpZUNoYXJ0ID8gZ2V0TmVzdGVkUGllQ2hhcnRBbGlhc05hbWVzKHNlcmllcykgOiBPYmplY3Qua2V5cyhzZXJpZXMpO1xuICAgIHRoZW1lTmFtZXMuZm9yRWFjaCgobmFtZSwgaWR4KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgdGhlbWVTZXJpZXMgPSBzZXJpZXNbbmFtZV0gfHwgW107XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkU2VyaWVzID0gdGhlbWVTZXJpZXMuZmlsdGVyKChjaGFydFNlcmllcykgPT4gY2hhcnRTZXJpZXMuY29sb3JCeUNhdGVnb3JpZXMpO1xuICAgICAgICBjb25zdCBoYXNDb2xvckJ5Q2F0ZWdvcmllcyA9IGZpbHRlcmVkU2VyaWVzLmxlbmd0aCA+IDA7XG4gICAgICAgIGxldCBzaXplO1xuICAgICAgICBpZiAoaXNOZXN0ZWRQaWVDaGFydCkge1xuICAgICAgICAgICAgc2l6ZSA9IHNlcmllcy5waWVbaWR4XS5kYXRhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNDb2xvckJ5Q2F0ZWdvcmllcykge1xuICAgICAgICAgICAgY29uc3QgcmVqZWN0ZWRTZXJpZXMgPSB0aGVtZVNlcmllcy5maWx0ZXIoKGNoYXJ0U2VyaWVzKSA9PiAhY2hhcnRTZXJpZXMuY29sb3JCeUNhdGVnb3JpZXMpO1xuICAgICAgICAgICAgc2l6ZSA9IHJlamVjdGVkU2VyaWVzLmxlbmd0aCArIGNhdGVnb3JpZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2l6ZSA9IHNlcmllc1tuYW1lXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gaXNOZXN0ZWRQaWVDaGFydCA/IHRoZW1lLnNlcmllcy5waWUgOiB0aGVtZS5zZXJpZXM7XG4gICAgICAgIGlmICghKChfYSA9IHRhcmdldFtuYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbG9ycykpIHtcbiAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0W25hbWVdKSwgeyBjb2xvcnM6IGNvbW1vbkNvbG9yc09wdGlvbi5zbGljZShpbmRleCwgaW5kZXggKyBzaXplKSB9KTtcbiAgICAgICAgICAgIGluZGV4ICs9IHNpemU7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNldFBsb3QodGhlbWUpIHtcbiAgICBbJ3ZlcnRpY2FsJywgJ2hvcml6b250YWwnXS5yZWR1Y2UoKGFjYywgY3VyKSA9PiB7XG4gICAgICAgIGlmICghYWNjW2N1cl0pIHtcbiAgICAgICAgICAgIGFjY1tjdXJdID0geyBsaW5lQ29sb3I6IGFjYy5saW5lQ29sb3IgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHRoZW1lLnBsb3QpO1xufVxuZnVuY3Rpb24gY2hlY2tBbmNob3JQaWVTZXJpZXNPcHRpb24ob3B0aW9ucywgc2VyaWVzLCBhbGlhcykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc091dGVyQW5jaG9yOiAhIXNlcmllcy5waWUgJiYgKChfZCA9IChfYyA9IChfYiA9IChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXJpZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlthbGlhc10pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kYXRhTGFiZWxzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYW5jaG9yKSA9PT0gJ291dGVyJyxcbiAgICAgICAgaGFzT3V0ZXJBbmNob3JQaWVTZXJpZXNOYW1lOiAhIXNlcmllcy5waWUgJiYgKChfaiA9IChfaCA9IChfZyA9IChfZiA9IChfZSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5zZXJpZXMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZlthbGlhc10pID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5kYXRhTGFiZWxzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2gucGllU2VyaWVzTmFtZSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmFuY2hvcikgPT09ICdvdXRlcicsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFRoZW1lKG9wdGlvbnMsIHNlcmllcywgY2F0ZWdvcmllcykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IGlzTmVzdGVkUGllQ2hhcnQgPSBoYXNOZXN0ZWRQaWVTZXJpZXMoc2VyaWVzKTtcbiAgICBjb25zdCBjb21tb25TZXJpZXNPcHRpb25zID0gZ2V0Q29tbW9uU2VyaWVzT3B0aW9ucyhvcHRpb25zLCBzZXJpZXMsIGlzTmVzdGVkUGllQ2hhcnQpO1xuICAgIGxldCBwaWVTZXJpZXNPdXRlckFuY2hvcnMgPSB7XG4gICAgICAgIGhhc091dGVyQW5jaG9yOiBoYXNPdXRlckRhdGFMYWJlbChvcHRpb25zLCBzZXJpZXMpLFxuICAgICAgICBoYXNPdXRlckFuY2hvclBpZVNlcmllc05hbWU6IGhhc091dGVyUGllU2VyaWVzTmFtZShvcHRpb25zLCBzZXJpZXMpLFxuICAgIH07XG4gICAgaWYgKGlzTmVzdGVkUGllQ2hhcnQpIHtcbiAgICAgICAgY29uc3QgYWxpYXNOYW1lcyA9IGdldE5lc3RlZFBpZUNoYXJ0QWxpYXNOYW1lcyhzZXJpZXMpO1xuICAgICAgICBwaWVTZXJpZXNPdXRlckFuY2hvcnMgPSBhbGlhc05hbWVzLnJlZHVjZSgoYWNjLCBjdXIpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHsgW2N1cl06IGNoZWNrQW5jaG9yUGllU2VyaWVzT3B0aW9uKG9wdGlvbnMsIHNlcmllcywgY3VyKSB9KSksIHt9KTtcbiAgICB9XG4gICAgY29uc3QgZ2xvYmFsRm9udEZhbWlseSA9IChfYyA9IChfYiA9IChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50aGVtZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNoYXJ0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZm9udEZhbWlseTtcbiAgICBjb25zdCB0aGVtZSA9IGRlZXBNZXJnZWRDb3B5KGdldERlZmF1bHRUaGVtZShzZXJpZXMsIHBpZVNlcmllc091dGVyQW5jaG9ycywgZ2xvYmFsRm9udEZhbWlseSwgaXNOZXN0ZWRQaWVDaGFydCksIGdldFRoZW1lT3B0aW9uc1dpdGhTZXJpZXNOYW1lKG9wdGlvbnMsIHNlcmllcywgY29tbW9uU2VyaWVzT3B0aW9ucywgaXNOZXN0ZWRQaWVDaGFydCkpO1xuICAgIGlmICghc2VyaWVzLmhlYXRtYXApIHtcbiAgICAgICAgc2V0Q29sb3JzKHRoZW1lLCBzZXJpZXMsIGNvbW1vblNlcmllc09wdGlvbnMsIGlzTmVzdGVkUGllQ2hhcnQsIGNhdGVnb3JpZXMpO1xuICAgIH1cbiAgICBzZXRQbG90KHRoZW1lKTtcbiAgICByZXR1cm4gdGhlbWU7XG59XG5jb25zdCB0aGVtZSA9IHtcbiAgICBuYW1lOiAndGhlbWUnLFxuICAgIHN0YXRlOiAoeyBvcHRpb25zLCBzZXJpZXMsIGNhdGVnb3JpZXMgfSkgPT4gKHtcbiAgICAgICAgdGhlbWU6IGdldFRoZW1lKG9wdGlvbnMsIHNlcmllcywgY2F0ZWdvcmllcyksXG4gICAgfSksXG4gICAgYWN0aW9uOiB7XG4gICAgICAgIGluaXRUaGVtZVN0YXRlKHsgc3RhdGUsIGluaXRTdG9yZVN0YXRlIH0pIHtcbiAgICAgICAgICAgIHN0YXRlLnRoZW1lID0gZ2V0VGhlbWUoc3RhdGUub3B0aW9ucywgaW5pdFN0b3JlU3RhdGUuc2VyaWVzLCBpbml0U3RvcmVTdGF0ZS5jYXRlZ29yaWVzKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIG9ic2VydmU6IHtcbiAgICAgICAgdXBkYXRlVGhlbWUoKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCdpbml0VGhlbWVTdGF0ZScpO1xuICAgICAgICB9LFxuICAgIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgdGhlbWU7XG4iLCJpbXBvcnQgeyBpc051bGwsIGlzVW5kZWZpbmVkLCBsYXN0IH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbHNcIjtcbmNvbnN0IFRSRUVNQVBfSURfUFJFRklYID0gJ19fVE9BU1RfVUlfVFJFRU1BUCc7XG5leHBvcnQgY29uc3QgVFJFRU1BUF9ST09UX0lEID0gYCR7VFJFRU1BUF9JRF9QUkVGSVh9X1JPT1RgO1xuZnVuY3Rpb24gbWFrZVRyZWVNb2RlbChzZXJpZXMsIGluZGV4ZXMsIGRlcHRoLCBwYXJlbnRJZCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBpZHggPSBsYXN0KGluZGV4ZXMpO1xuICAgIGNvbnN0IGlkID0gcGFyZW50SWQgPyBgJHtwYXJlbnRJZH1fJHtpZHh9YCA6IGAke1RSRUVNQVBfSURfUFJFRklYfV8ke2lkeH1gO1xuICAgIGNvbnN0IHsgY29sb3JWYWx1ZSB9ID0gc2VyaWVzO1xuICAgIGNvbnN0IG1vZGVscyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6IHNlcmllcy5sYWJlbCxcbiAgICAgICAgICAgIGhhc0NoaWxkOiAhIXNlcmllcy5jaGlsZHJlbixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgaW5kZXhlcyxcbiAgICAgICAgICAgIHBhcmVudElkOiBwYXJlbnRJZCA/IHBhcmVudElkIDogVFJFRU1BUF9ST09UX0lELFxuICAgICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgICBkYXRhOiAoX2EgPSBzZXJpZXMuZGF0YSwgKF9hICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApKSxcbiAgICAgICAgICAgIGNvbG9yVmFsdWUsXG4gICAgICAgIH0sXG4gICAgXTtcbiAgICBpZiAoc2VyaWVzLmNoaWxkcmVuKSB7XG4gICAgICAgIHNlcmllcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgY2hpbGRJZHgpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNOdWxsKGNoaWxkLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxzLnB1c2goLi4ubWFrZVRyZWVNb2RlbChjaGlsZCwgWy4uLmluZGV4ZXMsIGNoaWxkSWR4XSwgZGVwdGggKyAxLCBpZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVscztcbn1cbmZ1bmN0aW9uIHNldFBhcmVudFNlcmllc0RhdGEodHJlZW1hcFNlcmllcykge1xuICAgIHRyZWVtYXBTZXJpZXMuZm9yRWFjaCgoeyBwYXJlbnRJZCwgZGF0YSB9KSA9PiB7XG4gICAgICAgIGlmIChwYXJlbnRJZCAhPT0gVFJFRU1BUF9ST09UX0lEKSB7XG4gICAgICAgICAgICB0cmVlbWFwU2VyaWVzLmZpbmQoKHsgaWQgfSkgPT4gaWQgPT09IHBhcmVudElkKS5kYXRhICs9IGRhdGE7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNldFBhcmVudENvbG9yVmFsdWUodHJlZW1hcFNlcmllcykge1xuICAgIHRyZWVtYXBTZXJpZXMuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgICAgY29uc3QgeyBpZCwgY29sb3JWYWx1ZSB9ID0gZGF0dW07XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChjb2xvclZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWVzID0gdHJlZW1hcFNlcmllcy5maWx0ZXIoKHsgcGFyZW50SWQgfSkgPT4gcGFyZW50SWQgPT09IGlkKTtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsQ29sb3JWYWx1ZSA9IHNlcmllcy5yZWR1Y2UoKGFjYywgY3VyKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIChpc1VuZGVmaW5lZChjdXIuY29sb3JWYWx1ZSkgPyAwIDogY3VyLmNvbG9yVmFsdWUpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICBkYXR1bS5jb2xvclZhbHVlID0gdG90YWxDb2xvclZhbHVlIC8gc2VyaWVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0UmF0aW8odHJlZW1hcFNlcmllcykge1xuICAgIGNvbnN0IHJvb3RUb3RhbCA9IHRyZWVtYXBTZXJpZXNcbiAgICAgICAgLmZpbHRlcigoeyBwYXJlbnRJZCB9KSA9PiBwYXJlbnRJZCA9PT0gVFJFRU1BUF9ST09UX0lEKVxuICAgICAgICAucmVkdWNlKChhY2MsIHsgZGF0YSB9KSA9PiBhY2MgKyBkYXRhLCAwKTtcbiAgICB0cmVlbWFwU2VyaWVzLmZvckVhY2goKHNlcmllcykgPT4ge1xuICAgICAgICBjb25zdCB0b3RhbCA9IHNlcmllcy5wYXJlbnRJZCA9PT0gVFJFRU1BUF9ST09UX0lEXG4gICAgICAgICAgICA/IHJvb3RUb3RhbFxuICAgICAgICAgICAgOiB0cmVlbWFwU2VyaWVzLmZpbmQoKHsgaWQgfSkgPT4gaWQgPT09IHNlcmllcy5wYXJlbnRJZCkuZGF0YTtcbiAgICAgICAgc2VyaWVzLnJhdGlvID0gc2VyaWVzLmRhdGEgLyB0b3RhbDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG1ha2VUcmVlbWFwU2VyaWVzKHNlcmllcywgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXNlcmllcy50cmVlbWFwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgdHJlZW1hcFNlcmllcyA9IHNlcmllcy50cmVlbWFwLmRhdGFcbiAgICAgICAgLmZpbHRlcigoZGF0dW0pID0+ICFpc051bGwoZGF0dW0uZGF0YSkpXG4gICAgICAgIC5tYXAoKGRhdHVtLCBpZHgpID0+IG1ha2VUcmVlTW9kZWwoZGF0dW0sIFtpZHhdLCAwKSlcbiAgICAgICAgLmZsYXRNYXAoKHMpID0+IHMpXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLmRlcHRoIC0gYS5kZXB0aCk7XG4gICAgc2V0UGFyZW50U2VyaWVzRGF0YSh0cmVlbWFwU2VyaWVzKTtcbiAgICBzZXRSYXRpbyh0cmVlbWFwU2VyaWVzKTtcbiAgICBpZiAoKF9hID0gb3B0aW9ucy5zZXJpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51c2VDb2xvclZhbHVlKSB7XG4gICAgICAgIHNldFBhcmVudENvbG9yVmFsdWUodHJlZW1hcFNlcmllcyk7XG4gICAgfVxuICAgIHJldHVybiB0cmVlbWFwU2VyaWVzO1xufVxuY29uc3QgdHJlZW1hcFNlcmllc0RhdGEgPSB7XG4gICAgbmFtZTogJ3RyZWVtYXBTZXJpZXNEYXRhJyxcbiAgICBzdGF0ZTogKCkgPT4gKHtcbiAgICAgICAgdHJlZW1hcFNlcmllczogW10sXG4gICAgfSksXG4gICAgYWN0aW9uOiB7XG4gICAgICAgIHNldFRyZWVtYXBTZXJpZXNEYXRhKHsgc3RhdGUgfSkge1xuICAgICAgICAgICAgc3RhdGUudHJlZW1hcFNlcmllcyA9IG1ha2VUcmVlbWFwU2VyaWVzKHN0YXRlLnNlcmllcywgc3RhdGUub3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBvYnNlcnZlOiB7XG4gICAgICAgIHVwZGF0ZVRyZWVtYXBTZXJpZXNEYXRhKCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgnc2V0VHJlZW1hcFNlcmllc0RhdGEnKTtcbiAgICAgICAgfSxcbiAgICB9LFxufTtcbmV4cG9ydCBkZWZhdWx0IHRyZWVtYXBTZXJpZXNEYXRhO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLyohXFxuICogVE9BU1QgVUkgQ2hhcnQgNHRoIEVkaXRpb25cXG4gKiBAdmVyc2lvbiA0LjYuMSB8IFdlZCBEZWMgMjEgMjAyMlxcbiAqIEBhdXRob3IgTkhOIENsb3VkLiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cXG4gKiBAbGljZW5zZSBNSVRcXG4gKi8udG9hc3R1aS1jaGFydC13cmFwcGVye2hlaWdodDoxMDAlO3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjEwMCV9LnRvYXN0dWktY2hhcnQtZXhwb3J0LW1lbnV7YmFja2dyb3VuZDojZmZmO2JveC1zaXppbmc6Ym9yZGVyLWJveDtmb250LWZhbWlseTpBcmlhbCxzYW5zLXNlcmlmO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDt1c2VyLXNlbGVjdDpub25lfS50b2FzdHVpLWNoYXJ0LWV4cG9ydC1tZW51LXRpdGxle2JveC1zaXppbmc6aW5oZXJpdDtoZWlnaHQ6MzRweDttYXJnaW46MDtwYWRkaW5nOjEwcHg7d2lkdGg6MTQwcHh9LnRvYXN0dWktY2hhcnQtZXhwb3J0LW1lbnUtYnRuLXdyYXBwZXJ7aGVpZ2h0Ojc2cHg7d2lkdGg6MTAwJX0udG9hc3R1aS1jaGFydC1leHBvcnQtbWVudS1idG57YmFja2dyb3VuZDp0cmFuc3BhcmVudDtib3JkZXI6bm9uZTtjb2xvcjppbmhlcml0O2N1cnNvcjpwb2ludGVyO2Zsb2F0OmxlZnQ7Zm9udC1mYW1pbHk6aW5oZXJpdDtoZWlnaHQ6NTAlO3BhZGRpbmc6MTJweCAzcHg7d2lkdGg6NTAlfS50b2FzdHVpLWNoYXJ0LWV4cG9ydC1tZW51LWJ0bjpob3Zlcntmb250LXdlaWdodDo3MDB9LnRvYXN0dWktY2hhcnQtZXhwb3J0LW1lbnUtYnRuOm50aC1jaGlsZCgzKXtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOmluaGVyaXR9LnRvYXN0dWktY2hhcnQtZXhwb3J0LW1lbnUtYnRuOm50aC1jaGlsZCg0KXtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czppbmhlcml0fS50b2FzdHVpLWNoYXJ0LXRvb2x0aXAtY29udGFpbmVye2xlZnQ6MDtwb2ludGVyLWV2ZW50czpub25lO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3VzZXItc2VsZWN0Om5vbmV9LnRvYXN0dWktY2hhcnQtdG9vbHRpcHtib3gtc2l6aW5nOmJvcmRlci1ib3g7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjttaW4td2lkdGg6MTUwcHh9LnRvYXN0dWktY2hhcnQtdG9vbHRpcC1jYXRlZ29yeXtib3JkZXItYm90dG9tOjFweCBzb2xpZCByZ2JhKDAsMCwwLC4xKTtwYWRkaW5nOjhweCAxNXB4fS50b2FzdHVpLWNoYXJ0LXRvb2x0aXAtc2VyaWVzLXdyYXBwZXJ7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtwYWRkaW5nOjEzcHggMTVweH0udG9hc3R1aS1jaGFydC10b29sdGlwLXNlcmllc3tkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47d2lkdGg6MTAwJX0udG9hc3R1aS1jaGFydC1zZXJpZXMtbmFtZXthbGlnbi1pdGVtczpjZW50ZXI7ZGlzcGxheTpmbGV4O2xpbmUtaGVpZ2h0OjEwcHh9LnRvYXN0dWktY2hhcnQtc2VyaWVzLW5hbWUgLnRvYXN0dWktY2hhcnQtaWNvbiwudG9hc3R1aS1jaGFydC10b29sdGlwLXNlcmllcyAudG9hc3R1aS1jaGFydC1pY29ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO2hlaWdodDoxMHB4O21hcmdpbi1yaWdodDo4cHg7d2lkdGg6MTBweH0udG9hc3R1aS1jaGFydC1zZXJpZXMtbmFtZSAudG9hc3R1aS1jaGFydC1uYW1le3doaXRlLXNwYWNlOm5vd3JhcH0udG9hc3R1aS1jaGFydC1zZXJpZXMtdmFsdWV7bWFyZ2luLWxlZnQ6MTBweDt3aGl0ZS1zcGFjZTpub3dyYXB9LnRvYXN0dWktY2hhcnQtdG9vbHRpcC1zZXJpZXMtd3JhcHBlciAudG9hc3R1aS1jaGFydC10b29sdGlwLXRpdGxle3BhZGRpbmc6OHB4IDAgNXB4fS50b2FzdHVpLWNoYXJ0LXRvb2x0aXAtc2VyaWVzLXdyYXBwZXIgLnRvYXN0dWktY2hhcnQtdG9vbHRpcC10aXRsZTpmaXJzdC1jaGlsZHtwYWRkaW5nLXRvcDowfVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvY2hhcnQvZGlzdC90b2FzdHVpLWNoYXJ0Lm1pbi5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7Ozs7O0VBS0UsQ0FBQyx1QkFBdUIsV0FBVyxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQywyQkFBMkIsZUFBZSxDQUFDLHFCQUFxQixDQUFDLDRCQUE0QixDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsaUNBQWlDLGtCQUFrQixDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyx1Q0FBdUMsV0FBVyxDQUFDLFVBQVUsQ0FBQywrQkFBK0Isc0JBQXNCLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLG1CQUFtQixDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMscUNBQXFDLGVBQWUsQ0FBQyw0Q0FBNEMsaUNBQWlDLENBQUMsNENBQTRDLGtDQUFrQyxDQUFDLGlDQUFpQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLHVCQUF1QixxQkFBcUIsQ0FBQyxZQUFZLENBQUMscUJBQXFCLENBQUMsZUFBZSxDQUFDLGdDQUFnQyxzQ0FBc0MsQ0FBQyxnQkFBZ0IsQ0FBQyxzQ0FBc0MsWUFBWSxDQUFDLHFCQUFxQixDQUFDLGlCQUFpQixDQUFDLDhCQUE4QixZQUFZLENBQUMsNkJBQTZCLENBQUMsVUFBVSxDQUFDLDJCQUEyQixrQkFBa0IsQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsaUdBQWlHLG9CQUFvQixDQUFDLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsK0NBQStDLGtCQUFrQixDQUFDLDRCQUE0QixnQkFBZ0IsQ0FBQyxrQkFBa0IsQ0FBQyxtRUFBbUUsaUJBQWlCLENBQUMsK0VBQStFLGFBQWFcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLyohXFxuICogVE9BU1QgVUkgQ2hhcnQgNHRoIEVkaXRpb25cXG4gKiBAdmVyc2lvbiA0LjYuMSB8IFdlZCBEZWMgMjEgMjAyMlxcbiAqIEBhdXRob3IgTkhOIENsb3VkLiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cXG4gKiBAbGljZW5zZSBNSVRcXG4gKi8udG9hc3R1aS1jaGFydC13cmFwcGVye2hlaWdodDoxMDAlO3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjEwMCV9LnRvYXN0dWktY2hhcnQtZXhwb3J0LW1lbnV7YmFja2dyb3VuZDojZmZmO2JveC1zaXppbmc6Ym9yZGVyLWJveDtmb250LWZhbWlseTpBcmlhbCxzYW5zLXNlcmlmO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDt1c2VyLXNlbGVjdDpub25lfS50b2FzdHVpLWNoYXJ0LWV4cG9ydC1tZW51LXRpdGxle2JveC1zaXppbmc6aW5oZXJpdDtoZWlnaHQ6MzRweDttYXJnaW46MDtwYWRkaW5nOjEwcHg7d2lkdGg6MTQwcHh9LnRvYXN0dWktY2hhcnQtZXhwb3J0LW1lbnUtYnRuLXdyYXBwZXJ7aGVpZ2h0Ojc2cHg7d2lkdGg6MTAwJX0udG9hc3R1aS1jaGFydC1leHBvcnQtbWVudS1idG57YmFja2dyb3VuZDp0cmFuc3BhcmVudDtib3JkZXI6bm9uZTtjb2xvcjppbmhlcml0O2N1cnNvcjpwb2ludGVyO2Zsb2F0OmxlZnQ7Zm9udC1mYW1pbHk6aW5oZXJpdDtoZWlnaHQ6NTAlO3BhZGRpbmc6MTJweCAzcHg7d2lkdGg6NTAlfS50b2FzdHVpLWNoYXJ0LWV4cG9ydC1tZW51LWJ0bjpob3Zlcntmb250LXdlaWdodDo3MDB9LnRvYXN0dWktY2hhcnQtZXhwb3J0LW1lbnUtYnRuOm50aC1jaGlsZCgzKXtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOmluaGVyaXR9LnRvYXN0dWktY2hhcnQtZXhwb3J0LW1lbnUtYnRuOm50aC1jaGlsZCg0KXtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czppbmhlcml0fS50b2FzdHVpLWNoYXJ0LXRvb2x0aXAtY29udGFpbmVye2xlZnQ6MDtwb2ludGVyLWV2ZW50czpub25lO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3VzZXItc2VsZWN0Om5vbmV9LnRvYXN0dWktY2hhcnQtdG9vbHRpcHtib3gtc2l6aW5nOmJvcmRlci1ib3g7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjttaW4td2lkdGg6MTUwcHh9LnRvYXN0dWktY2hhcnQtdG9vbHRpcC1jYXRlZ29yeXtib3JkZXItYm90dG9tOjFweCBzb2xpZCByZ2JhKDAsMCwwLC4xKTtwYWRkaW5nOjhweCAxNXB4fS50b2FzdHVpLWNoYXJ0LXRvb2x0aXAtc2VyaWVzLXdyYXBwZXJ7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtwYWRkaW5nOjEzcHggMTVweH0udG9hc3R1aS1jaGFydC10b29sdGlwLXNlcmllc3tkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47d2lkdGg6MTAwJX0udG9hc3R1aS1jaGFydC1zZXJpZXMtbmFtZXthbGlnbi1pdGVtczpjZW50ZXI7ZGlzcGxheTpmbGV4O2xpbmUtaGVpZ2h0OjEwcHh9LnRvYXN0dWktY2hhcnQtc2VyaWVzLW5hbWUgLnRvYXN0dWktY2hhcnQtaWNvbiwudG9hc3R1aS1jaGFydC10b29sdGlwLXNlcmllcyAudG9hc3R1aS1jaGFydC1pY29ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO2hlaWdodDoxMHB4O21hcmdpbi1yaWdodDo4cHg7d2lkdGg6MTBweH0udG9hc3R1aS1jaGFydC1zZXJpZXMtbmFtZSAudG9hc3R1aS1jaGFydC1uYW1le3doaXRlLXNwYWNlOm5vd3JhcH0udG9hc3R1aS1jaGFydC1zZXJpZXMtdmFsdWV7bWFyZ2luLWxlZnQ6MTBweDt3aGl0ZS1zcGFjZTpub3dyYXB9LnRvYXN0dWktY2hhcnQtdG9vbHRpcC1zZXJpZXMtd3JhcHBlciAudG9hc3R1aS1jaGFydC10b29sdGlwLXRpdGxle3BhZGRpbmc6OHB4IDAgNXB4fS50b2FzdHVpLWNoYXJ0LXRvb2x0aXAtc2VyaWVzLXdyYXBwZXIgLnRvYXN0dWktY2hhcnQtdG9vbHRpcC10aXRsZTpmaXJzdC1jaGlsZHtwYWRkaW5nLXRvcDowfVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcpIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2YgaXRlbVs1XSAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKTtcbiAgICAgIH1cblxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuXG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiBpKG1vZHVsZXMsIG1lZGlhLCBkZWR1cGUsIHN1cHBvcnRzLCBsYXllcikge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgdW5kZWZpbmVkXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2tdWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IG1vZHVsZXMubGVuZ3RoOyBfaysrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19rXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBsYXllciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW1bNV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1cHBvcnRzKSB7XG4gICAgICAgIGlmICghaXRlbVs0XSkge1xuICAgICAgICAgIGl0ZW1bNF0gPSBcIlwiLmNvbmNhdChzdXBwb3J0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzRdID0gc3VwcG9ydHM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCBcIlwiKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiLCJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uLy4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uLy4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uLy4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4uLy4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uLy4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi90b2FzdHVpLWNoYXJ0Lm1pbi5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vdG9hc3R1aS1jaGFydC5taW4uY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdHlsZXNJbkRPTSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRE9NLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRE9NW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXhCeUlkZW50aWZpZXIgPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM10sXG4gICAgICBzdXBwb3J0czogaXRlbVs0XSxcbiAgICAgIGxheWVyOiBpdGVtWzVdXG4gICAgfTtcblxuICAgIGlmIChpbmRleEJ5SWRlbnRpZmllciAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdXBkYXRlciA9IGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5ieUluZGV4ID0gaTtcbiAgICAgIHN0eWxlc0luRE9NLnNwbGljZShpLCAwLCB7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IHVwZGF0ZXIsXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGFwaSA9IG9wdGlvbnMuZG9tQVBJKG9wdGlvbnMpO1xuICBhcGkudXBkYXRlKG9iaik7XG5cbiAgdmFyIHVwZGF0ZXIgPSBmdW5jdGlvbiB1cGRhdGVyKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXAgJiYgbmV3T2JqLnN1cHBvcnRzID09PSBvYmouc3VwcG9ydHMgJiYgbmV3T2JqLmxheWVyID09PSBvYmoubGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhcGkudXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHVwZGF0ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRPTVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5ET01bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbmZ1bmN0aW9uIGluc2VydEJ5U2VsZWN0b3IoaW5zZXJ0LCBzdHlsZSkge1xuICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGluc2VydCk7XG5cbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG5cbiAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRCeVNlbGVjdG9yOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBvcHRpb25zLnNldEF0dHJpYnV0ZXMoZWxlbWVudCwgb3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgb3B0aW9ucy5pbnNlcnQoZWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0U3R5bGVFbGVtZW50OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcyhzdHlsZUVsZW1lbnQpIHtcbiAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IFwiXCI7XG5cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KG9iai5zdXBwb3J0cywgXCIpIHtcIik7XG4gIH1cblxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIik7XG4gIH1cblxuICB2YXIgbmVlZExheWVyID0gdHlwZW9mIG9iai5sYXllciAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwiQGxheWVyXCIuY29uY2F0KG9iai5sYXllci5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KG9iai5sYXllcikgOiBcIlwiLCBcIiB7XCIpO1xuICB9XG5cbiAgY3NzICs9IG9iai5jc3M7XG5cbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBvcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGVFbGVtZW50LnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG9tQVBJOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50KSB7XG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWxlVGFnVHJhbnNmb3JtOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV93aWRnZXRzX187IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImltcG9ydCBcIndpZGdldHNcIjtcclxuaW1wb3J0IENoYXJ0IGZyb20gXCJAdG9hc3QtdWkvY2hhcnRcIjtcclxuaW1wb3J0IFwiQHRvYXN0LXVpL2NoYXJ0L2Rpc3QvdG9hc3R1aS1jaGFydC5taW4uY3NzXCI7XHJcblxyXG5IVE1MV2lkZ2V0cy53aWRnZXQoe1xyXG4gIG5hbWU6IFwiY2hhcnRcIixcclxuXHJcbiAgdHlwZTogXCJvdXRwdXRcIixcclxuXHJcbiAgZmFjdG9yeTogZnVuY3Rpb24gKGVsLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICB2YXIgY2hhcnQ7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmVuZGVyVmFsdWU6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgdmFyIHR5cGUgPSB4LmNvbmZpZy50eXBlO1xyXG4gICAgICAgIHZhciBkYXRhID0geC5jb25maWcuZGF0YTtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHguY29uZmlnLm9wdGlvbnM7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFydCAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgY2hhcnQuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGFydCA9IENoYXJ0W3R5cGVdKHsgZWwsIGRhdGEsIG9wdGlvbnMgfSk7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBnZXRXaWRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gY2hhcnQ7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgLypcclxuICAgICAgICBjaGFydC51cGRhdGVPcHRpb25zKHtcclxuICAgICAgICAgIGNoYXJ0OiB7d2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAqL1xyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9LFxyXG59KTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9